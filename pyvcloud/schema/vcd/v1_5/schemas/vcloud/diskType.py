#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Dec 16 09:53:07 2014 by generateDS.py version 2.14a.
#
# Command line options:
#   ('-o', 'schema/vcd/v1_5/schemas/vcloud/diskType.py')
#
# Command line arguments:
#   schema/vcd/v1_5/schemas/vcloud/disk.xsd
#
# Command line:
#   ../bin/generateDS.py -o "schema/vcd/v1_5/schemas/vcloud/diskType.py" schema/vcd/v1_5/schemas/vcloud/disk.xsd
#
# Current working directory (os.getcwd()):
#   pyvcloud
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_


Validate_simpletypes_ = True


etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class VCloudExtensionType(GeneratedsSuper):
    """0.9 General purpose extension element. Not related to extension
    services. always True if the request should fail when the server
    does not understand the extension. false"""
    subclass = None
    superclass = None
    def __init__(self, required=True, anytypeobjs_=None):
        self.original_tagname_ = None
        self.required = _cast(bool, required)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if VCloudExtensionType.subclass:
            return VCloudExtensionType.subclass(*args_, **kwargs_)
        else:
            return VCloudExtensionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_required(self): return self.required
    def set_required(self, required): self.required = required
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VCloudExtensionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VCloudExtensionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VCloudExtensionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VCloudExtensionType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required="%s"' % self.gds_format_boolean(self.required, input_name='required'))
    def exportChildren(self, outfile, level, namespace_='', name_='VCloudExtensionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VCloudExtensionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            showIndent(outfile, level)
            outfile.write('required=%s,\n' % (self.required,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            if value in ('true', '1'):
                self.required = True
            elif value in ('false', '0'):
                self.required = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'VCloudExtensionType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class VCloudExtensionType


class VCloudExtensibleType(GeneratedsSuper):
    """0.9 A base abstract type for all complex types that support
    extensions."""
    subclass = None
    superclass = None
    def __init__(self, VCloudExtension=None, extensiontype_=None):
        self.original_tagname_ = None
        if VCloudExtension is None:
            self.VCloudExtension = []
        else:
            self.VCloudExtension = VCloudExtension
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if VCloudExtensibleType.subclass:
            return VCloudExtensibleType.subclass(*args_, **kwargs_)
        else:
            return VCloudExtensibleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VCloudExtension(self): return self.VCloudExtension
    def set_VCloudExtension(self, VCloudExtension): self.VCloudExtension = VCloudExtension
    def add_VCloudExtension(self, value): self.VCloudExtension.append(value)
    def insert_VCloudExtension_at(self, index, value): self.VCloudExtension.insert(index, value)
    def replace_VCloudExtension_at(self, index, value): self.VCloudExtension[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.VCloudExtension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VCloudExtensibleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VCloudExtensibleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VCloudExtensibleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VCloudExtensibleType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VCloudExtensibleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VCloudExtension_ in self.VCloudExtension:
            VCloudExtension_.export(outfile, level, namespace_, name_='VCloudExtension', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VCloudExtensibleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('VCloudExtension=[\n')
        level += 1
        for VCloudExtension_ in self.VCloudExtension:
            showIndent(outfile, level)
            outfile.write('model_.VCloudExtensionType(\n')
            VCloudExtension_.exportLiteral(outfile, level, name_='VCloudExtensionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VCloudExtension':
            obj_ = VCloudExtensionType.factory()
            obj_.build(child_)
            self.VCloudExtension.append(obj_)
            obj_.original_tagname_ = 'VCloudExtension'
# end class VCloudExtensibleType


class ErrorType(VCloudExtensibleType):
    """0.9 The standard error message type used in the vCloud REST API.
    none An one line, human-readable message describing the error
    that occurred. truenone The class of the error. Matches the HTTP
    status code. truenone Resource-specific error code. truenone A
    vendor- or implementation-specific error code that can reference
    specific modules or source lines for diagnostic purposes.
    false1.0none The stack trace of the exception. false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, vendorSpecificErrorCode=None, stackTrace=None, message=None, minorErrorCode=None, majorErrorCode=None):
        self.original_tagname_ = None
        super(ErrorType, self).__init__(VCloudExtension, )
        self.vendorSpecificErrorCode = _cast(None, vendorSpecificErrorCode)
        self.stackTrace = _cast(None, stackTrace)
        self.message = _cast(None, message)
        self.minorErrorCode = _cast(None, minorErrorCode)
        self.majorErrorCode = _cast(int, majorErrorCode)
    def factory(*args_, **kwargs_):
        if ErrorType.subclass:
            return ErrorType.subclass(*args_, **kwargs_)
        else:
            return ErrorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendorSpecificErrorCode(self): return self.vendorSpecificErrorCode
    def set_vendorSpecificErrorCode(self, vendorSpecificErrorCode): self.vendorSpecificErrorCode = vendorSpecificErrorCode
    def get_stackTrace(self): return self.stackTrace
    def set_stackTrace(self, stackTrace): self.stackTrace = stackTrace
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_minorErrorCode(self): return self.minorErrorCode
    def set_minorErrorCode(self, minorErrorCode): self.minorErrorCode = minorErrorCode
    def get_majorErrorCode(self): return self.majorErrorCode
    def set_majorErrorCode(self, majorErrorCode): self.majorErrorCode = majorErrorCode
    def hasContent_(self):
        if (
            super(ErrorType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ErrorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ErrorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ErrorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ErrorType'):
        super(ErrorType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ErrorType')
        if self.vendorSpecificErrorCode is not None and 'vendorSpecificErrorCode' not in already_processed:
            already_processed.add('vendorSpecificErrorCode')
            outfile.write(' vendorSpecificErrorCode=%s' % (self.gds_format_string(quote_attrib(self.vendorSpecificErrorCode).encode(ExternalEncoding), input_name='vendorSpecificErrorCode'), ))
        if self.stackTrace is not None and 'stackTrace' not in already_processed:
            already_processed.add('stackTrace')
            outfile.write(' stackTrace=%s' % (self.gds_format_string(quote_attrib(self.stackTrace).encode(ExternalEncoding), input_name='stackTrace'), ))
        if self.message is not None and 'message' not in already_processed:
            already_processed.add('message')
            outfile.write(' message=%s' % (self.gds_format_string(quote_attrib(self.message).encode(ExternalEncoding), input_name='message'), ))
        if self.minorErrorCode is not None and 'minorErrorCode' not in already_processed:
            already_processed.add('minorErrorCode')
            outfile.write(' minorErrorCode=%s' % (self.gds_format_string(quote_attrib(self.minorErrorCode).encode(ExternalEncoding), input_name='minorErrorCode'), ))
        if self.majorErrorCode is not None and 'majorErrorCode' not in already_processed:
            already_processed.add('majorErrorCode')
            outfile.write(' majorErrorCode="%s"' % self.gds_format_integer(self.majorErrorCode, input_name='majorErrorCode'))
    def exportChildren(self, outfile, level, namespace_='', name_='ErrorType', fromsubclass_=False, pretty_print=True):
        super(ErrorType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ErrorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vendorSpecificErrorCode is not None and 'vendorSpecificErrorCode' not in already_processed:
            already_processed.add('vendorSpecificErrorCode')
            showIndent(outfile, level)
            outfile.write('vendorSpecificErrorCode="%s",\n' % (self.vendorSpecificErrorCode,))
        if self.stackTrace is not None and 'stackTrace' not in already_processed:
            already_processed.add('stackTrace')
            showIndent(outfile, level)
            outfile.write('stackTrace="%s",\n' % (self.stackTrace,))
        if self.message is not None and 'message' not in already_processed:
            already_processed.add('message')
            showIndent(outfile, level)
            outfile.write('message="%s",\n' % (self.message,))
        if self.minorErrorCode is not None and 'minorErrorCode' not in already_processed:
            already_processed.add('minorErrorCode')
            showIndent(outfile, level)
            outfile.write('minorErrorCode="%s",\n' % (self.minorErrorCode,))
        if self.majorErrorCode is not None and 'majorErrorCode' not in already_processed:
            already_processed.add('majorErrorCode')
            showIndent(outfile, level)
            outfile.write('majorErrorCode=%d,\n' % (self.majorErrorCode,))
        super(ErrorType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ErrorType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vendorSpecificErrorCode', node)
        if value is not None and 'vendorSpecificErrorCode' not in already_processed:
            already_processed.add('vendorSpecificErrorCode')
            self.vendorSpecificErrorCode = value
        value = find_attr_value_('stackTrace', node)
        if value is not None and 'stackTrace' not in already_processed:
            already_processed.add('stackTrace')
            self.stackTrace = value
        value = find_attr_value_('message', node)
        if value is not None and 'message' not in already_processed:
            already_processed.add('message')
            self.message = value
        value = find_attr_value_('minorErrorCode', node)
        if value is not None and 'minorErrorCode' not in already_processed:
            already_processed.add('minorErrorCode')
            self.minorErrorCode = value
        value = find_attr_value_('majorErrorCode', node)
        if value is not None and 'majorErrorCode' not in already_processed:
            already_processed.add('majorErrorCode')
            try:
                self.majorErrorCode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(ErrorType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ErrorType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ErrorType


class ResourceType(VCloudExtensibleType):
    """0.9 The base type for all objects in the vCloud model. Has an
    optional list of links and href and type attributes. always The
    URI of the entity. falsealways The MIME type of the entity.
    false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, href=None, type_=None, Link=None):
        self.original_tagname_ = None
        super(ResourceType, self).__init__(VCloudExtension, )
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
    def factory(*args_, **kwargs_):
        if ResourceType.subclass:
            return ResourceType.subclass(*args_, **kwargs_)
        else:
            return ResourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def add_Link(self, value): self.Link.append(value)
    def insert_Link_at(self, index, value): self.Link.insert(index, value)
    def replace_Link_at(self, index, value): self.Link[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.Link or
            super(ResourceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceType'):
        super(ResourceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceType', fromsubclass_=False, pretty_print=True):
        super(ResourceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResourceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(ResourceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResourceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            Link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(ResourceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.Link.append(obj_)
            obj_.original_tagname_ = 'Link'
        super(ResourceType, self).buildChildren(child_, node, nodeName_, True)
# end class ResourceType


class IdentifiableResourceType(ResourceType):
    """0.9 The base type for all resource types which contain an id
    attribute. none The entity identifier, expressed in URN format.
    The value of this attribute uniquely identifies the entity,
    persists for the life of the entity, and is never reused.
    falsecreate Optional unique identifier to support idempotent
    semantics for create and delete operations. false"""
    subclass = None
    superclass = ResourceType
    def __init__(self, operationKey=None, id=None, extensiontype_=None):
        self.original_tagname_ = None
        super(IdentifiableResourceType, self).__init__(extensiontype_, )
        self.operationKey = _cast(None, operationKey)
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if IdentifiableResourceType.subclass:
            return IdentifiableResourceType.subclass(*args_, **kwargs_)
        else:
            return IdentifiableResourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_operationKey(self): return self.operationKey
    def set_operationKey(self, operationKey): self.operationKey = operationKey
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(IdentifiableResourceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiableResourceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiableResourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiableResourceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiableResourceType'):
        super(IdentifiableResourceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiableResourceType')
        if self.operationKey is not None and 'operationKey' not in already_processed:
            already_processed.add('operationKey')
            outfile.write(' operationKey=%s' % (self.gds_format_string(quote_attrib(self.operationKey).encode(ExternalEncoding), input_name='operationKey'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiableResourceType', fromsubclass_=False, pretty_print=True):
        super(IdentifiableResourceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='IdentifiableResourceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.operationKey is not None and 'operationKey' not in already_processed:
            already_processed.add('operationKey')
            showIndent(outfile, level)
            outfile.write('operationKey="%s",\n' % (self.operationKey,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        super(IdentifiableResourceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IdentifiableResourceType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operationKey', node)
        if value is not None and 'operationKey' not in already_processed:
            already_processed.add('operationKey')
            self.operationKey = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IdentifiableResourceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IdentifiableResourceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentifiableResourceType


class ParamsType(VCloudExtensibleType):
    """0.9 A basic type used to specify request parameters. always
    Typically used to name or identify the subject of the request.
    For example, the name of the object being created or modified.
    false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, name=None, Description=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ParamsType, self).__init__(VCloudExtension, extensiontype_, )
        self.name = _cast(None, name)
        self.Description = Description
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ParamsType.subclass:
            return ParamsType.subclass(*args_, **kwargs_)
        else:
            return ParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Description is not None or
            super(ParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParamsType'):
        super(ParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ParamsType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ParamsType', fromsubclass_=False, pretty_print=True):
        super(ParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(ParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        super(ParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class ParamsType


class ReferenceType(VCloudExtensibleType):
    """0.9 A reference to a resource. Contains an href attribute and
    optional name and type attributes. always Contains the URI to
    the entity. truealways The resource identifier, expressed in URN
    format. The value of this attribute uniquely identifies the
    resource, persists for the life of the resource, and is never
    reused. falsealways Contains the type of the the entity.
    falsealways Contains the name of the the entity. false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, href=None, type_=None, id=None, name=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ReferenceType, self).__init__(VCloudExtension, extensiontype_, )
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(ReferenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceType'):
        super(ReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        super(ReferenceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(ReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReferenceType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ReferenceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ReferenceType


class ResourceReferenceType(ReferenceType):
    """0.9 Represents a reference to a resource. Contains an href
    attribute, a resource status attribute, and optional name and
    type attributes. none Status of a resource. false"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, VCloudExtension=None, href=None, type_=None, id=None, name=None, status=None):
        self.original_tagname_ = None
        super(ResourceReferenceType, self).__init__(VCloudExtension, href, type_, id, name, )
        self.status = _cast(int, status)
    def factory(*args_, **kwargs_):
        if ResourceReferenceType.subclass:
            return ResourceReferenceType.subclass(*args_, **kwargs_)
        else:
            return ResourceReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def hasContent_(self):
        if (
            super(ResourceReferenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceReferenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceReferenceType'):
        super(ResourceReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceReferenceType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status="%s"' % self.gds_format_integer(self.status, input_name='status'))
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceReferenceType', fromsubclass_=False, pretty_print=True):
        super(ResourceReferenceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResourceReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % (self.status,))
        super(ResourceReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResourceReferenceType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            try:
                self.status = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(ResourceReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ResourceReferenceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ResourceReferenceType


class ContainerType(ResourceType):
    """Container for query result sets. none Query name that generated this
    result set. falsenone Page of the result set that this container
    holds. The first page is page number 1. falsenone Page size, as
    a number of records or references. falsenone Total number of
    records or references in the container. false"""
    subclass = None
    superclass = ResourceType
    def __init__(self, total=None, name=None, pageSize=None, page=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ContainerType, self).__init__(extensiontype_, )
        self.total = _cast(int, total)
        self.name = _cast(None, name)
        self.pageSize = _cast(int, pageSize)
        self.page = _cast(int, page)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ContainerType.subclass:
            return ContainerType.subclass(*args_, **kwargs_)
        else:
            return ContainerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_total(self): return self.total
    def set_total(self, total): self.total = total
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_pageSize(self): return self.pageSize
    def set_pageSize(self, pageSize): self.pageSize = pageSize
    def get_page(self): return self.page
    def set_page(self, page): self.page = page
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(ContainerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContainerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContainerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContainerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContainerType'):
        super(ContainerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ContainerType')
        if self.total is not None and 'total' not in already_processed:
            already_processed.add('total')
            outfile.write(' total="%s"' % self.gds_format_integer(self.total, input_name='total'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.pageSize is not None and 'pageSize' not in already_processed:
            already_processed.add('pageSize')
            outfile.write(' pageSize="%s"' % self.gds_format_integer(self.pageSize, input_name='pageSize'))
        if self.page is not None and 'page' not in already_processed:
            already_processed.add('page')
            outfile.write(' page="%s"' % self.gds_format_integer(self.page, input_name='page'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ContainerType', fromsubclass_=False, pretty_print=True):
        super(ContainerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ContainerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.total is not None and 'total' not in already_processed:
            already_processed.add('total')
            showIndent(outfile, level)
            outfile.write('total=%d,\n' % (self.total,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.pageSize is not None and 'pageSize' not in already_processed:
            already_processed.add('pageSize')
            showIndent(outfile, level)
            outfile.write('pageSize=%d,\n' % (self.pageSize,))
        if self.page is not None and 'page' not in already_processed:
            already_processed.add('page')
            showIndent(outfile, level)
            outfile.write('page=%d,\n' % (self.page,))
        super(ContainerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ContainerType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('total', node)
        if value is not None and 'total' not in already_processed:
            already_processed.add('total')
            try:
                self.total = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('pageSize', node)
        if value is not None and 'pageSize' not in already_processed:
            already_processed.add('pageSize')
            try:
                self.pageSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('page', node)
        if value is not None and 'page' not in already_processed:
            already_processed.add('page')
            try:
                self.page = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ContainerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ContainerType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ContainerType


class CapacityType(VCloudExtensibleType):
    """0.9 Represents the capacity of a given resource."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Units=None, Allocated=None, Limit=None, extensiontype_=None):
        self.original_tagname_ = None
        super(CapacityType, self).__init__(VCloudExtension, extensiontype_, )
        self.Units = Units
        self.Allocated = Allocated
        self.Limit = Limit
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CapacityType.subclass:
            return CapacityType.subclass(*args_, **kwargs_)
        else:
            return CapacityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def get_Allocated(self): return self.Allocated
    def set_Allocated(self, Allocated): self.Allocated = Allocated
    def get_Limit(self): return self.Limit
    def set_Limit(self, Limit): self.Limit = Limit
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Units is not None or
            self.Allocated is not None or
            self.Limit is not None or
            super(CapacityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CapacityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CapacityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CapacityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CapacityType'):
        super(CapacityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CapacityType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CapacityType', fromsubclass_=False, pretty_print=True):
        super(CapacityType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnits>%s</%sUnits>%s' % (namespace_, self.gds_format_string(quote_xml(self.Units).encode(ExternalEncoding), input_name='Units'), namespace_, eol_))
        if self.Allocated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllocated>%s</%sAllocated>%s' % (namespace_, self.gds_format_integer(self.Allocated, input_name='Allocated'), namespace_, eol_))
        if self.Limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLimit>%s</%sLimit>%s' % (namespace_, self.gds_format_integer(self.Limit, input_name='Limit'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CapacityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CapacityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CapacityType, self).exportLiteralChildren(outfile, level, name_)
        if self.Units is not None:
            showIndent(outfile, level)
            outfile.write('Units=%s,\n' % quote_python(self.Units).encode(ExternalEncoding))
        if self.Allocated is not None:
            showIndent(outfile, level)
            outfile.write('Allocated=%d,\n' % self.Allocated)
        if self.Limit is not None:
            showIndent(outfile, level)
            outfile.write('Limit=%d,\n' % self.Limit)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CapacityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Units':
            Units_ = child_.text
            Units_ = self.gds_validate_string(Units_, node, 'Units')
            self.Units = Units_
        elif nodeName_ == 'Allocated':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Allocated')
            self.Allocated = ival_
        elif nodeName_ == 'Limit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Limit')
            self.Limit = ival_
        super(CapacityType, self).buildChildren(child_, node, nodeName_, True)
# end class CapacityType


class CapacityWithUsageType(CapacityType):
    """0.9 Represents a capacity and usage of a given resource."""
    subclass = None
    superclass = CapacityType
    def __init__(self, VCloudExtension=None, Units=None, Allocated=None, Limit=None, Reserved=None, Used=None, Overhead=None):
        self.original_tagname_ = None
        super(CapacityWithUsageType, self).__init__(VCloudExtension, Units, Allocated, Limit, )
        self.Reserved = Reserved
        self.Used = Used
        self.Overhead = Overhead
    def factory(*args_, **kwargs_):
        if CapacityWithUsageType.subclass:
            return CapacityWithUsageType.subclass(*args_, **kwargs_)
        else:
            return CapacityWithUsageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reserved(self): return self.Reserved
    def set_Reserved(self, Reserved): self.Reserved = Reserved
    def get_Used(self): return self.Used
    def set_Used(self, Used): self.Used = Used
    def get_Overhead(self): return self.Overhead
    def set_Overhead(self, Overhead): self.Overhead = Overhead
    def hasContent_(self):
        if (
            self.Reserved is not None or
            self.Used is not None or
            self.Overhead is not None or
            super(CapacityWithUsageType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CapacityWithUsageType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CapacityWithUsageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CapacityWithUsageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CapacityWithUsageType'):
        super(CapacityWithUsageType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CapacityWithUsageType')
    def exportChildren(self, outfile, level, namespace_='', name_='CapacityWithUsageType', fromsubclass_=False, pretty_print=True):
        super(CapacityWithUsageType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Reserved is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReserved>%s</%sReserved>%s' % (namespace_, self.gds_format_integer(self.Reserved, input_name='Reserved'), namespace_, eol_))
        if self.Used is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUsed>%s</%sUsed>%s' % (namespace_, self.gds_format_integer(self.Used, input_name='Used'), namespace_, eol_))
        if self.Overhead is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOverhead>%s</%sOverhead>%s' % (namespace_, self.gds_format_integer(self.Overhead, input_name='Overhead'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CapacityWithUsageType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CapacityWithUsageType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CapacityWithUsageType, self).exportLiteralChildren(outfile, level, name_)
        if self.Reserved is not None:
            showIndent(outfile, level)
            outfile.write('Reserved=%d,\n' % self.Reserved)
        if self.Used is not None:
            showIndent(outfile, level)
            outfile.write('Used=%d,\n' % self.Used)
        if self.Overhead is not None:
            showIndent(outfile, level)
            outfile.write('Overhead=%d,\n' % self.Overhead)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CapacityWithUsageType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reserved':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Reserved')
            self.Reserved = ival_
        elif nodeName_ == 'Used':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Used')
            self.Used = ival_
        elif nodeName_ == 'Overhead':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Overhead')
            self.Overhead = ival_
        super(CapacityWithUsageType, self).buildChildren(child_, node, nodeName_, True)
# end class CapacityWithUsageType


class AccessSettingType(VCloudExtensibleType):
    """0.9 Controls access to the resource."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Subject=None, AccessLevel=None):
        self.original_tagname_ = None
        super(AccessSettingType, self).__init__(VCloudExtension, )
        self.Subject = Subject
        self.AccessLevel = AccessLevel
    def factory(*args_, **kwargs_):
        if AccessSettingType.subclass:
            return AccessSettingType.subclass(*args_, **kwargs_)
        else:
            return AccessSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Subject(self): return self.Subject
    def set_Subject(self, Subject): self.Subject = Subject
    def get_AccessLevel(self): return self.AccessLevel
    def set_AccessLevel(self, AccessLevel): self.AccessLevel = AccessLevel
    def hasContent_(self):
        if (
            self.Subject is not None or
            self.AccessLevel is not None or
            super(AccessSettingType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccessSettingType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccessSettingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccessSettingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccessSettingType'):
        super(AccessSettingType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AccessSettingType')
    def exportChildren(self, outfile, level, namespace_='', name_='AccessSettingType', fromsubclass_=False, pretty_print=True):
        super(AccessSettingType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Subject is not None:
            self.Subject.export(outfile, level, namespace_, name_='Subject', pretty_print=pretty_print)
        if self.AccessLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccessLevel>%s</%sAccessLevel>%s' % (namespace_, self.gds_format_string(quote_xml(self.AccessLevel).encode(ExternalEncoding), input_name='AccessLevel'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AccessSettingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AccessSettingType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AccessSettingType, self).exportLiteralChildren(outfile, level, name_)
        if self.Subject is not None:
            showIndent(outfile, level)
            outfile.write('Subject=model_.ReferenceType(\n')
            self.Subject.exportLiteral(outfile, level, name_='Subject')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AccessLevel is not None:
            showIndent(outfile, level)
            outfile.write('AccessLevel=%s,\n' % quote_python(self.AccessLevel).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AccessSettingType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Subject':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Subject = obj_
            obj_.original_tagname_ = 'Subject'
        elif nodeName_ == 'AccessLevel':
            AccessLevel_ = child_.text
            AccessLevel_ = self.gds_validate_string(AccessLevel_, node, 'AccessLevel')
            self.AccessLevel = AccessLevel_
        super(AccessSettingType, self).buildChildren(child_, node, nodeName_, True)
# end class AccessSettingType


class AccessSettingsType(VCloudExtensibleType):
    """0.9 A list of access settings for a resource."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, AccessSetting=None):
        self.original_tagname_ = None
        super(AccessSettingsType, self).__init__(VCloudExtension, )
        if AccessSetting is None:
            self.AccessSetting = []
        else:
            self.AccessSetting = AccessSetting
    def factory(*args_, **kwargs_):
        if AccessSettingsType.subclass:
            return AccessSettingsType.subclass(*args_, **kwargs_)
        else:
            return AccessSettingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AccessSetting(self): return self.AccessSetting
    def set_AccessSetting(self, AccessSetting): self.AccessSetting = AccessSetting
    def add_AccessSetting(self, value): self.AccessSetting.append(value)
    def insert_AccessSetting_at(self, index, value): self.AccessSetting.insert(index, value)
    def replace_AccessSetting_at(self, index, value): self.AccessSetting[index] = value
    def hasContent_(self):
        if (
            self.AccessSetting or
            super(AccessSettingsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccessSettingsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccessSettingsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccessSettingsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccessSettingsType'):
        super(AccessSettingsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AccessSettingsType')
    def exportChildren(self, outfile, level, namespace_='', name_='AccessSettingsType', fromsubclass_=False, pretty_print=True):
        super(AccessSettingsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AccessSetting_ in self.AccessSetting:
            AccessSetting_.export(outfile, level, namespace_, name_='AccessSetting', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AccessSettingsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AccessSettingsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AccessSettingsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('AccessSetting=[\n')
        level += 1
        for AccessSetting_ in self.AccessSetting:
            showIndent(outfile, level)
            outfile.write('model_.AccessSettingType(\n')
            AccessSetting_.exportLiteral(outfile, level, name_='AccessSettingType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AccessSettingsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AccessSetting':
            obj_ = AccessSettingType.factory()
            obj_.build(child_)
            self.AccessSetting.append(obj_)
            obj_.original_tagname_ = 'AccessSetting'
        super(AccessSettingsType, self).buildChildren(child_, node, nodeName_, True)
# end class AccessSettingsType


class ControlAccessParamsType(VCloudExtensibleType):
    """0.9 Specifies access controls for a resource."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsSharedToEveryone=None, EveryoneAccessLevel=None, AccessSettings=None):
        self.original_tagname_ = None
        super(ControlAccessParamsType, self).__init__(VCloudExtension, )
        self.IsSharedToEveryone = IsSharedToEveryone
        self.EveryoneAccessLevel = EveryoneAccessLevel
        self.AccessSettings = AccessSettings
    def factory(*args_, **kwargs_):
        if ControlAccessParamsType.subclass:
            return ControlAccessParamsType.subclass(*args_, **kwargs_)
        else:
            return ControlAccessParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsSharedToEveryone(self): return self.IsSharedToEveryone
    def set_IsSharedToEveryone(self, IsSharedToEveryone): self.IsSharedToEveryone = IsSharedToEveryone
    def get_EveryoneAccessLevel(self): return self.EveryoneAccessLevel
    def set_EveryoneAccessLevel(self, EveryoneAccessLevel): self.EveryoneAccessLevel = EveryoneAccessLevel
    def get_AccessSettings(self): return self.AccessSettings
    def set_AccessSettings(self, AccessSettings): self.AccessSettings = AccessSettings
    def hasContent_(self):
        if (
            self.IsSharedToEveryone is not None or
            self.EveryoneAccessLevel is not None or
            self.AccessSettings is not None or
            super(ControlAccessParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ControlAccessParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ControlAccessParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ControlAccessParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ControlAccessParamsType'):
        super(ControlAccessParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ControlAccessParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='ControlAccessParamsType', fromsubclass_=False, pretty_print=True):
        super(ControlAccessParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsSharedToEveryone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsSharedToEveryone>%s</%sIsSharedToEveryone>%s' % (namespace_, self.gds_format_boolean(self.IsSharedToEveryone, input_name='IsSharedToEveryone'), namespace_, eol_))
        if self.EveryoneAccessLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEveryoneAccessLevel>%s</%sEveryoneAccessLevel>%s' % (namespace_, self.gds_format_string(quote_xml(self.EveryoneAccessLevel).encode(ExternalEncoding), input_name='EveryoneAccessLevel'), namespace_, eol_))
        if self.AccessSettings is not None:
            self.AccessSettings.export(outfile, level, namespace_, name_='AccessSettings', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ControlAccessParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ControlAccessParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ControlAccessParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsSharedToEveryone is not None:
            showIndent(outfile, level)
            outfile.write('IsSharedToEveryone=%s,\n' % self.IsSharedToEveryone)
        if self.EveryoneAccessLevel is not None:
            showIndent(outfile, level)
            outfile.write('EveryoneAccessLevel=%s,\n' % quote_python(self.EveryoneAccessLevel).encode(ExternalEncoding))
        if self.AccessSettings is not None:
            showIndent(outfile, level)
            outfile.write('AccessSettings=model_.AccessSettingsType(\n')
            self.AccessSettings.exportLiteral(outfile, level, name_='AccessSettings')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ControlAccessParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsSharedToEveryone':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsSharedToEveryone')
            self.IsSharedToEveryone = ival_
        elif nodeName_ == 'EveryoneAccessLevel':
            EveryoneAccessLevel_ = child_.text
            EveryoneAccessLevel_ = self.gds_validate_string(EveryoneAccessLevel_, node, 'EveryoneAccessLevel')
            self.EveryoneAccessLevel = EveryoneAccessLevel_
        elif nodeName_ == 'AccessSettings':
            obj_ = AccessSettingsType.factory()
            obj_.build(child_)
            self.AccessSettings = obj_
            obj_.original_tagname_ = 'AccessSettings'
        super(ControlAccessParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class ControlAccessParamsType


class OwnerType(ResourceType):
    """1.5 Represents the owner of this entity."""
    subclass = None
    superclass = ResourceType
    def __init__(self, User=None):
        self.original_tagname_ = None
        super(OwnerType, self).__init__()
        self.User = User
    def factory(*args_, **kwargs_):
        if OwnerType.subclass:
            return OwnerType.subclass(*args_, **kwargs_)
        else:
            return OwnerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_User(self): return self.User
    def set_User(self, User): self.User = User
    def hasContent_(self):
        if (
            self.User is not None or
            super(OwnerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OwnerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OwnerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OwnerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OwnerType'):
        super(OwnerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OwnerType')
    def exportChildren(self, outfile, level, namespace_='', name_='OwnerType', fromsubclass_=False, pretty_print=True):
        super(OwnerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.User is not None:
            self.User.export(outfile, level, namespace_, name_='User', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OwnerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OwnerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OwnerType, self).exportLiteralChildren(outfile, level, name_)
        if self.User is not None:
            showIndent(outfile, level)
            outfile.write('User=model_.ReferenceType(\n')
            self.User.exportLiteral(outfile, level, name_='User')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OwnerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'User':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.User = obj_
            obj_.original_tagname_ = 'User'
        super(OwnerType, self).buildChildren(child_, node, nodeName_, True)
# end class OwnerType


class ReferencesType(ContainerType):
    """Container for query results returned in references format."""
    subclass = None
    superclass = ContainerType
    def __init__(self, total=None, name=None, pageSize=None, page=None, Reference=None):
        self.original_tagname_ = None
        super(ReferencesType, self).__init__(total, name, pageSize, page, )
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if ReferencesType.subclass:
            return ReferencesType.subclass(*args_, **kwargs_)
        else:
            return ReferencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference_at(self, index, value): self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value): self.Reference[index] = value
    def hasContent_(self):
        if (
            self.Reference or
            super(ReferencesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferencesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferencesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferencesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferencesType'):
        super(ReferencesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReferencesType')
    def exportChildren(self, outfile, level, namespace_='', name_='ReferencesType', fromsubclass_=False, pretty_print=True):
        super(ReferencesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespace_, name_='Reference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferencesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ReferencesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReferencesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Reference=[\n')
        level += 1
        for Reference_ in self.Reference:
            showIndent(outfile, level)
            outfile.write('model_.Reference(\n')
            Reference_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReferencesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
        super(ReferencesType, self).buildChildren(child_, node, nodeName_, True)
# end class ReferencesType


class QueryListType(ContainerType):
    """Container for the list of typed queries available to the requesting
    user."""
    subclass = None
    superclass = ContainerType
    def __init__(self, total=None, name=None, pageSize=None, page=None):
        self.original_tagname_ = None
        super(QueryListType, self).__init__(total, name, pageSize, page, )
    def factory(*args_, **kwargs_):
        if QueryListType.subclass:
            return QueryListType.subclass(*args_, **kwargs_)
        else:
            return QueryListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(QueryListType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryListType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryListType'):
        super(QueryListType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryListType')
    def exportChildren(self, outfile, level, namespace_='', name_='QueryListType', fromsubclass_=False, pretty_print=True):
        super(QueryListType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='QueryListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryListType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryListType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(QueryListType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryListType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryListType


class MetadataDomainTagType(GeneratedsSuper):
    """A value of SYSTEM places this MetadataEntry in the SYSTEM domain.
    Omit or leave empty to place this MetadataEntry in the GENERAL
    domain. true One of:<br> PRIVATE<br> READONLY"""
    subclass = None
    superclass = None
    def __init__(self, visibility=None, valueOf_=None):
        self.original_tagname_ = None
        self.visibility = _cast(None, visibility)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if MetadataDomainTagType.subclass:
            return MetadataDomainTagType.subclass(*args_, **kwargs_)
        else:
            return MetadataDomainTagType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_visibility(self): return self.visibility
    def set_visibility(self, visibility): self.visibility = visibility
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataDomainTagType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataDomainTagType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataDomainTagType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataDomainTagType'):
        if self.visibility is not None and 'visibility' not in already_processed:
            already_processed.add('visibility')
            outfile.write(' visibility=%s' % (self.gds_format_string(quote_attrib(self.visibility).encode(ExternalEncoding), input_name='visibility'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataDomainTagType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='MetadataDomainTagType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.visibility is not None and 'visibility' not in already_processed:
            already_processed.add('visibility')
            showIndent(outfile, level)
            outfile.write('visibility="%s",\n' % (self.visibility,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('visibility', node)
        if value is not None and 'visibility' not in already_processed:
            already_processed.add('visibility')
            self.visibility = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MetadataDomainTagType


class MetadataEntryType(ResourceType):
    subclass = None
    superclass = ResourceType
    def __init__(self, Domain=None, Key=None, Value=None, TypedValue=None):
        self.original_tagname_ = None
        super(MetadataEntryType, self).__init__()
        self.Domain = Domain
        self.Key = Key
        self.Value = Value
        self.TypedValue = TypedValue
    def factory(*args_, **kwargs_):
        if MetadataEntryType.subclass:
            return MetadataEntryType.subclass(*args_, **kwargs_)
        else:
            return MetadataEntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Domain(self): return self.Domain
    def set_Domain(self, Domain): self.Domain = Domain
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_TypedValue(self): return self.TypedValue
    def set_TypedValue(self, TypedValue): self.TypedValue = TypedValue
    def hasContent_(self):
        if (
            self.Domain is not None or
            self.Key is not None or
            self.Value is not None or
            self.TypedValue is not None or
            super(MetadataEntryType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataEntryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataEntryType'):
        super(MetadataEntryType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataEntryType')
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataEntryType', fromsubclass_=False, pretty_print=True):
        super(MetadataEntryType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Domain is not None:
            self.Domain.export(outfile, level, namespace_, name_='Domain', pretty_print=pretty_print)
        if self.Key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKey>%s</%sKey>%s' % (namespace_, self.gds_format_string(quote_xml(self.Key).encode(ExternalEncoding), input_name='Key'), namespace_, eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
        if self.TypedValue is not None:
            self.TypedValue.export(outfile, level, namespace_, name_='TypedValue', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataEntryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataEntryType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataEntryType, self).exportLiteralChildren(outfile, level, name_)
        if self.Domain is not None:
            showIndent(outfile, level)
            outfile.write('Domain=model_.MetadataDomainTagType(\n')
            self.Domain.exportLiteral(outfile, level, name_='Domain')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Key is not None:
            showIndent(outfile, level)
            outfile.write('Key=%s,\n' % quote_python(self.Key).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
        if self.MetadataTypedValue is not None:
            showIndent(outfile, level)
            outfile.write('MetadataTypedValue=model_.MetadataTypedValue(\n')
            self.MetadataTypedValue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataEntryType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Domain':
            obj_ = MetadataDomainTagType.factory()
            obj_.build(child_)
            self.Domain = obj_
            obj_.original_tagname_ = 'Domain'
        elif nodeName_ == 'Key':
            Key_ = child_.text
            Key_ = self.gds_validate_string(Key_, node, 'Key')
            self.Key = Key_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        elif nodeName_ == 'TypedValue':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <TypedValue> element')
            self.TypedValue = obj_
            obj_.original_tagname_ = 'TypedValue'
        super(MetadataEntryType, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataEntryType


class MetadataTypedValue(GeneratedsSuper):
    """One of:<br> MetadataStringValue<br> MetadataNumberValue<br>
    MetadataBooleanValue<br> MetadataDateTimeValue"""
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MetadataTypedValue.subclass:
            return MetadataTypedValue.subclass(*args_, **kwargs_)
        else:
            return MetadataTypedValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataTypedValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataTypedValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataTypedValue', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataTypedValue'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataTypedValue', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='MetadataTypedValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MetadataTypedValue


class MetadataStringValue(MetadataTypedValue):
    """UTF-8 character set. Strings longer than 1000 characters cannot be
    searched for in a query."""
    subclass = None
    superclass = MetadataTypedValue
    def __init__(self, Value=None):
        self.original_tagname_ = None
        super(MetadataStringValue, self).__init__()
        self.Value = Value
    def factory(*args_, **kwargs_):
        if MetadataStringValue.subclass:
            return MetadataStringValue.subclass(*args_, **kwargs_)
        else:
            return MetadataStringValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(MetadataStringValue, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataStringValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataStringValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataStringValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataStringValue'):
        super(MetadataStringValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataStringValue')
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataStringValue', fromsubclass_=False, pretty_print=True):
        super(MetadataStringValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MetadataStringValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataStringValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataStringValue, self).exportLiteralChildren(outfile, level, name_)
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataStringValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        super(MetadataStringValue, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataStringValue


class MetadataNumberValue(MetadataTypedValue):
    """A signed 8-byte integer."""
    subclass = None
    superclass = MetadataTypedValue
    def __init__(self, Value=None):
        self.original_tagname_ = None
        super(MetadataNumberValue, self).__init__()
        self.Value = Value
    def factory(*args_, **kwargs_):
        if MetadataNumberValue.subclass:
            return MetadataNumberValue.subclass(*args_, **kwargs_)
        else:
            return MetadataNumberValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(MetadataNumberValue, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataNumberValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataNumberValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataNumberValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataNumberValue'):
        super(MetadataNumberValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataNumberValue')
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataNumberValue', fromsubclass_=False, pretty_print=True):
        super(MetadataNumberValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_integer(self.Value, input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MetadataNumberValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataNumberValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataNumberValue, self).exportLiteralChildren(outfile, level, name_)
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%d,\n' % self.Value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataNumberValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Value')
            self.Value = ival_
        super(MetadataNumberValue, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataNumberValue


class MetadataBooleanValue(MetadataTypedValue):
    """One of: 1, 0, true, false"""
    subclass = None
    superclass = MetadataTypedValue
    def __init__(self, Value=None):
        self.original_tagname_ = None
        super(MetadataBooleanValue, self).__init__()
        self.Value = Value
    def factory(*args_, **kwargs_):
        if MetadataBooleanValue.subclass:
            return MetadataBooleanValue.subclass(*args_, **kwargs_)
        else:
            return MetadataBooleanValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(MetadataBooleanValue, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataBooleanValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataBooleanValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataBooleanValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataBooleanValue'):
        super(MetadataBooleanValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataBooleanValue')
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataBooleanValue', fromsubclass_=False, pretty_print=True):
        super(MetadataBooleanValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_boolean(self.Value, input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MetadataBooleanValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataBooleanValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataBooleanValue, self).exportLiteralChildren(outfile, level, name_)
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % self.Value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataBooleanValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Value')
            self.Value = ival_
        super(MetadataBooleanValue, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataBooleanValue


class MetadataDateTimeValue(MetadataTypedValue):
    """UTC format. For example 2012-06-18T12:00:00-05:00"""
    subclass = None
    superclass = MetadataTypedValue
    def __init__(self, Value=None):
        self.original_tagname_ = None
        super(MetadataDateTimeValue, self).__init__()
        if isinstance(Value, basestring):
            initvalue_ = datetime_.datetime.strptime(Value, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Value
        self.Value = initvalue_
    def factory(*args_, **kwargs_):
        if MetadataDateTimeValue.subclass:
            return MetadataDateTimeValue.subclass(*args_, **kwargs_)
        else:
            return MetadataDateTimeValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(MetadataDateTimeValue, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataDateTimeValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataDateTimeValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataDateTimeValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataDateTimeValue'):
        super(MetadataDateTimeValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataDateTimeValue')
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataDateTimeValue', fromsubclass_=False, pretty_print=True):
        super(MetadataDateTimeValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_datetime(self.Value, input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MetadataDateTimeValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataDateTimeValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataDateTimeValue, self).exportLiteralChildren(outfile, level, name_)
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.Value, input_name='Value'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataDateTimeValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Value = dval_
        super(MetadataDateTimeValue, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataDateTimeValue


class MetadataType(ResourceType):
    """User-defined metadata associated with with an object."""
    subclass = None
    superclass = ResourceType
    def __init__(self, MetadataEntry=None):
        self.original_tagname_ = None
        super(MetadataType, self).__init__()
        if MetadataEntry is None:
            self.MetadataEntry = []
        else:
            self.MetadataEntry = MetadataEntry
    def factory(*args_, **kwargs_):
        if MetadataType.subclass:
            return MetadataType.subclass(*args_, **kwargs_)
        else:
            return MetadataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MetadataEntry(self): return self.MetadataEntry
    def set_MetadataEntry(self, MetadataEntry): self.MetadataEntry = MetadataEntry
    def add_MetadataEntry(self, value): self.MetadataEntry.append(value)
    def insert_MetadataEntry_at(self, index, value): self.MetadataEntry.insert(index, value)
    def replace_MetadataEntry_at(self, index, value): self.MetadataEntry[index] = value
    def hasContent_(self):
        if (
            self.MetadataEntry or
            super(MetadataType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataType'):
        super(MetadataType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataType')
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataType', fromsubclass_=False, pretty_print=True):
        super(MetadataType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MetadataEntry_ in self.MetadataEntry:
            MetadataEntry_.export(outfile, level, namespace_, name_='MetadataEntry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('MetadataEntry=[\n')
        level += 1
        for MetadataEntry_ in self.MetadataEntry:
            showIndent(outfile, level)
            outfile.write('model_.MetadataEntryType(\n')
            MetadataEntry_.exportLiteral(outfile, level, name_='MetadataEntryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MetadataEntry':
            obj_ = MetadataEntryType.factory()
            obj_.build(child_)
            self.MetadataEntry.append(obj_)
            obj_.original_tagname_ = 'MetadataEntry'
        super(MetadataType, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataType


class MetadataValueType(ResourceType):
    subclass = None
    superclass = ResourceType
    def __init__(self, Domain=None, Value=None, TypedValue=None):
        self.original_tagname_ = None
        super(MetadataValueType, self).__init__()
        self.Domain = Domain
        self.Value = Value
        self.TypedValue = TypedValue
    def factory(*args_, **kwargs_):
        if MetadataValueType.subclass:
            return MetadataValueType.subclass(*args_, **kwargs_)
        else:
            return MetadataValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Domain(self): return self.Domain
    def set_Domain(self, Domain): self.Domain = Domain
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_TypedValue(self): return self.TypedValue
    def set_TypedValue(self, TypedValue): self.TypedValue = TypedValue
    def hasContent_(self):
        if (
            self.Domain is not None or
            self.Value is not None or
            self.TypedValue is not None or
            super(MetadataValueType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataValueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataValueType'):
        super(MetadataValueType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataValueType')
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataValueType', fromsubclass_=False, pretty_print=True):
        super(MetadataValueType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Domain is not None:
            self.Domain.export(outfile, level, namespace_, name_='Domain', pretty_print=pretty_print)
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
        if self.TypedValue is not None:
            self.TypedValue.export(outfile, level, namespace_, name_='TypedValue', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataValueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataValueType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataValueType, self).exportLiteralChildren(outfile, level, name_)
        if self.Domain is not None:
            showIndent(outfile, level)
            outfile.write('Domain=model_.MetadataDomainTagType(\n')
            self.Domain.exportLiteral(outfile, level, name_='Domain')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
        if self.MetadataTypedValue is not None:
            showIndent(outfile, level)
            outfile.write('MetadataTypedValue=model_.MetadataTypedValue(\n')
            self.MetadataTypedValue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataValueType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Domain':
            obj_ = MetadataDomainTagType.factory()
            obj_.build(child_)
            self.Domain = obj_
            obj_.original_tagname_ = 'Domain'
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        elif nodeName_ == 'TypedValue':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <TypedValue> element')
            self.TypedValue = obj_
            obj_.original_tagname_ = 'TypedValue'
        super(MetadataValueType, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataValueType


class FileUploadParamsType(VCloudExtensibleType):
    """5.1 Parameters for initializing file upload session. create Size in
    bytes of the file which will be uploaded. true"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, fileSize=None):
        self.original_tagname_ = None
        super(FileUploadParamsType, self).__init__(VCloudExtension, )
        self.fileSize = _cast(int, fileSize)
    def factory(*args_, **kwargs_):
        if FileUploadParamsType.subclass:
            return FileUploadParamsType.subclass(*args_, **kwargs_)
        else:
            return FileUploadParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileSize(self): return self.fileSize
    def set_fileSize(self, fileSize): self.fileSize = fileSize
    def hasContent_(self):
        if (
            super(FileUploadParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FileUploadParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FileUploadParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FileUploadParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FileUploadParamsType'):
        super(FileUploadParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FileUploadParamsType')
        if self.fileSize is not None and 'fileSize' not in already_processed:
            already_processed.add('fileSize')
            outfile.write(' fileSize="%s"' % self.gds_format_integer(self.fileSize, input_name='fileSize'))
    def exportChildren(self, outfile, level, namespace_='', name_='FileUploadParamsType', fromsubclass_=False, pretty_print=True):
        super(FileUploadParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FileUploadParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fileSize is not None and 'fileSize' not in already_processed:
            already_processed.add('fileSize')
            showIndent(outfile, level)
            outfile.write('fileSize=%d,\n' % (self.fileSize,))
        super(FileUploadParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FileUploadParamsType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fileSize', node)
        if value is not None and 'fileSize' not in already_processed:
            already_processed.add('fileSize')
            try:
                self.fileSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(FileUploadParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FileUploadParamsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FileUploadParamsType


class FileUploadSocketType(VCloudExtensibleType):
    """5.1 Parameters for initiating file upload. none URL where the file
    must be uploaded. false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, uploadLocation=None, Task=None):
        self.original_tagname_ = None
        super(FileUploadSocketType, self).__init__(VCloudExtension, )
        self.uploadLocation = _cast(None, uploadLocation)
        self.Task = Task
    def factory(*args_, **kwargs_):
        if FileUploadSocketType.subclass:
            return FileUploadSocketType.subclass(*args_, **kwargs_)
        else:
            return FileUploadSocketType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Task(self): return self.Task
    def set_Task(self, Task): self.Task = Task
    def get_uploadLocation(self): return self.uploadLocation
    def set_uploadLocation(self, uploadLocation): self.uploadLocation = uploadLocation
    def hasContent_(self):
        if (
            self.Task is not None or
            super(FileUploadSocketType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FileUploadSocketType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FileUploadSocketType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FileUploadSocketType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FileUploadSocketType'):
        super(FileUploadSocketType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FileUploadSocketType')
        if self.uploadLocation is not None and 'uploadLocation' not in already_processed:
            already_processed.add('uploadLocation')
            outfile.write(' uploadLocation=%s' % (self.gds_format_string(quote_attrib(self.uploadLocation).encode(ExternalEncoding), input_name='uploadLocation'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FileUploadSocketType', fromsubclass_=False, pretty_print=True):
        super(FileUploadSocketType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Task is not None:
            self.Task.export(outfile, level, namespace_, name_='Task', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FileUploadSocketType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uploadLocation is not None and 'uploadLocation' not in already_processed:
            already_processed.add('uploadLocation')
            showIndent(outfile, level)
            outfile.write('uploadLocation="%s",\n' % (self.uploadLocation,))
        super(FileUploadSocketType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FileUploadSocketType, self).exportLiteralChildren(outfile, level, name_)
        if self.Task is not None:
            showIndent(outfile, level)
            outfile.write('Task=model_.TaskType(\n')
            self.Task.exportLiteral(outfile, level, name_='Task')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uploadLocation', node)
        if value is not None and 'uploadLocation' not in already_processed:
            already_processed.add('uploadLocation')
            self.uploadLocation = value
        super(FileUploadSocketType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Task':
            obj_ = TaskType.factory()
            obj_.build(child_)
            self.Task = obj_
            obj_.original_tagname_ = 'Task'
        super(FileUploadSocketType, self).buildChildren(child_, node, nodeName_, True)
# end class FileUploadSocketType


class TaskOperationListType(ResourceType):
    """List of operation names. 1.5"""
    subclass = None
    superclass = ResourceType
    def __init__(self, Operation=None):
        self.original_tagname_ = None
        super(TaskOperationListType, self).__init__()
        if Operation is None:
            self.Operation = []
        else:
            self.Operation = Operation
    def factory(*args_, **kwargs_):
        if TaskOperationListType.subclass:
            return TaskOperationListType.subclass(*args_, **kwargs_)
        else:
            return TaskOperationListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Operation(self): return self.Operation
    def set_Operation(self, Operation): self.Operation = Operation
    def add_Operation(self, value): self.Operation.append(value)
    def insert_Operation_at(self, index, value): self.Operation.insert(index, value)
    def replace_Operation_at(self, index, value): self.Operation[index] = value
    def hasContent_(self):
        if (
            self.Operation or
            super(TaskOperationListType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TaskOperationListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaskOperationListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TaskOperationListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TaskOperationListType'):
        super(TaskOperationListType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TaskOperationListType')
    def exportChildren(self, outfile, level, namespace_='', name_='TaskOperationListType', fromsubclass_=False, pretty_print=True):
        super(TaskOperationListType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Operation_ in self.Operation:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOperation>%s</%sOperation>%s' % (namespace_, self.gds_format_string(quote_xml(Operation_).encode(ExternalEncoding), input_name='Operation'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TaskOperationListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TaskOperationListType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TaskOperationListType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Operation=[\n')
        level += 1
        for Operation_ in self.Operation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Operation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TaskOperationListType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Operation':
            Operation_ = child_.text
            Operation_ = self.gds_validate_string(Operation_, node, 'Operation')
            self.Operation.append(Operation_)
        super(TaskOperationListType, self).buildChildren(child_, node, nodeName_, True)
# end class TaskOperationListType


class EntityType(IdentifiableResourceType):
    """0.9 Basic entity type in the vCloud object model. Includes a name,
    an optional description, and an optional list of links. always
    The name of the entity. true"""
    subclass = None
    superclass = IdentifiableResourceType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, extensiontype_=None):
        self.original_tagname_ = None
        super(EntityType, self).__init__(operationKey, id, extensiontype_, )
        self.name = _cast(None, name)
        self.Description = Description
        self.Tasks = Tasks
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EntityType.subclass:
            return EntityType.subclass(*args_, **kwargs_)
        else:
            return EntityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Tasks(self): return self.Tasks
    def set_Tasks(self, Tasks): self.Tasks = Tasks
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Tasks is not None or
            super(EntityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityType'):
        super(EntityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='EntityType', fromsubclass_=False, pretty_print=True):
        super(EntityType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.Tasks is not None:
            self.Tasks.export(outfile, level, namespace_, name_='Tasks', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EntityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(EntityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityType, self).exportLiteralChildren(outfile, level, name_)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Tasks is not None:
            showIndent(outfile, level)
            outfile.write('Tasks=model_.TasksInProgressType(\n')
            self.Tasks.exportLiteral(outfile, level, name_='Tasks')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EntityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Tasks':
            obj_ = TasksInProgressType.factory()
            obj_.build(child_)
            self.Tasks = obj_
            obj_.original_tagname_ = 'Tasks'
        super(EntityType, self).buildChildren(child_, node, nodeName_, True)
# end class EntityType


class EntityReferenceType(VCloudExtensibleType):
    """1.5 A reference to a vCloud entity. none The object identifier,
    expressed in URN format. The value of this attribute uniquely
    identifies the object, persists for the life of the object, and
    is never reused. This context-free identifier can apply to any
    object in any system. truealways The type of the the referenced
    object. falsealways The name of the referenced object. false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, type_=None, id=None, name=None, extensiontype_=None):
        self.original_tagname_ = None
        super(EntityReferenceType, self).__init__(VCloudExtension, extensiontype_, )
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EntityReferenceType.subclass:
            return EntityReferenceType.subclass(*args_, **kwargs_)
        else:
            return EntityReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(EntityReferenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityReferenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityReferenceType'):
        super(EntityReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityReferenceType')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='EntityReferenceType', fromsubclass_=False, pretty_print=True):
        super(EntityReferenceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EntityReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(EntityReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityReferenceType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EntityReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EntityReferenceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EntityReferenceType


class EntityLinkType(EntityReferenceType):
    """1.5 Extends EntityReference type by adding relation attribute.
    always Defines the relationship of the link to the object that
    contains it. A relationship can be the name of an operation on
    the object, a reference to a contained or containing object, or
    a reference to an alternate representation of the object. The
    relationship value implies the HTTP verb to use when you use the
    link's href value as a request URL. true"""
    subclass = None
    superclass = EntityReferenceType
    def __init__(self, VCloudExtension=None, type_=None, id=None, name=None, rel=None):
        self.original_tagname_ = None
        super(EntityLinkType, self).__init__(VCloudExtension, type_, id, name, )
        self.rel = _cast(None, rel)
    def factory(*args_, **kwargs_):
        if EntityLinkType.subclass:
            return EntityLinkType.subclass(*args_, **kwargs_)
        else:
            return EntityLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rel(self): return self.rel
    def set_rel(self, rel): self.rel = rel
    def hasContent_(self):
        if (
            super(EntityLinkType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityLinkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityLinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityLinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityLinkType'):
        super(EntityLinkType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityLinkType')
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            outfile.write(' rel=%s' % (self.gds_format_string(quote_attrib(self.rel).encode(ExternalEncoding), input_name='rel'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntityLinkType', fromsubclass_=False, pretty_print=True):
        super(EntityLinkType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EntityLinkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            showIndent(outfile, level)
            outfile.write('rel="%s",\n' % (self.rel,))
        super(EntityLinkType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityLinkType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rel', node)
        if value is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            self.rel = value
        super(EntityLinkType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EntityLinkType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EntityLinkType


class TasksInProgressType(VCloudExtensibleType):
    """0.9 A list of queued, running, or recently completed tasks."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Task=None):
        self.original_tagname_ = None
        super(TasksInProgressType, self).__init__(VCloudExtension, )
        if Task is None:
            self.Task = []
        else:
            self.Task = Task
    def factory(*args_, **kwargs_):
        if TasksInProgressType.subclass:
            return TasksInProgressType.subclass(*args_, **kwargs_)
        else:
            return TasksInProgressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Task(self): return self.Task
    def set_Task(self, Task): self.Task = Task
    def add_Task(self, value): self.Task.append(value)
    def insert_Task_at(self, index, value): self.Task.insert(index, value)
    def replace_Task_at(self, index, value): self.Task[index] = value
    def hasContent_(self):
        if (
            self.Task or
            super(TasksInProgressType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TasksInProgressType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TasksInProgressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TasksInProgressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TasksInProgressType'):
        super(TasksInProgressType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TasksInProgressType')
    def exportChildren(self, outfile, level, namespace_='', name_='TasksInProgressType', fromsubclass_=False, pretty_print=True):
        super(TasksInProgressType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Task_ in self.Task:
            Task_.export(outfile, level, namespace_, name_='Task', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TasksInProgressType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TasksInProgressType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TasksInProgressType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Task=[\n')
        level += 1
        for Task_ in self.Task:
            showIndent(outfile, level)
            outfile.write('model_.TaskType(\n')
            Task_.exportLiteral(outfile, level, name_='TaskType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TasksInProgressType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Task':
            obj_ = TaskType.factory()
            obj_.build(child_)
            self.Task.append(obj_)
            obj_.original_tagname_ = 'Task'
        super(TasksInProgressType, self).buildChildren(child_, node, nodeName_, True)
# end class TasksInProgressType


class ResourceEntityType(EntityType):
    """0.9 Base type that represents a resource entity such as a vApp
    template or virtual media. none Creation status of the resource
    entity. false"""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, Files=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ResourceEntityType, self).__init__(operationKey, id, name, Description, Tasks, extensiontype_, )
        self.status = _cast(int, status)
        self.Files = Files
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ResourceEntityType.subclass:
            return ResourceEntityType.subclass(*args_, **kwargs_)
        else:
            return ResourceEntityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Files(self): return self.Files
    def set_Files(self, Files): self.Files = Files
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Files is not None or
            super(ResourceEntityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceEntityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceEntityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceEntityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceEntityType'):
        super(ResourceEntityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceEntityType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status="%s"' % self.gds_format_integer(self.status, input_name='status'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceEntityType', fromsubclass_=False, pretty_print=True):
        super(ResourceEntityType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Files is not None:
            self.Files.export(outfile, level, namespace_, name_='Files', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResourceEntityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % (self.status,))
        super(ResourceEntityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResourceEntityType, self).exportLiteralChildren(outfile, level, name_)
        if self.Files is not None:
            showIndent(outfile, level)
            outfile.write('Files=model_.FilesListType(\n')
            self.Files.exportLiteral(outfile, level, name_='Files')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            try:
                self.status = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ResourceEntityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Files':
            obj_ = FilesListType.factory()
            obj_.build(child_)
            self.Files = obj_
            obj_.original_tagname_ = 'Files'
        super(ResourceEntityType, self).buildChildren(child_, node, nodeName_, True)
# end class ResourceEntityType


class FilesListType(VCloudExtensibleType):
    """0.9 Represents a list of files to be transferred (uploaded or
    downloaded)."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, File=None):
        self.original_tagname_ = None
        super(FilesListType, self).__init__(VCloudExtension, )
        if File is None:
            self.File = []
        else:
            self.File = File
    def factory(*args_, **kwargs_):
        if FilesListType.subclass:
            return FilesListType.subclass(*args_, **kwargs_)
        else:
            return FilesListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_File(self): return self.File
    def set_File(self, File): self.File = File
    def add_File(self, value): self.File.append(value)
    def insert_File_at(self, index, value): self.File.insert(index, value)
    def replace_File_at(self, index, value): self.File[index] = value
    def hasContent_(self):
        if (
            self.File or
            super(FilesListType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FilesListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FilesListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FilesListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FilesListType'):
        super(FilesListType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FilesListType')
    def exportChildren(self, outfile, level, namespace_='', name_='FilesListType', fromsubclass_=False, pretty_print=True):
        super(FilesListType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for File_ in self.File:
            File_.export(outfile, level, namespace_, name_='File', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FilesListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FilesListType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FilesListType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('File=[\n')
        level += 1
        for File_ in self.File:
            showIndent(outfile, level)
            outfile.write('model_.FileType(\n')
            File_.exportLiteral(outfile, level, name_='FileType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FilesListType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'File':
            obj_ = FileType.factory()
            obj_.build(child_)
            self.File.append(obj_)
            obj_.original_tagname_ = 'File'
        super(FilesListType, self).buildChildren(child_, node, nodeName_, True)
# end class FilesListType


class FileType(EntityType):
    """0.9 Represents a file to be transferred (uploaded or downloaded).
    none File size in bytes. falsenone Bytes that have been
    transferred. falsenone The checksum of the file. false"""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, checksum=None, bytesTransferred=None, size=None):
        self.original_tagname_ = None
        super(FileType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.checksum = _cast(None, checksum)
        self.bytesTransferred = _cast(int, bytesTransferred)
        self.size = _cast(int, size)
    def factory(*args_, **kwargs_):
        if FileType.subclass:
            return FileType.subclass(*args_, **kwargs_)
        else:
            return FileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_checksum(self): return self.checksum
    def set_checksum(self, checksum): self.checksum = checksum
    def get_bytesTransferred(self): return self.bytesTransferred
    def set_bytesTransferred(self, bytesTransferred): self.bytesTransferred = bytesTransferred
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            super(FileType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FileType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FileType'):
        super(FileType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FileType')
        if self.checksum is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            outfile.write(' checksum=%s' % (self.gds_format_string(quote_attrib(self.checksum).encode(ExternalEncoding), input_name='checksum'), ))
        if self.bytesTransferred is not None and 'bytesTransferred' not in already_processed:
            already_processed.add('bytesTransferred')
            outfile.write(' bytesTransferred="%s"' % self.gds_format_integer(self.bytesTransferred, input_name='bytesTransferred'))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespace_='', name_='FileType', fromsubclass_=False, pretty_print=True):
        super(FileType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FileType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.checksum is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            showIndent(outfile, level)
            outfile.write('checksum="%s",\n' % (self.checksum,))
        if self.bytesTransferred is not None and 'bytesTransferred' not in already_processed:
            already_processed.add('bytesTransferred')
            showIndent(outfile, level)
            outfile.write('bytesTransferred=%d,\n' % (self.bytesTransferred,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % (self.size,))
        super(FileType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FileType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('checksum', node)
        if value is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            self.checksum = value
        value = find_attr_value_('bytesTransferred', node)
        if value is not None and 'bytesTransferred' not in already_processed:
            already_processed.add('bytesTransferred')
            try:
                self.bytesTransferred = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(FileType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FileType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FileType


class AbstractVAppType(ResourceEntityType):
    """0.9 Represents a base type for VAppType and VmType. 1.0none True if
    the virtual machine is deployed. false"""
    subclass = None
    superclass = ResourceEntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, Files=None, deployed=None, VAppParent=None, Section=None, DateCreated=None, extensiontype_=None):
        self.original_tagname_ = None
        super(AbstractVAppType, self).__init__(operationKey, id, name, Description, Tasks, status, Files, extensiontype_, )
        self.deployed = _cast(bool, deployed)
        self.VAppParent = VAppParent
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
        if isinstance(DateCreated, basestring):
            initvalue_ = datetime_.datetime.strptime(DateCreated, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DateCreated
        self.DateCreated = initvalue_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractVAppType.subclass:
            return AbstractVAppType.subclass(*args_, **kwargs_)
        else:
            return AbstractVAppType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VAppParent(self): return self.VAppParent
    def set_VAppParent(self, VAppParent): self.VAppParent = VAppParent
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def get_DateCreated(self): return self.DateCreated
    def set_DateCreated(self, DateCreated): self.DateCreated = DateCreated
    def get_deployed(self): return self.deployed
    def set_deployed(self, deployed): self.deployed = deployed
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.VAppParent is not None or
            self.Section or
            self.DateCreated is not None or
            super(AbstractVAppType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AbstractVAppType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractVAppType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AbstractVAppType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractVAppType'):
        super(AbstractVAppType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractVAppType')
        if self.deployed is not None and 'deployed' not in already_processed:
            already_processed.add('deployed')
            outfile.write(' deployed="%s"' % self.gds_format_boolean(self.deployed, input_name='deployed'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractVAppType', fromsubclass_=False, pretty_print=True):
        super(AbstractVAppType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VAppParent is not None:
            self.VAppParent.export(outfile, level, namespace_, name_='VAppParent', pretty_print=pretty_print)
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovf:', name_='Section', pretty_print=pretty_print)
        if self.DateCreated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateCreated>%s</%sDateCreated>%s' % (namespace_, self.gds_format_datetime(self.DateCreated, input_name='DateCreated'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AbstractVAppType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deployed is not None and 'deployed' not in already_processed:
            already_processed.add('deployed')
            showIndent(outfile, level)
            outfile.write('deployed=%s,\n' % (self.deployed,))
        super(AbstractVAppType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractVAppType, self).exportLiteralChildren(outfile, level, name_)
        if self.VAppParent is not None:
            showIndent(outfile, level)
            outfile.write('VAppParent=model_.ReferenceType(\n')
            self.VAppParent.exportLiteral(outfile, level, name_='VAppParent')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DateCreated is not None:
            showIndent(outfile, level)
            outfile.write('DateCreated=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.DateCreated, input_name='DateCreated'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deployed', node)
        if value is not None and 'deployed' not in already_processed:
            already_processed.add('deployed')
            if value in ('true', '1'):
                self.deployed = True
            elif value in ('false', '0'):
                self.deployed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractVAppType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VAppParent':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VAppParent = obj_
            obj_.original_tagname_ = 'VAppParent'
        elif nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
        elif nodeName_ == 'DateCreated':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DateCreated = dval_
        super(AbstractVAppType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractVAppType


class VmType(AbstractVAppType):
    """0.9 Represents a virtual machine. none True if this virtual machine
    needs customization. falsenone True if hardware-assisted CPU
    virtualization capabilities in the host should be exposed to the
    guest operating system. false"""
    subclass = None
    superclass = AbstractVAppType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, Files=None, deployed=None, VAppParent=None, Section=None, DateCreated=None, needsCustomization=None, nestedHypervisorEnabled=None, VAppScopedLocalId=None, Environment=None, VmCapabilities=None, StorageProfile=None):
        self.original_tagname_ = None
        super(VmType, self).__init__(operationKey, id, name, Description, Tasks, status, Files, deployed, VAppParent, Section, DateCreated, )
        self.needsCustomization = _cast(bool, needsCustomization)
        self.nestedHypervisorEnabled = _cast(bool, nestedHypervisorEnabled)
        self.VAppScopedLocalId = VAppScopedLocalId
        self.Environment = Environment
        self.VmCapabilities = VmCapabilities
        self.StorageProfile = StorageProfile
    def factory(*args_, **kwargs_):
        if VmType.subclass:
            return VmType.subclass(*args_, **kwargs_)
        else:
            return VmType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VAppScopedLocalId(self): return self.VAppScopedLocalId
    def set_VAppScopedLocalId(self, VAppScopedLocalId): self.VAppScopedLocalId = VAppScopedLocalId
    def get_Environment(self): return self.Environment
    def set_Environment(self, Environment): self.Environment = Environment
    def get_VmCapabilities(self): return self.VmCapabilities
    def set_VmCapabilities(self, VmCapabilities): self.VmCapabilities = VmCapabilities
    def get_StorageProfile(self): return self.StorageProfile
    def set_StorageProfile(self, StorageProfile): self.StorageProfile = StorageProfile
    def get_needsCustomization(self): return self.needsCustomization
    def set_needsCustomization(self, needsCustomization): self.needsCustomization = needsCustomization
    def get_nestedHypervisorEnabled(self): return self.nestedHypervisorEnabled
    def set_nestedHypervisorEnabled(self, nestedHypervisorEnabled): self.nestedHypervisorEnabled = nestedHypervisorEnabled
    def hasContent_(self):
        if (
            self.VAppScopedLocalId is not None or
            self.Environment is not None or
            self.VmCapabilities is not None or
            self.StorageProfile is not None or
            super(VmType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmType'):
        super(VmType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmType')
        if self.needsCustomization is not None and 'needsCustomization' not in already_processed:
            already_processed.add('needsCustomization')
            outfile.write(' needsCustomization="%s"' % self.gds_format_boolean(self.needsCustomization, input_name='needsCustomization'))
        if self.nestedHypervisorEnabled is not None and 'nestedHypervisorEnabled' not in already_processed:
            already_processed.add('nestedHypervisorEnabled')
            outfile.write(' nestedHypervisorEnabled="%s"' % self.gds_format_boolean(self.nestedHypervisorEnabled, input_name='nestedHypervisorEnabled'))
    def exportChildren(self, outfile, level, namespace_='', name_='VmType', fromsubclass_=False, pretty_print=True):
        super(VmType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VAppScopedLocalId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVAppScopedLocalId>%s</%sVAppScopedLocalId>%s' % (namespace_, self.gds_format_string(quote_xml(self.VAppScopedLocalId).encode(ExternalEncoding), input_name='VAppScopedLocalId'), namespace_, eol_))
        if self.Environment is not None:
            self.Environment.export(outfile, level, namespace_='ovfenv:', name_='Environment', pretty_print=pretty_print)
        if self.VmCapabilities is not None:
            self.VmCapabilities.export(outfile, level, namespace_, name_='VmCapabilities', pretty_print=pretty_print)
        if self.StorageProfile is not None:
            self.StorageProfile.export(outfile, level, namespace_, name_='StorageProfile', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VmType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.needsCustomization is not None and 'needsCustomization' not in already_processed:
            already_processed.add('needsCustomization')
            showIndent(outfile, level)
            outfile.write('needsCustomization=%s,\n' % (self.needsCustomization,))
        if self.nestedHypervisorEnabled is not None and 'nestedHypervisorEnabled' not in already_processed:
            already_processed.add('nestedHypervisorEnabled')
            showIndent(outfile, level)
            outfile.write('nestedHypervisorEnabled=%s,\n' % (self.nestedHypervisorEnabled,))
        super(VmType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmType, self).exportLiteralChildren(outfile, level, name_)
        if self.VAppScopedLocalId is not None:
            showIndent(outfile, level)
            outfile.write('VAppScopedLocalId=%s,\n' % quote_python(self.VAppScopedLocalId).encode(ExternalEncoding))
        if self.Environment is not None:
            showIndent(outfile, level)
            outfile.write('Environment=model_.Environment(\n')
            self.Environment.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VmCapabilities is not None:
            showIndent(outfile, level)
            outfile.write('VmCapabilities=model_.VmCapabilitiesType(\n')
            self.VmCapabilities.exportLiteral(outfile, level, name_='VmCapabilities')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('StorageProfile=model_.ReferenceType(\n')
            self.StorageProfile.exportLiteral(outfile, level, name_='StorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('needsCustomization', node)
        if value is not None and 'needsCustomization' not in already_processed:
            already_processed.add('needsCustomization')
            if value in ('true', '1'):
                self.needsCustomization = True
            elif value in ('false', '0'):
                self.needsCustomization = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('nestedHypervisorEnabled', node)
        if value is not None and 'nestedHypervisorEnabled' not in already_processed:
            already_processed.add('nestedHypervisorEnabled')
            if value in ('true', '1'):
                self.nestedHypervisorEnabled = True
            elif value in ('false', '0'):
                self.nestedHypervisorEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(VmType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VAppScopedLocalId':
            VAppScopedLocalId_ = child_.text
            VAppScopedLocalId_ = self.gds_validate_string(VAppScopedLocalId_, node, 'VAppScopedLocalId')
            self.VAppScopedLocalId = VAppScopedLocalId_
        elif nodeName_ == 'Environment':
            obj_ = Environment_Type.factory()
            obj_.build(child_)
            self.Environment = obj_
            obj_.original_tagname_ = 'Environment'
        elif nodeName_ == 'VmCapabilities':
            obj_ = VmCapabilitiesType.factory()
            obj_.build(child_)
            self.VmCapabilities = obj_
            obj_.original_tagname_ = 'VmCapabilities'
        elif nodeName_ == 'StorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.StorageProfile = obj_
            obj_.original_tagname_ = 'StorageProfile'
        super(VmType, self).buildChildren(child_, node, nodeName_, True)
# end class VmType


class VmCapabilitiesType(ResourceType):
    """5.1 Allows you to specify certain capabilities of this virtual
    machine."""
    subclass = None
    superclass = ResourceType
    def __init__(self, MemoryHotAddEnabled=None, CpuHotAddEnabled=None):
        self.original_tagname_ = None
        super(VmCapabilitiesType, self).__init__()
        self.MemoryHotAddEnabled = MemoryHotAddEnabled
        self.CpuHotAddEnabled = CpuHotAddEnabled
    def factory(*args_, **kwargs_):
        if VmCapabilitiesType.subclass:
            return VmCapabilitiesType.subclass(*args_, **kwargs_)
        else:
            return VmCapabilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MemoryHotAddEnabled(self): return self.MemoryHotAddEnabled
    def set_MemoryHotAddEnabled(self, MemoryHotAddEnabled): self.MemoryHotAddEnabled = MemoryHotAddEnabled
    def get_CpuHotAddEnabled(self): return self.CpuHotAddEnabled
    def set_CpuHotAddEnabled(self, CpuHotAddEnabled): self.CpuHotAddEnabled = CpuHotAddEnabled
    def hasContent_(self):
        if (
            self.MemoryHotAddEnabled is not None or
            self.CpuHotAddEnabled is not None or
            super(VmCapabilitiesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmCapabilitiesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmCapabilitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmCapabilitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmCapabilitiesType'):
        super(VmCapabilitiesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmCapabilitiesType')
    def exportChildren(self, outfile, level, namespace_='', name_='VmCapabilitiesType', fromsubclass_=False, pretty_print=True):
        super(VmCapabilitiesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MemoryHotAddEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMemoryHotAddEnabled>%s</%sMemoryHotAddEnabled>%s' % (namespace_, self.gds_format_boolean(self.MemoryHotAddEnabled, input_name='MemoryHotAddEnabled'), namespace_, eol_))
        if self.CpuHotAddEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCpuHotAddEnabled>%s</%sCpuHotAddEnabled>%s' % (namespace_, self.gds_format_boolean(self.CpuHotAddEnabled, input_name='CpuHotAddEnabled'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VmCapabilitiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmCapabilitiesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmCapabilitiesType, self).exportLiteralChildren(outfile, level, name_)
        if self.MemoryHotAddEnabled is not None:
            showIndent(outfile, level)
            outfile.write('MemoryHotAddEnabled=%s,\n' % self.MemoryHotAddEnabled)
        if self.CpuHotAddEnabled is not None:
            showIndent(outfile, level)
            outfile.write('CpuHotAddEnabled=%s,\n' % self.CpuHotAddEnabled)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VmCapabilitiesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MemoryHotAddEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'MemoryHotAddEnabled')
            self.MemoryHotAddEnabled = ival_
        elif nodeName_ == 'CpuHotAddEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CpuHotAddEnabled')
            self.CpuHotAddEnabled = ival_
        super(VmCapabilitiesType, self).buildChildren(child_, node, nodeName_, True)
# end class VmCapabilitiesType


class VAppType(AbstractVAppType):
    """0.9 Represents a vApp. none Read-only indicator that the OVF
    descriptor for this vApp has been uploaded. false"""
    subclass = None
    superclass = AbstractVAppType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, Files=None, deployed=None, VAppParent=None, Section=None, DateCreated=None, ovfDescriptorUploaded=None, Owner=None, InMaintenanceMode=None, Children=None):
        self.original_tagname_ = None
        super(VAppType, self).__init__(operationKey, id, name, Description, Tasks, status, Files, deployed, VAppParent, Section, DateCreated, )
        self.ovfDescriptorUploaded = _cast(bool, ovfDescriptorUploaded)
        self.Owner = Owner
        self.InMaintenanceMode = InMaintenanceMode
        self.Children = Children
    def factory(*args_, **kwargs_):
        if VAppType.subclass:
            return VAppType.subclass(*args_, **kwargs_)
        else:
            return VAppType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Owner(self): return self.Owner
    def set_Owner(self, Owner): self.Owner = Owner
    def get_InMaintenanceMode(self): return self.InMaintenanceMode
    def set_InMaintenanceMode(self, InMaintenanceMode): self.InMaintenanceMode = InMaintenanceMode
    def get_Children(self): return self.Children
    def set_Children(self, Children): self.Children = Children
    def get_ovfDescriptorUploaded(self): return self.ovfDescriptorUploaded
    def set_ovfDescriptorUploaded(self, ovfDescriptorUploaded): self.ovfDescriptorUploaded = ovfDescriptorUploaded
    def hasContent_(self):
        if (
            self.Owner is not None or
            self.InMaintenanceMode is not None or
            self.Children is not None or
            super(VAppType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VAppType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VAppType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VAppType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VAppType'):
        super(VAppType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VAppType')
        if self.ovfDescriptorUploaded is not None and 'ovfDescriptorUploaded' not in already_processed:
            already_processed.add('ovfDescriptorUploaded')
            outfile.write(' ovfDescriptorUploaded="%s"' % self.gds_format_boolean(self.ovfDescriptorUploaded, input_name='ovfDescriptorUploaded'))
    def exportChildren(self, outfile, level, namespace_='', name_='VAppType', fromsubclass_=False, pretty_print=True):
        super(VAppType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Owner is not None:
            self.Owner.export(outfile, level, namespace_, name_='Owner', pretty_print=pretty_print)
        if self.InMaintenanceMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInMaintenanceMode>%s</%sInMaintenanceMode>%s' % (namespace_, self.gds_format_boolean(self.InMaintenanceMode, input_name='InMaintenanceMode'), namespace_, eol_))
        if self.Children is not None:
            self.Children.export(outfile, level, namespace_, name_='Children', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VAppType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ovfDescriptorUploaded is not None and 'ovfDescriptorUploaded' not in already_processed:
            already_processed.add('ovfDescriptorUploaded')
            showIndent(outfile, level)
            outfile.write('ovfDescriptorUploaded=%s,\n' % (self.ovfDescriptorUploaded,))
        super(VAppType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VAppType, self).exportLiteralChildren(outfile, level, name_)
        if self.Owner is not None:
            showIndent(outfile, level)
            outfile.write('Owner=model_.OwnerType(\n')
            self.Owner.exportLiteral(outfile, level, name_='Owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InMaintenanceMode is not None:
            showIndent(outfile, level)
            outfile.write('InMaintenanceMode=%s,\n' % self.InMaintenanceMode)
        if self.Children is not None:
            showIndent(outfile, level)
            outfile.write('Children=model_.VAppChildrenType(\n')
            self.Children.exportLiteral(outfile, level, name_='Children')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ovfDescriptorUploaded', node)
        if value is not None and 'ovfDescriptorUploaded' not in already_processed:
            already_processed.add('ovfDescriptorUploaded')
            if value in ('true', '1'):
                self.ovfDescriptorUploaded = True
            elif value in ('false', '0'):
                self.ovfDescriptorUploaded = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(VAppType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Owner':
            obj_ = OwnerType.factory()
            obj_.build(child_)
            self.Owner = obj_
            obj_.original_tagname_ = 'Owner'
        elif nodeName_ == 'InMaintenanceMode':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'InMaintenanceMode')
            self.InMaintenanceMode = ival_
        elif nodeName_ == 'Children':
            obj_ = VAppChildrenType.factory()
            obj_.build(child_)
            self.Children = obj_
            obj_.original_tagname_ = 'Children'
        super(VAppType, self).buildChildren(child_, node, nodeName_, True)
# end class VAppType


class VAppChildrenType(VCloudExtensibleType):
    """0.9 Container for virtual machines included in this vApp."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, VApp=None, Vm=None):
        self.original_tagname_ = None
        super(VAppChildrenType, self).__init__(VCloudExtension, )
        if VApp is None:
            self.VApp = []
        else:
            self.VApp = VApp
        if Vm is None:
            self.Vm = []
        else:
            self.Vm = Vm
    def factory(*args_, **kwargs_):
        if VAppChildrenType.subclass:
            return VAppChildrenType.subclass(*args_, **kwargs_)
        else:
            return VAppChildrenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VApp(self): return self.VApp
    def set_VApp(self, VApp): self.VApp = VApp
    def add_VApp(self, value): self.VApp.append(value)
    def insert_VApp_at(self, index, value): self.VApp.insert(index, value)
    def replace_VApp_at(self, index, value): self.VApp[index] = value
    def get_Vm(self): return self.Vm
    def set_Vm(self, Vm): self.Vm = Vm
    def add_Vm(self, value): self.Vm.append(value)
    def insert_Vm_at(self, index, value): self.Vm.insert(index, value)
    def replace_Vm_at(self, index, value): self.Vm[index] = value
    def hasContent_(self):
        if (
            self.VApp or
            self.Vm or
            super(VAppChildrenType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VAppChildrenType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VAppChildrenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VAppChildrenType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VAppChildrenType'):
        super(VAppChildrenType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VAppChildrenType')
    def exportChildren(self, outfile, level, namespace_='', name_='VAppChildrenType', fromsubclass_=False, pretty_print=True):
        super(VAppChildrenType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VApp_ in self.VApp:
            VApp_.export(outfile, level, namespace_, name_='VApp', pretty_print=pretty_print)
        for Vm_ in self.Vm:
            Vm_.export(outfile, level, namespace_, name_='Vm', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VAppChildrenType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VAppChildrenType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VAppChildrenType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('VApp=[\n')
        level += 1
        for VApp_ in self.VApp:
            showIndent(outfile, level)
            outfile.write('model_.VApp(\n')
            VApp_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Vm=[\n')
        level += 1
        for Vm_ in self.Vm:
            showIndent(outfile, level)
            outfile.write('model_.Vm(\n')
            Vm_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VAppChildrenType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VApp':
            obj_ = VAppType.factory()
            obj_.build(child_)
            self.VApp.append(obj_)
            obj_.original_tagname_ = 'VApp'
        elif nodeName_ == 'Vm':
            obj_ = VmType.factory()
            obj_.build(child_)
            self.Vm.append(obj_)
            obj_.original_tagname_ = 'Vm'
        super(VAppChildrenType, self).buildChildren(child_, node, nodeName_, True)
# end class VAppChildrenType


class RasdItemsListType(ResourceType):
    """0.9 Represents a list of RASD items specifying a group of related
    DMTF Resource Allocation Setting Data properties of this virtual
    machine."""
    subclass = None
    superclass = ResourceType
    def __init__(self, Item=None):
        self.original_tagname_ = None
        super(RasdItemsListType, self).__init__()
        if Item is None:
            self.Item = []
        else:
            self.Item = Item
    def factory(*args_, **kwargs_):
        if RasdItemsListType.subclass:
            return RasdItemsListType.subclass(*args_, **kwargs_)
        else:
            return RasdItemsListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Item(self): return self.Item
    def set_Item(self, Item): self.Item = Item
    def add_Item(self, value): self.Item.append(value)
    def insert_Item_at(self, index, value): self.Item.insert(index, value)
    def replace_Item_at(self, index, value): self.Item[index] = value
    def hasContent_(self):
        if (
            self.Item or
            super(RasdItemsListType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RasdItemsListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RasdItemsListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RasdItemsListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RasdItemsListType'):
        super(RasdItemsListType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RasdItemsListType')
    def exportChildren(self, outfile, level, namespace_='', name_='RasdItemsListType', fromsubclass_=False, pretty_print=True):
        super(RasdItemsListType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Item_ in self.Item:
            Item_.export(outfile, level, namespace_, name_='Item', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RasdItemsListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RasdItemsListType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RasdItemsListType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Item=[\n')
        level += 1
        for Item_ in self.Item:
            showIndent(outfile, level)
            outfile.write('model_.Item(\n')
            Item_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RasdItemsListType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Item':
            obj_ = RASD_Type.factory()
            obj_.build(child_)
            self.Item.append(obj_)
            obj_.original_tagname_ = 'Item'
        super(RasdItemsListType, self).buildChildren(child_, node, nodeName_, True)
# end class RasdItemsListType


class InstantiationParamsType(VCloudExtensibleType):
    """0.9 Container for ovf:Section_Type elements that specify vApp
    configuration on instantiate, compose, or recompose."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Section=None):
        self.original_tagname_ = None
        super(InstantiationParamsType, self).__init__(VCloudExtension, )
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
    def factory(*args_, **kwargs_):
        if InstantiationParamsType.subclass:
            return InstantiationParamsType.subclass(*args_, **kwargs_)
        else:
            return InstantiationParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def hasContent_(self):
        if (
            self.Section or
            super(InstantiationParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstantiationParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiationParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstantiationParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstantiationParamsType'):
        super(InstantiationParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiationParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='InstantiationParamsType', fromsubclass_=False, pretty_print=True):
        super(InstantiationParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovf:', name_='Section', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InstantiationParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(InstantiationParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstantiationParamsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InstantiationParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
        super(InstantiationParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class InstantiationParamsType


class VAppNetworkConfigurationType(ResourceType):
    """0.9 Represents a vApp network configuration. always The name of the
    vApp network. true"""
    subclass = None
    superclass = ResourceType
    def __init__(self, networkName=None, Description=None, Configuration=None, IsDeployed=None):
        self.original_tagname_ = None
        super(VAppNetworkConfigurationType, self).__init__()
        self.networkName = _cast(None, networkName)
        self.Description = Description
        self.Configuration = Configuration
        self.IsDeployed = IsDeployed
    def factory(*args_, **kwargs_):
        if VAppNetworkConfigurationType.subclass:
            return VAppNetworkConfigurationType.subclass(*args_, **kwargs_)
        else:
            return VAppNetworkConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Configuration(self): return self.Configuration
    def set_Configuration(self, Configuration): self.Configuration = Configuration
    def get_IsDeployed(self): return self.IsDeployed
    def set_IsDeployed(self, IsDeployed): self.IsDeployed = IsDeployed
    def get_networkName(self): return self.networkName
    def set_networkName(self, networkName): self.networkName = networkName
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Configuration is not None or
            self.IsDeployed is not None or
            super(VAppNetworkConfigurationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VAppNetworkConfigurationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VAppNetworkConfigurationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VAppNetworkConfigurationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VAppNetworkConfigurationType'):
        super(VAppNetworkConfigurationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VAppNetworkConfigurationType')
        if self.networkName is not None and 'networkName' not in already_processed:
            already_processed.add('networkName')
            outfile.write(' networkName=%s' % (self.gds_format_string(quote_attrib(self.networkName).encode(ExternalEncoding), input_name='networkName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VAppNetworkConfigurationType', fromsubclass_=False, pretty_print=True):
        super(VAppNetworkConfigurationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.Configuration is not None:
            self.Configuration.export(outfile, level, namespace_, name_='Configuration', pretty_print=pretty_print)
        if self.IsDeployed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsDeployed>%s</%sIsDeployed>%s' % (namespace_, self.gds_format_boolean(self.IsDeployed, input_name='IsDeployed'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VAppNetworkConfigurationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.networkName is not None and 'networkName' not in already_processed:
            already_processed.add('networkName')
            showIndent(outfile, level)
            outfile.write('networkName="%s",\n' % (self.networkName,))
        super(VAppNetworkConfigurationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VAppNetworkConfigurationType, self).exportLiteralChildren(outfile, level, name_)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Configuration is not None:
            showIndent(outfile, level)
            outfile.write('Configuration=model_.NetworkConfigurationType(\n')
            self.Configuration.exportLiteral(outfile, level, name_='Configuration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IsDeployed is not None:
            showIndent(outfile, level)
            outfile.write('IsDeployed=%s,\n' % self.IsDeployed)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('networkName', node)
        if value is not None and 'networkName' not in already_processed:
            already_processed.add('networkName')
            self.networkName = value
        super(VAppNetworkConfigurationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Configuration':
            obj_ = NetworkConfigurationType.factory()
            obj_.build(child_)
            self.Configuration = obj_
            obj_.original_tagname_ = 'Configuration'
        elif nodeName_ == 'IsDeployed':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsDeployed')
            self.IsDeployed = ival_
        super(VAppNetworkConfigurationType, self).buildChildren(child_, node, nodeName_, True)
# end class VAppNetworkConfigurationType


class NetworkConnectionType(VCloudExtensibleType):
    """0.9 Represents a network connection in the virtual machine. always
    Name of the network to which this NIC is connected. truenone
    True if this NIC needs customization. false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, needsCustomization=None, network=None, NetworkConnectionIndex=None, IpAddress=None, ExternalIpAddress=None, IsConnected=None, MACAddress=None, IpAddressAllocationMode=None):
        self.original_tagname_ = None
        super(NetworkConnectionType, self).__init__(VCloudExtension, )
        self.needsCustomization = _cast(bool, needsCustomization)
        self.network = _cast(None, network)
        self.NetworkConnectionIndex = NetworkConnectionIndex
        self.IpAddress = IpAddress
        self.validate_IpAddressType(self.IpAddress)
        self.ExternalIpAddress = ExternalIpAddress
        self.validate_IpAddressType(self.ExternalIpAddress)
        self.IsConnected = IsConnected
        self.MACAddress = MACAddress
        self.IpAddressAllocationMode = IpAddressAllocationMode
    def factory(*args_, **kwargs_):
        if NetworkConnectionType.subclass:
            return NetworkConnectionType.subclass(*args_, **kwargs_)
        else:
            return NetworkConnectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NetworkConnectionIndex(self): return self.NetworkConnectionIndex
    def set_NetworkConnectionIndex(self, NetworkConnectionIndex): self.NetworkConnectionIndex = NetworkConnectionIndex
    def get_IpAddress(self): return self.IpAddress
    def set_IpAddress(self, IpAddress): self.IpAddress = IpAddress
    def get_ExternalIpAddress(self): return self.ExternalIpAddress
    def set_ExternalIpAddress(self, ExternalIpAddress): self.ExternalIpAddress = ExternalIpAddress
    def get_IsConnected(self): return self.IsConnected
    def set_IsConnected(self, IsConnected): self.IsConnected = IsConnected
    def get_MACAddress(self): return self.MACAddress
    def set_MACAddress(self, MACAddress): self.MACAddress = MACAddress
    def get_IpAddressAllocationMode(self): return self.IpAddressAllocationMode
    def set_IpAddressAllocationMode(self, IpAddressAllocationMode): self.IpAddressAllocationMode = IpAddressAllocationMode
    def get_needsCustomization(self): return self.needsCustomization
    def set_needsCustomization(self, needsCustomization): self.needsCustomization = needsCustomization
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.NetworkConnectionIndex is not None or
            self.IpAddress is not None or
            self.ExternalIpAddress is not None or
            self.IsConnected is not None or
            self.MACAddress is not None or
            self.IpAddressAllocationMode is not None or
            super(NetworkConnectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkConnectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConnectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkConnectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkConnectionType'):
        super(NetworkConnectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConnectionType')
        if self.needsCustomization is not None and 'needsCustomization' not in already_processed:
            already_processed.add('needsCustomization')
            outfile.write(' needsCustomization="%s"' % self.gds_format_boolean(self.needsCustomization, input_name='needsCustomization'))
        if self.network is not None and 'network' not in already_processed:
            already_processed.add('network')
            outfile.write(' network=%s' % (self.gds_format_string(quote_attrib(self.network).encode(ExternalEncoding), input_name='network'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkConnectionType', fromsubclass_=False, pretty_print=True):
        super(NetworkConnectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NetworkConnectionIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetworkConnectionIndex>%s</%sNetworkConnectionIndex>%s' % (namespace_, self.gds_format_integer(self.NetworkConnectionIndex, input_name='NetworkConnectionIndex'), namespace_, eol_))
        if self.IpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpAddress>%s</%sIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IpAddress).encode(ExternalEncoding), input_name='IpAddress'), namespace_, eol_))
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIpAddress>%s</%sExternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIpAddress).encode(ExternalEncoding), input_name='ExternalIpAddress'), namespace_, eol_))
        if self.IsConnected is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsConnected>%s</%sIsConnected>%s' % (namespace_, self.gds_format_boolean(self.IsConnected, input_name='IsConnected'), namespace_, eol_))
        if self.MACAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMACAddress>%s</%sMACAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.MACAddress).encode(ExternalEncoding), input_name='MACAddress'), namespace_, eol_))
        if self.IpAddressAllocationMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpAddressAllocationMode>%s</%sIpAddressAllocationMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.IpAddressAllocationMode).encode(ExternalEncoding), input_name='IpAddressAllocationMode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NetworkConnectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.needsCustomization is not None and 'needsCustomization' not in already_processed:
            already_processed.add('needsCustomization')
            showIndent(outfile, level)
            outfile.write('needsCustomization=%s,\n' % (self.needsCustomization,))
        if self.network is not None and 'network' not in already_processed:
            already_processed.add('network')
            showIndent(outfile, level)
            outfile.write('network="%s",\n' % (self.network,))
        super(NetworkConnectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkConnectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.NetworkConnectionIndex is not None:
            showIndent(outfile, level)
            outfile.write('NetworkConnectionIndex=%d,\n' % self.NetworkConnectionIndex)
        if self.IpAddress is not None:
            showIndent(outfile, level)
            outfile.write('IpAddress=%s,\n' % quote_python(self.IpAddress).encode(ExternalEncoding))
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIpAddress=%s,\n' % quote_python(self.ExternalIpAddress).encode(ExternalEncoding))
        if self.IsConnected is not None:
            showIndent(outfile, level)
            outfile.write('IsConnected=%s,\n' % self.IsConnected)
        if self.MACAddress is not None:
            showIndent(outfile, level)
            outfile.write('MACAddress=%s,\n' % quote_python(self.MACAddress).encode(ExternalEncoding))
        if self.IpAddressAllocationMode is not None:
            showIndent(outfile, level)
            outfile.write('IpAddressAllocationMode=%s,\n' % quote_python(self.IpAddressAllocationMode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('needsCustomization', node)
        if value is not None and 'needsCustomization' not in already_processed:
            already_processed.add('needsCustomization')
            if value in ('true', '1'):
                self.needsCustomization = True
            elif value in ('false', '0'):
                self.needsCustomization = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('network', node)
        if value is not None and 'network' not in already_processed:
            already_processed.add('network')
            self.network = value
        super(NetworkConnectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetworkConnectionIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NetworkConnectionIndex')
            self.NetworkConnectionIndex = ival_
        elif nodeName_ == 'IpAddress':
            IpAddress_ = child_.text
            IpAddress_ = self.gds_validate_string(IpAddress_, node, 'IpAddress')
            self.IpAddress = IpAddress_
            self.validate_IpAddressType(self.IpAddress)    # validate type IpAddressType
        elif nodeName_ == 'ExternalIpAddress':
            ExternalIpAddress_ = child_.text
            ExternalIpAddress_ = self.gds_validate_string(ExternalIpAddress_, node, 'ExternalIpAddress')
            self.ExternalIpAddress = ExternalIpAddress_
            self.validate_IpAddressType(self.ExternalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'IsConnected':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsConnected')
            self.IsConnected = ival_
        elif nodeName_ == 'MACAddress':
            MACAddress_ = child_.text
            MACAddress_ = self.gds_validate_string(MACAddress_, node, 'MACAddress')
            self.MACAddress = MACAddress_
        elif nodeName_ == 'IpAddressAllocationMode':
            IpAddressAllocationMode_ = child_.text
            IpAddressAllocationMode_ = self.gds_validate_string(IpAddressAllocationMode_, node, 'IpAddressAllocationMode')
            self.IpAddressAllocationMode = IpAddressAllocationMode_
        super(NetworkConnectionType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkConnectionType


class SnapshotType(VCloudExtensibleType):
    """5.1 Represents a virtual machine snapshot. none True if the virtual
    machine was powered on when the snapshot was created. truenone
    Creation date/time of the snapshot. truenone Size of the
    snapshot. true"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, poweredOn=None, size=None, created=None):
        self.original_tagname_ = None
        super(SnapshotType, self).__init__(VCloudExtension, )
        self.poweredOn = _cast(bool, poweredOn)
        self.size = _cast(int, size)
        if isinstance(created, basestring):
            initvalue_ = datetime_.datetime.strptime(created, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = created
        self.created = initvalue_
    def factory(*args_, **kwargs_):
        if SnapshotType.subclass:
            return SnapshotType.subclass(*args_, **kwargs_)
        else:
            return SnapshotType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_poweredOn(self): return self.poweredOn
    def set_poweredOn(self, poweredOn): self.poweredOn = poweredOn
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_created(self): return self.created
    def set_created(self, created): self.created = created
    def hasContent_(self):
        if (
            super(SnapshotType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SnapshotType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SnapshotType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SnapshotType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SnapshotType'):
        super(SnapshotType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SnapshotType')
        if self.poweredOn is not None and 'poweredOn' not in already_processed:
            already_processed.add('poweredOn')
            outfile.write(' poweredOn="%s"' % self.gds_format_boolean(self.poweredOn, input_name='poweredOn'))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
        if self.created is not None and 'created' not in already_processed:
            already_processed.add('created')
            outfile.write(' created="%s"' % self.gds_format_datetime(self.created, input_name='created'))
    def exportChildren(self, outfile, level, namespace_='', name_='SnapshotType', fromsubclass_=False, pretty_print=True):
        super(SnapshotType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SnapshotType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.poweredOn is not None and 'poweredOn' not in already_processed:
            already_processed.add('poweredOn')
            showIndent(outfile, level)
            outfile.write('poweredOn=%s,\n' % (self.poweredOn,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % (self.size,))
        if self.created is not None and 'created' not in already_processed:
            already_processed.add('created')
            showIndent(outfile, level)
            outfile.write('created=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.created, input_name='created'))
        super(SnapshotType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SnapshotType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('poweredOn', node)
        if value is not None and 'poweredOn' not in already_processed:
            already_processed.add('poweredOn')
            if value in ('true', '1'):
                self.poweredOn = True
            elif value in ('false', '0'):
                self.poweredOn = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('created', node)
        if value is not None and 'created' not in already_processed:
            already_processed.add('created')
            try:
                self.created = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (created): %s' % exp)
        super(SnapshotType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SnapshotType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SnapshotType


class NetworkAssignmentType(VCloudExtensibleType):
    """0.9 Maps a network name specified in a Vm to the network name of a
    vApp network defined in the VApp that contains the Vm always
    Name of the network as specified in the Vm. truealways Name of
    the vApp network to map to. true"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, containerNetwork=None, innerNetwork=None):
        self.original_tagname_ = None
        super(NetworkAssignmentType, self).__init__(VCloudExtension, )
        self.containerNetwork = _cast(None, containerNetwork)
        self.innerNetwork = _cast(None, innerNetwork)
    def factory(*args_, **kwargs_):
        if NetworkAssignmentType.subclass:
            return NetworkAssignmentType.subclass(*args_, **kwargs_)
        else:
            return NetworkAssignmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_containerNetwork(self): return self.containerNetwork
    def set_containerNetwork(self, containerNetwork): self.containerNetwork = containerNetwork
    def get_innerNetwork(self): return self.innerNetwork
    def set_innerNetwork(self, innerNetwork): self.innerNetwork = innerNetwork
    def hasContent_(self):
        if (
            super(NetworkAssignmentType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkAssignmentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkAssignmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkAssignmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkAssignmentType'):
        super(NetworkAssignmentType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkAssignmentType')
        if self.containerNetwork is not None and 'containerNetwork' not in already_processed:
            already_processed.add('containerNetwork')
            outfile.write(' containerNetwork=%s' % (self.gds_format_string(quote_attrib(self.containerNetwork).encode(ExternalEncoding), input_name='containerNetwork'), ))
        if self.innerNetwork is not None and 'innerNetwork' not in already_processed:
            already_processed.add('innerNetwork')
            outfile.write(' innerNetwork=%s' % (self.gds_format_string(quote_attrib(self.innerNetwork).encode(ExternalEncoding), input_name='innerNetwork'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkAssignmentType', fromsubclass_=False, pretty_print=True):
        super(NetworkAssignmentType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkAssignmentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.containerNetwork is not None and 'containerNetwork' not in already_processed:
            already_processed.add('containerNetwork')
            showIndent(outfile, level)
            outfile.write('containerNetwork="%s",\n' % (self.containerNetwork,))
        if self.innerNetwork is not None and 'innerNetwork' not in already_processed:
            already_processed.add('innerNetwork')
            showIndent(outfile, level)
            outfile.write('innerNetwork="%s",\n' % (self.innerNetwork,))
        super(NetworkAssignmentType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkAssignmentType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('containerNetwork', node)
        if value is not None and 'containerNetwork' not in already_processed:
            already_processed.add('containerNetwork')
            self.containerNetwork = value
        value = find_attr_value_('innerNetwork', node)
        if value is not None and 'innerNetwork' not in already_processed:
            already_processed.add('innerNetwork')
            self.innerNetwork = value
        super(NetworkAssignmentType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NetworkAssignmentType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NetworkAssignmentType


class VAppCreationParamsType(ParamsType):
    """0.9 Represents vApp creation parameters. always True if the vApp
    should be deployed at instantiation. Defaults to true.
    falsealways True if the vApp should be powered-on at
    instantiation. Defaults to true. false"""
    subclass = None
    superclass = ParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, powerOn=None, deploy=None, VAppParent=None, InstantiationParams=None, extensiontype_=None):
        self.original_tagname_ = None
        super(VAppCreationParamsType, self).__init__(VCloudExtension, name, Description, extensiontype_, )
        self.powerOn = _cast(bool, powerOn)
        self.deploy = _cast(bool, deploy)
        self.VAppParent = VAppParent
        self.InstantiationParams = InstantiationParams
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if VAppCreationParamsType.subclass:
            return VAppCreationParamsType.subclass(*args_, **kwargs_)
        else:
            return VAppCreationParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VAppParent(self): return self.VAppParent
    def set_VAppParent(self, VAppParent): self.VAppParent = VAppParent
    def get_InstantiationParams(self): return self.InstantiationParams
    def set_InstantiationParams(self, InstantiationParams): self.InstantiationParams = InstantiationParams
    def get_powerOn(self): return self.powerOn
    def set_powerOn(self, powerOn): self.powerOn = powerOn
    def get_deploy(self): return self.deploy
    def set_deploy(self, deploy): self.deploy = deploy
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.VAppParent is not None or
            self.InstantiationParams is not None or
            super(VAppCreationParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VAppCreationParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VAppCreationParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VAppCreationParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VAppCreationParamsType'):
        super(VAppCreationParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VAppCreationParamsType')
        if self.powerOn is not None and 'powerOn' not in already_processed:
            already_processed.add('powerOn')
            outfile.write(' powerOn="%s"' % self.gds_format_boolean(self.powerOn, input_name='powerOn'))
        if self.deploy is not None and 'deploy' not in already_processed:
            already_processed.add('deploy')
            outfile.write(' deploy="%s"' % self.gds_format_boolean(self.deploy, input_name='deploy'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='VAppCreationParamsType', fromsubclass_=False, pretty_print=True):
        super(VAppCreationParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VAppParent is not None:
            self.VAppParent.export(outfile, level, namespace_, name_='VAppParent', pretty_print=pretty_print)
        if self.InstantiationParams is not None:
            self.InstantiationParams.export(outfile, level, namespace_, name_='InstantiationParams', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VAppCreationParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.powerOn is not None and 'powerOn' not in already_processed:
            already_processed.add('powerOn')
            showIndent(outfile, level)
            outfile.write('powerOn=%s,\n' % (self.powerOn,))
        if self.deploy is not None and 'deploy' not in already_processed:
            already_processed.add('deploy')
            showIndent(outfile, level)
            outfile.write('deploy=%s,\n' % (self.deploy,))
        super(VAppCreationParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VAppCreationParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.VAppParent is not None:
            showIndent(outfile, level)
            outfile.write('VAppParent=model_.ReferenceType(\n')
            self.VAppParent.exportLiteral(outfile, level, name_='VAppParent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InstantiationParams is not None:
            showIndent(outfile, level)
            outfile.write('InstantiationParams=model_.InstantiationParamsType(\n')
            self.InstantiationParams.exportLiteral(outfile, level, name_='InstantiationParams')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('powerOn', node)
        if value is not None and 'powerOn' not in already_processed:
            already_processed.add('powerOn')
            if value in ('true', '1'):
                self.powerOn = True
            elif value in ('false', '0'):
                self.powerOn = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('deploy', node)
        if value is not None and 'deploy' not in already_processed:
            already_processed.add('deploy')
            if value in ('true', '1'):
                self.deploy = True
            elif value in ('false', '0'):
                self.deploy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(VAppCreationParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VAppParent':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VAppParent = obj_
            obj_.original_tagname_ = 'VAppParent'
        elif nodeName_ == 'InstantiationParams':
            obj_ = InstantiationParamsType.factory()
            obj_.build(child_)
            self.InstantiationParams = obj_
            obj_.original_tagname_ = 'InstantiationParams'
        super(VAppCreationParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class VAppCreationParamsType


class SourcedCompositionItemParamType(VCloudExtensibleType):
    """0.9 Represents a vApp, vApp template or Vm to include in a composed
    vApp. 1.0always True if the source item should be deleted after
    composition is complete. false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, sourceDelete=None, Source=None, VmGeneralParams=None, VAppScopedLocalId=None, InstantiationParams=None, NetworkAssignment=None, StorageProfile=None, LocalityParams=None):
        self.original_tagname_ = None
        super(SourcedCompositionItemParamType, self).__init__(VCloudExtension, )
        self.sourceDelete = _cast(bool, sourceDelete)
        self.Source = Source
        self.VmGeneralParams = VmGeneralParams
        self.VAppScopedLocalId = VAppScopedLocalId
        self.InstantiationParams = InstantiationParams
        if NetworkAssignment is None:
            self.NetworkAssignment = []
        else:
            self.NetworkAssignment = NetworkAssignment
        self.StorageProfile = StorageProfile
        self.LocalityParams = LocalityParams
    def factory(*args_, **kwargs_):
        if SourcedCompositionItemParamType.subclass:
            return SourcedCompositionItemParamType.subclass(*args_, **kwargs_)
        else:
            return SourcedCompositionItemParamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_VmGeneralParams(self): return self.VmGeneralParams
    def set_VmGeneralParams(self, VmGeneralParams): self.VmGeneralParams = VmGeneralParams
    def get_VAppScopedLocalId(self): return self.VAppScopedLocalId
    def set_VAppScopedLocalId(self, VAppScopedLocalId): self.VAppScopedLocalId = VAppScopedLocalId
    def get_InstantiationParams(self): return self.InstantiationParams
    def set_InstantiationParams(self, InstantiationParams): self.InstantiationParams = InstantiationParams
    def get_NetworkAssignment(self): return self.NetworkAssignment
    def set_NetworkAssignment(self, NetworkAssignment): self.NetworkAssignment = NetworkAssignment
    def add_NetworkAssignment(self, value): self.NetworkAssignment.append(value)
    def insert_NetworkAssignment_at(self, index, value): self.NetworkAssignment.insert(index, value)
    def replace_NetworkAssignment_at(self, index, value): self.NetworkAssignment[index] = value
    def get_StorageProfile(self): return self.StorageProfile
    def set_StorageProfile(self, StorageProfile): self.StorageProfile = StorageProfile
    def get_LocalityParams(self): return self.LocalityParams
    def set_LocalityParams(self, LocalityParams): self.LocalityParams = LocalityParams
    def get_sourceDelete(self): return self.sourceDelete
    def set_sourceDelete(self, sourceDelete): self.sourceDelete = sourceDelete
    def hasContent_(self):
        if (
            self.Source is not None or
            self.VmGeneralParams is not None or
            self.VAppScopedLocalId is not None or
            self.InstantiationParams is not None or
            self.NetworkAssignment or
            self.StorageProfile is not None or
            self.LocalityParams is not None or
            super(SourcedCompositionItemParamType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SourcedCompositionItemParamType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourcedCompositionItemParamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SourcedCompositionItemParamType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SourcedCompositionItemParamType'):
        super(SourcedCompositionItemParamType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SourcedCompositionItemParamType')
        if self.sourceDelete is not None and 'sourceDelete' not in already_processed:
            already_processed.add('sourceDelete')
            outfile.write(' sourceDelete="%s"' % self.gds_format_boolean(self.sourceDelete, input_name='sourceDelete'))
    def exportChildren(self, outfile, level, namespace_='', name_='SourcedCompositionItemParamType', fromsubclass_=False, pretty_print=True):
        super(SourcedCompositionItemParamType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Source is not None:
            self.Source.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
        if self.VmGeneralParams is not None:
            self.VmGeneralParams.export(outfile, level, namespace_, name_='VmGeneralParams', pretty_print=pretty_print)
        if self.VAppScopedLocalId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVAppScopedLocalId>%s</%sVAppScopedLocalId>%s' % (namespace_, self.gds_format_string(quote_xml(self.VAppScopedLocalId).encode(ExternalEncoding), input_name='VAppScopedLocalId'), namespace_, eol_))
        if self.InstantiationParams is not None:
            self.InstantiationParams.export(outfile, level, namespace_, name_='InstantiationParams', pretty_print=pretty_print)
        for NetworkAssignment_ in self.NetworkAssignment:
            NetworkAssignment_.export(outfile, level, namespace_, name_='NetworkAssignment', pretty_print=pretty_print)
        if self.StorageProfile is not None:
            self.StorageProfile.export(outfile, level, namespace_, name_='StorageProfile', pretty_print=pretty_print)
        if self.LocalityParams is not None:
            self.LocalityParams.export(outfile, level, namespace_, name_='LocalityParams', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SourcedCompositionItemParamType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sourceDelete is not None and 'sourceDelete' not in already_processed:
            already_processed.add('sourceDelete')
            showIndent(outfile, level)
            outfile.write('sourceDelete=%s,\n' % (self.sourceDelete,))
        super(SourcedCompositionItemParamType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SourcedCompositionItemParamType, self).exportLiteralChildren(outfile, level, name_)
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.ReferenceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VmGeneralParams is not None:
            showIndent(outfile, level)
            outfile.write('VmGeneralParams=model_.VmGeneralParamsType(\n')
            self.VmGeneralParams.exportLiteral(outfile, level, name_='VmGeneralParams')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VAppScopedLocalId is not None:
            showIndent(outfile, level)
            outfile.write('VAppScopedLocalId=%s,\n' % quote_python(self.VAppScopedLocalId).encode(ExternalEncoding))
        if self.InstantiationParams is not None:
            showIndent(outfile, level)
            outfile.write('InstantiationParams=model_.InstantiationParamsType(\n')
            self.InstantiationParams.exportLiteral(outfile, level, name_='InstantiationParams')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('NetworkAssignment=[\n')
        level += 1
        for NetworkAssignment_ in self.NetworkAssignment:
            showIndent(outfile, level)
            outfile.write('model_.NetworkAssignmentType(\n')
            NetworkAssignment_.exportLiteral(outfile, level, name_='NetworkAssignmentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.StorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('StorageProfile=model_.ReferenceType(\n')
            self.StorageProfile.exportLiteral(outfile, level, name_='StorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalityParams is not None:
            showIndent(outfile, level)
            outfile.write('LocalityParams=model_.LocalityParamsType(\n')
            self.LocalityParams.exportLiteral(outfile, level, name_='LocalityParams')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sourceDelete', node)
        if value is not None and 'sourceDelete' not in already_processed:
            already_processed.add('sourceDelete')
            if value in ('true', '1'):
                self.sourceDelete = True
            elif value in ('false', '0'):
                self.sourceDelete = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(SourcedCompositionItemParamType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Source = obj_
            obj_.original_tagname_ = 'Source'
        elif nodeName_ == 'VmGeneralParams':
            obj_ = VmGeneralParamsType.factory()
            obj_.build(child_)
            self.VmGeneralParams = obj_
            obj_.original_tagname_ = 'VmGeneralParams'
        elif nodeName_ == 'VAppScopedLocalId':
            VAppScopedLocalId_ = child_.text
            VAppScopedLocalId_ = self.gds_validate_string(VAppScopedLocalId_, node, 'VAppScopedLocalId')
            self.VAppScopedLocalId = VAppScopedLocalId_
        elif nodeName_ == 'InstantiationParams':
            obj_ = InstantiationParamsType.factory()
            obj_.build(child_)
            self.InstantiationParams = obj_
            obj_.original_tagname_ = 'InstantiationParams'
        elif nodeName_ == 'NetworkAssignment':
            obj_ = NetworkAssignmentType.factory()
            obj_.build(child_)
            self.NetworkAssignment.append(obj_)
            obj_.original_tagname_ = 'NetworkAssignment'
        elif nodeName_ == 'StorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.StorageProfile = obj_
            obj_.original_tagname_ = 'StorageProfile'
        elif nodeName_ == 'LocalityParams':
            obj_ = LocalityParamsType.factory()
            obj_.build(child_)
            self.LocalityParams = obj_
            obj_.original_tagname_ = 'LocalityParams'
        super(SourcedCompositionItemParamType, self).buildChildren(child_, node, nodeName_, True)
# end class SourcedCompositionItemParamType


class VmGeneralParamsType(VCloudExtensibleType):
    """5.6 A set of overrides to source VM properties to apply to target VM
    during copying."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Description=None, NeedsCustomization=None):
        self.original_tagname_ = None
        super(VmGeneralParamsType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Description = Description
        self.NeedsCustomization = NeedsCustomization
    def factory(*args_, **kwargs_):
        if VmGeneralParamsType.subclass:
            return VmGeneralParamsType.subclass(*args_, **kwargs_)
        else:
            return VmGeneralParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_NeedsCustomization(self): return self.NeedsCustomization
    def set_NeedsCustomization(self, NeedsCustomization): self.NeedsCustomization = NeedsCustomization
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Description is not None or
            self.NeedsCustomization is not None or
            super(VmGeneralParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmGeneralParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmGeneralParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmGeneralParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmGeneralParamsType'):
        super(VmGeneralParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmGeneralParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='VmGeneralParamsType', fromsubclass_=False, pretty_print=True):
        super(VmGeneralParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.NeedsCustomization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNeedsCustomization>%s</%sNeedsCustomization>%s' % (namespace_, self.gds_format_boolean(self.NeedsCustomization, input_name='NeedsCustomization'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VmGeneralParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmGeneralParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmGeneralParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.NeedsCustomization is not None:
            showIndent(outfile, level)
            outfile.write('NeedsCustomization=%s,\n' % self.NeedsCustomization)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VmGeneralParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'NeedsCustomization':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'NeedsCustomization')
            self.NeedsCustomization = ival_
        super(VmGeneralParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class VmGeneralParamsType


class ComposeVAppParamsType(VAppCreationParamsType):
    """0.9 Represents vApp composition parameters. always Reserved.
    Unimplemented. false"""
    subclass = None
    superclass = VAppCreationParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, powerOn=None, deploy=None, VAppParent=None, InstantiationParams=None, linkedClone=None, SourcedItem=None, AllEULAsAccepted=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ComposeVAppParamsType, self).__init__(VCloudExtension, name, Description, powerOn, deploy, VAppParent, InstantiationParams, extensiontype_, )
        self.linkedClone = _cast(bool, linkedClone)
        if SourcedItem is None:
            self.SourcedItem = []
        else:
            self.SourcedItem = SourcedItem
        self.AllEULAsAccepted = AllEULAsAccepted
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ComposeVAppParamsType.subclass:
            return ComposeVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return ComposeVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SourcedItem(self): return self.SourcedItem
    def set_SourcedItem(self, SourcedItem): self.SourcedItem = SourcedItem
    def add_SourcedItem(self, value): self.SourcedItem.append(value)
    def insert_SourcedItem_at(self, index, value): self.SourcedItem.insert(index, value)
    def replace_SourcedItem_at(self, index, value): self.SourcedItem[index] = value
    def get_AllEULAsAccepted(self): return self.AllEULAsAccepted
    def set_AllEULAsAccepted(self, AllEULAsAccepted): self.AllEULAsAccepted = AllEULAsAccepted
    def get_linkedClone(self): return self.linkedClone
    def set_linkedClone(self, linkedClone): self.linkedClone = linkedClone
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.SourcedItem or
            self.AllEULAsAccepted is not None or
            super(ComposeVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ComposeVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComposeVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ComposeVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ComposeVAppParamsType'):
        super(ComposeVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ComposeVAppParamsType')
        if self.linkedClone is not None and 'linkedClone' not in already_processed:
            already_processed.add('linkedClone')
            outfile.write(' linkedClone="%s"' % self.gds_format_boolean(self.linkedClone, input_name='linkedClone'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ComposeVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(ComposeVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SourcedItem_ in self.SourcedItem:
            SourcedItem_.export(outfile, level, namespace_, name_='SourcedItem', pretty_print=pretty_print)
        if self.AllEULAsAccepted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllEULAsAccepted>%s</%sAllEULAsAccepted>%s' % (namespace_, self.gds_format_boolean(self.AllEULAsAccepted, input_name='AllEULAsAccepted'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ComposeVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.linkedClone is not None and 'linkedClone' not in already_processed:
            already_processed.add('linkedClone')
            showIndent(outfile, level)
            outfile.write('linkedClone=%s,\n' % (self.linkedClone,))
        super(ComposeVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ComposeVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('SourcedItem=[\n')
        level += 1
        for SourcedItem_ in self.SourcedItem:
            showIndent(outfile, level)
            outfile.write('model_.SourcedCompositionItemParamType(\n')
            SourcedItem_.exportLiteral(outfile, level, name_='SourcedCompositionItemParamType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.AllEULAsAccepted is not None:
            showIndent(outfile, level)
            outfile.write('AllEULAsAccepted=%s,\n' % self.AllEULAsAccepted)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('linkedClone', node)
        if value is not None and 'linkedClone' not in already_processed:
            already_processed.add('linkedClone')
            if value in ('true', '1'):
                self.linkedClone = True
            elif value in ('false', '0'):
                self.linkedClone = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ComposeVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SourcedItem':
            obj_ = SourcedCompositionItemParamType.factory()
            obj_.build(child_)
            self.SourcedItem.append(obj_)
            obj_.original_tagname_ = 'SourcedItem'
        elif nodeName_ == 'AllEULAsAccepted':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AllEULAsAccepted')
            self.AllEULAsAccepted = ival_
        super(ComposeVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class ComposeVAppParamsType


class RecomposeVAppParamsType(ComposeVAppParamsType):
    """1.0 Parameters for a recompose vApp request."""
    subclass = None
    superclass = ComposeVAppParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, powerOn=None, deploy=None, VAppParent=None, InstantiationParams=None, linkedClone=None, SourcedItem=None, AllEULAsAccepted=None, CreateItem=None, DeleteItem=None):
        self.original_tagname_ = None
        super(RecomposeVAppParamsType, self).__init__(VCloudExtension, name, Description, powerOn, deploy, VAppParent, InstantiationParams, linkedClone, SourcedItem, AllEULAsAccepted, )
        if CreateItem is None:
            self.CreateItem = []
        else:
            self.CreateItem = CreateItem
        if DeleteItem is None:
            self.DeleteItem = []
        else:
            self.DeleteItem = DeleteItem
    def factory(*args_, **kwargs_):
        if RecomposeVAppParamsType.subclass:
            return RecomposeVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return RecomposeVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CreateItem(self): return self.CreateItem
    def set_CreateItem(self, CreateItem): self.CreateItem = CreateItem
    def add_CreateItem(self, value): self.CreateItem.append(value)
    def insert_CreateItem_at(self, index, value): self.CreateItem.insert(index, value)
    def replace_CreateItem_at(self, index, value): self.CreateItem[index] = value
    def get_DeleteItem(self): return self.DeleteItem
    def set_DeleteItem(self, DeleteItem): self.DeleteItem = DeleteItem
    def add_DeleteItem(self, value): self.DeleteItem.append(value)
    def insert_DeleteItem_at(self, index, value): self.DeleteItem.insert(index, value)
    def replace_DeleteItem_at(self, index, value): self.DeleteItem[index] = value
    def hasContent_(self):
        if (
            self.CreateItem or
            self.DeleteItem or
            super(RecomposeVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RecomposeVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RecomposeVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RecomposeVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RecomposeVAppParamsType'):
        super(RecomposeVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RecomposeVAppParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='RecomposeVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(RecomposeVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CreateItem_ in self.CreateItem:
            CreateItem_.export(outfile, level, namespace_, name_='CreateItem', pretty_print=pretty_print)
        for DeleteItem_ in self.DeleteItem:
            DeleteItem_.export(outfile, level, namespace_, name_='DeleteItem', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RecomposeVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RecomposeVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RecomposeVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('CreateItem=[\n')
        level += 1
        for CreateItem_ in self.CreateItem:
            showIndent(outfile, level)
            outfile.write('model_.VmType(\n')
            CreateItem_.exportLiteral(outfile, level, name_='VmType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DeleteItem=[\n')
        level += 1
        for DeleteItem_ in self.DeleteItem:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            DeleteItem_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RecomposeVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CreateItem':
            obj_ = VmType.factory()
            obj_.build(child_)
            self.CreateItem.append(obj_)
            obj_.original_tagname_ = 'CreateItem'
        elif nodeName_ == 'DeleteItem':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.DeleteItem.append(obj_)
            obj_.original_tagname_ = 'DeleteItem'
        super(RecomposeVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class RecomposeVAppParamsType


class RegisterVAppParamsType(ParamsType):
    """5.5 Represents vApp registration parameters."""
    subclass = None
    superclass = ParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, Ovf=None, VsToVmxMap=None, OvfToVdcNetworkMap=None, ExternalNatIpMap=None, NicIpMap=None):
        self.original_tagname_ = None
        super(RegisterVAppParamsType, self).__init__(VCloudExtension, name, Description, )
        self.Ovf = Ovf
        self.VsToVmxMap = VsToVmxMap
        self.OvfToVdcNetworkMap = OvfToVdcNetworkMap
        self.ExternalNatIpMap = ExternalNatIpMap
        self.NicIpMap = NicIpMap
    def factory(*args_, **kwargs_):
        if RegisterVAppParamsType.subclass:
            return RegisterVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return RegisterVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Ovf(self): return self.Ovf
    def set_Ovf(self, Ovf): self.Ovf = Ovf
    def get_VsToVmxMap(self): return self.VsToVmxMap
    def set_VsToVmxMap(self, VsToVmxMap): self.VsToVmxMap = VsToVmxMap
    def get_OvfToVdcNetworkMap(self): return self.OvfToVdcNetworkMap
    def set_OvfToVdcNetworkMap(self, OvfToVdcNetworkMap): self.OvfToVdcNetworkMap = OvfToVdcNetworkMap
    def get_ExternalNatIpMap(self): return self.ExternalNatIpMap
    def set_ExternalNatIpMap(self, ExternalNatIpMap): self.ExternalNatIpMap = ExternalNatIpMap
    def get_NicIpMap(self): return self.NicIpMap
    def set_NicIpMap(self, NicIpMap): self.NicIpMap = NicIpMap
    def hasContent_(self):
        if (
            self.Ovf is not None or
            self.VsToVmxMap is not None or
            self.OvfToVdcNetworkMap is not None or
            self.ExternalNatIpMap is not None or
            self.NicIpMap is not None or
            super(RegisterVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RegisterVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegisterVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RegisterVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegisterVAppParamsType'):
        super(RegisterVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RegisterVAppParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='RegisterVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(RegisterVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Ovf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOvf>%s</%sOvf>%s' % (namespace_, self.gds_format_string(quote_xml(self.Ovf).encode(ExternalEncoding), input_name='Ovf'), namespace_, eol_))
        if self.VsToVmxMap is not None:
            self.VsToVmxMap.export(outfile, level, namespace_, name_='VsToVmxMap', pretty_print=pretty_print)
        if self.OvfToVdcNetworkMap is not None:
            self.OvfToVdcNetworkMap.export(outfile, level, namespace_, name_='OvfToVdcNetworkMap', pretty_print=pretty_print)
        if self.ExternalNatIpMap is not None:
            self.ExternalNatIpMap.export(outfile, level, namespace_, name_='ExternalNatIpMap', pretty_print=pretty_print)
        if self.NicIpMap is not None:
            self.NicIpMap.export(outfile, level, namespace_, name_='NicIpMap', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RegisterVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RegisterVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RegisterVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Ovf is not None:
            showIndent(outfile, level)
            outfile.write('Ovf=%s,\n' % quote_python(self.Ovf).encode(ExternalEncoding))
        if self.VsToVmxMap is not None:
            showIndent(outfile, level)
            outfile.write('VsToVmxMap=model_.VsToVmxMapType(\n')
            self.VsToVmxMap.exportLiteral(outfile, level, name_='VsToVmxMap')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OvfToVdcNetworkMap is not None:
            showIndent(outfile, level)
            outfile.write('OvfToVdcNetworkMap=model_.OvfToVdcNetworkMapType(\n')
            self.OvfToVdcNetworkMap.exportLiteral(outfile, level, name_='OvfToVdcNetworkMap')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExternalNatIpMap is not None:
            showIndent(outfile, level)
            outfile.write('ExternalNatIpMap=model_.ExternalNatIpMapType(\n')
            self.ExternalNatIpMap.exportLiteral(outfile, level, name_='ExternalNatIpMap')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NicIpMap is not None:
            showIndent(outfile, level)
            outfile.write('NicIpMap=model_.NicIpMapType(\n')
            self.NicIpMap.exportLiteral(outfile, level, name_='NicIpMap')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RegisterVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Ovf':
            Ovf_ = child_.text
            Ovf_ = self.gds_validate_string(Ovf_, node, 'Ovf')
            self.Ovf = Ovf_
        elif nodeName_ == 'VsToVmxMap':
            obj_ = VsToVmxMapType.factory()
            obj_.build(child_)
            self.VsToVmxMap = obj_
            obj_.original_tagname_ = 'VsToVmxMap'
        elif nodeName_ == 'OvfToVdcNetworkMap':
            obj_ = OvfToVdcNetworkMapType.factory()
            obj_.build(child_)
            self.OvfToVdcNetworkMap = obj_
            obj_.original_tagname_ = 'OvfToVdcNetworkMap'
        elif nodeName_ == 'ExternalNatIpMap':
            obj_ = ExternalNatIpMapType.factory()
            obj_.build(child_)
            self.ExternalNatIpMap = obj_
            obj_.original_tagname_ = 'ExternalNatIpMap'
        elif nodeName_ == 'NicIpMap':
            obj_ = NicIpMapType.factory()
            obj_.build(child_)
            self.NicIpMap = obj_
            obj_.original_tagname_ = 'NicIpMap'
        super(RegisterVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class RegisterVAppParamsType


class VsToVmxMapType(GeneratedsSuper):
    """always Map from OVF Virtual Systems via the BIOS UUID to the
    datastore location of the replicated VM's files on the
    destination site."""
    subclass = None
    superclass = None
    def __init__(self, Entry=None):
        self.original_tagname_ = None
        if Entry is None:
            self.Entry = []
        else:
            self.Entry = Entry
    def factory(*args_, **kwargs_):
        if VsToVmxMapType.subclass:
            return VsToVmxMapType.subclass(*args_, **kwargs_)
        else:
            return VsToVmxMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Entry(self): return self.Entry
    def set_Entry(self, Entry): self.Entry = Entry
    def add_Entry(self, value): self.Entry.append(value)
    def insert_Entry_at(self, index, value): self.Entry.insert(index, value)
    def replace_Entry_at(self, index, value): self.Entry[index] = value
    def hasContent_(self):
        if (
            self.Entry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VsToVmxMapType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VsToVmxMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VsToVmxMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VsToVmxMapType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VsToVmxMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Entry_ in self.Entry:
            Entry_.export(outfile, level, namespace_, name_='Entry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VsToVmxMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Entry=[\n')
        level += 1
        for Entry_ in self.Entry:
            showIndent(outfile, level)
            outfile.write('model_.EntryType(\n')
            Entry_.exportLiteral(outfile, level, name_='EntryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Entry':
            obj_ = EntryType.factory()
            obj_.build(child_)
            self.Entry.append(obj_)
            obj_.original_tagname_ = 'Entry'
# end class VsToVmxMapType


class OvfToVdcNetworkMapType(GeneratedsSuper):
    """always Map from OVF to Org networks."""
    subclass = None
    superclass = None
    def __init__(self, Entry=None):
        self.original_tagname_ = None
        if Entry is None:
            self.Entry = []
        else:
            self.Entry = Entry
    def factory(*args_, **kwargs_):
        if OvfToVdcNetworkMapType.subclass:
            return OvfToVdcNetworkMapType.subclass(*args_, **kwargs_)
        else:
            return OvfToVdcNetworkMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Entry(self): return self.Entry
    def set_Entry(self, Entry): self.Entry = Entry
    def add_Entry(self, value): self.Entry.append(value)
    def insert_Entry_at(self, index, value): self.Entry.insert(index, value)
    def replace_Entry_at(self, index, value): self.Entry[index] = value
    def hasContent_(self):
        if (
            self.Entry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OvfToVdcNetworkMapType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OvfToVdcNetworkMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OvfToVdcNetworkMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OvfToVdcNetworkMapType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OvfToVdcNetworkMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Entry_ in self.Entry:
            Entry_.export(outfile, level, namespace_, name_='Entry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OvfToVdcNetworkMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Entry=[\n')
        level += 1
        for Entry_ in self.Entry:
            showIndent(outfile, level)
            outfile.write('model_.EntryType1(\n')
            Entry_.exportLiteral(outfile, level, name_='EntryType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Entry':
            obj_ = EntryType1.factory()
            obj_.build(child_)
            self.Entry.append(obj_)
            obj_.original_tagname_ = 'Entry'
# end class OvfToVdcNetworkMapType


class ExternalNatIpMapType(GeneratedsSuper):
    """always Maps source site external NAT IP addresses to destination
    site external NAT IP addresses."""
    subclass = None
    superclass = None
    def __init__(self, Entry=None):
        self.original_tagname_ = None
        if Entry is None:
            self.Entry = []
        else:
            self.Entry = Entry
    def factory(*args_, **kwargs_):
        if ExternalNatIpMapType.subclass:
            return ExternalNatIpMapType.subclass(*args_, **kwargs_)
        else:
            return ExternalNatIpMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Entry(self): return self.Entry
    def set_Entry(self, Entry): self.Entry = Entry
    def add_Entry(self, value): self.Entry.append(value)
    def insert_Entry_at(self, index, value): self.Entry.insert(index, value)
    def replace_Entry_at(self, index, value): self.Entry[index] = value
    def hasContent_(self):
        if (
            self.Entry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExternalNatIpMapType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExternalNatIpMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExternalNatIpMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExternalNatIpMapType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExternalNatIpMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Entry_ in self.Entry:
            Entry_.export(outfile, level, namespace_, name_='Entry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ExternalNatIpMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Entry=[\n')
        level += 1
        for Entry_ in self.Entry:
            showIndent(outfile, level)
            outfile.write('model_.EntryType2(\n')
            Entry_.exportLiteral(outfile, level, name_='EntryType2')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Entry':
            obj_ = EntryType2.factory()
            obj_.build(child_)
            self.Entry.append(obj_)
            obj_.original_tagname_ = 'Entry'
# end class ExternalNatIpMapType


class NicIpMapType(GeneratedsSuper):
    """always VM's with NICs that are connected directly to a VDC network
    and where the NICs have manually assigned IP addresses needs to
    be mapped to a valid IP address within the IP range of the
    destination site's VDC network. This type provides that mapping."""
    subclass = None
    superclass = None
    def __init__(self, Entry=None):
        self.original_tagname_ = None
        if Entry is None:
            self.Entry = []
        else:
            self.Entry = Entry
    def factory(*args_, **kwargs_):
        if NicIpMapType.subclass:
            return NicIpMapType.subclass(*args_, **kwargs_)
        else:
            return NicIpMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Entry(self): return self.Entry
    def set_Entry(self, Entry): self.Entry = Entry
    def add_Entry(self, value): self.Entry.append(value)
    def insert_Entry_at(self, index, value): self.Entry.insert(index, value)
    def replace_Entry_at(self, index, value): self.Entry[index] = value
    def hasContent_(self):
        if (
            self.Entry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NicIpMapType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NicIpMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NicIpMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NicIpMapType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NicIpMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Entry_ in self.Entry:
            Entry_.export(outfile, level, namespace_, name_='Entry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NicIpMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Entry=[\n')
        level += 1
        for Entry_ in self.Entry:
            showIndent(outfile, level)
            outfile.write('model_.EntryType3(\n')
            Entry_.exportLiteral(outfile, level, name_='EntryType3')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Entry':
            obj_ = EntryType3.factory()
            obj_.build(child_)
            self.Entry.append(obj_)
            obj_.original_tagname_ = 'Entry'
# end class NicIpMapType


class LocalityParamsType(VCloudExtensibleType):
    """5.1 Represents locality parameters. Locality parameters provide a
    hint that may help the placement engine optimize placement of a
    VM with respect to another VM or an independent disk."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, ResourceEntity=None):
        self.original_tagname_ = None
        super(LocalityParamsType, self).__init__(VCloudExtension, )
        if ResourceEntity is None:
            self.ResourceEntity = []
        else:
            self.ResourceEntity = ResourceEntity
    def factory(*args_, **kwargs_):
        if LocalityParamsType.subclass:
            return LocalityParamsType.subclass(*args_, **kwargs_)
        else:
            return LocalityParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ResourceEntity(self): return self.ResourceEntity
    def set_ResourceEntity(self, ResourceEntity): self.ResourceEntity = ResourceEntity
    def add_ResourceEntity(self, value): self.ResourceEntity.append(value)
    def insert_ResourceEntity_at(self, index, value): self.ResourceEntity.insert(index, value)
    def replace_ResourceEntity_at(self, index, value): self.ResourceEntity[index] = value
    def hasContent_(self):
        if (
            self.ResourceEntity or
            super(LocalityParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LocalityParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalityParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LocalityParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocalityParamsType'):
        super(LocalityParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LocalityParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='LocalityParamsType', fromsubclass_=False, pretty_print=True):
        super(LocalityParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResourceEntity_ in self.ResourceEntity:
            ResourceEntity_.export(outfile, level, namespace_, name_='ResourceEntity', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LocalityParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LocalityParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LocalityParamsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('ResourceEntity=[\n')
        level += 1
        for ResourceEntity_ in self.ResourceEntity:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            ResourceEntity_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LocalityParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResourceEntity':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ResourceEntity.append(obj_)
            obj_.original_tagname_ = 'ResourceEntity'
        super(LocalityParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class LocalityParamsType


class SourcedVmInstantiationParamsType(VCloudExtensibleType):
    """5.65.1 Represents instantiation parameters. Deprecated in favor of
    SourcedCompositionItemParamType"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Source=None, StorageProfile=None, LocalityParams=None, HardwareCustomization=None):
        self.original_tagname_ = None
        super(SourcedVmInstantiationParamsType, self).__init__(VCloudExtension, )
        self.Source = Source
        self.StorageProfile = StorageProfile
        self.LocalityParams = LocalityParams
        self.HardwareCustomization = HardwareCustomization
    def factory(*args_, **kwargs_):
        if SourcedVmInstantiationParamsType.subclass:
            return SourcedVmInstantiationParamsType.subclass(*args_, **kwargs_)
        else:
            return SourcedVmInstantiationParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_StorageProfile(self): return self.StorageProfile
    def set_StorageProfile(self, StorageProfile): self.StorageProfile = StorageProfile
    def get_LocalityParams(self): return self.LocalityParams
    def set_LocalityParams(self, LocalityParams): self.LocalityParams = LocalityParams
    def get_HardwareCustomization(self): return self.HardwareCustomization
    def set_HardwareCustomization(self, HardwareCustomization): self.HardwareCustomization = HardwareCustomization
    def hasContent_(self):
        if (
            self.Source is not None or
            self.StorageProfile is not None or
            self.LocalityParams is not None or
            self.HardwareCustomization is not None or
            super(SourcedVmInstantiationParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SourcedVmInstantiationParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourcedVmInstantiationParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SourcedVmInstantiationParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SourcedVmInstantiationParamsType'):
        super(SourcedVmInstantiationParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SourcedVmInstantiationParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='SourcedVmInstantiationParamsType', fromsubclass_=False, pretty_print=True):
        super(SourcedVmInstantiationParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Source is not None:
            self.Source.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
        if self.StorageProfile is not None:
            self.StorageProfile.export(outfile, level, namespace_, name_='StorageProfile', pretty_print=pretty_print)
        if self.LocalityParams is not None:
            self.LocalityParams.export(outfile, level, namespace_, name_='LocalityParams', pretty_print=pretty_print)
        if self.HardwareCustomization is not None:
            self.HardwareCustomization.export(outfile, level, namespace_, name_='HardwareCustomization', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SourcedVmInstantiationParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SourcedVmInstantiationParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SourcedVmInstantiationParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.ReferenceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('StorageProfile=model_.ReferenceType(\n')
            self.StorageProfile.exportLiteral(outfile, level, name_='StorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalityParams is not None:
            showIndent(outfile, level)
            outfile.write('LocalityParams=model_.LocalityParamsType(\n')
            self.LocalityParams.exportLiteral(outfile, level, name_='LocalityParams')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HardwareCustomization is not None:
            showIndent(outfile, level)
            outfile.write('HardwareCustomization=model_.InstantiateVmHardwareCustomizationParamsType(\n')
            self.HardwareCustomization.exportLiteral(outfile, level, name_='HardwareCustomization')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SourcedVmInstantiationParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Source = obj_
            obj_.original_tagname_ = 'Source'
        elif nodeName_ == 'StorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.StorageProfile = obj_
            obj_.original_tagname_ = 'StorageProfile'
        elif nodeName_ == 'LocalityParams':
            obj_ = LocalityParamsType.factory()
            obj_.build(child_)
            self.LocalityParams = obj_
            obj_.original_tagname_ = 'LocalityParams'
        elif nodeName_ == 'HardwareCustomization':
            obj_ = InstantiateVmHardwareCustomizationParamsType.factory()
            obj_.build(child_)
            self.HardwareCustomization = obj_
            obj_.original_tagname_ = 'HardwareCustomization'
        super(SourcedVmInstantiationParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class SourcedVmInstantiationParamsType


class InstantiateVAppParamsType(VAppCreationParamsType):
    """0.9 Represents vApp instantiation parameters. always Reserved.
    Unimplemented. false"""
    subclass = None
    superclass = VAppCreationParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, powerOn=None, deploy=None, VAppParent=None, InstantiationParams=None, linkedClone=None, Source=None, IsSourceDelete=None, SourcedVmInstantiationParams=None, SourcedItem=None, extensiontype_=None):
        self.original_tagname_ = None
        super(InstantiateVAppParamsType, self).__init__(VCloudExtension, name, Description, powerOn, deploy, VAppParent, InstantiationParams, extensiontype_, )
        self.linkedClone = _cast(bool, linkedClone)
        self.Source = Source
        self.IsSourceDelete = IsSourceDelete
        if SourcedVmInstantiationParams is None:
            self.SourcedVmInstantiationParams = []
        else:
            self.SourcedVmInstantiationParams = SourcedVmInstantiationParams
        if SourcedItem is None:
            self.SourcedItem = []
        else:
            self.SourcedItem = SourcedItem
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if InstantiateVAppParamsType.subclass:
            return InstantiateVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return InstantiateVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_IsSourceDelete(self): return self.IsSourceDelete
    def set_IsSourceDelete(self, IsSourceDelete): self.IsSourceDelete = IsSourceDelete
    def get_SourcedVmInstantiationParams(self): return self.SourcedVmInstantiationParams
    def set_SourcedVmInstantiationParams(self, SourcedVmInstantiationParams): self.SourcedVmInstantiationParams = SourcedVmInstantiationParams
    def add_SourcedVmInstantiationParams(self, value): self.SourcedVmInstantiationParams.append(value)
    def insert_SourcedVmInstantiationParams_at(self, index, value): self.SourcedVmInstantiationParams.insert(index, value)
    def replace_SourcedVmInstantiationParams_at(self, index, value): self.SourcedVmInstantiationParams[index] = value
    def get_SourcedItem(self): return self.SourcedItem
    def set_SourcedItem(self, SourcedItem): self.SourcedItem = SourcedItem
    def add_SourcedItem(self, value): self.SourcedItem.append(value)
    def insert_SourcedItem_at(self, index, value): self.SourcedItem.insert(index, value)
    def replace_SourcedItem_at(self, index, value): self.SourcedItem[index] = value
    def get_linkedClone(self): return self.linkedClone
    def set_linkedClone(self, linkedClone): self.linkedClone = linkedClone
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Source is not None or
            self.IsSourceDelete is not None or
            self.SourcedVmInstantiationParams or
            self.SourcedItem or
            super(InstantiateVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstantiateVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstantiateVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstantiateVAppParamsType'):
        super(InstantiateVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVAppParamsType')
        if self.linkedClone is not None and 'linkedClone' not in already_processed:
            already_processed.add('linkedClone')
            outfile.write(' linkedClone="%s"' % self.gds_format_boolean(self.linkedClone, input_name='linkedClone'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='InstantiateVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(InstantiateVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Source is not None:
            self.Source.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
        if self.IsSourceDelete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsSourceDelete>%s</%sIsSourceDelete>%s' % (namespace_, self.gds_format_boolean(self.IsSourceDelete, input_name='IsSourceDelete'), namespace_, eol_))
        for SourcedVmInstantiationParams_ in self.SourcedVmInstantiationParams:
            SourcedVmInstantiationParams_.export(outfile, level, namespace_, name_='SourcedVmInstantiationParams', pretty_print=pretty_print)
        for SourcedItem_ in self.SourcedItem:
            SourcedItem_.export(outfile, level, namespace_, name_='SourcedItem', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InstantiateVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.linkedClone is not None and 'linkedClone' not in already_processed:
            already_processed.add('linkedClone')
            showIndent(outfile, level)
            outfile.write('linkedClone=%s,\n' % (self.linkedClone,))
        super(InstantiateVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstantiateVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.ReferenceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IsSourceDelete is not None:
            showIndent(outfile, level)
            outfile.write('IsSourceDelete=%s,\n' % self.IsSourceDelete)
        showIndent(outfile, level)
        outfile.write('SourcedVmInstantiationParams=[\n')
        level += 1
        for SourcedVmInstantiationParams_ in self.SourcedVmInstantiationParams:
            showIndent(outfile, level)
            outfile.write('model_.SourcedVmInstantiationParamsType(\n')
            SourcedVmInstantiationParams_.exportLiteral(outfile, level, name_='SourcedVmInstantiationParamsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SourcedItem=[\n')
        level += 1
        for SourcedItem_ in self.SourcedItem:
            showIndent(outfile, level)
            outfile.write('model_.SourcedCompositionItemParamType(\n')
            SourcedItem_.exportLiteral(outfile, level, name_='SourcedCompositionItemParamType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('linkedClone', node)
        if value is not None and 'linkedClone' not in already_processed:
            already_processed.add('linkedClone')
            if value in ('true', '1'):
                self.linkedClone = True
            elif value in ('false', '0'):
                self.linkedClone = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(InstantiateVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Source = obj_
            obj_.original_tagname_ = 'Source'
        elif nodeName_ == 'IsSourceDelete':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsSourceDelete')
            self.IsSourceDelete = ival_
        elif nodeName_ == 'SourcedVmInstantiationParams':
            obj_ = SourcedVmInstantiationParamsType.factory()
            obj_.build(child_)
            self.SourcedVmInstantiationParams.append(obj_)
            obj_.original_tagname_ = 'SourcedVmInstantiationParams'
        elif nodeName_ == 'SourcedItem':
            obj_ = SourcedCompositionItemParamType.factory()
            obj_.build(child_)
            self.SourcedItem.append(obj_)
            obj_.original_tagname_ = 'SourcedItem'
        super(InstantiateVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class InstantiateVAppParamsType


class InstantiateVAppTemplateParamsType(InstantiateVAppParamsType):
    """0.9 Represents vApp template instantiation parameters."""
    subclass = None
    superclass = InstantiateVAppParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, powerOn=None, deploy=None, VAppParent=None, InstantiationParams=None, linkedClone=None, Source=None, IsSourceDelete=None, SourcedVmInstantiationParams=None, SourcedItem=None, AllEULAsAccepted=None):
        self.original_tagname_ = None
        super(InstantiateVAppTemplateParamsType, self).__init__(VCloudExtension, name, Description, powerOn, deploy, VAppParent, InstantiationParams, linkedClone, Source, IsSourceDelete, SourcedVmInstantiationParams, SourcedItem, )
        self.AllEULAsAccepted = AllEULAsAccepted
    def factory(*args_, **kwargs_):
        if InstantiateVAppTemplateParamsType.subclass:
            return InstantiateVAppTemplateParamsType.subclass(*args_, **kwargs_)
        else:
            return InstantiateVAppTemplateParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AllEULAsAccepted(self): return self.AllEULAsAccepted
    def set_AllEULAsAccepted(self, AllEULAsAccepted): self.AllEULAsAccepted = AllEULAsAccepted
    def hasContent_(self):
        if (
            self.AllEULAsAccepted is not None or
            super(InstantiateVAppTemplateParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstantiateVAppTemplateParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVAppTemplateParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstantiateVAppTemplateParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstantiateVAppTemplateParamsType'):
        super(InstantiateVAppTemplateParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVAppTemplateParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='InstantiateVAppTemplateParamsType', fromsubclass_=False, pretty_print=True):
        super(InstantiateVAppTemplateParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AllEULAsAccepted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllEULAsAccepted>%s</%sAllEULAsAccepted>%s' % (namespace_, self.gds_format_boolean(self.AllEULAsAccepted, input_name='AllEULAsAccepted'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='InstantiateVAppTemplateParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(InstantiateVAppTemplateParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstantiateVAppTemplateParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.AllEULAsAccepted is not None:
            showIndent(outfile, level)
            outfile.write('AllEULAsAccepted=%s,\n' % self.AllEULAsAccepted)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InstantiateVAppTemplateParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AllEULAsAccepted':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AllEULAsAccepted')
            self.AllEULAsAccepted = ival_
        super(InstantiateVAppTemplateParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class InstantiateVAppTemplateParamsType


class InstantiateOvfParamsType(VAppCreationParamsType):
    """Represents vApp instantiation from OVF parameters false"""
    subclass = None
    superclass = VAppCreationParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, powerOn=None, deploy=None, VAppParent=None, InstantiationParams=None, transferFormat=None, AllEULAsAccepted=None, NetworkMapping=None, InstantiateOvfProperty=None, InstantiateVmParams=None):
        self.original_tagname_ = None
        super(InstantiateOvfParamsType, self).__init__(VCloudExtension, name, Description, powerOn, deploy, VAppParent, InstantiationParams, )
        self.transferFormat = _cast(None, transferFormat)
        self.AllEULAsAccepted = AllEULAsAccepted
        if NetworkMapping is None:
            self.NetworkMapping = []
        else:
            self.NetworkMapping = NetworkMapping
        if InstantiateOvfProperty is None:
            self.InstantiateOvfProperty = []
        else:
            self.InstantiateOvfProperty = InstantiateOvfProperty
        if InstantiateVmParams is None:
            self.InstantiateVmParams = []
        else:
            self.InstantiateVmParams = InstantiateVmParams
    def factory(*args_, **kwargs_):
        if InstantiateOvfParamsType.subclass:
            return InstantiateOvfParamsType.subclass(*args_, **kwargs_)
        else:
            return InstantiateOvfParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AllEULAsAccepted(self): return self.AllEULAsAccepted
    def set_AllEULAsAccepted(self, AllEULAsAccepted): self.AllEULAsAccepted = AllEULAsAccepted
    def get_NetworkMapping(self): return self.NetworkMapping
    def set_NetworkMapping(self, NetworkMapping): self.NetworkMapping = NetworkMapping
    def add_NetworkMapping(self, value): self.NetworkMapping.append(value)
    def insert_NetworkMapping_at(self, index, value): self.NetworkMapping.insert(index, value)
    def replace_NetworkMapping_at(self, index, value): self.NetworkMapping[index] = value
    def get_InstantiateOvfProperty(self): return self.InstantiateOvfProperty
    def set_InstantiateOvfProperty(self, InstantiateOvfProperty): self.InstantiateOvfProperty = InstantiateOvfProperty
    def add_InstantiateOvfProperty(self, value): self.InstantiateOvfProperty.append(value)
    def insert_InstantiateOvfProperty_at(self, index, value): self.InstantiateOvfProperty.insert(index, value)
    def replace_InstantiateOvfProperty_at(self, index, value): self.InstantiateOvfProperty[index] = value
    def get_InstantiateVmParams(self): return self.InstantiateVmParams
    def set_InstantiateVmParams(self, InstantiateVmParams): self.InstantiateVmParams = InstantiateVmParams
    def add_InstantiateVmParams(self, value): self.InstantiateVmParams.append(value)
    def insert_InstantiateVmParams_at(self, index, value): self.InstantiateVmParams.insert(index, value)
    def replace_InstantiateVmParams_at(self, index, value): self.InstantiateVmParams[index] = value
    def get_transferFormat(self): return self.transferFormat
    def set_transferFormat(self, transferFormat): self.transferFormat = transferFormat
    def hasContent_(self):
        if (
            self.AllEULAsAccepted is not None or
            self.NetworkMapping or
            self.InstantiateOvfProperty or
            self.InstantiateVmParams or
            super(InstantiateOvfParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstantiateOvfParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateOvfParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstantiateOvfParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstantiateOvfParamsType'):
        super(InstantiateOvfParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateOvfParamsType')
        if self.transferFormat is not None and 'transferFormat' not in already_processed:
            already_processed.add('transferFormat')
            outfile.write(' transferFormat=%s' % (self.gds_format_string(quote_attrib(self.transferFormat).encode(ExternalEncoding), input_name='transferFormat'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InstantiateOvfParamsType', fromsubclass_=False, pretty_print=True):
        super(InstantiateOvfParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AllEULAsAccepted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllEULAsAccepted>%s</%sAllEULAsAccepted>%s' % (namespace_, self.gds_format_boolean(self.AllEULAsAccepted, input_name='AllEULAsAccepted'), namespace_, eol_))
        for NetworkMapping_ in self.NetworkMapping:
            NetworkMapping_.export(outfile, level, namespace_, name_='NetworkMapping', pretty_print=pretty_print)
        for InstantiateOvfProperty_ in self.InstantiateOvfProperty:
            InstantiateOvfProperty_.export(outfile, level, namespace_, name_='InstantiateOvfProperty', pretty_print=pretty_print)
        for InstantiateVmParams_ in self.InstantiateVmParams:
            InstantiateVmParams_.export(outfile, level, namespace_, name_='InstantiateVmParams', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InstantiateOvfParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.transferFormat is not None and 'transferFormat' not in already_processed:
            already_processed.add('transferFormat')
            showIndent(outfile, level)
            outfile.write('transferFormat="%s",\n' % (self.transferFormat,))
        super(InstantiateOvfParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstantiateOvfParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.AllEULAsAccepted is not None:
            showIndent(outfile, level)
            outfile.write('AllEULAsAccepted=%s,\n' % self.AllEULAsAccepted)
        showIndent(outfile, level)
        outfile.write('NetworkMapping=[\n')
        level += 1
        for NetworkMapping_ in self.NetworkMapping:
            showIndent(outfile, level)
            outfile.write('model_.NetworkMapping(\n')
            NetworkMapping_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InstantiateOvfProperty=[\n')
        level += 1
        for InstantiateOvfProperty_ in self.InstantiateOvfProperty:
            showIndent(outfile, level)
            outfile.write('model_.InstantiateOvfProperty(\n')
            InstantiateOvfProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InstantiateVmParams=[\n')
        level += 1
        for InstantiateVmParams_ in self.InstantiateVmParams:
            showIndent(outfile, level)
            outfile.write('model_.InstantiateVmParams(\n')
            InstantiateVmParams_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('transferFormat', node)
        if value is not None and 'transferFormat' not in already_processed:
            already_processed.add('transferFormat')
            self.transferFormat = value
        super(InstantiateOvfParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AllEULAsAccepted':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AllEULAsAccepted')
            self.AllEULAsAccepted = ival_
        elif nodeName_ == 'NetworkMapping':
            obj_ = NetworkMappingType.factory()
            obj_.build(child_)
            self.NetworkMapping.append(obj_)
            obj_.original_tagname_ = 'NetworkMapping'
        elif nodeName_ == 'InstantiateOvfProperty':
            obj_ = InstantiateOvfPropertyType.factory()
            obj_.build(child_)
            self.InstantiateOvfProperty.append(obj_)
            obj_.original_tagname_ = 'InstantiateOvfProperty'
        elif nodeName_ == 'InstantiateVmParams':
            obj_ = InstantiateVmParamsType.factory()
            obj_.build(child_)
            self.InstantiateVmParams.append(obj_)
            obj_.original_tagname_ = 'InstantiateVmParams'
        super(InstantiateOvfParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class InstantiateOvfParamsType


class NetworkMappingType(GeneratedsSuper):
    """Represents a mapping from an OVF source network to a vCloud target
    network. Used to update network properties in the OVF. 5.5"""
    subclass = None
    superclass = None
    def __init__(self, Source=None, Target=None):
        self.original_tagname_ = None
        self.Source = Source
        self.Target = Target
    def factory(*args_, **kwargs_):
        if NetworkMappingType.subclass:
            return NetworkMappingType.subclass(*args_, **kwargs_)
        else:
            return NetworkMappingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_Target(self): return self.Target
    def set_Target(self, Target): self.Target = Target
    def hasContent_(self):
        if (
            self.Source is not None or
            self.Target is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkMappingType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkMappingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkMappingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkMappingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkMappingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSource>%s</%sSource>%s' % (namespace_, self.gds_format_string(quote_xml(self.Source).encode(ExternalEncoding), input_name='Source'), namespace_, eol_))
        if self.Target is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTarget>%s</%sTarget>%s' % (namespace_, self.gds_format_string(quote_xml(self.Target).encode(ExternalEncoding), input_name='Target'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NetworkMappingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=%s,\n' % quote_python(self.Source).encode(ExternalEncoding))
        if self.Target is not None:
            showIndent(outfile, level)
            outfile.write('Target=%s,\n' % quote_python(self.Target).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source = Source_
        elif nodeName_ == 'Target':
            Target_ = child_.text
            Target_ = self.gds_validate_string(Target_, node, 'Target')
            self.Target = Target_
# end class NetworkMappingType


class InstantiateOvfPropertyType(GeneratedsSuper):
    """Represents an OVF property value assignment. 5.5"""
    subclass = None
    superclass = None
    def __init__(self, ClassId=None, InstanceId=None, Key=None, Value=None):
        self.original_tagname_ = None
        self.ClassId = ClassId
        self.InstanceId = InstanceId
        self.Key = Key
        self.Value = Value
    def factory(*args_, **kwargs_):
        if InstantiateOvfPropertyType.subclass:
            return InstantiateOvfPropertyType.subclass(*args_, **kwargs_)
        else:
            return InstantiateOvfPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ClassId(self): return self.ClassId
    def set_ClassId(self, ClassId): self.ClassId = ClassId
    def get_InstanceId(self): return self.InstanceId
    def set_InstanceId(self, InstanceId): self.InstanceId = InstanceId
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.ClassId is not None or
            self.InstanceId is not None or
            self.Key is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstantiateOvfPropertyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateOvfPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstantiateOvfPropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstantiateOvfPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InstantiateOvfPropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClassId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClassId>%s</%sClassId>%s' % (namespace_, self.gds_format_string(quote_xml(self.ClassId).encode(ExternalEncoding), input_name='ClassId'), namespace_, eol_))
        if self.InstanceId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstanceId>%s</%sInstanceId>%s' % (namespace_, self.gds_format_string(quote_xml(self.InstanceId).encode(ExternalEncoding), input_name='InstanceId'), namespace_, eol_))
        if self.Key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKey>%s</%sKey>%s' % (namespace_, self.gds_format_string(quote_xml(self.Key).encode(ExternalEncoding), input_name='Key'), namespace_, eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='InstantiateOvfPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ClassId is not None:
            showIndent(outfile, level)
            outfile.write('ClassId=%s,\n' % quote_python(self.ClassId).encode(ExternalEncoding))
        if self.InstanceId is not None:
            showIndent(outfile, level)
            outfile.write('InstanceId=%s,\n' % quote_python(self.InstanceId).encode(ExternalEncoding))
        if self.Key is not None:
            showIndent(outfile, level)
            outfile.write('Key=%s,\n' % quote_python(self.Key).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClassId':
            ClassId_ = child_.text
            ClassId_ = self.gds_validate_string(ClassId_, node, 'ClassId')
            self.ClassId = ClassId_
        elif nodeName_ == 'InstanceId':
            InstanceId_ = child_.text
            InstanceId_ = self.gds_validate_string(InstanceId_, node, 'InstanceId')
            self.InstanceId = InstanceId_
        elif nodeName_ == 'Key':
            Key_ = child_.text
            Key_ = self.gds_validate_string(Key_, node, 'Key')
            self.Key = Key_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class InstantiateOvfPropertyType


class InstantiateVmParamsType(VCloudExtensibleType):
    """Instantiation parameters for a VM in a vApp. 5.5 always The ovf:id
    of the VirtualSystem in the source OVF that the instantiation
    parameters apply to. 5.5true"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, id=None, NetworkConnectionSection=None, ComputerName=None, VdcStorageProfile=None, HardwareCustomization=None):
        self.original_tagname_ = None
        super(InstantiateVmParamsType, self).__init__(VCloudExtension, )
        self.id = _cast(None, id)
        self.NetworkConnectionSection = NetworkConnectionSection
        self.ComputerName = ComputerName
        self.VdcStorageProfile = VdcStorageProfile
        self.HardwareCustomization = HardwareCustomization
    def factory(*args_, **kwargs_):
        if InstantiateVmParamsType.subclass:
            return InstantiateVmParamsType.subclass(*args_, **kwargs_)
        else:
            return InstantiateVmParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NetworkConnectionSection(self): return self.NetworkConnectionSection
    def set_NetworkConnectionSection(self, NetworkConnectionSection): self.NetworkConnectionSection = NetworkConnectionSection
    def get_ComputerName(self): return self.ComputerName
    def set_ComputerName(self, ComputerName): self.ComputerName = ComputerName
    def get_VdcStorageProfile(self): return self.VdcStorageProfile
    def set_VdcStorageProfile(self, VdcStorageProfile): self.VdcStorageProfile = VdcStorageProfile
    def get_HardwareCustomization(self): return self.HardwareCustomization
    def set_HardwareCustomization(self, HardwareCustomization): self.HardwareCustomization = HardwareCustomization
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.NetworkConnectionSection is not None or
            self.ComputerName is not None or
            self.VdcStorageProfile is not None or
            self.HardwareCustomization is not None or
            super(InstantiateVmParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstantiateVmParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVmParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstantiateVmParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstantiateVmParamsType'):
        super(InstantiateVmParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVmParamsType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InstantiateVmParamsType', fromsubclass_=False, pretty_print=True):
        super(InstantiateVmParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NetworkConnectionSection is not None:
            self.NetworkConnectionSection.export(outfile, level, namespace_, name_='NetworkConnectionSection', pretty_print=pretty_print)
        if self.ComputerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComputerName>%s</%sComputerName>%s' % (namespace_, self.gds_format_string(quote_xml(self.ComputerName).encode(ExternalEncoding), input_name='ComputerName'), namespace_, eol_))
        if self.VdcStorageProfile is not None:
            self.VdcStorageProfile.export(outfile, level, namespace_, name_='VdcStorageProfile', pretty_print=pretty_print)
        if self.HardwareCustomization is not None:
            self.HardwareCustomization.export(outfile, level, namespace_, name_='HardwareCustomization', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InstantiateVmParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        super(InstantiateVmParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstantiateVmParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.NetworkConnectionSection is not None:
            showIndent(outfile, level)
            outfile.write('NetworkConnectionSection=model_.NetworkConnectionSectionType(\n')
            self.NetworkConnectionSection.exportLiteral(outfile, level, name_='NetworkConnectionSection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ComputerName is not None:
            showIndent(outfile, level)
            outfile.write('ComputerName=%s,\n' % quote_python(self.ComputerName).encode(ExternalEncoding))
        if self.VdcStorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('VdcStorageProfile=model_.ReferenceType(\n')
            self.VdcStorageProfile.exportLiteral(outfile, level, name_='VdcStorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HardwareCustomization is not None:
            showIndent(outfile, level)
            outfile.write('HardwareCustomization=model_.InstantiateVmHardwareCustomizationParamsType(\n')
            self.HardwareCustomization.exportLiteral(outfile, level, name_='HardwareCustomization')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(InstantiateVmParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.NetworkConnectionSection = obj_
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'ComputerName':
            ComputerName_ = child_.text
            ComputerName_ = self.gds_validate_string(ComputerName_, node, 'ComputerName')
            self.ComputerName = ComputerName_
        elif nodeName_ == 'VdcStorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VdcStorageProfile = obj_
            obj_.original_tagname_ = 'VdcStorageProfile'
        elif nodeName_ == 'HardwareCustomization':
            obj_ = InstantiateVmHardwareCustomizationParamsType.factory()
            obj_.build(child_)
            self.HardwareCustomization = obj_
            obj_.original_tagname_ = 'HardwareCustomization'
        super(InstantiateVmParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class InstantiateVmParamsType


class InstantiateVmHardwareCustomizationParamsType(VCloudExtensibleType):
    """Hardware parameter customization applied to a virtual machine in a
    vApp when instantiated. 5.5"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, NumberOfCpus=None, CoresPerSocket=None, MemorySize=None, Disk=None):
        self.original_tagname_ = None
        super(InstantiateVmHardwareCustomizationParamsType, self).__init__(VCloudExtension, )
        self.NumberOfCpus = NumberOfCpus
        self.CoresPerSocket = CoresPerSocket
        self.MemorySize = MemorySize
        if Disk is None:
            self.Disk = []
        else:
            self.Disk = Disk
    def factory(*args_, **kwargs_):
        if InstantiateVmHardwareCustomizationParamsType.subclass:
            return InstantiateVmHardwareCustomizationParamsType.subclass(*args_, **kwargs_)
        else:
            return InstantiateVmHardwareCustomizationParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumberOfCpus(self): return self.NumberOfCpus
    def set_NumberOfCpus(self, NumberOfCpus): self.NumberOfCpus = NumberOfCpus
    def get_CoresPerSocket(self): return self.CoresPerSocket
    def set_CoresPerSocket(self, CoresPerSocket): self.CoresPerSocket = CoresPerSocket
    def get_MemorySize(self): return self.MemorySize
    def set_MemorySize(self, MemorySize): self.MemorySize = MemorySize
    def get_Disk(self): return self.Disk
    def set_Disk(self, Disk): self.Disk = Disk
    def add_Disk(self, value): self.Disk.append(value)
    def insert_Disk_at(self, index, value): self.Disk.insert(index, value)
    def replace_Disk_at(self, index, value): self.Disk[index] = value
    def hasContent_(self):
        if (
            self.NumberOfCpus is not None or
            self.CoresPerSocket is not None or
            self.MemorySize is not None or
            self.Disk or
            super(InstantiateVmHardwareCustomizationParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstantiateVmHardwareCustomizationParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVmHardwareCustomizationParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstantiateVmHardwareCustomizationParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstantiateVmHardwareCustomizationParamsType'):
        super(InstantiateVmHardwareCustomizationParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVmHardwareCustomizationParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='InstantiateVmHardwareCustomizationParamsType', fromsubclass_=False, pretty_print=True):
        super(InstantiateVmHardwareCustomizationParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumberOfCpus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberOfCpus>%s</%sNumberOfCpus>%s' % (namespace_, self.gds_format_integer(self.NumberOfCpus, input_name='NumberOfCpus'), namespace_, eol_))
        if self.CoresPerSocket is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCoresPerSocket>%s</%sCoresPerSocket>%s' % (namespace_, self.gds_format_integer(self.CoresPerSocket, input_name='CoresPerSocket'), namespace_, eol_))
        if self.MemorySize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMemorySize>%s</%sMemorySize>%s' % (namespace_, self.gds_format_integer(self.MemorySize, input_name='MemorySize'), namespace_, eol_))
        for Disk_ in self.Disk:
            Disk_.export(outfile, level, namespace_, name_='Disk', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InstantiateVmHardwareCustomizationParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(InstantiateVmHardwareCustomizationParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstantiateVmHardwareCustomizationParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.NumberOfCpus is not None:
            showIndent(outfile, level)
            outfile.write('NumberOfCpus=%d,\n' % self.NumberOfCpus)
        if self.CoresPerSocket is not None:
            showIndent(outfile, level)
            outfile.write('CoresPerSocket=%d,\n' % self.CoresPerSocket)
        if self.MemorySize is not None:
            showIndent(outfile, level)
            outfile.write('MemorySize=%d,\n' % self.MemorySize)
        showIndent(outfile, level)
        outfile.write('Disk=[\n')
        level += 1
        for Disk_ in self.Disk:
            showIndent(outfile, level)
            outfile.write('model_.DiskType4(\n')
            Disk_.exportLiteral(outfile, level, name_='DiskType4')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InstantiateVmHardwareCustomizationParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumberOfCpus':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfCpus')
            self.NumberOfCpus = ival_
        elif nodeName_ == 'CoresPerSocket':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CoresPerSocket')
            self.CoresPerSocket = ival_
        elif nodeName_ == 'MemorySize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MemorySize')
            self.MemorySize = ival_
        elif nodeName_ == 'Disk':
            obj_ = DiskType4.factory()
            obj_.build(child_)
            self.Disk.append(obj_)
            obj_.original_tagname_ = 'Disk'
        super(InstantiateVmHardwareCustomizationParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class InstantiateVmHardwareCustomizationParamsType


class CloneVAppParamsType(InstantiateVAppParamsType):
    """0.9 Parameters for a clonevApp request."""
    subclass = None
    superclass = InstantiateVAppParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, powerOn=None, deploy=None, VAppParent=None, InstantiationParams=None, linkedClone=None, Source=None, IsSourceDelete=None, SourcedVmInstantiationParams=None, SourcedItem=None):
        self.original_tagname_ = None
        super(CloneVAppParamsType, self).__init__(VCloudExtension, name, Description, powerOn, deploy, VAppParent, InstantiationParams, linkedClone, Source, IsSourceDelete, SourcedVmInstantiationParams, SourcedItem, )
    def factory(*args_, **kwargs_):
        if CloneVAppParamsType.subclass:
            return CloneVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return CloneVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(CloneVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CloneVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CloneVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CloneVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CloneVAppParamsType'):
        super(CloneVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CloneVAppParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='CloneVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(CloneVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CloneVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CloneVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CloneVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CloneVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CloneVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CloneVAppParamsType


class DeployVAppParamsType(VCloudExtensibleType):
    """0.9 Parameters to a deploy vApp request. always Used to specify
    whether to power on vapp on deployment, if not set default value
    is true. falsealways Lease in seconds for deployment. A value of
    0 is replaced by the organization default deploymentLeaseSeconds
    value. false Used to specify whether to force customization on
    deployment, if not set default value is false. false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, forceCustomization=None, powerOn=None, deploymentLeaseSeconds=None):
        self.original_tagname_ = None
        super(DeployVAppParamsType, self).__init__(VCloudExtension, )
        self.forceCustomization = _cast(bool, forceCustomization)
        self.powerOn = _cast(bool, powerOn)
        self.deploymentLeaseSeconds = _cast(int, deploymentLeaseSeconds)
    def factory(*args_, **kwargs_):
        if DeployVAppParamsType.subclass:
            return DeployVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return DeployVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_forceCustomization(self): return self.forceCustomization
    def set_forceCustomization(self, forceCustomization): self.forceCustomization = forceCustomization
    def get_powerOn(self): return self.powerOn
    def set_powerOn(self, powerOn): self.powerOn = powerOn
    def get_deploymentLeaseSeconds(self): return self.deploymentLeaseSeconds
    def set_deploymentLeaseSeconds(self, deploymentLeaseSeconds): self.deploymentLeaseSeconds = deploymentLeaseSeconds
    def hasContent_(self):
        if (
            super(DeployVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeployVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeployVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeployVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeployVAppParamsType'):
        super(DeployVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeployVAppParamsType')
        if self.forceCustomization is not None and 'forceCustomization' not in already_processed:
            already_processed.add('forceCustomization')
            outfile.write(' forceCustomization="%s"' % self.gds_format_boolean(self.forceCustomization, input_name='forceCustomization'))
        if self.powerOn is not None and 'powerOn' not in already_processed:
            already_processed.add('powerOn')
            outfile.write(' powerOn="%s"' % self.gds_format_boolean(self.powerOn, input_name='powerOn'))
        if self.deploymentLeaseSeconds is not None and 'deploymentLeaseSeconds' not in already_processed:
            already_processed.add('deploymentLeaseSeconds')
            outfile.write(' deploymentLeaseSeconds="%s"' % self.gds_format_integer(self.deploymentLeaseSeconds, input_name='deploymentLeaseSeconds'))
    def exportChildren(self, outfile, level, namespace_='', name_='DeployVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(DeployVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DeployVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.forceCustomization is not None and 'forceCustomization' not in already_processed:
            already_processed.add('forceCustomization')
            showIndent(outfile, level)
            outfile.write('forceCustomization=%s,\n' % (self.forceCustomization,))
        if self.powerOn is not None and 'powerOn' not in already_processed:
            already_processed.add('powerOn')
            showIndent(outfile, level)
            outfile.write('powerOn=%s,\n' % (self.powerOn,))
        if self.deploymentLeaseSeconds is not None and 'deploymentLeaseSeconds' not in already_processed:
            already_processed.add('deploymentLeaseSeconds')
            showIndent(outfile, level)
            outfile.write('deploymentLeaseSeconds=%d,\n' % (self.deploymentLeaseSeconds,))
        super(DeployVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DeployVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('forceCustomization', node)
        if value is not None and 'forceCustomization' not in already_processed:
            already_processed.add('forceCustomization')
            if value in ('true', '1'):
                self.forceCustomization = True
            elif value in ('false', '0'):
                self.forceCustomization = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('powerOn', node)
        if value is not None and 'powerOn' not in already_processed:
            already_processed.add('powerOn')
            if value in ('true', '1'):
                self.powerOn = True
            elif value in ('false', '0'):
                self.powerOn = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('deploymentLeaseSeconds', node)
        if value is not None and 'deploymentLeaseSeconds' not in already_processed:
            already_processed.add('deploymentLeaseSeconds')
            try:
                self.deploymentLeaseSeconds = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(DeployVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DeployVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DeployVAppParamsType


class UndeployVAppParamsType(VCloudExtensibleType):
    """0.9 Parameters to an undeploy vApp request."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, UndeployPowerAction=None):
        self.original_tagname_ = None
        super(UndeployVAppParamsType, self).__init__(VCloudExtension, )
        self.UndeployPowerAction = UndeployPowerAction
    def factory(*args_, **kwargs_):
        if UndeployVAppParamsType.subclass:
            return UndeployVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return UndeployVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UndeployPowerAction(self): return self.UndeployPowerAction
    def set_UndeployPowerAction(self, UndeployPowerAction): self.UndeployPowerAction = UndeployPowerAction
    def hasContent_(self):
        if (
            self.UndeployPowerAction is not None or
            super(UndeployVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UndeployVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UndeployVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UndeployVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UndeployVAppParamsType'):
        super(UndeployVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UndeployVAppParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='UndeployVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(UndeployVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UndeployPowerAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUndeployPowerAction>%s</%sUndeployPowerAction>%s' % (namespace_, self.gds_format_string(quote_xml(self.UndeployPowerAction).encode(ExternalEncoding), input_name='UndeployPowerAction'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='UndeployVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(UndeployVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UndeployVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.UndeployPowerAction is not None:
            showIndent(outfile, level)
            outfile.write('UndeployPowerAction=%s,\n' % quote_python(self.UndeployPowerAction).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UndeployVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UndeployPowerAction':
            UndeployPowerAction_ = child_.text
            UndeployPowerAction_ = self.gds_validate_string(UndeployPowerAction_, node, 'UndeployPowerAction')
            self.UndeployPowerAction = UndeployPowerAction_
        super(UndeployVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class UndeployVAppParamsType


class MediaInsertOrEjectParamsType(VCloudExtensibleType):
    """0.9 Parameters for an insertMedia or ejectMedia request."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Media=None):
        self.original_tagname_ = None
        super(MediaInsertOrEjectParamsType, self).__init__(VCloudExtension, )
        self.Media = Media
    def factory(*args_, **kwargs_):
        if MediaInsertOrEjectParamsType.subclass:
            return MediaInsertOrEjectParamsType.subclass(*args_, **kwargs_)
        else:
            return MediaInsertOrEjectParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Media(self): return self.Media
    def set_Media(self, Media): self.Media = Media
    def hasContent_(self):
        if (
            self.Media is not None or
            super(MediaInsertOrEjectParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MediaInsertOrEjectParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MediaInsertOrEjectParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MediaInsertOrEjectParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MediaInsertOrEjectParamsType'):
        super(MediaInsertOrEjectParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MediaInsertOrEjectParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='MediaInsertOrEjectParamsType', fromsubclass_=False, pretty_print=True):
        super(MediaInsertOrEjectParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Media is not None:
            self.Media.export(outfile, level, namespace_, name_='Media', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MediaInsertOrEjectParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MediaInsertOrEjectParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MediaInsertOrEjectParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Media is not None:
            showIndent(outfile, level)
            outfile.write('Media=model_.ReferenceType(\n')
            self.Media.exportLiteral(outfile, level, name_='Media')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MediaInsertOrEjectParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Media':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Media = obj_
            obj_.original_tagname_ = 'Media'
        super(MediaInsertOrEjectParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class MediaInsertOrEjectParamsType


class CaptureVAppParamsType(ParamsType):
    """0.9 Parameters for a captureVapp request."""
    subclass = None
    superclass = ParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, Source=None, Section=None, VdcStorageProfile=None, TargetCatalogItem=None):
        self.original_tagname_ = None
        super(CaptureVAppParamsType, self).__init__(VCloudExtension, name, Description, )
        self.Source = Source
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
        self.VdcStorageProfile = VdcStorageProfile
        self.TargetCatalogItem = TargetCatalogItem
    def factory(*args_, **kwargs_):
        if CaptureVAppParamsType.subclass:
            return CaptureVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return CaptureVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def get_VdcStorageProfile(self): return self.VdcStorageProfile
    def set_VdcStorageProfile(self, VdcStorageProfile): self.VdcStorageProfile = VdcStorageProfile
    def get_TargetCatalogItem(self): return self.TargetCatalogItem
    def set_TargetCatalogItem(self, TargetCatalogItem): self.TargetCatalogItem = TargetCatalogItem
    def hasContent_(self):
        if (
            self.Source is not None or
            self.Section or
            self.VdcStorageProfile is not None or
            self.TargetCatalogItem is not None or
            super(CaptureVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CaptureVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CaptureVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CaptureVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CaptureVAppParamsType'):
        super(CaptureVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CaptureVAppParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='CaptureVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(CaptureVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Source is not None:
            self.Source.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovf:', name_='Section', pretty_print=pretty_print)
        if self.VdcStorageProfile is not None:
            self.VdcStorageProfile.export(outfile, level, namespace_, name_='VdcStorageProfile', pretty_print=pretty_print)
        if self.TargetCatalogItem is not None:
            self.TargetCatalogItem.export(outfile, level, namespace_, name_='TargetCatalogItem', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CaptureVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CaptureVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CaptureVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.ReferenceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.VdcStorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('VdcStorageProfile=model_.ReferenceType(\n')
            self.VdcStorageProfile.exportLiteral(outfile, level, name_='VdcStorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TargetCatalogItem is not None:
            showIndent(outfile, level)
            outfile.write('TargetCatalogItem=model_.ReferenceType(\n')
            self.TargetCatalogItem.exportLiteral(outfile, level, name_='TargetCatalogItem')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CaptureVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Source = obj_
            obj_.original_tagname_ = 'Source'
        elif nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
        elif nodeName_ == 'VdcStorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VdcStorageProfile = obj_
            obj_.original_tagname_ = 'VdcStorageProfile'
        elif nodeName_ == 'TargetCatalogItem':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.TargetCatalogItem = obj_
            obj_.original_tagname_ = 'TargetCatalogItem'
        super(CaptureVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class CaptureVAppParamsType


class VmPendingQuestionType(ResourceType):
    """0.9 Represents a question posted by a virtual machine that is
    WAITING_FOR_INPUT (status="5")."""
    subclass = None
    superclass = ResourceType
    def __init__(self, Question=None, QuestionId=None, Choices=None):
        self.original_tagname_ = None
        super(VmPendingQuestionType, self).__init__()
        self.Question = Question
        self.QuestionId = QuestionId
        if Choices is None:
            self.Choices = []
        else:
            self.Choices = Choices
    def factory(*args_, **kwargs_):
        if VmPendingQuestionType.subclass:
            return VmPendingQuestionType.subclass(*args_, **kwargs_)
        else:
            return VmPendingQuestionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Question(self): return self.Question
    def set_Question(self, Question): self.Question = Question
    def get_QuestionId(self): return self.QuestionId
    def set_QuestionId(self, QuestionId): self.QuestionId = QuestionId
    def get_Choices(self): return self.Choices
    def set_Choices(self, Choices): self.Choices = Choices
    def add_Choices(self, value): self.Choices.append(value)
    def insert_Choices_at(self, index, value): self.Choices.insert(index, value)
    def replace_Choices_at(self, index, value): self.Choices[index] = value
    def hasContent_(self):
        if (
            self.Question is not None or
            self.QuestionId is not None or
            self.Choices or
            super(VmPendingQuestionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmPendingQuestionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmPendingQuestionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmPendingQuestionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmPendingQuestionType'):
        super(VmPendingQuestionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmPendingQuestionType')
    def exportChildren(self, outfile, level, namespace_='', name_='VmPendingQuestionType', fromsubclass_=False, pretty_print=True):
        super(VmPendingQuestionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Question is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQuestion>%s</%sQuestion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Question).encode(ExternalEncoding), input_name='Question'), namespace_, eol_))
        if self.QuestionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQuestionId>%s</%sQuestionId>%s' % (namespace_, self.gds_format_string(quote_xml(self.QuestionId).encode(ExternalEncoding), input_name='QuestionId'), namespace_, eol_))
        for Choices_ in self.Choices:
            Choices_.export(outfile, level, namespace_, name_='Choices', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VmPendingQuestionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmPendingQuestionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmPendingQuestionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Question is not None:
            showIndent(outfile, level)
            outfile.write('Question=%s,\n' % quote_python(self.Question).encode(ExternalEncoding))
        if self.QuestionId is not None:
            showIndent(outfile, level)
            outfile.write('QuestionId=%s,\n' % quote_python(self.QuestionId).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Choices=[\n')
        level += 1
        for Choices_ in self.Choices:
            showIndent(outfile, level)
            outfile.write('model_.VmQuestionAnswerChoiceType(\n')
            Choices_.exportLiteral(outfile, level, name_='VmQuestionAnswerChoiceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VmPendingQuestionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Question':
            Question_ = child_.text
            Question_ = self.gds_validate_string(Question_, node, 'Question')
            self.Question = Question_
        elif nodeName_ == 'QuestionId':
            QuestionId_ = child_.text
            QuestionId_ = self.gds_validate_string(QuestionId_, node, 'QuestionId')
            self.QuestionId = QuestionId_
        elif nodeName_ == 'Choices':
            obj_ = VmQuestionAnswerChoiceType.factory()
            obj_.build(child_)
            self.Choices.append(obj_)
            obj_.original_tagname_ = 'Choices'
        super(VmPendingQuestionType, self).buildChildren(child_, node, nodeName_, True)
# end class VmPendingQuestionType


class VmQuestionAnswerType(GeneratedsSuper):
    """0.9 Represents the answer to a question posted by a virtual machine
    that is WAITING_FOR_INPUT (status="5")."""
    subclass = None
    superclass = None
    def __init__(self, ChoiceId=None, QuestionId=None):
        self.original_tagname_ = None
        self.ChoiceId = ChoiceId
        self.QuestionId = QuestionId
    def factory(*args_, **kwargs_):
        if VmQuestionAnswerType.subclass:
            return VmQuestionAnswerType.subclass(*args_, **kwargs_)
        else:
            return VmQuestionAnswerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChoiceId(self): return self.ChoiceId
    def set_ChoiceId(self, ChoiceId): self.ChoiceId = ChoiceId
    def get_QuestionId(self): return self.QuestionId
    def set_QuestionId(self, QuestionId): self.QuestionId = QuestionId
    def hasContent_(self):
        if (
            self.ChoiceId is not None or
            self.QuestionId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmQuestionAnswerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmQuestionAnswerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmQuestionAnswerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmQuestionAnswerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VmQuestionAnswerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ChoiceId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChoiceId>%s</%sChoiceId>%s' % (namespace_, self.gds_format_integer(self.ChoiceId, input_name='ChoiceId'), namespace_, eol_))
        if self.QuestionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQuestionId>%s</%sQuestionId>%s' % (namespace_, self.gds_format_string(quote_xml(self.QuestionId).encode(ExternalEncoding), input_name='QuestionId'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VmQuestionAnswerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ChoiceId is not None:
            showIndent(outfile, level)
            outfile.write('ChoiceId=%d,\n' % self.ChoiceId)
        if self.QuestionId is not None:
            showIndent(outfile, level)
            outfile.write('QuestionId=%s,\n' % quote_python(self.QuestionId).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChoiceId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ChoiceId')
            self.ChoiceId = ival_
        elif nodeName_ == 'QuestionId':
            QuestionId_ = child_.text
            QuestionId_ = self.gds_validate_string(QuestionId_, node, 'QuestionId')
            self.QuestionId = QuestionId_
# end class VmQuestionAnswerType


class VmQuestionAnswerChoiceType(GeneratedsSuper):
    """0.9 Represents the answer to a question posted by a virtual machine
    that is WAITING_FOR_INPUT (status="5")."""
    subclass = None
    superclass = None
    def __init__(self, Id=None, Text=None):
        self.original_tagname_ = None
        self.Id = Id
        self.Text = Text
    def factory(*args_, **kwargs_):
        if VmQuestionAnswerChoiceType.subclass:
            return VmQuestionAnswerChoiceType.subclass(*args_, **kwargs_)
        else:
            return VmQuestionAnswerChoiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Text is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmQuestionAnswerChoiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmQuestionAnswerChoiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmQuestionAnswerChoiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmQuestionAnswerChoiceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VmQuestionAnswerChoiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_integer(self.Id, input_name='Id'), namespace_, eol_))
        if self.Text is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sText>%s</%sText>%s' % (namespace_, self.gds_format_string(quote_xml(self.Text).encode(ExternalEncoding), input_name='Text'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VmQuestionAnswerChoiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%d,\n' % self.Id)
        if self.Text is not None:
            showIndent(outfile, level)
            outfile.write('Text=%s,\n' % quote_python(self.Text).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Id')
            self.Id = ival_
        elif nodeName_ == 'Text':
            Text_ = child_.text
            Text_ = self.gds_validate_string(Text_, node, 'Text')
            self.Text = Text_
# end class VmQuestionAnswerChoiceType


class RelocateParamsType(GeneratedsSuper):
    """5.11.5 Parameters to be used for virtual machine relocation."""
    subclass = None
    superclass = None
    def __init__(self, Datastore=None):
        self.original_tagname_ = None
        self.Datastore = Datastore
    def factory(*args_, **kwargs_):
        if RelocateParamsType.subclass:
            return RelocateParamsType.subclass(*args_, **kwargs_)
        else:
            return RelocateParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Datastore(self): return self.Datastore
    def set_Datastore(self, Datastore): self.Datastore = Datastore
    def hasContent_(self):
        if (
            self.Datastore is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelocateParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelocateParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelocateParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelocateParamsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelocateParamsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Datastore is not None:
            self.Datastore.export(outfile, level, namespace_, name_='Datastore', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RelocateParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Datastore is not None:
            showIndent(outfile, level)
            outfile.write('Datastore=model_.ReferenceType(\n')
            self.Datastore.exportLiteral(outfile, level, name_='Datastore')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Datastore':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Datastore = obj_
            obj_.original_tagname_ = 'Datastore'
# end class RelocateParamsType


class CreateSnapshotParamsType(ParamsType):
    """5.1 Parameters for a createSnapshot request. always True if the
    snapshot should include the virtual machine's memory.
    falsealways True if the file system of the virtual machine
    should be quiesced before the snapshot is created. false"""
    subclass = None
    superclass = ParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, quiesce=None, memory=None):
        self.original_tagname_ = None
        super(CreateSnapshotParamsType, self).__init__(VCloudExtension, name, Description, )
        self.quiesce = _cast(bool, quiesce)
        self.memory = _cast(bool, memory)
    def factory(*args_, **kwargs_):
        if CreateSnapshotParamsType.subclass:
            return CreateSnapshotParamsType.subclass(*args_, **kwargs_)
        else:
            return CreateSnapshotParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quiesce(self): return self.quiesce
    def set_quiesce(self, quiesce): self.quiesce = quiesce
    def get_memory(self): return self.memory
    def set_memory(self, memory): self.memory = memory
    def hasContent_(self):
        if (
            super(CreateSnapshotParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreateSnapshotParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreateSnapshotParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreateSnapshotParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreateSnapshotParamsType'):
        super(CreateSnapshotParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CreateSnapshotParamsType')
        if self.quiesce is not None and 'quiesce' not in already_processed:
            already_processed.add('quiesce')
            outfile.write(' quiesce="%s"' % self.gds_format_boolean(self.quiesce, input_name='quiesce'))
        if self.memory is not None and 'memory' not in already_processed:
            already_processed.add('memory')
            outfile.write(' memory="%s"' % self.gds_format_boolean(self.memory, input_name='memory'))
    def exportChildren(self, outfile, level, namespace_='', name_='CreateSnapshotParamsType', fromsubclass_=False, pretty_print=True):
        super(CreateSnapshotParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CreateSnapshotParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.quiesce is not None and 'quiesce' not in already_processed:
            already_processed.add('quiesce')
            showIndent(outfile, level)
            outfile.write('quiesce=%s,\n' % (self.quiesce,))
        if self.memory is not None and 'memory' not in already_processed:
            already_processed.add('memory')
            showIndent(outfile, level)
            outfile.write('memory=%s,\n' % (self.memory,))
        super(CreateSnapshotParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CreateSnapshotParamsType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quiesce', node)
        if value is not None and 'quiesce' not in already_processed:
            already_processed.add('quiesce')
            if value in ('true', '1'):
                self.quiesce = True
            elif value in ('false', '0'):
                self.quiesce = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('memory', node)
        if value is not None and 'memory' not in already_processed:
            already_processed.add('memory')
            if value in ('true', '1'):
                self.memory = True
            elif value in ('false', '0'):
                self.memory = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(CreateSnapshotParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CreateSnapshotParamsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CreateSnapshotParamsType


class ComplianceResultType(VCloudExtensibleType):
    """5.1 Represents the results of a compliance check."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, ComplianceStatus=None, ComplianceStatusMessage=None, ComplianceCheckTime=None):
        self.original_tagname_ = None
        super(ComplianceResultType, self).__init__(VCloudExtension, )
        self.ComplianceStatus = ComplianceStatus
        self.ComplianceStatusMessage = ComplianceStatusMessage
        if isinstance(ComplianceCheckTime, basestring):
            initvalue_ = datetime_.datetime.strptime(ComplianceCheckTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = ComplianceCheckTime
        self.ComplianceCheckTime = initvalue_
    def factory(*args_, **kwargs_):
        if ComplianceResultType.subclass:
            return ComplianceResultType.subclass(*args_, **kwargs_)
        else:
            return ComplianceResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ComplianceStatus(self): return self.ComplianceStatus
    def set_ComplianceStatus(self, ComplianceStatus): self.ComplianceStatus = ComplianceStatus
    def get_ComplianceStatusMessage(self): return self.ComplianceStatusMessage
    def set_ComplianceStatusMessage(self, ComplianceStatusMessage): self.ComplianceStatusMessage = ComplianceStatusMessage
    def get_ComplianceCheckTime(self): return self.ComplianceCheckTime
    def set_ComplianceCheckTime(self, ComplianceCheckTime): self.ComplianceCheckTime = ComplianceCheckTime
    def hasContent_(self):
        if (
            self.ComplianceStatus is not None or
            self.ComplianceStatusMessage is not None or
            self.ComplianceCheckTime is not None or
            super(ComplianceResultType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ComplianceResultType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComplianceResultType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ComplianceResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ComplianceResultType'):
        super(ComplianceResultType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ComplianceResultType')
    def exportChildren(self, outfile, level, namespace_='', name_='ComplianceResultType', fromsubclass_=False, pretty_print=True):
        super(ComplianceResultType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ComplianceStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComplianceStatus>%s</%sComplianceStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.ComplianceStatus).encode(ExternalEncoding), input_name='ComplianceStatus'), namespace_, eol_))
        if self.ComplianceStatusMessage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComplianceStatusMessage>%s</%sComplianceStatusMessage>%s' % (namespace_, self.gds_format_string(quote_xml(self.ComplianceStatusMessage).encode(ExternalEncoding), input_name='ComplianceStatusMessage'), namespace_, eol_))
        if self.ComplianceCheckTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComplianceCheckTime>%s</%sComplianceCheckTime>%s' % (namespace_, self.gds_format_datetime(self.ComplianceCheckTime, input_name='ComplianceCheckTime'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ComplianceResultType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ComplianceResultType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ComplianceResultType, self).exportLiteralChildren(outfile, level, name_)
        if self.ComplianceStatus is not None:
            showIndent(outfile, level)
            outfile.write('ComplianceStatus=%s,\n' % quote_python(self.ComplianceStatus).encode(ExternalEncoding))
        if self.ComplianceStatusMessage is not None:
            showIndent(outfile, level)
            outfile.write('ComplianceStatusMessage=%s,\n' % quote_python(self.ComplianceStatusMessage).encode(ExternalEncoding))
        if self.ComplianceCheckTime is not None:
            showIndent(outfile, level)
            outfile.write('ComplianceCheckTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.ComplianceCheckTime, input_name='ComplianceCheckTime'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ComplianceResultType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ComplianceStatus':
            ComplianceStatus_ = child_.text
            ComplianceStatus_ = self.gds_validate_string(ComplianceStatus_, node, 'ComplianceStatus')
            self.ComplianceStatus = ComplianceStatus_
        elif nodeName_ == 'ComplianceStatusMessage':
            ComplianceStatusMessage_ = child_.text
            ComplianceStatusMessage_ = self.gds_validate_string(ComplianceStatusMessage_, node, 'ComplianceStatusMessage')
            self.ComplianceStatusMessage = ComplianceStatusMessage_
        elif nodeName_ == 'ComplianceCheckTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.ComplianceCheckTime = dval_
        super(ComplianceResultType, self).buildChildren(child_, node, nodeName_, True)
# end class ComplianceResultType


class ResourceEntitiesType(VCloudExtensibleType):
    """0.9 Container for references to ResourceEntity objects in this vDC."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, ResourceEntity=None):
        self.original_tagname_ = None
        super(ResourceEntitiesType, self).__init__(VCloudExtension, )
        if ResourceEntity is None:
            self.ResourceEntity = []
        else:
            self.ResourceEntity = ResourceEntity
    def factory(*args_, **kwargs_):
        if ResourceEntitiesType.subclass:
            return ResourceEntitiesType.subclass(*args_, **kwargs_)
        else:
            return ResourceEntitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ResourceEntity(self): return self.ResourceEntity
    def set_ResourceEntity(self, ResourceEntity): self.ResourceEntity = ResourceEntity
    def add_ResourceEntity(self, value): self.ResourceEntity.append(value)
    def insert_ResourceEntity_at(self, index, value): self.ResourceEntity.insert(index, value)
    def replace_ResourceEntity_at(self, index, value): self.ResourceEntity[index] = value
    def hasContent_(self):
        if (
            self.ResourceEntity or
            super(ResourceEntitiesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceEntitiesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceEntitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceEntitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceEntitiesType'):
        super(ResourceEntitiesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceEntitiesType')
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceEntitiesType', fromsubclass_=False, pretty_print=True):
        super(ResourceEntitiesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResourceEntity_ in self.ResourceEntity:
            ResourceEntity_.export(outfile, level, namespace_, name_='ResourceEntity', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResourceEntitiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ResourceEntitiesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResourceEntitiesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('ResourceEntity=[\n')
        level += 1
        for ResourceEntity_ in self.ResourceEntity:
            showIndent(outfile, level)
            outfile.write('model_.ResourceReferenceType(\n')
            ResourceEntity_.exportLiteral(outfile, level, name_='ResourceReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResourceEntitiesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResourceEntity':
            obj_ = ResourceReferenceType.factory()
            obj_.build(child_)
            self.ResourceEntity.append(obj_)
            obj_.original_tagname_ = 'ResourceEntity'
        super(ResourceEntitiesType, self).buildChildren(child_, node, nodeName_, True)
# end class ResourceEntitiesType


class AvailableNetworksType(VCloudExtensibleType):
    """0.9 Container for references to available organization vDC networks."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Network=None):
        self.original_tagname_ = None
        super(AvailableNetworksType, self).__init__(VCloudExtension, )
        if Network is None:
            self.Network = []
        else:
            self.Network = Network
    def factory(*args_, **kwargs_):
        if AvailableNetworksType.subclass:
            return AvailableNetworksType.subclass(*args_, **kwargs_)
        else:
            return AvailableNetworksType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Network(self): return self.Network
    def set_Network(self, Network): self.Network = Network
    def add_Network(self, value): self.Network.append(value)
    def insert_Network_at(self, index, value): self.Network.insert(index, value)
    def replace_Network_at(self, index, value): self.Network[index] = value
    def hasContent_(self):
        if (
            self.Network or
            super(AvailableNetworksType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AvailableNetworksType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AvailableNetworksType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AvailableNetworksType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AvailableNetworksType'):
        super(AvailableNetworksType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AvailableNetworksType')
    def exportChildren(self, outfile, level, namespace_='', name_='AvailableNetworksType', fromsubclass_=False, pretty_print=True):
        super(AvailableNetworksType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Network_ in self.Network:
            Network_.export(outfile, level, namespace_, name_='Network', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AvailableNetworksType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AvailableNetworksType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AvailableNetworksType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Network=[\n')
        level += 1
        for Network_ in self.Network:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            Network_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AvailableNetworksType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Network':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Network.append(obj_)
            obj_.original_tagname_ = 'Network'
        super(AvailableNetworksType, self).buildChildren(child_, node, nodeName_, True)
# end class AvailableNetworksType


class VdcsType(VCloudExtensibleType):
    """0.9 Represents a list of references to vDCs."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Vdc=None):
        self.original_tagname_ = None
        super(VdcsType, self).__init__(VCloudExtension, )
        if Vdc is None:
            self.Vdc = []
        else:
            self.Vdc = Vdc
    def factory(*args_, **kwargs_):
        if VdcsType.subclass:
            return VdcsType.subclass(*args_, **kwargs_)
        else:
            return VdcsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Vdc(self): return self.Vdc
    def set_Vdc(self, Vdc): self.Vdc = Vdc
    def add_Vdc(self, value): self.Vdc.append(value)
    def insert_Vdc_at(self, index, value): self.Vdc.insert(index, value)
    def replace_Vdc_at(self, index, value): self.Vdc[index] = value
    def hasContent_(self):
        if (
            self.Vdc or
            super(VdcsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VdcsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VdcsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VdcsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VdcsType'):
        super(VdcsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VdcsType')
    def exportChildren(self, outfile, level, namespace_='', name_='VdcsType', fromsubclass_=False, pretty_print=True):
        super(VdcsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Vdc_ in self.Vdc:
            Vdc_.export(outfile, level, namespace_, name_='Vdc', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VdcsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VdcsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VdcsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Vdc=[\n')
        level += 1
        for Vdc_ in self.Vdc:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            Vdc_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VdcsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Vdc':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Vdc.append(obj_)
            obj_.original_tagname_ = 'Vdc'
        super(VdcsType, self).buildChildren(child_, node, nodeName_, True)
# end class VdcsType


class VdcType(EntityType):
    """0.9 Represents the user view of an organization vDC. none Creation
    status of the vDC. One of:<br> 0 (The vDC is still being
    created)<br> 1 (The vDC is ready)<br> -1 (There was an error
    while creating the vDC). false"""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, AllocationModel=None, StorageCapacity=None, ComputeCapacity=None, ResourceEntities=None, AvailableNetworks=None, Capabilities=None, NicQuota=None, NetworkQuota=None, UsedNetworkCount=None, VmQuota=None, IsEnabled=None, VdcStorageProfiles=None):
        self.original_tagname_ = None
        super(VdcType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.status = _cast(int, status)
        self.AllocationModel = AllocationModel
        self.StorageCapacity = StorageCapacity
        self.ComputeCapacity = ComputeCapacity
        self.ResourceEntities = ResourceEntities
        self.AvailableNetworks = AvailableNetworks
        self.Capabilities = Capabilities
        self.NicQuota = NicQuota
        self.NetworkQuota = NetworkQuota
        self.UsedNetworkCount = UsedNetworkCount
        self.VmQuota = VmQuota
        self.IsEnabled = IsEnabled
        self.VdcStorageProfiles = VdcStorageProfiles
    def factory(*args_, **kwargs_):
        if VdcType.subclass:
            return VdcType.subclass(*args_, **kwargs_)
        else:
            return VdcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AllocationModel(self): return self.AllocationModel
    def set_AllocationModel(self, AllocationModel): self.AllocationModel = AllocationModel
    def get_StorageCapacity(self): return self.StorageCapacity
    def set_StorageCapacity(self, StorageCapacity): self.StorageCapacity = StorageCapacity
    def get_ComputeCapacity(self): return self.ComputeCapacity
    def set_ComputeCapacity(self, ComputeCapacity): self.ComputeCapacity = ComputeCapacity
    def get_ResourceEntities(self): return self.ResourceEntities
    def set_ResourceEntities(self, ResourceEntities): self.ResourceEntities = ResourceEntities
    def get_AvailableNetworks(self): return self.AvailableNetworks
    def set_AvailableNetworks(self, AvailableNetworks): self.AvailableNetworks = AvailableNetworks
    def get_Capabilities(self): return self.Capabilities
    def set_Capabilities(self, Capabilities): self.Capabilities = Capabilities
    def get_NicQuota(self): return self.NicQuota
    def set_NicQuota(self, NicQuota): self.NicQuota = NicQuota
    def get_NetworkQuota(self): return self.NetworkQuota
    def set_NetworkQuota(self, NetworkQuota): self.NetworkQuota = NetworkQuota
    def get_UsedNetworkCount(self): return self.UsedNetworkCount
    def set_UsedNetworkCount(self, UsedNetworkCount): self.UsedNetworkCount = UsedNetworkCount
    def get_VmQuota(self): return self.VmQuota
    def set_VmQuota(self, VmQuota): self.VmQuota = VmQuota
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_VdcStorageProfiles(self): return self.VdcStorageProfiles
    def set_VdcStorageProfiles(self, VdcStorageProfiles): self.VdcStorageProfiles = VdcStorageProfiles
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def hasContent_(self):
        if (
            self.AllocationModel is not None or
            self.StorageCapacity is not None or
            self.ComputeCapacity is not None or
            self.ResourceEntities is not None or
            self.AvailableNetworks is not None or
            self.Capabilities is not None or
            self.NicQuota is not None or
            self.NetworkQuota is not None or
            self.UsedNetworkCount is not None or
            self.VmQuota is not None or
            self.IsEnabled is not None or
            self.VdcStorageProfiles is not None or
            super(VdcType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VdcType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VdcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VdcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VdcType'):
        super(VdcType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VdcType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status="%s"' % self.gds_format_integer(self.status, input_name='status'))
    def exportChildren(self, outfile, level, namespace_='', name_='VdcType', fromsubclass_=False, pretty_print=True):
        super(VdcType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AllocationModel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllocationModel>%s</%sAllocationModel>%s' % (namespace_, self.gds_format_string(quote_xml(self.AllocationModel).encode(ExternalEncoding), input_name='AllocationModel'), namespace_, eol_))
        if self.StorageCapacity is not None:
            self.StorageCapacity.export(outfile, level, namespace_, name_='StorageCapacity', pretty_print=pretty_print)
        if self.ComputeCapacity is not None:
            self.ComputeCapacity.export(outfile, level, namespace_, name_='ComputeCapacity', pretty_print=pretty_print)
        if self.ResourceEntities is not None:
            self.ResourceEntities.export(outfile, level, namespace_, name_='ResourceEntities', pretty_print=pretty_print)
        if self.AvailableNetworks is not None:
            self.AvailableNetworks.export(outfile, level, namespace_, name_='AvailableNetworks', pretty_print=pretty_print)
        if self.Capabilities is not None:
            self.Capabilities.export(outfile, level, namespace_, name_='Capabilities', pretty_print=pretty_print)
        if self.NicQuota is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNicQuota>%s</%sNicQuota>%s' % (namespace_, self.gds_format_integer(self.NicQuota, input_name='NicQuota'), namespace_, eol_))
        if self.NetworkQuota is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetworkQuota>%s</%sNetworkQuota>%s' % (namespace_, self.gds_format_integer(self.NetworkQuota, input_name='NetworkQuota'), namespace_, eol_))
        if self.UsedNetworkCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUsedNetworkCount>%s</%sUsedNetworkCount>%s' % (namespace_, self.gds_format_integer(self.UsedNetworkCount, input_name='UsedNetworkCount'), namespace_, eol_))
        if self.VmQuota is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVmQuota>%s</%sVmQuota>%s' % (namespace_, self.gds_format_integer(self.VmQuota, input_name='VmQuota'), namespace_, eol_))
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.VdcStorageProfiles is not None:
            self.VdcStorageProfiles.export(outfile, level, namespace_, name_='VdcStorageProfiles', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VdcType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % (self.status,))
        super(VdcType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VdcType, self).exportLiteralChildren(outfile, level, name_)
        if self.AllocationModel is not None:
            showIndent(outfile, level)
            outfile.write('AllocationModel=%s,\n' % quote_python(self.AllocationModel).encode(ExternalEncoding))
        if self.StorageCapacity is not None:
            showIndent(outfile, level)
            outfile.write('StorageCapacity=model_.CapacityWithUsageType(\n')
            self.StorageCapacity.exportLiteral(outfile, level, name_='StorageCapacity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ComputeCapacity is not None:
            showIndent(outfile, level)
            outfile.write('ComputeCapacity=model_.ComputeCapacityType(\n')
            self.ComputeCapacity.exportLiteral(outfile, level, name_='ComputeCapacity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ResourceEntities is not None:
            showIndent(outfile, level)
            outfile.write('ResourceEntities=model_.ResourceEntitiesType(\n')
            self.ResourceEntities.exportLiteral(outfile, level, name_='ResourceEntities')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AvailableNetworks is not None:
            showIndent(outfile, level)
            outfile.write('AvailableNetworks=model_.AvailableNetworksType(\n')
            self.AvailableNetworks.exportLiteral(outfile, level, name_='AvailableNetworks')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Capabilities is not None:
            showIndent(outfile, level)
            outfile.write('Capabilities=model_.CapabilitiesType(\n')
            self.Capabilities.exportLiteral(outfile, level, name_='Capabilities')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NicQuota is not None:
            showIndent(outfile, level)
            outfile.write('NicQuota=%d,\n' % self.NicQuota)
        if self.NetworkQuota is not None:
            showIndent(outfile, level)
            outfile.write('NetworkQuota=%d,\n' % self.NetworkQuota)
        if self.UsedNetworkCount is not None:
            showIndent(outfile, level)
            outfile.write('UsedNetworkCount=%d,\n' % self.UsedNetworkCount)
        if self.VmQuota is not None:
            showIndent(outfile, level)
            outfile.write('VmQuota=%d,\n' % self.VmQuota)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.VdcStorageProfiles is not None:
            showIndent(outfile, level)
            outfile.write('VdcStorageProfiles=model_.VdcStorageProfilesType(\n')
            self.VdcStorageProfiles.exportLiteral(outfile, level, name_='VdcStorageProfiles')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            try:
                self.status = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(VdcType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AllocationModel':
            AllocationModel_ = child_.text
            AllocationModel_ = self.gds_validate_string(AllocationModel_, node, 'AllocationModel')
            self.AllocationModel = AllocationModel_
        elif nodeName_ == 'StorageCapacity':
            obj_ = CapacityWithUsageType.factory()
            obj_.build(child_)
            self.StorageCapacity = obj_
            obj_.original_tagname_ = 'StorageCapacity'
        elif nodeName_ == 'ComputeCapacity':
            obj_ = ComputeCapacityType.factory()
            obj_.build(child_)
            self.ComputeCapacity = obj_
            obj_.original_tagname_ = 'ComputeCapacity'
        elif nodeName_ == 'ResourceEntities':
            obj_ = ResourceEntitiesType.factory()
            obj_.build(child_)
            self.ResourceEntities = obj_
            obj_.original_tagname_ = 'ResourceEntities'
        elif nodeName_ == 'AvailableNetworks':
            obj_ = AvailableNetworksType.factory()
            obj_.build(child_)
            self.AvailableNetworks = obj_
            obj_.original_tagname_ = 'AvailableNetworks'
        elif nodeName_ == 'Capabilities':
            obj_ = CapabilitiesType.factory()
            obj_.build(child_)
            self.Capabilities = obj_
            obj_.original_tagname_ = 'Capabilities'
        elif nodeName_ == 'NicQuota':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NicQuota')
            self.NicQuota = ival_
        elif nodeName_ == 'NetworkQuota':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NetworkQuota')
            self.NetworkQuota = ival_
        elif nodeName_ == 'UsedNetworkCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UsedNetworkCount')
            self.UsedNetworkCount = ival_
        elif nodeName_ == 'VmQuota':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VmQuota')
            self.VmQuota = ival_
        elif nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'VdcStorageProfiles':
            obj_ = VdcStorageProfilesType.factory()
            obj_.build(child_)
            self.VdcStorageProfiles = obj_
            obj_.original_tagname_ = 'VdcStorageProfiles'
        super(VdcType, self).buildChildren(child_, node, nodeName_, True)
# end class VdcType


class ComputeCapacityType(VCloudExtensibleType):
    """0.9 Represents vDC compute capacity."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Cpu=None, Memory=None):
        self.original_tagname_ = None
        super(ComputeCapacityType, self).__init__(VCloudExtension, )
        self.Cpu = Cpu
        self.Memory = Memory
    def factory(*args_, **kwargs_):
        if ComputeCapacityType.subclass:
            return ComputeCapacityType.subclass(*args_, **kwargs_)
        else:
            return ComputeCapacityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cpu(self): return self.Cpu
    def set_Cpu(self, Cpu): self.Cpu = Cpu
    def get_Memory(self): return self.Memory
    def set_Memory(self, Memory): self.Memory = Memory
    def hasContent_(self):
        if (
            self.Cpu is not None or
            self.Memory is not None or
            super(ComputeCapacityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ComputeCapacityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComputeCapacityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ComputeCapacityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ComputeCapacityType'):
        super(ComputeCapacityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ComputeCapacityType')
    def exportChildren(self, outfile, level, namespace_='', name_='ComputeCapacityType', fromsubclass_=False, pretty_print=True):
        super(ComputeCapacityType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cpu is not None:
            self.Cpu.export(outfile, level, namespace_, name_='Cpu', pretty_print=pretty_print)
        if self.Memory is not None:
            self.Memory.export(outfile, level, namespace_, name_='Memory', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ComputeCapacityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ComputeCapacityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ComputeCapacityType, self).exportLiteralChildren(outfile, level, name_)
        if self.Cpu is not None:
            showIndent(outfile, level)
            outfile.write('Cpu=model_.CapacityWithUsageType(\n')
            self.Cpu.exportLiteral(outfile, level, name_='Cpu')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Memory is not None:
            showIndent(outfile, level)
            outfile.write('Memory=model_.CapacityWithUsageType(\n')
            self.Memory.exportLiteral(outfile, level, name_='Memory')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ComputeCapacityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cpu':
            obj_ = CapacityWithUsageType.factory()
            obj_.build(child_)
            self.Cpu = obj_
            obj_.original_tagname_ = 'Cpu'
        elif nodeName_ == 'Memory':
            obj_ = CapacityWithUsageType.factory()
            obj_.build(child_)
            self.Memory = obj_
            obj_.original_tagname_ = 'Memory'
        super(ComputeCapacityType, self).buildChildren(child_, node, nodeName_, True)
# end class ComputeCapacityType


class CapabilitiesType(VCloudExtensibleType):
    """1.5 Collection of supported hardware capabilities."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, SupportedHardwareVersions=None):
        self.original_tagname_ = None
        super(CapabilitiesType, self).__init__(VCloudExtension, )
        self.SupportedHardwareVersions = SupportedHardwareVersions
    def factory(*args_, **kwargs_):
        if CapabilitiesType.subclass:
            return CapabilitiesType.subclass(*args_, **kwargs_)
        else:
            return CapabilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SupportedHardwareVersions(self): return self.SupportedHardwareVersions
    def set_SupportedHardwareVersions(self, SupportedHardwareVersions): self.SupportedHardwareVersions = SupportedHardwareVersions
    def hasContent_(self):
        if (
            self.SupportedHardwareVersions is not None or
            super(CapabilitiesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CapabilitiesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CapabilitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CapabilitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CapabilitiesType'):
        super(CapabilitiesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CapabilitiesType')
    def exportChildren(self, outfile, level, namespace_='', name_='CapabilitiesType', fromsubclass_=False, pretty_print=True):
        super(CapabilitiesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SupportedHardwareVersions is not None:
            self.SupportedHardwareVersions.export(outfile, level, namespace_, name_='SupportedHardwareVersions', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CapabilitiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CapabilitiesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CapabilitiesType, self).exportLiteralChildren(outfile, level, name_)
        if self.SupportedHardwareVersions is not None:
            showIndent(outfile, level)
            outfile.write('SupportedHardwareVersions=model_.SupportedHardwareVersionsType(\n')
            self.SupportedHardwareVersions.exportLiteral(outfile, level, name_='SupportedHardwareVersions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CapabilitiesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SupportedHardwareVersions':
            obj_ = SupportedHardwareVersionsType.factory()
            obj_.build(child_)
            self.SupportedHardwareVersions = obj_
            obj_.original_tagname_ = 'SupportedHardwareVersions'
        super(CapabilitiesType, self).buildChildren(child_, node, nodeName_, True)
# end class CapabilitiesType


class SupportedHardwareVersionsType(VCloudExtensibleType):
    """1.5 Contains a list of VMware virtual hardware versions supported in
    this vDC."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, SupportedHardwareVersion=None):
        self.original_tagname_ = None
        super(SupportedHardwareVersionsType, self).__init__(VCloudExtension, )
        if SupportedHardwareVersion is None:
            self.SupportedHardwareVersion = []
        else:
            self.SupportedHardwareVersion = SupportedHardwareVersion
    def factory(*args_, **kwargs_):
        if SupportedHardwareVersionsType.subclass:
            return SupportedHardwareVersionsType.subclass(*args_, **kwargs_)
        else:
            return SupportedHardwareVersionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SupportedHardwareVersion(self): return self.SupportedHardwareVersion
    def set_SupportedHardwareVersion(self, SupportedHardwareVersion): self.SupportedHardwareVersion = SupportedHardwareVersion
    def add_SupportedHardwareVersion(self, value): self.SupportedHardwareVersion.append(value)
    def insert_SupportedHardwareVersion_at(self, index, value): self.SupportedHardwareVersion.insert(index, value)
    def replace_SupportedHardwareVersion_at(self, index, value): self.SupportedHardwareVersion[index] = value
    def validate_SupportedHardwareVersionType(self, value):
        # Validate type SupportedHardwareVersionType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.SupportedHardwareVersion or
            super(SupportedHardwareVersionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupportedHardwareVersionsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupportedHardwareVersionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupportedHardwareVersionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupportedHardwareVersionsType'):
        super(SupportedHardwareVersionsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SupportedHardwareVersionsType')
    def exportChildren(self, outfile, level, namespace_='', name_='SupportedHardwareVersionsType', fromsubclass_=False, pretty_print=True):
        super(SupportedHardwareVersionsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SupportedHardwareVersion_ in self.SupportedHardwareVersion:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSupportedHardwareVersion>%s</%sSupportedHardwareVersion>%s' % (namespace_, self.gds_format_string(quote_xml(SupportedHardwareVersion_).encode(ExternalEncoding), input_name='SupportedHardwareVersion'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SupportedHardwareVersionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SupportedHardwareVersionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SupportedHardwareVersionsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('SupportedHardwareVersion=[\n')
        level += 1
        for SupportedHardwareVersion_ in self.SupportedHardwareVersion:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SupportedHardwareVersion_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SupportedHardwareVersionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SupportedHardwareVersion':
            SupportedHardwareVersion_ = child_.text
            SupportedHardwareVersion_ = self.gds_validate_string(SupportedHardwareVersion_, node, 'SupportedHardwareVersion')
            self.SupportedHardwareVersion.append(SupportedHardwareVersion_)
            self.validate_SupportedHardwareVersionType(self.SupportedHardwareVersion)    # validate type SupportedHardwareVersionType
        super(SupportedHardwareVersionsType, self).buildChildren(child_, node, nodeName_, True)
# end class SupportedHardwareVersionsType


class NetworkType(EntityType):
    """0.9 Represents a Network in the vCloud model."""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, Configuration=None, extensiontype_=None):
        self.original_tagname_ = None
        super(NetworkType, self).__init__(operationKey, id, name, Description, Tasks, extensiontype_, )
        self.Configuration = Configuration
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if NetworkType.subclass:
            return NetworkType.subclass(*args_, **kwargs_)
        else:
            return NetworkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Configuration(self): return self.Configuration
    def set_Configuration(self, Configuration): self.Configuration = Configuration
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Configuration is not None or
            super(NetworkType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkType'):
        super(NetworkType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkType', fromsubclass_=False, pretty_print=True):
        super(NetworkType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Configuration is not None:
            self.Configuration.export(outfile, level, namespace_, name_='Configuration', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NetworkType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkType, self).exportLiteralChildren(outfile, level, name_)
        if self.Configuration is not None:
            showIndent(outfile, level)
            outfile.write('Configuration=model_.NetworkConfigurationType(\n')
            self.Configuration.exportLiteral(outfile, level, name_='Configuration')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NetworkType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Configuration':
            obj_ = NetworkConfigurationType.factory()
            obj_.build(child_)
            self.Configuration = obj_
            obj_.original_tagname_ = 'Configuration'
        super(NetworkType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkType


class OrgNetworkType(NetworkType):
    """0.95.1 Represents an organization network in the vCloud model."""
    subclass = None
    superclass = NetworkType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, Configuration=None, NetworkPool=None, AllowedExternalIpAddresses=None):
        self.original_tagname_ = None
        super(OrgNetworkType, self).__init__(operationKey, id, name, Description, Tasks, Configuration, )
        self.NetworkPool = NetworkPool
        self.AllowedExternalIpAddresses = AllowedExternalIpAddresses
    def factory(*args_, **kwargs_):
        if OrgNetworkType.subclass:
            return OrgNetworkType.subclass(*args_, **kwargs_)
        else:
            return OrgNetworkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NetworkPool(self): return self.NetworkPool
    def set_NetworkPool(self, NetworkPool): self.NetworkPool = NetworkPool
    def get_AllowedExternalIpAddresses(self): return self.AllowedExternalIpAddresses
    def set_AllowedExternalIpAddresses(self, AllowedExternalIpAddresses): self.AllowedExternalIpAddresses = AllowedExternalIpAddresses
    def hasContent_(self):
        if (
            self.NetworkPool is not None or
            self.AllowedExternalIpAddresses is not None or
            super(OrgNetworkType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrgNetworkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrgNetworkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrgNetworkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrgNetworkType'):
        super(OrgNetworkType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrgNetworkType')
    def exportChildren(self, outfile, level, namespace_='', name_='OrgNetworkType', fromsubclass_=False, pretty_print=True):
        super(OrgNetworkType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NetworkPool is not None:
            self.NetworkPool.export(outfile, level, namespace_, name_='NetworkPool', pretty_print=pretty_print)
        if self.AllowedExternalIpAddresses is not None:
            self.AllowedExternalIpAddresses.export(outfile, level, namespace_, name_='AllowedExternalIpAddresses', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OrgNetworkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OrgNetworkType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrgNetworkType, self).exportLiteralChildren(outfile, level, name_)
        if self.NetworkPool is not None:
            showIndent(outfile, level)
            outfile.write('NetworkPool=model_.ReferenceType(\n')
            self.NetworkPool.exportLiteral(outfile, level, name_='NetworkPool')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AllowedExternalIpAddresses is not None:
            showIndent(outfile, level)
            outfile.write('AllowedExternalIpAddresses=model_.IpAddressesType(\n')
            self.AllowedExternalIpAddresses.exportLiteral(outfile, level, name_='AllowedExternalIpAddresses')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OrgNetworkType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetworkPool':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.NetworkPool = obj_
            obj_.original_tagname_ = 'NetworkPool'
        elif nodeName_ == 'AllowedExternalIpAddresses':
            obj_ = IpAddressesType.factory()
            obj_.build(child_)
            self.AllowedExternalIpAddresses = obj_
            obj_.original_tagname_ = 'AllowedExternalIpAddresses'
        super(OrgNetworkType, self).buildChildren(child_, node, nodeName_, True)
# end class OrgNetworkType


class VAppNetworkType(NetworkType):
    """1.5 Represents a vApp network. 1.5none True if the network is
    deployed. false"""
    subclass = None
    superclass = NetworkType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, Configuration=None, deployed=None):
        self.original_tagname_ = None
        super(VAppNetworkType, self).__init__(operationKey, id, name, Description, Tasks, Configuration, )
        self.deployed = _cast(bool, deployed)
    def factory(*args_, **kwargs_):
        if VAppNetworkType.subclass:
            return VAppNetworkType.subclass(*args_, **kwargs_)
        else:
            return VAppNetworkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deployed(self): return self.deployed
    def set_deployed(self, deployed): self.deployed = deployed
    def hasContent_(self):
        if (
            super(VAppNetworkType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VAppNetworkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VAppNetworkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VAppNetworkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VAppNetworkType'):
        super(VAppNetworkType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VAppNetworkType')
        if self.deployed is not None and 'deployed' not in already_processed:
            already_processed.add('deployed')
            outfile.write(' deployed="%s"' % self.gds_format_boolean(self.deployed, input_name='deployed'))
    def exportChildren(self, outfile, level, namespace_='', name_='VAppNetworkType', fromsubclass_=False, pretty_print=True):
        super(VAppNetworkType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VAppNetworkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deployed is not None and 'deployed' not in already_processed:
            already_processed.add('deployed')
            showIndent(outfile, level)
            outfile.write('deployed=%s,\n' % (self.deployed,))
        super(VAppNetworkType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VAppNetworkType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deployed', node)
        if value is not None and 'deployed' not in already_processed:
            already_processed.add('deployed')
            if value in ('true', '1'):
                self.deployed = True
            elif value in ('false', '0'):
                self.deployed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(VAppNetworkType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VAppNetworkType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VAppNetworkType


class NetworkServiceType(VCloudExtensibleType):
    """This is the root of the substitution group for network services.
    Replace it with any of NatService, LoadBalancerService
    IpsecVpnService/GatewayIpsecVpnService,
    DhcpService/GatewayDhcpService, FirewallService, or
    StaticRoutingService."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsEnabled=None, extensiontype_=None):
        self.original_tagname_ = None
        super(NetworkServiceType, self).__init__(VCloudExtension, extensiontype_, )
        self.IsEnabled = IsEnabled
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if NetworkServiceType.subclass:
            return NetworkServiceType.subclass(*args_, **kwargs_)
        else:
            return NetworkServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.IsEnabled is not None or
            super(NetworkServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkServiceType'):
        super(NetworkServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkServiceType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkServiceType', fromsubclass_=False, pretty_print=True):
        super(NetworkServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NetworkServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NetworkServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkServiceType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NetworkServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        super(NetworkServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkServiceType


class NetworkFeaturesType(GeneratedsSuper):
    """Represents features of a network."""
    subclass = None
    superclass = None
    def __init__(self, NetworkService=None):
        self.original_tagname_ = None
        if NetworkService is None:
            self.NetworkService = []
        else:
            self.NetworkService = NetworkService
    def factory(*args_, **kwargs_):
        if NetworkFeaturesType.subclass:
            return NetworkFeaturesType.subclass(*args_, **kwargs_)
        else:
            return NetworkFeaturesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NetworkService(self): return self.NetworkService
    def set_NetworkService(self, NetworkService): self.NetworkService = NetworkService
    def add_NetworkService(self, value): self.NetworkService.append(value)
    def insert_NetworkService_at(self, index, value): self.NetworkService.insert(index, value)
    def replace_NetworkService_at(self, index, value): self.NetworkService[index] = value
    def hasContent_(self):
        if (
            self.NetworkService
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkFeaturesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkFeaturesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkFeaturesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkFeaturesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkFeaturesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NetworkService_ in self.NetworkService:
            NetworkService_.export(outfile, level, namespace_, name_='NetworkService', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkFeaturesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NetworkService=[\n')
        level += 1
        for NetworkService_ in self.NetworkService:
            showIndent(outfile, level)
            outfile.write('model_.NetworkService(\n')
            NetworkService_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetworkService':
            class_obj_ = self.get_class_obj_(child_, NetworkServiceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'NetworkService'
        elif nodeName_ == 'DhcpService':
            obj_ = DhcpServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'DhcpService'
        elif nodeName_ == 'FirewallService':
            obj_ = FirewallServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'FirewallService'
        elif nodeName_ == 'NatService':
            obj_ = NatServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'NatService'
        elif nodeName_ == 'IpsecVpnService':
            obj_ = IpsecVpnServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'IpsecVpnService'
        elif nodeName_ == 'StaticRoutingService':
            obj_ = StaticRoutingServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'StaticRoutingService'
        elif nodeName_ == 'GatewayIpsecVpnService':
            obj_ = GatewayIpsecVpnServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'GatewayIpsecVpnService'
        elif nodeName_ == 'LoadBalancerService':
            obj_ = LoadBalancerServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'LoadBalancerService'
        elif nodeName_ == 'GatewayDhcpService':
            obj_ = GatewayDhcpServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'GatewayDhcpService'
# end class NetworkFeaturesType


class RouterInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ExternalIp=None):
        self.original_tagname_ = None
        self.ExternalIp = ExternalIp
        self.validate_IpAddressType(self.ExternalIp)
    def factory(*args_, **kwargs_):
        if RouterInfoType.subclass:
            return RouterInfoType.subclass(*args_, **kwargs_)
        else:
            return RouterInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalIp(self): return self.ExternalIp
    def set_ExternalIp(self, ExternalIp): self.ExternalIp = ExternalIp
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.ExternalIp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RouterInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RouterInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RouterInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RouterInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RouterInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExternalIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIp>%s</%sExternalIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIp).encode(ExternalEncoding), input_name='ExternalIp'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='RouterInfoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ExternalIp is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIp=%s,\n' % quote_python(self.ExternalIp).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalIp':
            ExternalIp_ = child_.text
            ExternalIp_ = self.gds_validate_string(ExternalIp_, node, 'ExternalIp')
            self.ExternalIp = ExternalIp_
            self.validate_IpAddressType(self.ExternalIp)    # validate type IpAddressType
# end class RouterInfoType


class DhcpServiceType(NetworkServiceType):
    """Represents a DHCP network service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, DefaultLeaseTime=None, MaxLeaseTime=None, IpRange=None, RouterIp=None, SubMask=None, PrimaryNameServer=None, SecondaryNameServer=None, DomainName=None):
        self.original_tagname_ = None
        super(DhcpServiceType, self).__init__(VCloudExtension, IsEnabled, )
        self.DefaultLeaseTime = DefaultLeaseTime
        self.MaxLeaseTime = MaxLeaseTime
        self.IpRange = IpRange
        self.RouterIp = RouterIp
        self.validate_IpAddressType(self.RouterIp)
        self.SubMask = SubMask
        self.validate_IpAddressType(self.SubMask)
        self.PrimaryNameServer = PrimaryNameServer
        self.SecondaryNameServer = SecondaryNameServer
        self.DomainName = DomainName
    def factory(*args_, **kwargs_):
        if DhcpServiceType.subclass:
            return DhcpServiceType.subclass(*args_, **kwargs_)
        else:
            return DhcpServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DefaultLeaseTime(self): return self.DefaultLeaseTime
    def set_DefaultLeaseTime(self, DefaultLeaseTime): self.DefaultLeaseTime = DefaultLeaseTime
    def get_MaxLeaseTime(self): return self.MaxLeaseTime
    def set_MaxLeaseTime(self, MaxLeaseTime): self.MaxLeaseTime = MaxLeaseTime
    def get_IpRange(self): return self.IpRange
    def set_IpRange(self, IpRange): self.IpRange = IpRange
    def get_RouterIp(self): return self.RouterIp
    def set_RouterIp(self, RouterIp): self.RouterIp = RouterIp
    def get_SubMask(self): return self.SubMask
    def set_SubMask(self, SubMask): self.SubMask = SubMask
    def get_PrimaryNameServer(self): return self.PrimaryNameServer
    def set_PrimaryNameServer(self, PrimaryNameServer): self.PrimaryNameServer = PrimaryNameServer
    def get_SecondaryNameServer(self): return self.SecondaryNameServer
    def set_SecondaryNameServer(self, SecondaryNameServer): self.SecondaryNameServer = SecondaryNameServer
    def get_DomainName(self): return self.DomainName
    def set_DomainName(self, DomainName): self.DomainName = DomainName
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.DefaultLeaseTime is not None or
            self.MaxLeaseTime is not None or
            self.IpRange is not None or
            self.RouterIp is not None or
            self.SubMask is not None or
            self.PrimaryNameServer is not None or
            self.SecondaryNameServer is not None or
            self.DomainName is not None or
            super(DhcpServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DhcpServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DhcpServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DhcpServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DhcpServiceType'):
        super(DhcpServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DhcpServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='DhcpServiceType', fromsubclass_=False, pretty_print=True):
        super(DhcpServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultLeaseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefaultLeaseTime>%s</%sDefaultLeaseTime>%s' % (namespace_, self.gds_format_integer(self.DefaultLeaseTime, input_name='DefaultLeaseTime'), namespace_, eol_))
        if self.MaxLeaseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxLeaseTime>%s</%sMaxLeaseTime>%s' % (namespace_, self.gds_format_integer(self.MaxLeaseTime, input_name='MaxLeaseTime'), namespace_, eol_))
        if self.IpRange is not None:
            self.IpRange.export(outfile, level, namespace_, name_='IpRange', pretty_print=pretty_print)
        if self.RouterIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRouterIp>%s</%sRouterIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.RouterIp).encode(ExternalEncoding), input_name='RouterIp'), namespace_, eol_))
        if self.SubMask is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubMask>%s</%sSubMask>%s' % (namespace_, self.gds_format_string(quote_xml(self.SubMask).encode(ExternalEncoding), input_name='SubMask'), namespace_, eol_))
        if self.PrimaryNameServer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryNameServer>%s</%sPrimaryNameServer>%s' % (namespace_, self.gds_format_string(quote_xml(self.PrimaryNameServer).encode(ExternalEncoding), input_name='PrimaryNameServer'), namespace_, eol_))
        if self.SecondaryNameServer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSecondaryNameServer>%s</%sSecondaryNameServer>%s' % (namespace_, self.gds_format_string(quote_xml(self.SecondaryNameServer).encode(ExternalEncoding), input_name='SecondaryNameServer'), namespace_, eol_))
        if self.DomainName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDomainName>%s</%sDomainName>%s' % (namespace_, self.gds_format_string(quote_xml(self.DomainName).encode(ExternalEncoding), input_name='DomainName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DhcpServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DhcpServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DhcpServiceType, self).exportLiteralChildren(outfile, level, name_)
        if self.DefaultLeaseTime is not None:
            showIndent(outfile, level)
            outfile.write('DefaultLeaseTime=%d,\n' % self.DefaultLeaseTime)
        if self.MaxLeaseTime is not None:
            showIndent(outfile, level)
            outfile.write('MaxLeaseTime=%d,\n' % self.MaxLeaseTime)
        if self.IpRange is not None:
            showIndent(outfile, level)
            outfile.write('IpRange=model_.IpRangeType(\n')
            self.IpRange.exportLiteral(outfile, level, name_='IpRange')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RouterIp is not None:
            showIndent(outfile, level)
            outfile.write('RouterIp=%s,\n' % quote_python(self.RouterIp).encode(ExternalEncoding))
        if self.SubMask is not None:
            showIndent(outfile, level)
            outfile.write('SubMask=%s,\n' % quote_python(self.SubMask).encode(ExternalEncoding))
        if self.PrimaryNameServer is not None:
            showIndent(outfile, level)
            outfile.write('PrimaryNameServer=%s,\n' % quote_python(self.PrimaryNameServer).encode(ExternalEncoding))
        if self.SecondaryNameServer is not None:
            showIndent(outfile, level)
            outfile.write('SecondaryNameServer=%s,\n' % quote_python(self.SecondaryNameServer).encode(ExternalEncoding))
        if self.DomainName is not None:
            showIndent(outfile, level)
            outfile.write('DomainName=%s,\n' % quote_python(self.DomainName).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DhcpServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DefaultLeaseTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DefaultLeaseTime')
            self.DefaultLeaseTime = ival_
        elif nodeName_ == 'MaxLeaseTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaxLeaseTime')
            self.MaxLeaseTime = ival_
        elif nodeName_ == 'IpRange':
            obj_ = IpRangeType.factory()
            obj_.build(child_)
            self.IpRange = obj_
            obj_.original_tagname_ = 'IpRange'
        elif nodeName_ == 'RouterIp':
            RouterIp_ = child_.text
            RouterIp_ = self.gds_validate_string(RouterIp_, node, 'RouterIp')
            self.RouterIp = RouterIp_
            self.validate_IpAddressType(self.RouterIp)    # validate type IpAddressType
        elif nodeName_ == 'SubMask':
            SubMask_ = child_.text
            SubMask_ = self.gds_validate_string(SubMask_, node, 'SubMask')
            self.SubMask = SubMask_
            self.validate_IpAddressType(self.SubMask)    # validate type IpAddressType
        elif nodeName_ == 'PrimaryNameServer':
            PrimaryNameServer_ = child_.text
            PrimaryNameServer_ = self.gds_validate_string(PrimaryNameServer_, node, 'PrimaryNameServer')
            self.PrimaryNameServer = PrimaryNameServer_
        elif nodeName_ == 'SecondaryNameServer':
            SecondaryNameServer_ = child_.text
            SecondaryNameServer_ = self.gds_validate_string(SecondaryNameServer_, node, 'SecondaryNameServer')
            self.SecondaryNameServer = SecondaryNameServer_
        elif nodeName_ == 'DomainName':
            DomainName_ = child_.text
            DomainName_ = self.gds_validate_string(DomainName_, node, 'DomainName')
            self.DomainName = DomainName_
        super(DhcpServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class DhcpServiceType


class NatServiceType(NetworkServiceType):
    """Represents a NAT network service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, NatType=None, Policy=None, NatRule=None, ExternalIp=None):
        self.original_tagname_ = None
        super(NatServiceType, self).__init__(VCloudExtension, IsEnabled, )
        self.NatType = NatType
        self.Policy = Policy
        if NatRule is None:
            self.NatRule = []
        else:
            self.NatRule = NatRule
        self.ExternalIp = ExternalIp
        self.validate_IpAddressType(self.ExternalIp)
    def factory(*args_, **kwargs_):
        if NatServiceType.subclass:
            return NatServiceType.subclass(*args_, **kwargs_)
        else:
            return NatServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NatType(self): return self.NatType
    def set_NatType(self, NatType): self.NatType = NatType
    def get_Policy(self): return self.Policy
    def set_Policy(self, Policy): self.Policy = Policy
    def get_NatRule(self): return self.NatRule
    def set_NatRule(self, NatRule): self.NatRule = NatRule
    def add_NatRule(self, value): self.NatRule.append(value)
    def insert_NatRule_at(self, index, value): self.NatRule.insert(index, value)
    def replace_NatRule_at(self, index, value): self.NatRule[index] = value
    def get_ExternalIp(self): return self.ExternalIp
    def set_ExternalIp(self, ExternalIp): self.ExternalIp = ExternalIp
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.NatType is not None or
            self.Policy is not None or
            self.NatRule or
            self.ExternalIp is not None or
            super(NatServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NatServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NatServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NatServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NatServiceType'):
        super(NatServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NatServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='NatServiceType', fromsubclass_=False, pretty_print=True):
        super(NatServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NatType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNatType>%s</%sNatType>%s' % (namespace_, self.gds_format_string(quote_xml(self.NatType).encode(ExternalEncoding), input_name='NatType'), namespace_, eol_))
        if self.Policy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPolicy>%s</%sPolicy>%s' % (namespace_, self.gds_format_string(quote_xml(self.Policy).encode(ExternalEncoding), input_name='Policy'), namespace_, eol_))
        for NatRule_ in self.NatRule:
            NatRule_.export(outfile, level, namespace_, name_='NatRule', pretty_print=pretty_print)
        if self.ExternalIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIp>%s</%sExternalIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIp).encode(ExternalEncoding), input_name='ExternalIp'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NatServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NatServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NatServiceType, self).exportLiteralChildren(outfile, level, name_)
        if self.NatType is not None:
            showIndent(outfile, level)
            outfile.write('NatType=%s,\n' % quote_python(self.NatType).encode(ExternalEncoding))
        if self.Policy is not None:
            showIndent(outfile, level)
            outfile.write('Policy=%s,\n' % quote_python(self.Policy).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('NatRule=[\n')
        level += 1
        for NatRule_ in self.NatRule:
            showIndent(outfile, level)
            outfile.write('model_.NatRuleType(\n')
            NatRule_.exportLiteral(outfile, level, name_='NatRuleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ExternalIp is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIp=%s,\n' % quote_python(self.ExternalIp).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NatServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NatType':
            NatType_ = child_.text
            NatType_ = self.gds_validate_string(NatType_, node, 'NatType')
            self.NatType = NatType_
        elif nodeName_ == 'Policy':
            Policy_ = child_.text
            Policy_ = self.gds_validate_string(Policy_, node, 'Policy')
            self.Policy = Policy_
        elif nodeName_ == 'NatRule':
            obj_ = NatRuleType.factory()
            obj_.build(child_)
            self.NatRule.append(obj_)
            obj_.original_tagname_ = 'NatRule'
        elif nodeName_ == 'ExternalIp':
            ExternalIp_ = child_.text
            ExternalIp_ = self.gds_validate_string(ExternalIp_, node, 'ExternalIp')
            self.ExternalIp = ExternalIp_
            self.validate_IpAddressType(self.ExternalIp)    # validate type IpAddressType
        super(NatServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class NatServiceType


class NatRuleType(VCloudExtensibleType):
    """0.9 Represents a NAT rule."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Description=None, RuleType=None, IsEnabled=None, Id=None, GatewayNatRule=None, OneToOneBasicRule=None, OneToOneVmRule=None, PortForwardingRule=None, VmRule=None):
        self.original_tagname_ = None
        super(NatRuleType, self).__init__(VCloudExtension, )
        self.Description = Description
        self.RuleType = RuleType
        self.IsEnabled = IsEnabled
        self.Id = Id
        self.GatewayNatRule = GatewayNatRule
        self.OneToOneBasicRule = OneToOneBasicRule
        self.OneToOneVmRule = OneToOneVmRule
        self.PortForwardingRule = PortForwardingRule
        self.VmRule = VmRule
    def factory(*args_, **kwargs_):
        if NatRuleType.subclass:
            return NatRuleType.subclass(*args_, **kwargs_)
        else:
            return NatRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_RuleType(self): return self.RuleType
    def set_RuleType(self, RuleType): self.RuleType = RuleType
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_GatewayNatRule(self): return self.GatewayNatRule
    def set_GatewayNatRule(self, GatewayNatRule): self.GatewayNatRule = GatewayNatRule
    def get_OneToOneBasicRule(self): return self.OneToOneBasicRule
    def set_OneToOneBasicRule(self, OneToOneBasicRule): self.OneToOneBasicRule = OneToOneBasicRule
    def get_OneToOneVmRule(self): return self.OneToOneVmRule
    def set_OneToOneVmRule(self, OneToOneVmRule): self.OneToOneVmRule = OneToOneVmRule
    def get_PortForwardingRule(self): return self.PortForwardingRule
    def set_PortForwardingRule(self, PortForwardingRule): self.PortForwardingRule = PortForwardingRule
    def get_VmRule(self): return self.VmRule
    def set_VmRule(self, VmRule): self.VmRule = VmRule
    def hasContent_(self):
        if (
            self.Description is not None or
            self.RuleType is not None or
            self.IsEnabled is not None or
            self.Id is not None or
            self.GatewayNatRule is not None or
            self.OneToOneBasicRule is not None or
            self.OneToOneVmRule is not None or
            self.PortForwardingRule is not None or
            self.VmRule is not None or
            super(NatRuleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NatRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NatRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NatRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NatRuleType'):
        super(NatRuleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NatRuleType')
    def exportChildren(self, outfile, level, namespace_='', name_='NatRuleType', fromsubclass_=False, pretty_print=True):
        super(NatRuleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.RuleType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRuleType>%s</%sRuleType>%s' % (namespace_, self.gds_format_string(quote_xml(self.RuleType).encode(ExternalEncoding), input_name='RuleType'), namespace_, eol_))
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_integer(self.Id, input_name='Id'), namespace_, eol_))
        if self.GatewayNatRule is not None:
            self.GatewayNatRule.export(outfile, level, namespace_, name_='GatewayNatRule', pretty_print=pretty_print)
        if self.OneToOneBasicRule is not None:
            self.OneToOneBasicRule.export(outfile, level, namespace_, name_='OneToOneBasicRule', pretty_print=pretty_print)
        if self.OneToOneVmRule is not None:
            self.OneToOneVmRule.export(outfile, level, namespace_, name_='OneToOneVmRule', pretty_print=pretty_print)
        if self.PortForwardingRule is not None:
            self.PortForwardingRule.export(outfile, level, namespace_, name_='PortForwardingRule', pretty_print=pretty_print)
        if self.VmRule is not None:
            self.VmRule.export(outfile, level, namespace_, name_='VmRule', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NatRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NatRuleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NatRuleType, self).exportLiteralChildren(outfile, level, name_)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.RuleType is not None:
            showIndent(outfile, level)
            outfile.write('RuleType=%s,\n' % quote_python(self.RuleType).encode(ExternalEncoding))
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%d,\n' % self.Id)
        if self.GatewayNatRule is not None:
            showIndent(outfile, level)
            outfile.write('GatewayNatRule=model_.GatewayNatRuleType(\n')
            self.GatewayNatRule.exportLiteral(outfile, level, name_='GatewayNatRule')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OneToOneBasicRule is not None:
            showIndent(outfile, level)
            outfile.write('OneToOneBasicRule=model_.NatOneToOneBasicRuleType(\n')
            self.OneToOneBasicRule.exportLiteral(outfile, level, name_='OneToOneBasicRule')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OneToOneVmRule is not None:
            showIndent(outfile, level)
            outfile.write('OneToOneVmRule=model_.NatOneToOneVmRuleType(\n')
            self.OneToOneVmRule.exportLiteral(outfile, level, name_='OneToOneVmRule')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PortForwardingRule is not None:
            showIndent(outfile, level)
            outfile.write('PortForwardingRule=model_.NatPortForwardingRuleType(\n')
            self.PortForwardingRule.exportLiteral(outfile, level, name_='PortForwardingRule')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VmRule is not None:
            showIndent(outfile, level)
            outfile.write('VmRule=model_.NatVmRuleType(\n')
            self.VmRule.exportLiteral(outfile, level, name_='VmRule')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NatRuleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'RuleType':
            RuleType_ = child_.text
            RuleType_ = self.gds_validate_string(RuleType_, node, 'RuleType')
            self.RuleType = RuleType_
        elif nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'Id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Id')
            self.Id = ival_
        elif nodeName_ == 'GatewayNatRule':
            obj_ = GatewayNatRuleType.factory()
            obj_.build(child_)
            self.GatewayNatRule = obj_
            obj_.original_tagname_ = 'GatewayNatRule'
        elif nodeName_ == 'OneToOneBasicRule':
            obj_ = NatOneToOneBasicRuleType.factory()
            obj_.build(child_)
            self.OneToOneBasicRule = obj_
            obj_.original_tagname_ = 'OneToOneBasicRule'
        elif nodeName_ == 'OneToOneVmRule':
            obj_ = NatOneToOneVmRuleType.factory()
            obj_.build(child_)
            self.OneToOneVmRule = obj_
            obj_.original_tagname_ = 'OneToOneVmRule'
        elif nodeName_ == 'PortForwardingRule':
            obj_ = NatPortForwardingRuleType.factory()
            obj_.build(child_)
            self.PortForwardingRule = obj_
            obj_.original_tagname_ = 'PortForwardingRule'
        elif nodeName_ == 'VmRule':
            obj_ = NatVmRuleType.factory()
            obj_.build(child_)
            self.VmRule = obj_
            obj_.original_tagname_ = 'VmRule'
        super(NatRuleType, self).buildChildren(child_, node, nodeName_, True)
# end class NatRuleType


class GatewayNatRuleType(VCloudExtensibleType):
    """5.1 Represents the SNAT and DNAT rules."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Interface=None, OriginalIp=None, OriginalPort=None, TranslatedIp=None, TranslatedPort=None, Protocol=None, IcmpSubType=None):
        self.original_tagname_ = None
        super(GatewayNatRuleType, self).__init__(VCloudExtension, )
        self.Interface = Interface
        self.OriginalIp = OriginalIp
        self.validate_IpAddressType(self.OriginalIp)
        self.OriginalPort = OriginalPort
        self.TranslatedIp = TranslatedIp
        self.validate_IpAddressType(self.TranslatedIp)
        self.TranslatedPort = TranslatedPort
        self.Protocol = Protocol
        self.IcmpSubType = IcmpSubType
    def factory(*args_, **kwargs_):
        if GatewayNatRuleType.subclass:
            return GatewayNatRuleType.subclass(*args_, **kwargs_)
        else:
            return GatewayNatRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Interface(self): return self.Interface
    def set_Interface(self, Interface): self.Interface = Interface
    def get_OriginalIp(self): return self.OriginalIp
    def set_OriginalIp(self, OriginalIp): self.OriginalIp = OriginalIp
    def get_OriginalPort(self): return self.OriginalPort
    def set_OriginalPort(self, OriginalPort): self.OriginalPort = OriginalPort
    def get_TranslatedIp(self): return self.TranslatedIp
    def set_TranslatedIp(self, TranslatedIp): self.TranslatedIp = TranslatedIp
    def get_TranslatedPort(self): return self.TranslatedPort
    def set_TranslatedPort(self, TranslatedPort): self.TranslatedPort = TranslatedPort
    def get_Protocol(self): return self.Protocol
    def set_Protocol(self, Protocol): self.Protocol = Protocol
    def get_IcmpSubType(self): return self.IcmpSubType
    def set_IcmpSubType(self, IcmpSubType): self.IcmpSubType = IcmpSubType
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Interface is not None or
            self.OriginalIp is not None or
            self.OriginalPort is not None or
            self.TranslatedIp is not None or
            self.TranslatedPort is not None or
            self.Protocol is not None or
            self.IcmpSubType is not None or
            super(GatewayNatRuleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayNatRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayNatRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayNatRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayNatRuleType'):
        super(GatewayNatRuleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayNatRuleType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayNatRuleType', fromsubclass_=False, pretty_print=True):
        super(GatewayNatRuleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Interface is not None:
            self.Interface.export(outfile, level, namespace_, name_='Interface', pretty_print=pretty_print)
        if self.OriginalIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOriginalIp>%s</%sOriginalIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.OriginalIp).encode(ExternalEncoding), input_name='OriginalIp'), namespace_, eol_))
        if self.OriginalPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOriginalPort>%s</%sOriginalPort>%s' % (namespace_, self.gds_format_string(quote_xml(self.OriginalPort).encode(ExternalEncoding), input_name='OriginalPort'), namespace_, eol_))
        if self.TranslatedIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTranslatedIp>%s</%sTranslatedIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.TranslatedIp).encode(ExternalEncoding), input_name='TranslatedIp'), namespace_, eol_))
        if self.TranslatedPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTranslatedPort>%s</%sTranslatedPort>%s' % (namespace_, self.gds_format_string(quote_xml(self.TranslatedPort).encode(ExternalEncoding), input_name='TranslatedPort'), namespace_, eol_))
        if self.Protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol>%s</%sProtocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.Protocol).encode(ExternalEncoding), input_name='Protocol'), namespace_, eol_))
        if self.IcmpSubType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIcmpSubType>%s</%sIcmpSubType>%s' % (namespace_, self.gds_format_string(quote_xml(self.IcmpSubType).encode(ExternalEncoding), input_name='IcmpSubType'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GatewayNatRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayNatRuleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayNatRuleType, self).exportLiteralChildren(outfile, level, name_)
        if self.Interface is not None:
            showIndent(outfile, level)
            outfile.write('Interface=model_.ReferenceType(\n')
            self.Interface.exportLiteral(outfile, level, name_='Interface')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OriginalIp is not None:
            showIndent(outfile, level)
            outfile.write('OriginalIp=%s,\n' % quote_python(self.OriginalIp).encode(ExternalEncoding))
        if self.OriginalPort is not None:
            showIndent(outfile, level)
            outfile.write('OriginalPort=%s,\n' % quote_python(self.OriginalPort).encode(ExternalEncoding))
        if self.TranslatedIp is not None:
            showIndent(outfile, level)
            outfile.write('TranslatedIp=%s,\n' % quote_python(self.TranslatedIp).encode(ExternalEncoding))
        if self.TranslatedPort is not None:
            showIndent(outfile, level)
            outfile.write('TranslatedPort=%s,\n' % quote_python(self.TranslatedPort).encode(ExternalEncoding))
        if self.Protocol is not None:
            showIndent(outfile, level)
            outfile.write('Protocol=%s,\n' % quote_python(self.Protocol).encode(ExternalEncoding))
        if self.IcmpSubType is not None:
            showIndent(outfile, level)
            outfile.write('IcmpSubType=%s,\n' % quote_python(self.IcmpSubType).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayNatRuleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Interface':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Interface = obj_
            obj_.original_tagname_ = 'Interface'
        elif nodeName_ == 'OriginalIp':
            OriginalIp_ = child_.text
            OriginalIp_ = self.gds_validate_string(OriginalIp_, node, 'OriginalIp')
            self.OriginalIp = OriginalIp_
            self.validate_IpAddressType(self.OriginalIp)    # validate type IpAddressType
        elif nodeName_ == 'OriginalPort':
            OriginalPort_ = child_.text
            OriginalPort_ = self.gds_validate_string(OriginalPort_, node, 'OriginalPort')
            self.OriginalPort = OriginalPort_
        elif nodeName_ == 'TranslatedIp':
            TranslatedIp_ = child_.text
            TranslatedIp_ = self.gds_validate_string(TranslatedIp_, node, 'TranslatedIp')
            self.TranslatedIp = TranslatedIp_
            self.validate_IpAddressType(self.TranslatedIp)    # validate type IpAddressType
        elif nodeName_ == 'TranslatedPort':
            TranslatedPort_ = child_.text
            TranslatedPort_ = self.gds_validate_string(TranslatedPort_, node, 'TranslatedPort')
            self.TranslatedPort = TranslatedPort_
        elif nodeName_ == 'Protocol':
            Protocol_ = child_.text
            Protocol_ = self.gds_validate_string(Protocol_, node, 'Protocol')
            self.Protocol = Protocol_
        elif nodeName_ == 'IcmpSubType':
            IcmpSubType_ = child_.text
            IcmpSubType_ = self.gds_validate_string(IcmpSubType_, node, 'IcmpSubType')
            self.IcmpSubType = IcmpSubType_
        super(GatewayNatRuleType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayNatRuleType


class NatOneToOneBasicRuleType(VCloudExtensibleType):
    """0.9 Represents the NAT basic rule for one to one mapping of internal
    and external IP addresses from a network."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, MappingMode=None, ExternalIpAddress=None, InternalIpAddress=None):
        self.original_tagname_ = None
        super(NatOneToOneBasicRuleType, self).__init__(VCloudExtension, )
        self.MappingMode = MappingMode
        self.ExternalIpAddress = ExternalIpAddress
        self.validate_IpAddressType(self.ExternalIpAddress)
        self.InternalIpAddress = InternalIpAddress
        self.validate_IpAddressType(self.InternalIpAddress)
    def factory(*args_, **kwargs_):
        if NatOneToOneBasicRuleType.subclass:
            return NatOneToOneBasicRuleType.subclass(*args_, **kwargs_)
        else:
            return NatOneToOneBasicRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MappingMode(self): return self.MappingMode
    def set_MappingMode(self, MappingMode): self.MappingMode = MappingMode
    def get_ExternalIpAddress(self): return self.ExternalIpAddress
    def set_ExternalIpAddress(self, ExternalIpAddress): self.ExternalIpAddress = ExternalIpAddress
    def get_InternalIpAddress(self): return self.InternalIpAddress
    def set_InternalIpAddress(self, InternalIpAddress): self.InternalIpAddress = InternalIpAddress
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.MappingMode is not None or
            self.ExternalIpAddress is not None or
            self.InternalIpAddress is not None or
            super(NatOneToOneBasicRuleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NatOneToOneBasicRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NatOneToOneBasicRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NatOneToOneBasicRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NatOneToOneBasicRuleType'):
        super(NatOneToOneBasicRuleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NatOneToOneBasicRuleType')
    def exportChildren(self, outfile, level, namespace_='', name_='NatOneToOneBasicRuleType', fromsubclass_=False, pretty_print=True):
        super(NatOneToOneBasicRuleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MappingMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMappingMode>%s</%sMappingMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.MappingMode).encode(ExternalEncoding), input_name='MappingMode'), namespace_, eol_))
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIpAddress>%s</%sExternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIpAddress).encode(ExternalEncoding), input_name='ExternalIpAddress'), namespace_, eol_))
        if self.InternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInternalIpAddress>%s</%sInternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.InternalIpAddress).encode(ExternalEncoding), input_name='InternalIpAddress'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NatOneToOneBasicRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NatOneToOneBasicRuleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NatOneToOneBasicRuleType, self).exportLiteralChildren(outfile, level, name_)
        if self.MappingMode is not None:
            showIndent(outfile, level)
            outfile.write('MappingMode=%s,\n' % quote_python(self.MappingMode).encode(ExternalEncoding))
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIpAddress=%s,\n' % quote_python(self.ExternalIpAddress).encode(ExternalEncoding))
        if self.InternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('InternalIpAddress=%s,\n' % quote_python(self.InternalIpAddress).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NatOneToOneBasicRuleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MappingMode':
            MappingMode_ = child_.text
            MappingMode_ = self.gds_validate_string(MappingMode_, node, 'MappingMode')
            self.MappingMode = MappingMode_
        elif nodeName_ == 'ExternalIpAddress':
            ExternalIpAddress_ = child_.text
            ExternalIpAddress_ = self.gds_validate_string(ExternalIpAddress_, node, 'ExternalIpAddress')
            self.ExternalIpAddress = ExternalIpAddress_
            self.validate_IpAddressType(self.ExternalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'InternalIpAddress':
            InternalIpAddress_ = child_.text
            InternalIpAddress_ = self.gds_validate_string(InternalIpAddress_, node, 'InternalIpAddress')
            self.InternalIpAddress = InternalIpAddress_
            self.validate_IpAddressType(self.InternalIpAddress)    # validate type IpAddressType
        super(NatOneToOneBasicRuleType, self).buildChildren(child_, node, nodeName_, True)
# end class NatOneToOneBasicRuleType


class NatOneToOneVmRuleType(VCloudExtensibleType):
    """0.9 Represents the NAT rule for one to one mapping of VM NIC and
    external IP addresses from a network."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, MappingMode=None, ExternalIpAddress=None, VAppScopedVmId=None, VmNicId=None):
        self.original_tagname_ = None
        super(NatOneToOneVmRuleType, self).__init__(VCloudExtension, )
        self.MappingMode = MappingMode
        self.ExternalIpAddress = ExternalIpAddress
        self.validate_IpAddressType(self.ExternalIpAddress)
        self.VAppScopedVmId = VAppScopedVmId
        self.VmNicId = VmNicId
    def factory(*args_, **kwargs_):
        if NatOneToOneVmRuleType.subclass:
            return NatOneToOneVmRuleType.subclass(*args_, **kwargs_)
        else:
            return NatOneToOneVmRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MappingMode(self): return self.MappingMode
    def set_MappingMode(self, MappingMode): self.MappingMode = MappingMode
    def get_ExternalIpAddress(self): return self.ExternalIpAddress
    def set_ExternalIpAddress(self, ExternalIpAddress): self.ExternalIpAddress = ExternalIpAddress
    def get_VAppScopedVmId(self): return self.VAppScopedVmId
    def set_VAppScopedVmId(self, VAppScopedVmId): self.VAppScopedVmId = VAppScopedVmId
    def get_VmNicId(self): return self.VmNicId
    def set_VmNicId(self, VmNicId): self.VmNicId = VmNicId
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.MappingMode is not None or
            self.ExternalIpAddress is not None or
            self.VAppScopedVmId is not None or
            self.VmNicId is not None or
            super(NatOneToOneVmRuleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NatOneToOneVmRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NatOneToOneVmRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NatOneToOneVmRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NatOneToOneVmRuleType'):
        super(NatOneToOneVmRuleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NatOneToOneVmRuleType')
    def exportChildren(self, outfile, level, namespace_='', name_='NatOneToOneVmRuleType', fromsubclass_=False, pretty_print=True):
        super(NatOneToOneVmRuleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MappingMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMappingMode>%s</%sMappingMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.MappingMode).encode(ExternalEncoding), input_name='MappingMode'), namespace_, eol_))
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIpAddress>%s</%sExternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIpAddress).encode(ExternalEncoding), input_name='ExternalIpAddress'), namespace_, eol_))
        if self.VAppScopedVmId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVAppScopedVmId>%s</%sVAppScopedVmId>%s' % (namespace_, self.gds_format_string(quote_xml(self.VAppScopedVmId).encode(ExternalEncoding), input_name='VAppScopedVmId'), namespace_, eol_))
        if self.VmNicId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVmNicId>%s</%sVmNicId>%s' % (namespace_, self.gds_format_integer(self.VmNicId, input_name='VmNicId'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NatOneToOneVmRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NatOneToOneVmRuleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NatOneToOneVmRuleType, self).exportLiteralChildren(outfile, level, name_)
        if self.MappingMode is not None:
            showIndent(outfile, level)
            outfile.write('MappingMode=%s,\n' % quote_python(self.MappingMode).encode(ExternalEncoding))
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIpAddress=%s,\n' % quote_python(self.ExternalIpAddress).encode(ExternalEncoding))
        if self.VAppScopedVmId is not None:
            showIndent(outfile, level)
            outfile.write('VAppScopedVmId=%s,\n' % quote_python(self.VAppScopedVmId).encode(ExternalEncoding))
        if self.VmNicId is not None:
            showIndent(outfile, level)
            outfile.write('VmNicId=%d,\n' % self.VmNicId)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NatOneToOneVmRuleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MappingMode':
            MappingMode_ = child_.text
            MappingMode_ = self.gds_validate_string(MappingMode_, node, 'MappingMode')
            self.MappingMode = MappingMode_
        elif nodeName_ == 'ExternalIpAddress':
            ExternalIpAddress_ = child_.text
            ExternalIpAddress_ = self.gds_validate_string(ExternalIpAddress_, node, 'ExternalIpAddress')
            self.ExternalIpAddress = ExternalIpAddress_
            self.validate_IpAddressType(self.ExternalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'VAppScopedVmId':
            VAppScopedVmId_ = child_.text
            VAppScopedVmId_ = self.gds_validate_string(VAppScopedVmId_, node, 'VAppScopedVmId')
            self.VAppScopedVmId = VAppScopedVmId_
        elif nodeName_ == 'VmNicId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VmNicId')
            self.VmNicId = ival_
        super(NatOneToOneVmRuleType, self).buildChildren(child_, node, nodeName_, True)
# end class NatOneToOneVmRuleType


class NatPortForwardingRuleType(VCloudExtensibleType):
    """0.9 Represents the NAT rule for port forwarding between internal
    IP/port and external IP/port."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, ExternalIpAddress=None, ExternalPort=None, InternalIpAddress=None, InternalPort=None, Protocol=None):
        self.original_tagname_ = None
        super(NatPortForwardingRuleType, self).__init__(VCloudExtension, )
        self.ExternalIpAddress = ExternalIpAddress
        self.validate_IpAddressType(self.ExternalIpAddress)
        self.ExternalPort = ExternalPort
        self.InternalIpAddress = InternalIpAddress
        self.validate_IpAddressType(self.InternalIpAddress)
        self.InternalPort = InternalPort
        self.Protocol = Protocol
    def factory(*args_, **kwargs_):
        if NatPortForwardingRuleType.subclass:
            return NatPortForwardingRuleType.subclass(*args_, **kwargs_)
        else:
            return NatPortForwardingRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalIpAddress(self): return self.ExternalIpAddress
    def set_ExternalIpAddress(self, ExternalIpAddress): self.ExternalIpAddress = ExternalIpAddress
    def get_ExternalPort(self): return self.ExternalPort
    def set_ExternalPort(self, ExternalPort): self.ExternalPort = ExternalPort
    def get_InternalIpAddress(self): return self.InternalIpAddress
    def set_InternalIpAddress(self, InternalIpAddress): self.InternalIpAddress = InternalIpAddress
    def get_InternalPort(self): return self.InternalPort
    def set_InternalPort(self, InternalPort): self.InternalPort = InternalPort
    def get_Protocol(self): return self.Protocol
    def set_Protocol(self, Protocol): self.Protocol = Protocol
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.ExternalIpAddress is not None or
            self.ExternalPort is not None or
            self.InternalIpAddress is not None or
            self.InternalPort is not None or
            self.Protocol is not None or
            super(NatPortForwardingRuleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NatPortForwardingRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NatPortForwardingRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NatPortForwardingRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NatPortForwardingRuleType'):
        super(NatPortForwardingRuleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NatPortForwardingRuleType')
    def exportChildren(self, outfile, level, namespace_='', name_='NatPortForwardingRuleType', fromsubclass_=False, pretty_print=True):
        super(NatPortForwardingRuleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIpAddress>%s</%sExternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIpAddress).encode(ExternalEncoding), input_name='ExternalIpAddress'), namespace_, eol_))
        if self.ExternalPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalPort>%s</%sExternalPort>%s' % (namespace_, self.gds_format_integer(self.ExternalPort, input_name='ExternalPort'), namespace_, eol_))
        if self.InternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInternalIpAddress>%s</%sInternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.InternalIpAddress).encode(ExternalEncoding), input_name='InternalIpAddress'), namespace_, eol_))
        if self.InternalPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInternalPort>%s</%sInternalPort>%s' % (namespace_, self.gds_format_integer(self.InternalPort, input_name='InternalPort'), namespace_, eol_))
        if self.Protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol>%s</%sProtocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.Protocol).encode(ExternalEncoding), input_name='Protocol'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NatPortForwardingRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NatPortForwardingRuleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NatPortForwardingRuleType, self).exportLiteralChildren(outfile, level, name_)
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIpAddress=%s,\n' % quote_python(self.ExternalIpAddress).encode(ExternalEncoding))
        if self.ExternalPort is not None:
            showIndent(outfile, level)
            outfile.write('ExternalPort=%d,\n' % self.ExternalPort)
        if self.InternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('InternalIpAddress=%s,\n' % quote_python(self.InternalIpAddress).encode(ExternalEncoding))
        if self.InternalPort is not None:
            showIndent(outfile, level)
            outfile.write('InternalPort=%d,\n' % self.InternalPort)
        if self.Protocol is not None:
            showIndent(outfile, level)
            outfile.write('Protocol=%s,\n' % quote_python(self.Protocol).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NatPortForwardingRuleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalIpAddress':
            ExternalIpAddress_ = child_.text
            ExternalIpAddress_ = self.gds_validate_string(ExternalIpAddress_, node, 'ExternalIpAddress')
            self.ExternalIpAddress = ExternalIpAddress_
            self.validate_IpAddressType(self.ExternalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'ExternalPort':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ExternalPort')
            self.ExternalPort = ival_
        elif nodeName_ == 'InternalIpAddress':
            InternalIpAddress_ = child_.text
            InternalIpAddress_ = self.gds_validate_string(InternalIpAddress_, node, 'InternalIpAddress')
            self.InternalIpAddress = InternalIpAddress_
            self.validate_IpAddressType(self.InternalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'InternalPort':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InternalPort')
            self.InternalPort = ival_
        elif nodeName_ == 'Protocol':
            Protocol_ = child_.text
            Protocol_ = self.gds_validate_string(Protocol_, node, 'Protocol')
            self.Protocol = Protocol_
        super(NatPortForwardingRuleType, self).buildChildren(child_, node, nodeName_, True)
# end class NatPortForwardingRuleType


class NatVmRuleType(VCloudExtensibleType):
    """0.9 Represents the NAT rule for port forwarding between VM NIC/port
    and external IP/port."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, ExternalIpAddress=None, ExternalPort=None, VAppScopedVmId=None, VmNicId=None, InternalPort=None, Protocol=None):
        self.original_tagname_ = None
        super(NatVmRuleType, self).__init__(VCloudExtension, )
        self.ExternalIpAddress = ExternalIpAddress
        self.validate_IpAddressType(self.ExternalIpAddress)
        self.ExternalPort = ExternalPort
        self.VAppScopedVmId = VAppScopedVmId
        self.VmNicId = VmNicId
        self.InternalPort = InternalPort
        self.Protocol = Protocol
    def factory(*args_, **kwargs_):
        if NatVmRuleType.subclass:
            return NatVmRuleType.subclass(*args_, **kwargs_)
        else:
            return NatVmRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalIpAddress(self): return self.ExternalIpAddress
    def set_ExternalIpAddress(self, ExternalIpAddress): self.ExternalIpAddress = ExternalIpAddress
    def get_ExternalPort(self): return self.ExternalPort
    def set_ExternalPort(self, ExternalPort): self.ExternalPort = ExternalPort
    def get_VAppScopedVmId(self): return self.VAppScopedVmId
    def set_VAppScopedVmId(self, VAppScopedVmId): self.VAppScopedVmId = VAppScopedVmId
    def get_VmNicId(self): return self.VmNicId
    def set_VmNicId(self, VmNicId): self.VmNicId = VmNicId
    def get_InternalPort(self): return self.InternalPort
    def set_InternalPort(self, InternalPort): self.InternalPort = InternalPort
    def get_Protocol(self): return self.Protocol
    def set_Protocol(self, Protocol): self.Protocol = Protocol
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.ExternalIpAddress is not None or
            self.ExternalPort is not None or
            self.VAppScopedVmId is not None or
            self.VmNicId is not None or
            self.InternalPort is not None or
            self.Protocol is not None or
            super(NatVmRuleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NatVmRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NatVmRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NatVmRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NatVmRuleType'):
        super(NatVmRuleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NatVmRuleType')
    def exportChildren(self, outfile, level, namespace_='', name_='NatVmRuleType', fromsubclass_=False, pretty_print=True):
        super(NatVmRuleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIpAddress>%s</%sExternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIpAddress).encode(ExternalEncoding), input_name='ExternalIpAddress'), namespace_, eol_))
        if self.ExternalPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalPort>%s</%sExternalPort>%s' % (namespace_, self.gds_format_integer(self.ExternalPort, input_name='ExternalPort'), namespace_, eol_))
        if self.VAppScopedVmId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVAppScopedVmId>%s</%sVAppScopedVmId>%s' % (namespace_, self.gds_format_string(quote_xml(self.VAppScopedVmId).encode(ExternalEncoding), input_name='VAppScopedVmId'), namespace_, eol_))
        if self.VmNicId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVmNicId>%s</%sVmNicId>%s' % (namespace_, self.gds_format_integer(self.VmNicId, input_name='VmNicId'), namespace_, eol_))
        if self.InternalPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInternalPort>%s</%sInternalPort>%s' % (namespace_, self.gds_format_integer(self.InternalPort, input_name='InternalPort'), namespace_, eol_))
        if self.Protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol>%s</%sProtocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.Protocol).encode(ExternalEncoding), input_name='Protocol'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NatVmRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NatVmRuleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NatVmRuleType, self).exportLiteralChildren(outfile, level, name_)
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIpAddress=%s,\n' % quote_python(self.ExternalIpAddress).encode(ExternalEncoding))
        if self.ExternalPort is not None:
            showIndent(outfile, level)
            outfile.write('ExternalPort=%d,\n' % self.ExternalPort)
        if self.VAppScopedVmId is not None:
            showIndent(outfile, level)
            outfile.write('VAppScopedVmId=%s,\n' % quote_python(self.VAppScopedVmId).encode(ExternalEncoding))
        if self.VmNicId is not None:
            showIndent(outfile, level)
            outfile.write('VmNicId=%d,\n' % self.VmNicId)
        if self.InternalPort is not None:
            showIndent(outfile, level)
            outfile.write('InternalPort=%d,\n' % self.InternalPort)
        if self.Protocol is not None:
            showIndent(outfile, level)
            outfile.write('Protocol=%s,\n' % quote_python(self.Protocol).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NatVmRuleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalIpAddress':
            ExternalIpAddress_ = child_.text
            ExternalIpAddress_ = self.gds_validate_string(ExternalIpAddress_, node, 'ExternalIpAddress')
            self.ExternalIpAddress = ExternalIpAddress_
            self.validate_IpAddressType(self.ExternalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'ExternalPort':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ExternalPort')
            self.ExternalPort = ival_
        elif nodeName_ == 'VAppScopedVmId':
            VAppScopedVmId_ = child_.text
            VAppScopedVmId_ = self.gds_validate_string(VAppScopedVmId_, node, 'VAppScopedVmId')
            self.VAppScopedVmId = VAppScopedVmId_
        elif nodeName_ == 'VmNicId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VmNicId')
            self.VmNicId = ival_
        elif nodeName_ == 'InternalPort':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InternalPort')
            self.InternalPort = ival_
        elif nodeName_ == 'Protocol':
            Protocol_ = child_.text
            Protocol_ = self.gds_validate_string(Protocol_, node, 'Protocol')
            self.Protocol = Protocol_
        super(NatVmRuleType, self).buildChildren(child_, node, nodeName_, True)
# end class NatVmRuleType


class FirewallServiceType(NetworkServiceType):
    """Represents a network firewall service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, DefaultAction=None, LogDefaultAction=None, FirewallRule=None):
        self.original_tagname_ = None
        super(FirewallServiceType, self).__init__(VCloudExtension, IsEnabled, )
        self.DefaultAction = DefaultAction
        self.LogDefaultAction = LogDefaultAction
        if FirewallRule is None:
            self.FirewallRule = []
        else:
            self.FirewallRule = FirewallRule
    def factory(*args_, **kwargs_):
        if FirewallServiceType.subclass:
            return FirewallServiceType.subclass(*args_, **kwargs_)
        else:
            return FirewallServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DefaultAction(self): return self.DefaultAction
    def set_DefaultAction(self, DefaultAction): self.DefaultAction = DefaultAction
    def get_LogDefaultAction(self): return self.LogDefaultAction
    def set_LogDefaultAction(self, LogDefaultAction): self.LogDefaultAction = LogDefaultAction
    def get_FirewallRule(self): return self.FirewallRule
    def set_FirewallRule(self, FirewallRule): self.FirewallRule = FirewallRule
    def add_FirewallRule(self, value): self.FirewallRule.append(value)
    def insert_FirewallRule_at(self, index, value): self.FirewallRule.insert(index, value)
    def replace_FirewallRule_at(self, index, value): self.FirewallRule[index] = value
    def hasContent_(self):
        if (
            self.DefaultAction is not None or
            self.LogDefaultAction is not None or
            self.FirewallRule or
            super(FirewallServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FirewallServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FirewallServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirewallServiceType'):
        super(FirewallServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='FirewallServiceType', fromsubclass_=False, pretty_print=True):
        super(FirewallServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefaultAction>%s</%sDefaultAction>%s' % (namespace_, self.gds_format_string(quote_xml(self.DefaultAction).encode(ExternalEncoding), input_name='DefaultAction'), namespace_, eol_))
        if self.LogDefaultAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLogDefaultAction>%s</%sLogDefaultAction>%s' % (namespace_, self.gds_format_boolean(self.LogDefaultAction, input_name='LogDefaultAction'), namespace_, eol_))
        for FirewallRule_ in self.FirewallRule:
            FirewallRule_.export(outfile, level, namespace_, name_='FirewallRule', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FirewallServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FirewallServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FirewallServiceType, self).exportLiteralChildren(outfile, level, name_)
        if self.DefaultAction is not None:
            showIndent(outfile, level)
            outfile.write('DefaultAction=%s,\n' % quote_python(self.DefaultAction).encode(ExternalEncoding))
        if self.LogDefaultAction is not None:
            showIndent(outfile, level)
            outfile.write('LogDefaultAction=%s,\n' % self.LogDefaultAction)
        showIndent(outfile, level)
        outfile.write('FirewallRule=[\n')
        level += 1
        for FirewallRule_ in self.FirewallRule:
            showIndent(outfile, level)
            outfile.write('model_.FirewallRuleType(\n')
            FirewallRule_.exportLiteral(outfile, level, name_='FirewallRuleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FirewallServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DefaultAction':
            DefaultAction_ = child_.text
            DefaultAction_ = self.gds_validate_string(DefaultAction_, node, 'DefaultAction')
            self.DefaultAction = DefaultAction_
        elif nodeName_ == 'LogDefaultAction':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'LogDefaultAction')
            self.LogDefaultAction = ival_
        elif nodeName_ == 'FirewallRule':
            obj_ = FirewallRuleType.factory()
            obj_.build(child_)
            self.FirewallRule.append(obj_)
            obj_.original_tagname_ = 'FirewallRule'
        super(FirewallServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class FirewallServiceType


class VmSelectionType(VCloudExtensibleType):
    """5.1 Represents details of an vm+nic+iptype selection."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, VAppScopedVmId=None, VmNicId=None, IpType=None):
        self.original_tagname_ = None
        super(VmSelectionType, self).__init__(VCloudExtension, )
        self.VAppScopedVmId = VAppScopedVmId
        self.VmNicId = VmNicId
        self.IpType = IpType
    def factory(*args_, **kwargs_):
        if VmSelectionType.subclass:
            return VmSelectionType.subclass(*args_, **kwargs_)
        else:
            return VmSelectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VAppScopedVmId(self): return self.VAppScopedVmId
    def set_VAppScopedVmId(self, VAppScopedVmId): self.VAppScopedVmId = VAppScopedVmId
    def get_VmNicId(self): return self.VmNicId
    def set_VmNicId(self, VmNicId): self.VmNicId = VmNicId
    def get_IpType(self): return self.IpType
    def set_IpType(self, IpType): self.IpType = IpType
    def hasContent_(self):
        if (
            self.VAppScopedVmId is not None or
            self.VmNicId is not None or
            self.IpType is not None or
            super(VmSelectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmSelectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmSelectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmSelectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmSelectionType'):
        super(VmSelectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmSelectionType')
    def exportChildren(self, outfile, level, namespace_='', name_='VmSelectionType', fromsubclass_=False, pretty_print=True):
        super(VmSelectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VAppScopedVmId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVAppScopedVmId>%s</%sVAppScopedVmId>%s' % (namespace_, self.gds_format_string(quote_xml(self.VAppScopedVmId).encode(ExternalEncoding), input_name='VAppScopedVmId'), namespace_, eol_))
        if self.VmNicId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVmNicId>%s</%sVmNicId>%s' % (namespace_, self.gds_format_integer(self.VmNicId, input_name='VmNicId'), namespace_, eol_))
        if self.IpType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpType>%s</%sIpType>%s' % (namespace_, self.gds_format_string(quote_xml(self.IpType).encode(ExternalEncoding), input_name='IpType'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VmSelectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmSelectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmSelectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.VAppScopedVmId is not None:
            showIndent(outfile, level)
            outfile.write('VAppScopedVmId=%s,\n' % quote_python(self.VAppScopedVmId).encode(ExternalEncoding))
        if self.VmNicId is not None:
            showIndent(outfile, level)
            outfile.write('VmNicId=%d,\n' % self.VmNicId)
        if self.IpType is not None:
            showIndent(outfile, level)
            outfile.write('IpType=%s,\n' % quote_python(self.IpType).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VmSelectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VAppScopedVmId':
            VAppScopedVmId_ = child_.text
            VAppScopedVmId_ = self.gds_validate_string(VAppScopedVmId_, node, 'VAppScopedVmId')
            self.VAppScopedVmId = VAppScopedVmId_
        elif nodeName_ == 'VmNicId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VmNicId')
            self.VmNicId = ival_
        elif nodeName_ == 'IpType':
            IpType_ = child_.text
            IpType_ = self.gds_validate_string(IpType_, node, 'IpType')
            self.IpType = IpType_
        super(VmSelectionType, self).buildChildren(child_, node, nodeName_, True)
# end class VmSelectionType


class FirewallRuleType(VCloudExtensibleType):
    """0.9 Represents a firewall rule."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Id=None, IsEnabled=None, MatchOnTranslate=None, Description=None, Policy=None, Protocols=None, IcmpSubType=None, Port=None, DestinationPortRange=None, DestinationIp=None, DestinationVm=None, SourcePort=None, SourcePortRange=None, SourceIp=None, SourceVm=None, Direction=None, EnableLogging=None):
        self.original_tagname_ = None
        super(FirewallRuleType, self).__init__(VCloudExtension, )
        self.Id = Id
        self.IsEnabled = IsEnabled
        self.MatchOnTranslate = MatchOnTranslate
        self.Description = Description
        self.Policy = Policy
        self.Protocols = Protocols
        self.IcmpSubType = IcmpSubType
        self.Port = Port
        self.DestinationPortRange = DestinationPortRange
        self.DestinationIp = DestinationIp
        self.validate_FirewallIpAddressType(self.DestinationIp)
        self.DestinationVm = DestinationVm
        self.SourcePort = SourcePort
        self.SourcePortRange = SourcePortRange
        self.SourceIp = SourceIp
        self.validate_FirewallIpAddressType(self.SourceIp)
        self.SourceVm = SourceVm
        self.Direction = Direction
        self.EnableLogging = EnableLogging
    def factory(*args_, **kwargs_):
        if FirewallRuleType.subclass:
            return FirewallRuleType.subclass(*args_, **kwargs_)
        else:
            return FirewallRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_MatchOnTranslate(self): return self.MatchOnTranslate
    def set_MatchOnTranslate(self, MatchOnTranslate): self.MatchOnTranslate = MatchOnTranslate
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Policy(self): return self.Policy
    def set_Policy(self, Policy): self.Policy = Policy
    def get_Protocols(self): return self.Protocols
    def set_Protocols(self, Protocols): self.Protocols = Protocols
    def get_IcmpSubType(self): return self.IcmpSubType
    def set_IcmpSubType(self, IcmpSubType): self.IcmpSubType = IcmpSubType
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def get_DestinationPortRange(self): return self.DestinationPortRange
    def set_DestinationPortRange(self, DestinationPortRange): self.DestinationPortRange = DestinationPortRange
    def get_DestinationIp(self): return self.DestinationIp
    def set_DestinationIp(self, DestinationIp): self.DestinationIp = DestinationIp
    def get_DestinationVm(self): return self.DestinationVm
    def set_DestinationVm(self, DestinationVm): self.DestinationVm = DestinationVm
    def get_SourcePort(self): return self.SourcePort
    def set_SourcePort(self, SourcePort): self.SourcePort = SourcePort
    def get_SourcePortRange(self): return self.SourcePortRange
    def set_SourcePortRange(self, SourcePortRange): self.SourcePortRange = SourcePortRange
    def get_SourceIp(self): return self.SourceIp
    def set_SourceIp(self, SourceIp): self.SourceIp = SourceIp
    def get_SourceVm(self): return self.SourceVm
    def set_SourceVm(self, SourceVm): self.SourceVm = SourceVm
    def get_Direction(self): return self.Direction
    def set_Direction(self, Direction): self.Direction = Direction
    def get_EnableLogging(self): return self.EnableLogging
    def set_EnableLogging(self, EnableLogging): self.EnableLogging = EnableLogging
    def validate_FirewallIpAddressType(self, value):
        # Validate type FirewallIpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Id is not None or
            self.IsEnabled is not None or
            self.MatchOnTranslate is not None or
            self.Description is not None or
            self.Policy is not None or
            self.Protocols is not None or
            self.IcmpSubType is not None or
            self.Port is not None or
            self.DestinationPortRange is not None or
            self.DestinationIp is not None or
            self.DestinationVm is not None or
            self.SourcePort is not None or
            self.SourcePortRange is not None or
            self.SourceIp is not None or
            self.SourceVm is not None or
            self.Direction is not None or
            self.EnableLogging is not None or
            super(FirewallRuleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FirewallRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FirewallRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirewallRuleType'):
        super(FirewallRuleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallRuleType')
    def exportChildren(self, outfile, level, namespace_='', name_='FirewallRuleType', fromsubclass_=False, pretty_print=True):
        super(FirewallRuleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_, eol_))
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.MatchOnTranslate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMatchOnTranslate>%s</%sMatchOnTranslate>%s' % (namespace_, self.gds_format_boolean(self.MatchOnTranslate, input_name='MatchOnTranslate'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.Policy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPolicy>%s</%sPolicy>%s' % (namespace_, self.gds_format_string(quote_xml(self.Policy).encode(ExternalEncoding), input_name='Policy'), namespace_, eol_))
        if self.Protocols is not None:
            self.Protocols.export(outfile, level, namespace_, name_='Protocols', pretty_print=pretty_print)
        if self.IcmpSubType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIcmpSubType>%s</%sIcmpSubType>%s' % (namespace_, self.gds_format_string(quote_xml(self.IcmpSubType).encode(ExternalEncoding), input_name='IcmpSubType'), namespace_, eol_))
        if self.Port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPort>%s</%sPort>%s' % (namespace_, self.gds_format_integer(self.Port, input_name='Port'), namespace_, eol_))
        if self.DestinationPortRange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDestinationPortRange>%s</%sDestinationPortRange>%s' % (namespace_, self.gds_format_string(quote_xml(self.DestinationPortRange).encode(ExternalEncoding), input_name='DestinationPortRange'), namespace_, eol_))
        if self.DestinationIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDestinationIp>%s</%sDestinationIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.DestinationIp).encode(ExternalEncoding), input_name='DestinationIp'), namespace_, eol_))
        if self.DestinationVm is not None:
            self.DestinationVm.export(outfile, level, namespace_, name_='DestinationVm', pretty_print=pretty_print)
        if self.SourcePort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourcePort>%s</%sSourcePort>%s' % (namespace_, self.gds_format_integer(self.SourcePort, input_name='SourcePort'), namespace_, eol_))
        if self.SourcePortRange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourcePortRange>%s</%sSourcePortRange>%s' % (namespace_, self.gds_format_string(quote_xml(self.SourcePortRange).encode(ExternalEncoding), input_name='SourcePortRange'), namespace_, eol_))
        if self.SourceIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourceIp>%s</%sSourceIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.SourceIp).encode(ExternalEncoding), input_name='SourceIp'), namespace_, eol_))
        if self.SourceVm is not None:
            self.SourceVm.export(outfile, level, namespace_, name_='SourceVm', pretty_print=pretty_print)
        if self.Direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDirection>%s</%sDirection>%s' % (namespace_, self.gds_format_string(quote_xml(self.Direction).encode(ExternalEncoding), input_name='Direction'), namespace_, eol_))
        if self.EnableLogging is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnableLogging>%s</%sEnableLogging>%s' % (namespace_, self.gds_format_boolean(self.EnableLogging, input_name='EnableLogging'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='FirewallRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FirewallRuleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FirewallRuleType, self).exportLiteralChildren(outfile, level, name_)
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.MatchOnTranslate is not None:
            showIndent(outfile, level)
            outfile.write('MatchOnTranslate=%s,\n' % self.MatchOnTranslate)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Policy is not None:
            showIndent(outfile, level)
            outfile.write('Policy=%s,\n' % quote_python(self.Policy).encode(ExternalEncoding))
        if self.Protocols is not None:
            showIndent(outfile, level)
            outfile.write('Protocols=model_.ProtocolsType(\n')
            self.Protocols.exportLiteral(outfile, level, name_='Protocols')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IcmpSubType is not None:
            showIndent(outfile, level)
            outfile.write('IcmpSubType=%s,\n' % quote_python(self.IcmpSubType).encode(ExternalEncoding))
        if self.Port is not None:
            showIndent(outfile, level)
            outfile.write('Port=%d,\n' % self.Port)
        if self.DestinationPortRange is not None:
            showIndent(outfile, level)
            outfile.write('DestinationPortRange=%s,\n' % quote_python(self.DestinationPortRange).encode(ExternalEncoding))
        if self.DestinationIp is not None:
            showIndent(outfile, level)
            outfile.write('DestinationIp=%s,\n' % quote_python(self.DestinationIp).encode(ExternalEncoding))
        if self.DestinationVm is not None:
            showIndent(outfile, level)
            outfile.write('DestinationVm=model_.VmSelectionType(\n')
            self.DestinationVm.exportLiteral(outfile, level, name_='DestinationVm')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SourcePort is not None:
            showIndent(outfile, level)
            outfile.write('SourcePort=%d,\n' % self.SourcePort)
        if self.SourcePortRange is not None:
            showIndent(outfile, level)
            outfile.write('SourcePortRange=%s,\n' % quote_python(self.SourcePortRange).encode(ExternalEncoding))
        if self.SourceIp is not None:
            showIndent(outfile, level)
            outfile.write('SourceIp=%s,\n' % quote_python(self.SourceIp).encode(ExternalEncoding))
        if self.SourceVm is not None:
            showIndent(outfile, level)
            outfile.write('SourceVm=model_.VmSelectionType(\n')
            self.SourceVm.exportLiteral(outfile, level, name_='SourceVm')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Direction is not None:
            showIndent(outfile, level)
            outfile.write('Direction=%s,\n' % quote_python(self.Direction).encode(ExternalEncoding))
        if self.EnableLogging is not None:
            showIndent(outfile, level)
            outfile.write('EnableLogging=%s,\n' % self.EnableLogging)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FirewallRuleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'MatchOnTranslate':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'MatchOnTranslate')
            self.MatchOnTranslate = ival_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Policy':
            Policy_ = child_.text
            Policy_ = self.gds_validate_string(Policy_, node, 'Policy')
            self.Policy = Policy_
        elif nodeName_ == 'Protocols':
            obj_ = ProtocolsType.factory()
            obj_.build(child_)
            self.Protocols = obj_
            obj_.original_tagname_ = 'Protocols'
        elif nodeName_ == 'IcmpSubType':
            IcmpSubType_ = child_.text
            IcmpSubType_ = self.gds_validate_string(IcmpSubType_, node, 'IcmpSubType')
            self.IcmpSubType = IcmpSubType_
        elif nodeName_ == 'Port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Port')
            self.Port = ival_
        elif nodeName_ == 'DestinationPortRange':
            DestinationPortRange_ = child_.text
            DestinationPortRange_ = self.gds_validate_string(DestinationPortRange_, node, 'DestinationPortRange')
            self.DestinationPortRange = DestinationPortRange_
        elif nodeName_ == 'DestinationIp':
            DestinationIp_ = child_.text
            DestinationIp_ = self.gds_validate_string(DestinationIp_, node, 'DestinationIp')
            self.DestinationIp = DestinationIp_
            self.validate_FirewallIpAddressType(self.DestinationIp)    # validate type FirewallIpAddressType
        elif nodeName_ == 'DestinationVm':
            obj_ = VmSelectionType.factory()
            obj_.build(child_)
            self.DestinationVm = obj_
            obj_.original_tagname_ = 'DestinationVm'
        elif nodeName_ == 'SourcePort':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SourcePort')
            self.SourcePort = ival_
        elif nodeName_ == 'SourcePortRange':
            SourcePortRange_ = child_.text
            SourcePortRange_ = self.gds_validate_string(SourcePortRange_, node, 'SourcePortRange')
            self.SourcePortRange = SourcePortRange_
        elif nodeName_ == 'SourceIp':
            SourceIp_ = child_.text
            SourceIp_ = self.gds_validate_string(SourceIp_, node, 'SourceIp')
            self.SourceIp = SourceIp_
            self.validate_FirewallIpAddressType(self.SourceIp)    # validate type FirewallIpAddressType
        elif nodeName_ == 'SourceVm':
            obj_ = VmSelectionType.factory()
            obj_.build(child_)
            self.SourceVm = obj_
            obj_.original_tagname_ = 'SourceVm'
        elif nodeName_ == 'Direction':
            Direction_ = child_.text
            Direction_ = self.gds_validate_string(Direction_, node, 'Direction')
            self.Direction = Direction_
        elif nodeName_ == 'EnableLogging':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'EnableLogging')
            self.EnableLogging = ival_
        super(FirewallRuleType, self).buildChildren(child_, node, nodeName_, True)
# end class FirewallRuleType


class IpsecVpnServiceType(NetworkServiceType):
    """1.5 Represents an IPSec-VPN network service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, ExternalIpAddress=None, PublicIpAddress=None, IpsecVpnTunnel=None):
        self.original_tagname_ = None
        super(IpsecVpnServiceType, self).__init__(VCloudExtension, IsEnabled, )
        self.ExternalIpAddress = ExternalIpAddress
        self.validate_IpAddressType(self.ExternalIpAddress)
        self.PublicIpAddress = PublicIpAddress
        self.validate_IpAddressType(self.PublicIpAddress)
        if IpsecVpnTunnel is None:
            self.IpsecVpnTunnel = []
        else:
            self.IpsecVpnTunnel = IpsecVpnTunnel
    def factory(*args_, **kwargs_):
        if IpsecVpnServiceType.subclass:
            return IpsecVpnServiceType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalIpAddress(self): return self.ExternalIpAddress
    def set_ExternalIpAddress(self, ExternalIpAddress): self.ExternalIpAddress = ExternalIpAddress
    def get_PublicIpAddress(self): return self.PublicIpAddress
    def set_PublicIpAddress(self, PublicIpAddress): self.PublicIpAddress = PublicIpAddress
    def get_IpsecVpnTunnel(self): return self.IpsecVpnTunnel
    def set_IpsecVpnTunnel(self, IpsecVpnTunnel): self.IpsecVpnTunnel = IpsecVpnTunnel
    def add_IpsecVpnTunnel(self, value): self.IpsecVpnTunnel.append(value)
    def insert_IpsecVpnTunnel_at(self, index, value): self.IpsecVpnTunnel.insert(index, value)
    def replace_IpsecVpnTunnel_at(self, index, value): self.IpsecVpnTunnel[index] = value
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.ExternalIpAddress is not None or
            self.PublicIpAddress is not None or
            self.IpsecVpnTunnel or
            super(IpsecVpnServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnServiceType'):
        super(IpsecVpnServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnServiceType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIpAddress>%s</%sExternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIpAddress).encode(ExternalEncoding), input_name='ExternalIpAddress'), namespace_, eol_))
        if self.PublicIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPublicIpAddress>%s</%sPublicIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.PublicIpAddress).encode(ExternalEncoding), input_name='PublicIpAddress'), namespace_, eol_))
        for IpsecVpnTunnel_ in self.IpsecVpnTunnel:
            IpsecVpnTunnel_.export(outfile, level, namespace_, name_='IpsecVpnTunnel', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IpsecVpnServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnServiceType, self).exportLiteralChildren(outfile, level, name_)
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIpAddress=%s,\n' % quote_python(self.ExternalIpAddress).encode(ExternalEncoding))
        if self.PublicIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('PublicIpAddress=%s,\n' % quote_python(self.PublicIpAddress).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('IpsecVpnTunnel=[\n')
        level += 1
        for IpsecVpnTunnel_ in self.IpsecVpnTunnel:
            showIndent(outfile, level)
            outfile.write('model_.IpsecVpnTunnelType(\n')
            IpsecVpnTunnel_.exportLiteral(outfile, level, name_='IpsecVpnTunnelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpsecVpnServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalIpAddress':
            ExternalIpAddress_ = child_.text
            ExternalIpAddress_ = self.gds_validate_string(ExternalIpAddress_, node, 'ExternalIpAddress')
            self.ExternalIpAddress = ExternalIpAddress_
            self.validate_IpAddressType(self.ExternalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'PublicIpAddress':
            PublicIpAddress_ = child_.text
            PublicIpAddress_ = self.gds_validate_string(PublicIpAddress_, node, 'PublicIpAddress')
            self.PublicIpAddress = PublicIpAddress_
            self.validate_IpAddressType(self.PublicIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'IpsecVpnTunnel':
            obj_ = IpsecVpnTunnelType.factory()
            obj_.build(child_)
            self.IpsecVpnTunnel.append(obj_)
            obj_.original_tagname_ = 'IpsecVpnTunnel'
        super(IpsecVpnServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class IpsecVpnServiceType


class IpsecVpnTunnelType(VCloudExtensibleType):
    """1.5 Represents details of an IPSec-VPN tunnel."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Description=None, IpsecVpnPeer=None, PeerIpAddress=None, PeerNetworkAddress=None, PeerNetworkMask=None, SharedSecret=None, EncryptionProtocol=None, Mtu=None, IsEnabled=None, IsOperational=None, ErrorDetails=None):
        self.original_tagname_ = None
        super(IpsecVpnTunnelType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Description = Description
        self.IpsecVpnPeer = IpsecVpnPeer
        self.PeerIpAddress = PeerIpAddress
        self.validate_IpAddressType(self.PeerIpAddress)
        self.PeerNetworkAddress = PeerNetworkAddress
        self.validate_IpAddressType(self.PeerNetworkAddress)
        self.PeerNetworkMask = PeerNetworkMask
        self.validate_IpAddressType(self.PeerNetworkMask)
        self.SharedSecret = SharedSecret
        self.EncryptionProtocol = EncryptionProtocol
        self.Mtu = Mtu
        self.IsEnabled = IsEnabled
        self.IsOperational = IsOperational
        self.ErrorDetails = ErrorDetails
    def factory(*args_, **kwargs_):
        if IpsecVpnTunnelType.subclass:
            return IpsecVpnTunnelType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnTunnelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_IpsecVpnPeer(self): return self.IpsecVpnPeer
    def set_IpsecVpnPeer(self, IpsecVpnPeer): self.IpsecVpnPeer = IpsecVpnPeer
    def get_PeerIpAddress(self): return self.PeerIpAddress
    def set_PeerIpAddress(self, PeerIpAddress): self.PeerIpAddress = PeerIpAddress
    def get_PeerNetworkAddress(self): return self.PeerNetworkAddress
    def set_PeerNetworkAddress(self, PeerNetworkAddress): self.PeerNetworkAddress = PeerNetworkAddress
    def get_PeerNetworkMask(self): return self.PeerNetworkMask
    def set_PeerNetworkMask(self, PeerNetworkMask): self.PeerNetworkMask = PeerNetworkMask
    def get_SharedSecret(self): return self.SharedSecret
    def set_SharedSecret(self, SharedSecret): self.SharedSecret = SharedSecret
    def get_EncryptionProtocol(self): return self.EncryptionProtocol
    def set_EncryptionProtocol(self, EncryptionProtocol): self.EncryptionProtocol = EncryptionProtocol
    def get_Mtu(self): return self.Mtu
    def set_Mtu(self, Mtu): self.Mtu = Mtu
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_IsOperational(self): return self.IsOperational
    def set_IsOperational(self, IsOperational): self.IsOperational = IsOperational
    def get_ErrorDetails(self): return self.ErrorDetails
    def set_ErrorDetails(self, ErrorDetails): self.ErrorDetails = ErrorDetails
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Description is not None or
            self.IpsecVpnPeer is not None or
            self.PeerIpAddress is not None or
            self.PeerNetworkAddress is not None or
            self.PeerNetworkMask is not None or
            self.SharedSecret is not None or
            self.EncryptionProtocol is not None or
            self.Mtu is not None or
            self.IsEnabled is not None or
            self.IsOperational is not None or
            self.ErrorDetails is not None or
            super(IpsecVpnTunnelType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnTunnelType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnTunnelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnTunnelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnTunnelType'):
        super(IpsecVpnTunnelType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnTunnelType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnTunnelType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnTunnelType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.IpsecVpnPeer is not None:
            self.IpsecVpnPeer.export(outfile, level, namespace_, name_='IpsecVpnPeer', pretty_print=pretty_print)
        if self.PeerIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeerIpAddress>%s</%sPeerIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.PeerIpAddress).encode(ExternalEncoding), input_name='PeerIpAddress'), namespace_, eol_))
        if self.PeerNetworkAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeerNetworkAddress>%s</%sPeerNetworkAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.PeerNetworkAddress).encode(ExternalEncoding), input_name='PeerNetworkAddress'), namespace_, eol_))
        if self.PeerNetworkMask is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeerNetworkMask>%s</%sPeerNetworkMask>%s' % (namespace_, self.gds_format_string(quote_xml(self.PeerNetworkMask).encode(ExternalEncoding), input_name='PeerNetworkMask'), namespace_, eol_))
        if self.SharedSecret is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSharedSecret>%s</%sSharedSecret>%s' % (namespace_, self.gds_format_string(quote_xml(self.SharedSecret).encode(ExternalEncoding), input_name='SharedSecret'), namespace_, eol_))
        if self.EncryptionProtocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEncryptionProtocol>%s</%sEncryptionProtocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.EncryptionProtocol).encode(ExternalEncoding), input_name='EncryptionProtocol'), namespace_, eol_))
        if self.Mtu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMtu>%s</%sMtu>%s' % (namespace_, self.gds_format_integer(self.Mtu, input_name='Mtu'), namespace_, eol_))
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.IsOperational is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsOperational>%s</%sIsOperational>%s' % (namespace_, self.gds_format_boolean(self.IsOperational, input_name='IsOperational'), namespace_, eol_))
        if self.ErrorDetails is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sErrorDetails>%s</%sErrorDetails>%s' % (namespace_, self.gds_format_string(quote_xml(self.ErrorDetails).encode(ExternalEncoding), input_name='ErrorDetails'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IpsecVpnTunnelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnTunnelType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnTunnelType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.IpsecVpnPeer is not None:
            showIndent(outfile, level)
            outfile.write('IpsecVpnPeer=model_.IpsecVpnPeer(\n')
            self.IpsecVpnPeer.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PeerIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('PeerIpAddress=%s,\n' % quote_python(self.PeerIpAddress).encode(ExternalEncoding))
        if self.PeerNetworkAddress is not None:
            showIndent(outfile, level)
            outfile.write('PeerNetworkAddress=%s,\n' % quote_python(self.PeerNetworkAddress).encode(ExternalEncoding))
        if self.PeerNetworkMask is not None:
            showIndent(outfile, level)
            outfile.write('PeerNetworkMask=%s,\n' % quote_python(self.PeerNetworkMask).encode(ExternalEncoding))
        if self.SharedSecret is not None:
            showIndent(outfile, level)
            outfile.write('SharedSecret=%s,\n' % quote_python(self.SharedSecret).encode(ExternalEncoding))
        if self.EncryptionProtocol is not None:
            showIndent(outfile, level)
            outfile.write('EncryptionProtocol=%s,\n' % quote_python(self.EncryptionProtocol).encode(ExternalEncoding))
        if self.Mtu is not None:
            showIndent(outfile, level)
            outfile.write('Mtu=%d,\n' % self.Mtu)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.IsOperational is not None:
            showIndent(outfile, level)
            outfile.write('IsOperational=%s,\n' % self.IsOperational)
        if self.ErrorDetails is not None:
            showIndent(outfile, level)
            outfile.write('ErrorDetails=%s,\n' % quote_python(self.ErrorDetails).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpsecVpnTunnelType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'IpsecVpnPeer':
            class_obj_ = self.get_class_obj_(child_, IpsecVpnPeerType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnPeer'
        elif nodeName_ == 'IpsecVpnLocalPeer':
            obj_ = IpsecVpnLocalPeerType.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnLocalPeer'
        elif nodeName_ == 'IpsecVpnRemotePeer':
            obj_ = IpsecVpnRemotePeerType.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnRemotePeer'
        elif nodeName_ == 'IpsecVpnThirdPartyPeer':
            obj_ = IpsecVpnThirdPartyPeerType.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnThirdPartyPeer'
        elif nodeName_ == 'PeerIpAddress':
            PeerIpAddress_ = child_.text
            PeerIpAddress_ = self.gds_validate_string(PeerIpAddress_, node, 'PeerIpAddress')
            self.PeerIpAddress = PeerIpAddress_
            self.validate_IpAddressType(self.PeerIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'PeerNetworkAddress':
            PeerNetworkAddress_ = child_.text
            PeerNetworkAddress_ = self.gds_validate_string(PeerNetworkAddress_, node, 'PeerNetworkAddress')
            self.PeerNetworkAddress = PeerNetworkAddress_
            self.validate_IpAddressType(self.PeerNetworkAddress)    # validate type IpAddressType
        elif nodeName_ == 'PeerNetworkMask':
            PeerNetworkMask_ = child_.text
            PeerNetworkMask_ = self.gds_validate_string(PeerNetworkMask_, node, 'PeerNetworkMask')
            self.PeerNetworkMask = PeerNetworkMask_
            self.validate_IpAddressType(self.PeerNetworkMask)    # validate type IpAddressType
        elif nodeName_ == 'SharedSecret':
            SharedSecret_ = child_.text
            SharedSecret_ = self.gds_validate_string(SharedSecret_, node, 'SharedSecret')
            self.SharedSecret = SharedSecret_
        elif nodeName_ == 'EncryptionProtocol':
            EncryptionProtocol_ = child_.text
            EncryptionProtocol_ = self.gds_validate_string(EncryptionProtocol_, node, 'EncryptionProtocol')
            self.EncryptionProtocol = EncryptionProtocol_
        elif nodeName_ == 'Mtu':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Mtu')
            self.Mtu = ival_
        elif nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'IsOperational':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsOperational')
            self.IsOperational = ival_
        elif nodeName_ == 'ErrorDetails':
            ErrorDetails_ = child_.text
            ErrorDetails_ = self.gds_validate_string(ErrorDetails_, node, 'ErrorDetails')
            self.ErrorDetails = ErrorDetails_
        super(IpsecVpnTunnelType, self).buildChildren(child_, node, nodeName_, True)
# end class IpsecVpnTunnelType


class IpsecVpnPeerType(VCloudExtensibleType):
    """1.5 Gives more details of peer end point."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, extensiontype_=None):
        self.original_tagname_ = None
        super(IpsecVpnPeerType, self).__init__(VCloudExtension, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if IpsecVpnPeerType.subclass:
            return IpsecVpnPeerType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnPeerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(IpsecVpnPeerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnPeerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnPeerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnPeerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnPeerType'):
        super(IpsecVpnPeerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnPeerType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnPeerType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnPeerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IpsecVpnPeerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnPeerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnPeerType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IpsecVpnPeerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IpsecVpnPeerType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IpsecVpnPeerType


class IpsecVpnManagedPeerType(IpsecVpnPeerType):
    """1.5 Gives more details of peer end point."""
    subclass = None
    superclass = IpsecVpnPeerType
    def __init__(self, VCloudExtension=None, Id=None, Name=None, extensiontype_=None):
        self.original_tagname_ = None
        super(IpsecVpnManagedPeerType, self).__init__(VCloudExtension, extensiontype_, )
        self.Id = Id
        self.Name = Name
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if IpsecVpnManagedPeerType.subclass:
            return IpsecVpnManagedPeerType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnManagedPeerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Name is not None or
            super(IpsecVpnManagedPeerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnManagedPeerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnManagedPeerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnManagedPeerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnManagedPeerType'):
        super(IpsecVpnManagedPeerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnManagedPeerType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnManagedPeerType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnManagedPeerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IpsecVpnManagedPeerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnManagedPeerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnManagedPeerType, self).exportLiteralChildren(outfile, level, name_)
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IpsecVpnManagedPeerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        super(IpsecVpnManagedPeerType, self).buildChildren(child_, node, nodeName_, True)
# end class IpsecVpnManagedPeerType


class IpsecVpnLocalPeerType(IpsecVpnManagedPeerType):
    """1.5 Gives more details of local peer end point."""
    subclass = None
    superclass = IpsecVpnManagedPeerType
    def __init__(self, VCloudExtension=None, Id=None, Name=None):
        self.original_tagname_ = None
        super(IpsecVpnLocalPeerType, self).__init__(VCloudExtension, Id, Name, )
    def factory(*args_, **kwargs_):
        if IpsecVpnLocalPeerType.subclass:
            return IpsecVpnLocalPeerType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnLocalPeerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(IpsecVpnLocalPeerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnLocalPeerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnLocalPeerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnLocalPeerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnLocalPeerType'):
        super(IpsecVpnLocalPeerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnLocalPeerType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnLocalPeerType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnLocalPeerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IpsecVpnLocalPeerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnLocalPeerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnLocalPeerType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpsecVpnLocalPeerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IpsecVpnLocalPeerType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IpsecVpnLocalPeerType


class IpsecVpnRemotePeerType(IpsecVpnManagedPeerType):
    """1.5 Gives more details of remote peer end point."""
    subclass = None
    superclass = IpsecVpnManagedPeerType
    def __init__(self, VCloudExtension=None, Id=None, Name=None, VcdUrl=None, VcdOrganization=None, VcdUsername=None):
        self.original_tagname_ = None
        super(IpsecVpnRemotePeerType, self).__init__(VCloudExtension, Id, Name, )
        self.VcdUrl = VcdUrl
        self.VcdOrganization = VcdOrganization
        self.VcdUsername = VcdUsername
    def factory(*args_, **kwargs_):
        if IpsecVpnRemotePeerType.subclass:
            return IpsecVpnRemotePeerType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnRemotePeerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VcdUrl(self): return self.VcdUrl
    def set_VcdUrl(self, VcdUrl): self.VcdUrl = VcdUrl
    def get_VcdOrganization(self): return self.VcdOrganization
    def set_VcdOrganization(self, VcdOrganization): self.VcdOrganization = VcdOrganization
    def get_VcdUsername(self): return self.VcdUsername
    def set_VcdUsername(self, VcdUsername): self.VcdUsername = VcdUsername
    def hasContent_(self):
        if (
            self.VcdUrl is not None or
            self.VcdOrganization is not None or
            self.VcdUsername is not None or
            super(IpsecVpnRemotePeerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnRemotePeerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnRemotePeerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnRemotePeerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnRemotePeerType'):
        super(IpsecVpnRemotePeerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnRemotePeerType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnRemotePeerType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnRemotePeerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VcdUrl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVcdUrl>%s</%sVcdUrl>%s' % (namespace_, self.gds_format_string(quote_xml(self.VcdUrl).encode(ExternalEncoding), input_name='VcdUrl'), namespace_, eol_))
        if self.VcdOrganization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVcdOrganization>%s</%sVcdOrganization>%s' % (namespace_, self.gds_format_string(quote_xml(self.VcdOrganization).encode(ExternalEncoding), input_name='VcdOrganization'), namespace_, eol_))
        if self.VcdUsername is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVcdUsername>%s</%sVcdUsername>%s' % (namespace_, self.gds_format_string(quote_xml(self.VcdUsername).encode(ExternalEncoding), input_name='VcdUsername'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IpsecVpnRemotePeerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnRemotePeerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnRemotePeerType, self).exportLiteralChildren(outfile, level, name_)
        if self.VcdUrl is not None:
            showIndent(outfile, level)
            outfile.write('VcdUrl=%s,\n' % quote_python(self.VcdUrl).encode(ExternalEncoding))
        if self.VcdOrganization is not None:
            showIndent(outfile, level)
            outfile.write('VcdOrganization=%s,\n' % quote_python(self.VcdOrganization).encode(ExternalEncoding))
        if self.VcdUsername is not None:
            showIndent(outfile, level)
            outfile.write('VcdUsername=%s,\n' % quote_python(self.VcdUsername).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpsecVpnRemotePeerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VcdUrl':
            VcdUrl_ = child_.text
            VcdUrl_ = self.gds_validate_string(VcdUrl_, node, 'VcdUrl')
            self.VcdUrl = VcdUrl_
        elif nodeName_ == 'VcdOrganization':
            VcdOrganization_ = child_.text
            VcdOrganization_ = self.gds_validate_string(VcdOrganization_, node, 'VcdOrganization')
            self.VcdOrganization = VcdOrganization_
        elif nodeName_ == 'VcdUsername':
            VcdUsername_ = child_.text
            VcdUsername_ = self.gds_validate_string(VcdUsername_, node, 'VcdUsername')
            self.VcdUsername = VcdUsername_
        super(IpsecVpnRemotePeerType, self).buildChildren(child_, node, nodeName_, True)
# end class IpsecVpnRemotePeerType


class IpsecVpnUnmanagedPeerType(IpsecVpnPeerType):
    """1.5 Gives more details of peer end point not managed by vCloud
    Director."""
    subclass = None
    superclass = IpsecVpnPeerType
    def __init__(self, VCloudExtension=None, extensiontype_=None):
        self.original_tagname_ = None
        super(IpsecVpnUnmanagedPeerType, self).__init__(VCloudExtension, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if IpsecVpnUnmanagedPeerType.subclass:
            return IpsecVpnUnmanagedPeerType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnUnmanagedPeerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(IpsecVpnUnmanagedPeerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnUnmanagedPeerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnUnmanagedPeerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnUnmanagedPeerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnUnmanagedPeerType'):
        super(IpsecVpnUnmanagedPeerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnUnmanagedPeerType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnUnmanagedPeerType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnUnmanagedPeerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IpsecVpnUnmanagedPeerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnUnmanagedPeerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnUnmanagedPeerType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IpsecVpnUnmanagedPeerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IpsecVpnUnmanagedPeerType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IpsecVpnUnmanagedPeerType


class IpsecVpnThirdPartyPeerType(IpsecVpnUnmanagedPeerType):
    """1.5 Gives more details of third party peer end point."""
    subclass = None
    superclass = IpsecVpnUnmanagedPeerType
    def __init__(self, VCloudExtension=None, PeerId=None):
        self.original_tagname_ = None
        super(IpsecVpnThirdPartyPeerType, self).__init__(VCloudExtension, )
        self.PeerId = PeerId
    def factory(*args_, **kwargs_):
        if IpsecVpnThirdPartyPeerType.subclass:
            return IpsecVpnThirdPartyPeerType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnThirdPartyPeerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PeerId(self): return self.PeerId
    def set_PeerId(self, PeerId): self.PeerId = PeerId
    def hasContent_(self):
        if (
            self.PeerId is not None or
            super(IpsecVpnThirdPartyPeerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnThirdPartyPeerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnThirdPartyPeerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnThirdPartyPeerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnThirdPartyPeerType'):
        super(IpsecVpnThirdPartyPeerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnThirdPartyPeerType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnThirdPartyPeerType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnThirdPartyPeerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PeerId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeerId>%s</%sPeerId>%s' % (namespace_, self.gds_format_string(quote_xml(self.PeerId).encode(ExternalEncoding), input_name='PeerId'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IpsecVpnThirdPartyPeerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnThirdPartyPeerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnThirdPartyPeerType, self).exportLiteralChildren(outfile, level, name_)
        if self.PeerId is not None:
            showIndent(outfile, level)
            outfile.write('PeerId=%s,\n' % quote_python(self.PeerId).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpsecVpnThirdPartyPeerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PeerId':
            PeerId_ = child_.text
            PeerId_ = self.gds_validate_string(PeerId_, node, 'PeerId')
            self.PeerId = PeerId_
        super(IpsecVpnThirdPartyPeerType, self).buildChildren(child_, node, nodeName_, True)
# end class IpsecVpnThirdPartyPeerType


class StaticRoutingServiceType(NetworkServiceType):
    """1.5 Represents Static Routing network service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, StaticRoute=None):
        self.original_tagname_ = None
        super(StaticRoutingServiceType, self).__init__(VCloudExtension, IsEnabled, )
        if StaticRoute is None:
            self.StaticRoute = []
        else:
            self.StaticRoute = StaticRoute
    def factory(*args_, **kwargs_):
        if StaticRoutingServiceType.subclass:
            return StaticRoutingServiceType.subclass(*args_, **kwargs_)
        else:
            return StaticRoutingServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StaticRoute(self): return self.StaticRoute
    def set_StaticRoute(self, StaticRoute): self.StaticRoute = StaticRoute
    def add_StaticRoute(self, value): self.StaticRoute.append(value)
    def insert_StaticRoute_at(self, index, value): self.StaticRoute.insert(index, value)
    def replace_StaticRoute_at(self, index, value): self.StaticRoute[index] = value
    def hasContent_(self):
        if (
            self.StaticRoute or
            super(StaticRoutingServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StaticRoutingServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaticRoutingServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StaticRoutingServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StaticRoutingServiceType'):
        super(StaticRoutingServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StaticRoutingServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='StaticRoutingServiceType', fromsubclass_=False, pretty_print=True):
        super(StaticRoutingServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for StaticRoute_ in self.StaticRoute:
            StaticRoute_.export(outfile, level, namespace_, name_='StaticRoute', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StaticRoutingServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StaticRoutingServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StaticRoutingServiceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('StaticRoute=[\n')
        level += 1
        for StaticRoute_ in self.StaticRoute:
            showIndent(outfile, level)
            outfile.write('model_.StaticRouteType(\n')
            StaticRoute_.exportLiteral(outfile, level, name_='StaticRouteType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StaticRoutingServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StaticRoute':
            obj_ = StaticRouteType.factory()
            obj_.build(child_)
            self.StaticRoute.append(obj_)
            obj_.original_tagname_ = 'StaticRoute'
        super(StaticRoutingServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class StaticRoutingServiceType


class StaticRouteType(VCloudExtensibleType):
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Network=None, NextHopIp=None, Interface=None, GatewayInterface=None):
        self.original_tagname_ = None
        super(StaticRouteType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Network = Network
        self.NextHopIp = NextHopIp
        self.validate_IpAddressType(self.NextHopIp)
        self.Interface = Interface
        self.GatewayInterface = GatewayInterface
    def factory(*args_, **kwargs_):
        if StaticRouteType.subclass:
            return StaticRouteType.subclass(*args_, **kwargs_)
        else:
            return StaticRouteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Network(self): return self.Network
    def set_Network(self, Network): self.Network = Network
    def get_NextHopIp(self): return self.NextHopIp
    def set_NextHopIp(self, NextHopIp): self.NextHopIp = NextHopIp
    def get_Interface(self): return self.Interface
    def set_Interface(self, Interface): self.Interface = Interface
    def get_GatewayInterface(self): return self.GatewayInterface
    def set_GatewayInterface(self, GatewayInterface): self.GatewayInterface = GatewayInterface
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Network is not None or
            self.NextHopIp is not None or
            self.Interface is not None or
            self.GatewayInterface is not None or
            super(StaticRouteType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StaticRouteType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaticRouteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StaticRouteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StaticRouteType'):
        super(StaticRouteType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StaticRouteType')
    def exportChildren(self, outfile, level, namespace_='', name_='StaticRouteType', fromsubclass_=False, pretty_print=True):
        super(StaticRouteType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Network is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetwork>%s</%sNetwork>%s' % (namespace_, self.gds_format_string(quote_xml(self.Network).encode(ExternalEncoding), input_name='Network'), namespace_, eol_))
        if self.NextHopIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNextHopIp>%s</%sNextHopIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.NextHopIp).encode(ExternalEncoding), input_name='NextHopIp'), namespace_, eol_))
        if self.Interface is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInterface>%s</%sInterface>%s' % (namespace_, self.gds_format_string(quote_xml(self.Interface).encode(ExternalEncoding), input_name='Interface'), namespace_, eol_))
        if self.GatewayInterface is not None:
            self.GatewayInterface.export(outfile, level, namespace_, name_='GatewayInterface', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StaticRouteType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StaticRouteType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StaticRouteType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Network is not None:
            showIndent(outfile, level)
            outfile.write('Network=%s,\n' % quote_python(self.Network).encode(ExternalEncoding))
        if self.NextHopIp is not None:
            showIndent(outfile, level)
            outfile.write('NextHopIp=%s,\n' % quote_python(self.NextHopIp).encode(ExternalEncoding))
        if self.Interface is not None:
            showIndent(outfile, level)
            outfile.write('Interface=%s,\n' % quote_python(self.Interface).encode(ExternalEncoding))
        if self.GatewayInterface is not None:
            showIndent(outfile, level)
            outfile.write('GatewayInterface=model_.ReferenceType(\n')
            self.GatewayInterface.exportLiteral(outfile, level, name_='GatewayInterface')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StaticRouteType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Network':
            Network_ = child_.text
            Network_ = self.gds_validate_string(Network_, node, 'Network')
            self.Network = Network_
        elif nodeName_ == 'NextHopIp':
            NextHopIp_ = child_.text
            NextHopIp_ = self.gds_validate_string(NextHopIp_, node, 'NextHopIp')
            self.NextHopIp = NextHopIp_
            self.validate_IpAddressType(self.NextHopIp)    # validate type IpAddressType
        elif nodeName_ == 'Interface':
            Interface_ = child_.text
            Interface_ = self.gds_validate_string(Interface_, node, 'Interface')
            self.Interface = Interface_
        elif nodeName_ == 'GatewayInterface':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.GatewayInterface = obj_
            obj_.original_tagname_ = 'GatewayInterface'
        super(StaticRouteType, self).buildChildren(child_, node, nodeName_, True)
# end class StaticRouteType


class GatewayDhcpServiceType(NetworkServiceType):
    """5.1 Represents Gateway DHCP service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, Pool=None):
        self.original_tagname_ = None
        super(GatewayDhcpServiceType, self).__init__(VCloudExtension, IsEnabled, )
        if Pool is None:
            self.Pool = []
        else:
            self.Pool = Pool
    def factory(*args_, **kwargs_):
        if GatewayDhcpServiceType.subclass:
            return GatewayDhcpServiceType.subclass(*args_, **kwargs_)
        else:
            return GatewayDhcpServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Pool(self): return self.Pool
    def set_Pool(self, Pool): self.Pool = Pool
    def add_Pool(self, value): self.Pool.append(value)
    def insert_Pool_at(self, index, value): self.Pool.insert(index, value)
    def replace_Pool_at(self, index, value): self.Pool[index] = value
    def hasContent_(self):
        if (
            self.Pool or
            super(GatewayDhcpServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayDhcpServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayDhcpServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayDhcpServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayDhcpServiceType'):
        super(GatewayDhcpServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayDhcpServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayDhcpServiceType', fromsubclass_=False, pretty_print=True):
        super(GatewayDhcpServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Pool_ in self.Pool:
            Pool_.export(outfile, level, namespace_, name_='Pool', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GatewayDhcpServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayDhcpServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayDhcpServiceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Pool=[\n')
        level += 1
        for Pool_ in self.Pool:
            showIndent(outfile, level)
            outfile.write('model_.DhcpPoolServiceType(\n')
            Pool_.exportLiteral(outfile, level, name_='DhcpPoolServiceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayDhcpServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Pool':
            obj_ = DhcpPoolServiceType.factory()
            obj_.build(child_)
            self.Pool.append(obj_)
            obj_.original_tagname_ = 'Pool'
        super(GatewayDhcpServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayDhcpServiceType


class DhcpPoolServiceType(VCloudExtensibleType):
    """5.1 Represents DHCP pool service."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsEnabled=None, Network=None, DefaultLeaseTime=None, MaxLeaseTime=None, LowIpAddress=None, HighIpAddress=None):
        self.original_tagname_ = None
        super(DhcpPoolServiceType, self).__init__(VCloudExtension, )
        self.IsEnabled = IsEnabled
        self.Network = Network
        self.DefaultLeaseTime = DefaultLeaseTime
        self.MaxLeaseTime = MaxLeaseTime
        self.LowIpAddress = LowIpAddress
        self.validate_IpAddressType(self.LowIpAddress)
        self.HighIpAddress = HighIpAddress
        self.validate_IpAddressType(self.HighIpAddress)
    def factory(*args_, **kwargs_):
        if DhcpPoolServiceType.subclass:
            return DhcpPoolServiceType.subclass(*args_, **kwargs_)
        else:
            return DhcpPoolServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_Network(self): return self.Network
    def set_Network(self, Network): self.Network = Network
    def get_DefaultLeaseTime(self): return self.DefaultLeaseTime
    def set_DefaultLeaseTime(self, DefaultLeaseTime): self.DefaultLeaseTime = DefaultLeaseTime
    def get_MaxLeaseTime(self): return self.MaxLeaseTime
    def set_MaxLeaseTime(self, MaxLeaseTime): self.MaxLeaseTime = MaxLeaseTime
    def get_LowIpAddress(self): return self.LowIpAddress
    def set_LowIpAddress(self, LowIpAddress): self.LowIpAddress = LowIpAddress
    def get_HighIpAddress(self): return self.HighIpAddress
    def set_HighIpAddress(self, HighIpAddress): self.HighIpAddress = HighIpAddress
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.IsEnabled is not None or
            self.Network is not None or
            self.DefaultLeaseTime is not None or
            self.MaxLeaseTime is not None or
            self.LowIpAddress is not None or
            self.HighIpAddress is not None or
            super(DhcpPoolServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DhcpPoolServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DhcpPoolServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DhcpPoolServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DhcpPoolServiceType'):
        super(DhcpPoolServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DhcpPoolServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='DhcpPoolServiceType', fromsubclass_=False, pretty_print=True):
        super(DhcpPoolServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.Network is not None:
            self.Network.export(outfile, level, namespace_, name_='Network', pretty_print=pretty_print)
        if self.DefaultLeaseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefaultLeaseTime>%s</%sDefaultLeaseTime>%s' % (namespace_, self.gds_format_integer(self.DefaultLeaseTime, input_name='DefaultLeaseTime'), namespace_, eol_))
        if self.MaxLeaseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxLeaseTime>%s</%sMaxLeaseTime>%s' % (namespace_, self.gds_format_integer(self.MaxLeaseTime, input_name='MaxLeaseTime'), namespace_, eol_))
        if self.LowIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLowIpAddress>%s</%sLowIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.LowIpAddress).encode(ExternalEncoding), input_name='LowIpAddress'), namespace_, eol_))
        if self.HighIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHighIpAddress>%s</%sHighIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.HighIpAddress).encode(ExternalEncoding), input_name='HighIpAddress'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DhcpPoolServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DhcpPoolServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DhcpPoolServiceType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.Network is not None:
            showIndent(outfile, level)
            outfile.write('Network=model_.ReferenceType(\n')
            self.Network.exportLiteral(outfile, level, name_='Network')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DefaultLeaseTime is not None:
            showIndent(outfile, level)
            outfile.write('DefaultLeaseTime=%d,\n' % self.DefaultLeaseTime)
        if self.MaxLeaseTime is not None:
            showIndent(outfile, level)
            outfile.write('MaxLeaseTime=%d,\n' % self.MaxLeaseTime)
        if self.LowIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('LowIpAddress=%s,\n' % quote_python(self.LowIpAddress).encode(ExternalEncoding))
        if self.HighIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('HighIpAddress=%s,\n' % quote_python(self.HighIpAddress).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DhcpPoolServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'Network':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Network = obj_
            obj_.original_tagname_ = 'Network'
        elif nodeName_ == 'DefaultLeaseTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DefaultLeaseTime')
            self.DefaultLeaseTime = ival_
        elif nodeName_ == 'MaxLeaseTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaxLeaseTime')
            self.MaxLeaseTime = ival_
        elif nodeName_ == 'LowIpAddress':
            LowIpAddress_ = child_.text
            LowIpAddress_ = self.gds_validate_string(LowIpAddress_, node, 'LowIpAddress')
            self.LowIpAddress = LowIpAddress_
            self.validate_IpAddressType(self.LowIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'HighIpAddress':
            HighIpAddress_ = child_.text
            HighIpAddress_ = self.gds_validate_string(HighIpAddress_, node, 'HighIpAddress')
            self.HighIpAddress = HighIpAddress_
            self.validate_IpAddressType(self.HighIpAddress)    # validate type IpAddressType
        super(DhcpPoolServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class DhcpPoolServiceType


class LoadBalancerServiceType(NetworkServiceType):
    """5.1 Represents gateway load balancer service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, Pool=None, VirtualServer=None):
        self.original_tagname_ = None
        super(LoadBalancerServiceType, self).__init__(VCloudExtension, IsEnabled, )
        if Pool is None:
            self.Pool = []
        else:
            self.Pool = Pool
        if VirtualServer is None:
            self.VirtualServer = []
        else:
            self.VirtualServer = VirtualServer
    def factory(*args_, **kwargs_):
        if LoadBalancerServiceType.subclass:
            return LoadBalancerServiceType.subclass(*args_, **kwargs_)
        else:
            return LoadBalancerServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Pool(self): return self.Pool
    def set_Pool(self, Pool): self.Pool = Pool
    def add_Pool(self, value): self.Pool.append(value)
    def insert_Pool_at(self, index, value): self.Pool.insert(index, value)
    def replace_Pool_at(self, index, value): self.Pool[index] = value
    def get_VirtualServer(self): return self.VirtualServer
    def set_VirtualServer(self, VirtualServer): self.VirtualServer = VirtualServer
    def add_VirtualServer(self, value): self.VirtualServer.append(value)
    def insert_VirtualServer_at(self, index, value): self.VirtualServer.insert(index, value)
    def replace_VirtualServer_at(self, index, value): self.VirtualServer[index] = value
    def hasContent_(self):
        if (
            self.Pool or
            self.VirtualServer or
            super(LoadBalancerServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LoadBalancerServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadBalancerServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LoadBalancerServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LoadBalancerServiceType'):
        super(LoadBalancerServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LoadBalancerServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='LoadBalancerServiceType', fromsubclass_=False, pretty_print=True):
        super(LoadBalancerServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Pool_ in self.Pool:
            Pool_.export(outfile, level, namespace_, name_='Pool', pretty_print=pretty_print)
        for VirtualServer_ in self.VirtualServer:
            VirtualServer_.export(outfile, level, namespace_, name_='VirtualServer', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LoadBalancerServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LoadBalancerServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LoadBalancerServiceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Pool=[\n')
        level += 1
        for Pool_ in self.Pool:
            showIndent(outfile, level)
            outfile.write('model_.LoadBalancerPoolType(\n')
            Pool_.exportLiteral(outfile, level, name_='LoadBalancerPoolType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('VirtualServer=[\n')
        level += 1
        for VirtualServer_ in self.VirtualServer:
            showIndent(outfile, level)
            outfile.write('model_.LoadBalancerVirtualServerType(\n')
            VirtualServer_.exportLiteral(outfile, level, name_='LoadBalancerVirtualServerType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LoadBalancerServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Pool':
            obj_ = LoadBalancerPoolType.factory()
            obj_.build(child_)
            self.Pool.append(obj_)
            obj_.original_tagname_ = 'Pool'
        elif nodeName_ == 'VirtualServer':
            obj_ = LoadBalancerVirtualServerType.factory()
            obj_.build(child_)
            self.VirtualServer.append(obj_)
            obj_.original_tagname_ = 'VirtualServer'
        super(LoadBalancerServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class LoadBalancerServiceType


class LoadBalancerPoolType(VCloudExtensibleType):
    """5.1 Represents a load balancer pool."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Id=None, Name=None, Description=None, ServicePort=None, Member=None, Operational=None, ErrorDetails=None):
        self.original_tagname_ = None
        super(LoadBalancerPoolType, self).__init__(VCloudExtension, )
        self.Id = Id
        self.Name = Name
        self.Description = Description
        if ServicePort is None:
            self.ServicePort = []
        else:
            self.ServicePort = ServicePort
        if Member is None:
            self.Member = []
        else:
            self.Member = Member
        self.Operational = Operational
        self.ErrorDetails = ErrorDetails
    def factory(*args_, **kwargs_):
        if LoadBalancerPoolType.subclass:
            return LoadBalancerPoolType.subclass(*args_, **kwargs_)
        else:
            return LoadBalancerPoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ServicePort(self): return self.ServicePort
    def set_ServicePort(self, ServicePort): self.ServicePort = ServicePort
    def add_ServicePort(self, value): self.ServicePort.append(value)
    def insert_ServicePort_at(self, index, value): self.ServicePort.insert(index, value)
    def replace_ServicePort_at(self, index, value): self.ServicePort[index] = value
    def get_Member(self): return self.Member
    def set_Member(self, Member): self.Member = Member
    def add_Member(self, value): self.Member.append(value)
    def insert_Member_at(self, index, value): self.Member.insert(index, value)
    def replace_Member_at(self, index, value): self.Member[index] = value
    def get_Operational(self): return self.Operational
    def set_Operational(self, Operational): self.Operational = Operational
    def get_ErrorDetails(self): return self.ErrorDetails
    def set_ErrorDetails(self, ErrorDetails): self.ErrorDetails = ErrorDetails
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Name is not None or
            self.Description is not None or
            self.ServicePort or
            self.Member or
            self.Operational is not None or
            self.ErrorDetails is not None or
            super(LoadBalancerPoolType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LoadBalancerPoolType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadBalancerPoolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LoadBalancerPoolType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LoadBalancerPoolType'):
        super(LoadBalancerPoolType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LoadBalancerPoolType')
    def exportChildren(self, outfile, level, namespace_='', name_='LoadBalancerPoolType', fromsubclass_=False, pretty_print=True):
        super(LoadBalancerPoolType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        for ServicePort_ in self.ServicePort:
            ServicePort_.export(outfile, level, namespace_, name_='ServicePort', pretty_print=pretty_print)
        for Member_ in self.Member:
            Member_.export(outfile, level, namespace_, name_='Member', pretty_print=pretty_print)
        if self.Operational is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOperational>%s</%sOperational>%s' % (namespace_, self.gds_format_boolean(self.Operational, input_name='Operational'), namespace_, eol_))
        if self.ErrorDetails is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sErrorDetails>%s</%sErrorDetails>%s' % (namespace_, self.gds_format_string(quote_xml(self.ErrorDetails).encode(ExternalEncoding), input_name='ErrorDetails'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LoadBalancerPoolType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LoadBalancerPoolType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LoadBalancerPoolType, self).exportLiteralChildren(outfile, level, name_)
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ServicePort=[\n')
        level += 1
        for ServicePort_ in self.ServicePort:
            showIndent(outfile, level)
            outfile.write('model_.LBPoolServicePortType(\n')
            ServicePort_.exportLiteral(outfile, level, name_='LBPoolServicePortType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Member=[\n')
        level += 1
        for Member_ in self.Member:
            showIndent(outfile, level)
            outfile.write('model_.LBPoolMemberType(\n')
            Member_.exportLiteral(outfile, level, name_='LBPoolMemberType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Operational is not None:
            showIndent(outfile, level)
            outfile.write('Operational=%s,\n' % self.Operational)
        if self.ErrorDetails is not None:
            showIndent(outfile, level)
            outfile.write('ErrorDetails=%s,\n' % quote_python(self.ErrorDetails).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LoadBalancerPoolType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'ServicePort':
            obj_ = LBPoolServicePortType.factory()
            obj_.build(child_)
            self.ServicePort.append(obj_)
            obj_.original_tagname_ = 'ServicePort'
        elif nodeName_ == 'Member':
            obj_ = LBPoolMemberType.factory()
            obj_.build(child_)
            self.Member.append(obj_)
            obj_.original_tagname_ = 'Member'
        elif nodeName_ == 'Operational':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Operational')
            self.Operational = ival_
        elif nodeName_ == 'ErrorDetails':
            ErrorDetails_ = child_.text
            ErrorDetails_ = self.gds_validate_string(ErrorDetails_, node, 'ErrorDetails')
            self.ErrorDetails = ErrorDetails_
        super(LoadBalancerPoolType, self).buildChildren(child_, node, nodeName_, True)
# end class LoadBalancerPoolType


class LoadBalancerVirtualServerType(VCloudExtensibleType):
    """5.1 Represents a load balancer virtual server."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsEnabled=None, Name=None, Description=None, Interface=None, IpAddress=None, ServiceProfile=None, Logging=None, Pool=None, LoadBalancerTemplates=None):
        self.original_tagname_ = None
        super(LoadBalancerVirtualServerType, self).__init__(VCloudExtension, )
        self.IsEnabled = IsEnabled
        self.Name = Name
        self.Description = Description
        self.Interface = Interface
        self.IpAddress = IpAddress
        self.validate_IpAddressType(self.IpAddress)
        if ServiceProfile is None:
            self.ServiceProfile = []
        else:
            self.ServiceProfile = ServiceProfile
        self.Logging = Logging
        self.Pool = Pool
        if LoadBalancerTemplates is None:
            self.LoadBalancerTemplates = []
        else:
            self.LoadBalancerTemplates = LoadBalancerTemplates
    def factory(*args_, **kwargs_):
        if LoadBalancerVirtualServerType.subclass:
            return LoadBalancerVirtualServerType.subclass(*args_, **kwargs_)
        else:
            return LoadBalancerVirtualServerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Interface(self): return self.Interface
    def set_Interface(self, Interface): self.Interface = Interface
    def get_IpAddress(self): return self.IpAddress
    def set_IpAddress(self, IpAddress): self.IpAddress = IpAddress
    def get_ServiceProfile(self): return self.ServiceProfile
    def set_ServiceProfile(self, ServiceProfile): self.ServiceProfile = ServiceProfile
    def add_ServiceProfile(self, value): self.ServiceProfile.append(value)
    def insert_ServiceProfile_at(self, index, value): self.ServiceProfile.insert(index, value)
    def replace_ServiceProfile_at(self, index, value): self.ServiceProfile[index] = value
    def get_Logging(self): return self.Logging
    def set_Logging(self, Logging): self.Logging = Logging
    def get_Pool(self): return self.Pool
    def set_Pool(self, Pool): self.Pool = Pool
    def get_LoadBalancerTemplates(self): return self.LoadBalancerTemplates
    def set_LoadBalancerTemplates(self, LoadBalancerTemplates): self.LoadBalancerTemplates = LoadBalancerTemplates
    def add_LoadBalancerTemplates(self, value): self.LoadBalancerTemplates.append(value)
    def insert_LoadBalancerTemplates_at(self, index, value): self.LoadBalancerTemplates.insert(index, value)
    def replace_LoadBalancerTemplates_at(self, index, value): self.LoadBalancerTemplates[index] = value
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.IsEnabled is not None or
            self.Name is not None or
            self.Description is not None or
            self.Interface is not None or
            self.IpAddress is not None or
            self.ServiceProfile or
            self.Logging is not None or
            self.Pool is not None or
            self.LoadBalancerTemplates or
            super(LoadBalancerVirtualServerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LoadBalancerVirtualServerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadBalancerVirtualServerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LoadBalancerVirtualServerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LoadBalancerVirtualServerType'):
        super(LoadBalancerVirtualServerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LoadBalancerVirtualServerType')
    def exportChildren(self, outfile, level, namespace_='', name_='LoadBalancerVirtualServerType', fromsubclass_=False, pretty_print=True):
        super(LoadBalancerVirtualServerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.Interface is not None:
            self.Interface.export(outfile, level, namespace_, name_='Interface', pretty_print=pretty_print)
        if self.IpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpAddress>%s</%sIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IpAddress).encode(ExternalEncoding), input_name='IpAddress'), namespace_, eol_))
        for ServiceProfile_ in self.ServiceProfile:
            ServiceProfile_.export(outfile, level, namespace_, name_='ServiceProfile', pretty_print=pretty_print)
        if self.Logging is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLogging>%s</%sLogging>%s' % (namespace_, self.gds_format_boolean(self.Logging, input_name='Logging'), namespace_, eol_))
        if self.Pool is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPool>%s</%sPool>%s' % (namespace_, self.gds_format_string(quote_xml(self.Pool).encode(ExternalEncoding), input_name='Pool'), namespace_, eol_))
        for LoadBalancerTemplates_ in self.LoadBalancerTemplates:
            LoadBalancerTemplates_.export(outfile, level, namespace_, name_='LoadBalancerTemplates', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LoadBalancerVirtualServerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LoadBalancerVirtualServerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LoadBalancerVirtualServerType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Interface is not None:
            showIndent(outfile, level)
            outfile.write('Interface=model_.ReferenceType(\n')
            self.Interface.exportLiteral(outfile, level, name_='Interface')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IpAddress is not None:
            showIndent(outfile, level)
            outfile.write('IpAddress=%s,\n' % quote_python(self.IpAddress).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ServiceProfile=[\n')
        level += 1
        for ServiceProfile_ in self.ServiceProfile:
            showIndent(outfile, level)
            outfile.write('model_.LBVirtualServerServiceProfileType(\n')
            ServiceProfile_.exportLiteral(outfile, level, name_='LBVirtualServerServiceProfileType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Logging is not None:
            showIndent(outfile, level)
            outfile.write('Logging=%s,\n' % self.Logging)
        if self.Pool is not None:
            showIndent(outfile, level)
            outfile.write('Pool=%s,\n' % quote_python(self.Pool).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('LoadBalancerTemplates=[\n')
        level += 1
        for LoadBalancerTemplates_ in self.LoadBalancerTemplates:
            showIndent(outfile, level)
            outfile.write('model_.VendorTemplateType(\n')
            LoadBalancerTemplates_.exportLiteral(outfile, level, name_='VendorTemplateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LoadBalancerVirtualServerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Interface':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Interface = obj_
            obj_.original_tagname_ = 'Interface'
        elif nodeName_ == 'IpAddress':
            IpAddress_ = child_.text
            IpAddress_ = self.gds_validate_string(IpAddress_, node, 'IpAddress')
            self.IpAddress = IpAddress_
            self.validate_IpAddressType(self.IpAddress)    # validate type IpAddressType
        elif nodeName_ == 'ServiceProfile':
            obj_ = LBVirtualServerServiceProfileType.factory()
            obj_.build(child_)
            self.ServiceProfile.append(obj_)
            obj_.original_tagname_ = 'ServiceProfile'
        elif nodeName_ == 'Logging':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Logging')
            self.Logging = ival_
        elif nodeName_ == 'Pool':
            Pool_ = child_.text
            Pool_ = self.gds_validate_string(Pool_, node, 'Pool')
            self.Pool = Pool_
        elif nodeName_ == 'LoadBalancerTemplates':
            obj_ = VendorTemplateType.factory()
            obj_.build(child_)
            self.LoadBalancerTemplates.append(obj_)
            obj_.original_tagname_ = 'LoadBalancerTemplates'
        super(LoadBalancerVirtualServerType, self).buildChildren(child_, node, nodeName_, True)
# end class LoadBalancerVirtualServerType


class LBPoolServicePortType(VCloudExtensibleType):
    """5.1 Represents a service port in a load balancer pool."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsEnabled=None, Protocol=None, Algorithm=None, Port=None, HealthCheckPort=None, HealthCheck=None):
        self.original_tagname_ = None
        super(LBPoolServicePortType, self).__init__(VCloudExtension, )
        self.IsEnabled = IsEnabled
        self.Protocol = Protocol
        self.Algorithm = Algorithm
        self.Port = Port
        self.HealthCheckPort = HealthCheckPort
        if HealthCheck is None:
            self.HealthCheck = []
        else:
            self.HealthCheck = HealthCheck
    def factory(*args_, **kwargs_):
        if LBPoolServicePortType.subclass:
            return LBPoolServicePortType.subclass(*args_, **kwargs_)
        else:
            return LBPoolServicePortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_Protocol(self): return self.Protocol
    def set_Protocol(self, Protocol): self.Protocol = Protocol
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def get_HealthCheckPort(self): return self.HealthCheckPort
    def set_HealthCheckPort(self, HealthCheckPort): self.HealthCheckPort = HealthCheckPort
    def get_HealthCheck(self): return self.HealthCheck
    def set_HealthCheck(self, HealthCheck): self.HealthCheck = HealthCheck
    def add_HealthCheck(self, value): self.HealthCheck.append(value)
    def insert_HealthCheck_at(self, index, value): self.HealthCheck.insert(index, value)
    def replace_HealthCheck_at(self, index, value): self.HealthCheck[index] = value
    def hasContent_(self):
        if (
            self.IsEnabled is not None or
            self.Protocol is not None or
            self.Algorithm is not None or
            self.Port is not None or
            self.HealthCheckPort is not None or
            self.HealthCheck or
            super(LBPoolServicePortType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LBPoolServicePortType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LBPoolServicePortType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LBPoolServicePortType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LBPoolServicePortType'):
        super(LBPoolServicePortType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LBPoolServicePortType')
    def exportChildren(self, outfile, level, namespace_='', name_='LBPoolServicePortType', fromsubclass_=False, pretty_print=True):
        super(LBPoolServicePortType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.Protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol>%s</%sProtocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.Protocol).encode(ExternalEncoding), input_name='Protocol'), namespace_, eol_))
        if self.Algorithm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAlgorithm>%s</%sAlgorithm>%s' % (namespace_, self.gds_format_string(quote_xml(self.Algorithm).encode(ExternalEncoding), input_name='Algorithm'), namespace_, eol_))
        if self.Port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPort>%s</%sPort>%s' % (namespace_, self.gds_format_string(quote_xml(self.Port).encode(ExternalEncoding), input_name='Port'), namespace_, eol_))
        if self.HealthCheckPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHealthCheckPort>%s</%sHealthCheckPort>%s' % (namespace_, self.gds_format_string(quote_xml(self.HealthCheckPort).encode(ExternalEncoding), input_name='HealthCheckPort'), namespace_, eol_))
        for HealthCheck_ in self.HealthCheck:
            HealthCheck_.export(outfile, level, namespace_, name_='HealthCheck', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LBPoolServicePortType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LBPoolServicePortType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LBPoolServicePortType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.Protocol is not None:
            showIndent(outfile, level)
            outfile.write('Protocol=%s,\n' % quote_python(self.Protocol).encode(ExternalEncoding))
        if self.Algorithm is not None:
            showIndent(outfile, level)
            outfile.write('Algorithm=%s,\n' % quote_python(self.Algorithm).encode(ExternalEncoding))
        if self.Port is not None:
            showIndent(outfile, level)
            outfile.write('Port=%s,\n' % quote_python(self.Port).encode(ExternalEncoding))
        if self.HealthCheckPort is not None:
            showIndent(outfile, level)
            outfile.write('HealthCheckPort=%s,\n' % quote_python(self.HealthCheckPort).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('HealthCheck=[\n')
        level += 1
        for HealthCheck_ in self.HealthCheck:
            showIndent(outfile, level)
            outfile.write('model_.LBPoolHealthCheckType(\n')
            HealthCheck_.exportLiteral(outfile, level, name_='LBPoolHealthCheckType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LBPoolServicePortType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'Protocol':
            Protocol_ = child_.text
            Protocol_ = self.gds_validate_string(Protocol_, node, 'Protocol')
            self.Protocol = Protocol_
        elif nodeName_ == 'Algorithm':
            Algorithm_ = child_.text
            Algorithm_ = self.gds_validate_string(Algorithm_, node, 'Algorithm')
            self.Algorithm = Algorithm_
        elif nodeName_ == 'Port':
            Port_ = child_.text
            Port_ = self.gds_validate_string(Port_, node, 'Port')
            self.Port = Port_
        elif nodeName_ == 'HealthCheckPort':
            HealthCheckPort_ = child_.text
            HealthCheckPort_ = self.gds_validate_string(HealthCheckPort_, node, 'HealthCheckPort')
            self.HealthCheckPort = HealthCheckPort_
        elif nodeName_ == 'HealthCheck':
            obj_ = LBPoolHealthCheckType.factory()
            obj_.build(child_)
            self.HealthCheck.append(obj_)
            obj_.original_tagname_ = 'HealthCheck'
        super(LBPoolServicePortType, self).buildChildren(child_, node, nodeName_, True)
# end class LBPoolServicePortType


class LBVirtualServerServiceProfileType(VCloudExtensibleType):
    """5.1 Represents service profile for a load balancing virtual server."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsEnabled=None, Protocol=None, Port=None, Persistence=None):
        self.original_tagname_ = None
        super(LBVirtualServerServiceProfileType, self).__init__(VCloudExtension, )
        self.IsEnabled = IsEnabled
        self.Protocol = Protocol
        self.Port = Port
        self.Persistence = Persistence
    def factory(*args_, **kwargs_):
        if LBVirtualServerServiceProfileType.subclass:
            return LBVirtualServerServiceProfileType.subclass(*args_, **kwargs_)
        else:
            return LBVirtualServerServiceProfileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_Protocol(self): return self.Protocol
    def set_Protocol(self, Protocol): self.Protocol = Protocol
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def get_Persistence(self): return self.Persistence
    def set_Persistence(self, Persistence): self.Persistence = Persistence
    def hasContent_(self):
        if (
            self.IsEnabled is not None or
            self.Protocol is not None or
            self.Port is not None or
            self.Persistence is not None or
            super(LBVirtualServerServiceProfileType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LBVirtualServerServiceProfileType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LBVirtualServerServiceProfileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LBVirtualServerServiceProfileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LBVirtualServerServiceProfileType'):
        super(LBVirtualServerServiceProfileType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LBVirtualServerServiceProfileType')
    def exportChildren(self, outfile, level, namespace_='', name_='LBVirtualServerServiceProfileType', fromsubclass_=False, pretty_print=True):
        super(LBVirtualServerServiceProfileType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.Protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol>%s</%sProtocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.Protocol).encode(ExternalEncoding), input_name='Protocol'), namespace_, eol_))
        if self.Port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPort>%s</%sPort>%s' % (namespace_, self.gds_format_string(quote_xml(self.Port).encode(ExternalEncoding), input_name='Port'), namespace_, eol_))
        if self.Persistence is not None:
            self.Persistence.export(outfile, level, namespace_, name_='Persistence', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LBVirtualServerServiceProfileType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LBVirtualServerServiceProfileType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LBVirtualServerServiceProfileType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.Protocol is not None:
            showIndent(outfile, level)
            outfile.write('Protocol=%s,\n' % quote_python(self.Protocol).encode(ExternalEncoding))
        if self.Port is not None:
            showIndent(outfile, level)
            outfile.write('Port=%s,\n' % quote_python(self.Port).encode(ExternalEncoding))
        if self.Persistence is not None:
            showIndent(outfile, level)
            outfile.write('Persistence=model_.LBPersistenceType(\n')
            self.Persistence.exportLiteral(outfile, level, name_='Persistence')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LBVirtualServerServiceProfileType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'Protocol':
            Protocol_ = child_.text
            Protocol_ = self.gds_validate_string(Protocol_, node, 'Protocol')
            self.Protocol = Protocol_
        elif nodeName_ == 'Port':
            Port_ = child_.text
            Port_ = self.gds_validate_string(Port_, node, 'Port')
            self.Port = Port_
        elif nodeName_ == 'Persistence':
            obj_ = LBPersistenceType.factory()
            obj_.build(child_)
            self.Persistence = obj_
            obj_.original_tagname_ = 'Persistence'
        super(LBVirtualServerServiceProfileType, self).buildChildren(child_, node, nodeName_, True)
# end class LBVirtualServerServiceProfileType


class LBPersistenceType(VCloudExtensibleType):
    """5.1 Represents persistence type for a load balancer service profile."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Method=None, CookieName=None, CookieMode=None):
        self.original_tagname_ = None
        super(LBPersistenceType, self).__init__(VCloudExtension, )
        self.Method = Method
        self.CookieName = CookieName
        self.CookieMode = CookieMode
    def factory(*args_, **kwargs_):
        if LBPersistenceType.subclass:
            return LBPersistenceType.subclass(*args_, **kwargs_)
        else:
            return LBPersistenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Method(self): return self.Method
    def set_Method(self, Method): self.Method = Method
    def get_CookieName(self): return self.CookieName
    def set_CookieName(self, CookieName): self.CookieName = CookieName
    def get_CookieMode(self): return self.CookieMode
    def set_CookieMode(self, CookieMode): self.CookieMode = CookieMode
    def hasContent_(self):
        if (
            self.Method is not None or
            self.CookieName is not None or
            self.CookieMode is not None or
            super(LBPersistenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LBPersistenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LBPersistenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LBPersistenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LBPersistenceType'):
        super(LBPersistenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LBPersistenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='LBPersistenceType', fromsubclass_=False, pretty_print=True):
        super(LBPersistenceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Method is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMethod>%s</%sMethod>%s' % (namespace_, self.gds_format_string(quote_xml(self.Method).encode(ExternalEncoding), input_name='Method'), namespace_, eol_))
        if self.CookieName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCookieName>%s</%sCookieName>%s' % (namespace_, self.gds_format_string(quote_xml(self.CookieName).encode(ExternalEncoding), input_name='CookieName'), namespace_, eol_))
        if self.CookieMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCookieMode>%s</%sCookieMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CookieMode).encode(ExternalEncoding), input_name='CookieMode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LBPersistenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LBPersistenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LBPersistenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.Method is not None:
            showIndent(outfile, level)
            outfile.write('Method=%s,\n' % quote_python(self.Method).encode(ExternalEncoding))
        if self.CookieName is not None:
            showIndent(outfile, level)
            outfile.write('CookieName=%s,\n' % quote_python(self.CookieName).encode(ExternalEncoding))
        if self.CookieMode is not None:
            showIndent(outfile, level)
            outfile.write('CookieMode=%s,\n' % quote_python(self.CookieMode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LBPersistenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Method':
            Method_ = child_.text
            Method_ = self.gds_validate_string(Method_, node, 'Method')
            self.Method = Method_
        elif nodeName_ == 'CookieName':
            CookieName_ = child_.text
            CookieName_ = self.gds_validate_string(CookieName_, node, 'CookieName')
            self.CookieName = CookieName_
        elif nodeName_ == 'CookieMode':
            CookieMode_ = child_.text
            CookieMode_ = self.gds_validate_string(CookieMode_, node, 'CookieMode')
            self.CookieMode = CookieMode_
        super(LBPersistenceType, self).buildChildren(child_, node, nodeName_, True)
# end class LBPersistenceType


class LBPoolMemberType(VCloudExtensibleType):
    """5.1 Represents a member in a load balancer pool."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IpAddress=None, Weight=None, ServicePort=None):
        self.original_tagname_ = None
        super(LBPoolMemberType, self).__init__(VCloudExtension, )
        self.IpAddress = IpAddress
        self.validate_IpAddressType(self.IpAddress)
        self.Weight = Weight
        if ServicePort is None:
            self.ServicePort = []
        else:
            self.ServicePort = ServicePort
    def factory(*args_, **kwargs_):
        if LBPoolMemberType.subclass:
            return LBPoolMemberType.subclass(*args_, **kwargs_)
        else:
            return LBPoolMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IpAddress(self): return self.IpAddress
    def set_IpAddress(self, IpAddress): self.IpAddress = IpAddress
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_ServicePort(self): return self.ServicePort
    def set_ServicePort(self, ServicePort): self.ServicePort = ServicePort
    def add_ServicePort(self, value): self.ServicePort.append(value)
    def insert_ServicePort_at(self, index, value): self.ServicePort.insert(index, value)
    def replace_ServicePort_at(self, index, value): self.ServicePort[index] = value
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.IpAddress is not None or
            self.Weight is not None or
            self.ServicePort or
            super(LBPoolMemberType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LBPoolMemberType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LBPoolMemberType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LBPoolMemberType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LBPoolMemberType'):
        super(LBPoolMemberType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LBPoolMemberType')
    def exportChildren(self, outfile, level, namespace_='', name_='LBPoolMemberType', fromsubclass_=False, pretty_print=True):
        super(LBPoolMemberType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpAddress>%s</%sIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IpAddress).encode(ExternalEncoding), input_name='IpAddress'), namespace_, eol_))
        if self.Weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWeight>%s</%sWeight>%s' % (namespace_, self.gds_format_string(quote_xml(self.Weight).encode(ExternalEncoding), input_name='Weight'), namespace_, eol_))
        for ServicePort_ in self.ServicePort:
            ServicePort_.export(outfile, level, namespace_, name_='ServicePort', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LBPoolMemberType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LBPoolMemberType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LBPoolMemberType, self).exportLiteralChildren(outfile, level, name_)
        if self.IpAddress is not None:
            showIndent(outfile, level)
            outfile.write('IpAddress=%s,\n' % quote_python(self.IpAddress).encode(ExternalEncoding))
        if self.Weight is not None:
            showIndent(outfile, level)
            outfile.write('Weight=%s,\n' % quote_python(self.Weight).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ServicePort=[\n')
        level += 1
        for ServicePort_ in self.ServicePort:
            showIndent(outfile, level)
            outfile.write('model_.LBPoolServicePortType(\n')
            ServicePort_.exportLiteral(outfile, level, name_='LBPoolServicePortType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LBPoolMemberType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IpAddress':
            IpAddress_ = child_.text
            IpAddress_ = self.gds_validate_string(IpAddress_, node, 'IpAddress')
            self.IpAddress = IpAddress_
            self.validate_IpAddressType(self.IpAddress)    # validate type IpAddressType
        elif nodeName_ == 'Weight':
            Weight_ = child_.text
            Weight_ = self.gds_validate_string(Weight_, node, 'Weight')
            self.Weight = Weight_
        elif nodeName_ == 'ServicePort':
            obj_ = LBPoolServicePortType.factory()
            obj_.build(child_)
            self.ServicePort.append(obj_)
            obj_.original_tagname_ = 'ServicePort'
        super(LBPoolMemberType, self).buildChildren(child_, node, nodeName_, True)
# end class LBPoolMemberType


class LBPoolHealthCheckType(VCloudExtensibleType):
    """5.1 Represents a service port health check list."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Mode=None, Uri=None, HealthThreshold=None, UnhealthThreshold=None, Interval=None, Timeout=None):
        self.original_tagname_ = None
        super(LBPoolHealthCheckType, self).__init__(VCloudExtension, )
        self.Mode = Mode
        self.Uri = Uri
        self.HealthThreshold = HealthThreshold
        self.UnhealthThreshold = UnhealthThreshold
        self.Interval = Interval
        self.Timeout = Timeout
    def factory(*args_, **kwargs_):
        if LBPoolHealthCheckType.subclass:
            return LBPoolHealthCheckType.subclass(*args_, **kwargs_)
        else:
            return LBPoolHealthCheckType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Mode(self): return self.Mode
    def set_Mode(self, Mode): self.Mode = Mode
    def get_Uri(self): return self.Uri
    def set_Uri(self, Uri): self.Uri = Uri
    def get_HealthThreshold(self): return self.HealthThreshold
    def set_HealthThreshold(self, HealthThreshold): self.HealthThreshold = HealthThreshold
    def get_UnhealthThreshold(self): return self.UnhealthThreshold
    def set_UnhealthThreshold(self, UnhealthThreshold): self.UnhealthThreshold = UnhealthThreshold
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def get_Timeout(self): return self.Timeout
    def set_Timeout(self, Timeout): self.Timeout = Timeout
    def hasContent_(self):
        if (
            self.Mode is not None or
            self.Uri is not None or
            self.HealthThreshold is not None or
            self.UnhealthThreshold is not None or
            self.Interval is not None or
            self.Timeout is not None or
            super(LBPoolHealthCheckType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LBPoolHealthCheckType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LBPoolHealthCheckType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LBPoolHealthCheckType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LBPoolHealthCheckType'):
        super(LBPoolHealthCheckType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LBPoolHealthCheckType')
    def exportChildren(self, outfile, level, namespace_='', name_='LBPoolHealthCheckType', fromsubclass_=False, pretty_print=True):
        super(LBPoolHealthCheckType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMode>%s</%sMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.Mode).encode(ExternalEncoding), input_name='Mode'), namespace_, eol_))
        if self.Uri is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUri>%s</%sUri>%s' % (namespace_, self.gds_format_string(quote_xml(self.Uri).encode(ExternalEncoding), input_name='Uri'), namespace_, eol_))
        if self.HealthThreshold is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHealthThreshold>%s</%sHealthThreshold>%s' % (namespace_, self.gds_format_string(quote_xml(self.HealthThreshold).encode(ExternalEncoding), input_name='HealthThreshold'), namespace_, eol_))
        if self.UnhealthThreshold is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnhealthThreshold>%s</%sUnhealthThreshold>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnhealthThreshold).encode(ExternalEncoding), input_name='UnhealthThreshold'), namespace_, eol_))
        if self.Interval is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInterval>%s</%sInterval>%s' % (namespace_, self.gds_format_string(quote_xml(self.Interval).encode(ExternalEncoding), input_name='Interval'), namespace_, eol_))
        if self.Timeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeout>%s</%sTimeout>%s' % (namespace_, self.gds_format_string(quote_xml(self.Timeout).encode(ExternalEncoding), input_name='Timeout'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LBPoolHealthCheckType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LBPoolHealthCheckType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LBPoolHealthCheckType, self).exportLiteralChildren(outfile, level, name_)
        if self.Mode is not None:
            showIndent(outfile, level)
            outfile.write('Mode=%s,\n' % quote_python(self.Mode).encode(ExternalEncoding))
        if self.Uri is not None:
            showIndent(outfile, level)
            outfile.write('Uri=%s,\n' % quote_python(self.Uri).encode(ExternalEncoding))
        if self.HealthThreshold is not None:
            showIndent(outfile, level)
            outfile.write('HealthThreshold=%s,\n' % quote_python(self.HealthThreshold).encode(ExternalEncoding))
        if self.UnhealthThreshold is not None:
            showIndent(outfile, level)
            outfile.write('UnhealthThreshold=%s,\n' % quote_python(self.UnhealthThreshold).encode(ExternalEncoding))
        if self.Interval is not None:
            showIndent(outfile, level)
            outfile.write('Interval=%s,\n' % quote_python(self.Interval).encode(ExternalEncoding))
        if self.Timeout is not None:
            showIndent(outfile, level)
            outfile.write('Timeout=%s,\n' % quote_python(self.Timeout).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LBPoolHealthCheckType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Mode':
            Mode_ = child_.text
            Mode_ = self.gds_validate_string(Mode_, node, 'Mode')
            self.Mode = Mode_
        elif nodeName_ == 'Uri':
            Uri_ = child_.text
            Uri_ = self.gds_validate_string(Uri_, node, 'Uri')
            self.Uri = Uri_
        elif nodeName_ == 'HealthThreshold':
            HealthThreshold_ = child_.text
            HealthThreshold_ = self.gds_validate_string(HealthThreshold_, node, 'HealthThreshold')
            self.HealthThreshold = HealthThreshold_
        elif nodeName_ == 'UnhealthThreshold':
            UnhealthThreshold_ = child_.text
            UnhealthThreshold_ = self.gds_validate_string(UnhealthThreshold_, node, 'UnhealthThreshold')
            self.UnhealthThreshold = UnhealthThreshold_
        elif nodeName_ == 'Interval':
            Interval_ = child_.text
            Interval_ = self.gds_validate_string(Interval_, node, 'Interval')
            self.Interval = Interval_
        elif nodeName_ == 'Timeout':
            Timeout_ = child_.text
            Timeout_ = self.gds_validate_string(Timeout_, node, 'Timeout')
            self.Timeout = Timeout_
        super(LBPoolHealthCheckType, self).buildChildren(child_, node, nodeName_, True)
# end class LBPoolHealthCheckType


class GatewayIpsecVpnServiceType(NetworkServiceType):
    """5.1 Represents gateway IPsec VPN service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, Endpoint=None, Tunnel=None):
        self.original_tagname_ = None
        super(GatewayIpsecVpnServiceType, self).__init__(VCloudExtension, IsEnabled, )
        if Endpoint is None:
            self.Endpoint = []
        else:
            self.Endpoint = Endpoint
        if Tunnel is None:
            self.Tunnel = []
        else:
            self.Tunnel = Tunnel
    def factory(*args_, **kwargs_):
        if GatewayIpsecVpnServiceType.subclass:
            return GatewayIpsecVpnServiceType.subclass(*args_, **kwargs_)
        else:
            return GatewayIpsecVpnServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Endpoint(self): return self.Endpoint
    def set_Endpoint(self, Endpoint): self.Endpoint = Endpoint
    def add_Endpoint(self, value): self.Endpoint.append(value)
    def insert_Endpoint_at(self, index, value): self.Endpoint.insert(index, value)
    def replace_Endpoint_at(self, index, value): self.Endpoint[index] = value
    def get_Tunnel(self): return self.Tunnel
    def set_Tunnel(self, Tunnel): self.Tunnel = Tunnel
    def add_Tunnel(self, value): self.Tunnel.append(value)
    def insert_Tunnel_at(self, index, value): self.Tunnel.insert(index, value)
    def replace_Tunnel_at(self, index, value): self.Tunnel[index] = value
    def hasContent_(self):
        if (
            self.Endpoint or
            self.Tunnel or
            super(GatewayIpsecVpnServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayIpsecVpnServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayIpsecVpnServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayIpsecVpnServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayIpsecVpnServiceType'):
        super(GatewayIpsecVpnServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayIpsecVpnServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayIpsecVpnServiceType', fromsubclass_=False, pretty_print=True):
        super(GatewayIpsecVpnServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Endpoint_ in self.Endpoint:
            Endpoint_.export(outfile, level, namespace_, name_='Endpoint', pretty_print=pretty_print)
        for Tunnel_ in self.Tunnel:
            Tunnel_.export(outfile, level, namespace_, name_='Tunnel', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GatewayIpsecVpnServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayIpsecVpnServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayIpsecVpnServiceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Endpoint=[\n')
        level += 1
        for Endpoint_ in self.Endpoint:
            showIndent(outfile, level)
            outfile.write('model_.GatewayIpsecVpnEndpointType(\n')
            Endpoint_.exportLiteral(outfile, level, name_='GatewayIpsecVpnEndpointType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Tunnel=[\n')
        level += 1
        for Tunnel_ in self.Tunnel:
            showIndent(outfile, level)
            outfile.write('model_.GatewayIpsecVpnTunnelType(\n')
            Tunnel_.exportLiteral(outfile, level, name_='GatewayIpsecVpnTunnelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayIpsecVpnServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Endpoint':
            obj_ = GatewayIpsecVpnEndpointType.factory()
            obj_.build(child_)
            self.Endpoint.append(obj_)
            obj_.original_tagname_ = 'Endpoint'
        elif nodeName_ == 'Tunnel':
            obj_ = GatewayIpsecVpnTunnelType.factory()
            obj_.build(child_)
            self.Tunnel.append(obj_)
            obj_.original_tagname_ = 'Tunnel'
        super(GatewayIpsecVpnServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayIpsecVpnServiceType


class GatewayIpsecVpnEndpointType(VCloudExtensibleType):
    """5.1 Represents an IPSec VPN endpoint."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Network=None, PublicIp=None):
        self.original_tagname_ = None
        super(GatewayIpsecVpnEndpointType, self).__init__(VCloudExtension, )
        self.Network = Network
        self.PublicIp = PublicIp
        self.validate_IpAddressType(self.PublicIp)
    def factory(*args_, **kwargs_):
        if GatewayIpsecVpnEndpointType.subclass:
            return GatewayIpsecVpnEndpointType.subclass(*args_, **kwargs_)
        else:
            return GatewayIpsecVpnEndpointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Network(self): return self.Network
    def set_Network(self, Network): self.Network = Network
    def get_PublicIp(self): return self.PublicIp
    def set_PublicIp(self, PublicIp): self.PublicIp = PublicIp
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Network is not None or
            self.PublicIp is not None or
            super(GatewayIpsecVpnEndpointType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayIpsecVpnEndpointType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayIpsecVpnEndpointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayIpsecVpnEndpointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayIpsecVpnEndpointType'):
        super(GatewayIpsecVpnEndpointType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayIpsecVpnEndpointType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayIpsecVpnEndpointType', fromsubclass_=False, pretty_print=True):
        super(GatewayIpsecVpnEndpointType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Network is not None:
            self.Network.export(outfile, level, namespace_, name_='Network', pretty_print=pretty_print)
        if self.PublicIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPublicIp>%s</%sPublicIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.PublicIp).encode(ExternalEncoding), input_name='PublicIp'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GatewayIpsecVpnEndpointType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayIpsecVpnEndpointType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayIpsecVpnEndpointType, self).exportLiteralChildren(outfile, level, name_)
        if self.Network is not None:
            showIndent(outfile, level)
            outfile.write('Network=model_.ReferenceType(\n')
            self.Network.exportLiteral(outfile, level, name_='Network')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PublicIp is not None:
            showIndent(outfile, level)
            outfile.write('PublicIp=%s,\n' % quote_python(self.PublicIp).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayIpsecVpnEndpointType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Network':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Network = obj_
            obj_.original_tagname_ = 'Network'
        elif nodeName_ == 'PublicIp':
            PublicIp_ = child_.text
            PublicIp_ = self.gds_validate_string(PublicIp_, node, 'PublicIp')
            self.PublicIp = PublicIp_
            self.validate_IpAddressType(self.PublicIp)    # validate type IpAddressType
        super(GatewayIpsecVpnEndpointType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayIpsecVpnEndpointType


class GatewayIpsecVpnTunnelType(VCloudExtensibleType):
    """5.1 Represents an IPSec VPN tunnel."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Description=None, IpsecVpnPeer=None, PeerIpAddress=None, PeerId=None, LocalIpAddress=None, LocalId=None, LocalSubnet=None, PeerSubnet=None, SharedSecret=None, SharedSecretEncrypted=None, EncryptionProtocol=None, Mtu=None, IsEnabled=None, IsOperational=None, ErrorDetails=None):
        self.original_tagname_ = None
        super(GatewayIpsecVpnTunnelType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Description = Description
        self.IpsecVpnPeer = IpsecVpnPeer
        self.PeerIpAddress = PeerIpAddress
        self.validate_IpAddressType(self.PeerIpAddress)
        self.PeerId = PeerId
        self.LocalIpAddress = LocalIpAddress
        self.validate_IpAddressType(self.LocalIpAddress)
        self.LocalId = LocalId
        if LocalSubnet is None:
            self.LocalSubnet = []
        else:
            self.LocalSubnet = LocalSubnet
        if PeerSubnet is None:
            self.PeerSubnet = []
        else:
            self.PeerSubnet = PeerSubnet
        self.SharedSecret = SharedSecret
        self.SharedSecretEncrypted = SharedSecretEncrypted
        self.EncryptionProtocol = EncryptionProtocol
        self.Mtu = Mtu
        self.IsEnabled = IsEnabled
        self.IsOperational = IsOperational
        self.ErrorDetails = ErrorDetails
    def factory(*args_, **kwargs_):
        if GatewayIpsecVpnTunnelType.subclass:
            return GatewayIpsecVpnTunnelType.subclass(*args_, **kwargs_)
        else:
            return GatewayIpsecVpnTunnelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_IpsecVpnPeer(self): return self.IpsecVpnPeer
    def set_IpsecVpnPeer(self, IpsecVpnPeer): self.IpsecVpnPeer = IpsecVpnPeer
    def get_PeerIpAddress(self): return self.PeerIpAddress
    def set_PeerIpAddress(self, PeerIpAddress): self.PeerIpAddress = PeerIpAddress
    def get_PeerId(self): return self.PeerId
    def set_PeerId(self, PeerId): self.PeerId = PeerId
    def get_LocalIpAddress(self): return self.LocalIpAddress
    def set_LocalIpAddress(self, LocalIpAddress): self.LocalIpAddress = LocalIpAddress
    def get_LocalId(self): return self.LocalId
    def set_LocalId(self, LocalId): self.LocalId = LocalId
    def get_LocalSubnet(self): return self.LocalSubnet
    def set_LocalSubnet(self, LocalSubnet): self.LocalSubnet = LocalSubnet
    def add_LocalSubnet(self, value): self.LocalSubnet.append(value)
    def insert_LocalSubnet_at(self, index, value): self.LocalSubnet.insert(index, value)
    def replace_LocalSubnet_at(self, index, value): self.LocalSubnet[index] = value
    def get_PeerSubnet(self): return self.PeerSubnet
    def set_PeerSubnet(self, PeerSubnet): self.PeerSubnet = PeerSubnet
    def add_PeerSubnet(self, value): self.PeerSubnet.append(value)
    def insert_PeerSubnet_at(self, index, value): self.PeerSubnet.insert(index, value)
    def replace_PeerSubnet_at(self, index, value): self.PeerSubnet[index] = value
    def get_SharedSecret(self): return self.SharedSecret
    def set_SharedSecret(self, SharedSecret): self.SharedSecret = SharedSecret
    def get_SharedSecretEncrypted(self): return self.SharedSecretEncrypted
    def set_SharedSecretEncrypted(self, SharedSecretEncrypted): self.SharedSecretEncrypted = SharedSecretEncrypted
    def get_EncryptionProtocol(self): return self.EncryptionProtocol
    def set_EncryptionProtocol(self, EncryptionProtocol): self.EncryptionProtocol = EncryptionProtocol
    def get_Mtu(self): return self.Mtu
    def set_Mtu(self, Mtu): self.Mtu = Mtu
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_IsOperational(self): return self.IsOperational
    def set_IsOperational(self, IsOperational): self.IsOperational = IsOperational
    def get_ErrorDetails(self): return self.ErrorDetails
    def set_ErrorDetails(self, ErrorDetails): self.ErrorDetails = ErrorDetails
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Description is not None or
            self.IpsecVpnPeer is not None or
            self.PeerIpAddress is not None or
            self.PeerId is not None or
            self.LocalIpAddress is not None or
            self.LocalId is not None or
            self.LocalSubnet or
            self.PeerSubnet or
            self.SharedSecret is not None or
            self.SharedSecretEncrypted is not None or
            self.EncryptionProtocol is not None or
            self.Mtu is not None or
            self.IsEnabled is not None or
            self.IsOperational is not None or
            self.ErrorDetails is not None or
            super(GatewayIpsecVpnTunnelType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayIpsecVpnTunnelType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayIpsecVpnTunnelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayIpsecVpnTunnelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayIpsecVpnTunnelType'):
        super(GatewayIpsecVpnTunnelType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayIpsecVpnTunnelType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayIpsecVpnTunnelType', fromsubclass_=False, pretty_print=True):
        super(GatewayIpsecVpnTunnelType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.IpsecVpnPeer is not None:
            self.IpsecVpnPeer.export(outfile, level, namespace_, name_='IpsecVpnPeer', pretty_print=pretty_print)
        if self.PeerIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeerIpAddress>%s</%sPeerIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.PeerIpAddress).encode(ExternalEncoding), input_name='PeerIpAddress'), namespace_, eol_))
        if self.PeerId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeerId>%s</%sPeerId>%s' % (namespace_, self.gds_format_string(quote_xml(self.PeerId).encode(ExternalEncoding), input_name='PeerId'), namespace_, eol_))
        if self.LocalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocalIpAddress>%s</%sLocalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.LocalIpAddress).encode(ExternalEncoding), input_name='LocalIpAddress'), namespace_, eol_))
        if self.LocalId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocalId>%s</%sLocalId>%s' % (namespace_, self.gds_format_string(quote_xml(self.LocalId).encode(ExternalEncoding), input_name='LocalId'), namespace_, eol_))
        for LocalSubnet_ in self.LocalSubnet:
            LocalSubnet_.export(outfile, level, namespace_, name_='LocalSubnet', pretty_print=pretty_print)
        for PeerSubnet_ in self.PeerSubnet:
            PeerSubnet_.export(outfile, level, namespace_, name_='PeerSubnet', pretty_print=pretty_print)
        if self.SharedSecret is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSharedSecret>%s</%sSharedSecret>%s' % (namespace_, self.gds_format_string(quote_xml(self.SharedSecret).encode(ExternalEncoding), input_name='SharedSecret'), namespace_, eol_))
        if self.SharedSecretEncrypted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSharedSecretEncrypted>%s</%sSharedSecretEncrypted>%s' % (namespace_, self.gds_format_boolean(self.SharedSecretEncrypted, input_name='SharedSecretEncrypted'), namespace_, eol_))
        if self.EncryptionProtocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEncryptionProtocol>%s</%sEncryptionProtocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.EncryptionProtocol).encode(ExternalEncoding), input_name='EncryptionProtocol'), namespace_, eol_))
        if self.Mtu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMtu>%s</%sMtu>%s' % (namespace_, self.gds_format_integer(self.Mtu, input_name='Mtu'), namespace_, eol_))
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.IsOperational is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsOperational>%s</%sIsOperational>%s' % (namespace_, self.gds_format_boolean(self.IsOperational, input_name='IsOperational'), namespace_, eol_))
        if self.ErrorDetails is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sErrorDetails>%s</%sErrorDetails>%s' % (namespace_, self.gds_format_string(quote_xml(self.ErrorDetails).encode(ExternalEncoding), input_name='ErrorDetails'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GatewayIpsecVpnTunnelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayIpsecVpnTunnelType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayIpsecVpnTunnelType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.IpsecVpnPeer is not None:
            showIndent(outfile, level)
            outfile.write('IpsecVpnPeer=model_.IpsecVpnPeer(\n')
            self.IpsecVpnPeer.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PeerIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('PeerIpAddress=%s,\n' % quote_python(self.PeerIpAddress).encode(ExternalEncoding))
        if self.PeerId is not None:
            showIndent(outfile, level)
            outfile.write('PeerId=%s,\n' % quote_python(self.PeerId).encode(ExternalEncoding))
        if self.LocalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('LocalIpAddress=%s,\n' % quote_python(self.LocalIpAddress).encode(ExternalEncoding))
        if self.LocalId is not None:
            showIndent(outfile, level)
            outfile.write('LocalId=%s,\n' % quote_python(self.LocalId).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('LocalSubnet=[\n')
        level += 1
        for LocalSubnet_ in self.LocalSubnet:
            showIndent(outfile, level)
            outfile.write('model_.IpsecVpnSubnetType(\n')
            LocalSubnet_.exportLiteral(outfile, level, name_='IpsecVpnSubnetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PeerSubnet=[\n')
        level += 1
        for PeerSubnet_ in self.PeerSubnet:
            showIndent(outfile, level)
            outfile.write('model_.IpsecVpnSubnetType(\n')
            PeerSubnet_.exportLiteral(outfile, level, name_='IpsecVpnSubnetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SharedSecret is not None:
            showIndent(outfile, level)
            outfile.write('SharedSecret=%s,\n' % quote_python(self.SharedSecret).encode(ExternalEncoding))
        if self.SharedSecretEncrypted is not None:
            showIndent(outfile, level)
            outfile.write('SharedSecretEncrypted=%s,\n' % self.SharedSecretEncrypted)
        if self.EncryptionProtocol is not None:
            showIndent(outfile, level)
            outfile.write('EncryptionProtocol=%s,\n' % quote_python(self.EncryptionProtocol).encode(ExternalEncoding))
        if self.Mtu is not None:
            showIndent(outfile, level)
            outfile.write('Mtu=%d,\n' % self.Mtu)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.IsOperational is not None:
            showIndent(outfile, level)
            outfile.write('IsOperational=%s,\n' % self.IsOperational)
        if self.ErrorDetails is not None:
            showIndent(outfile, level)
            outfile.write('ErrorDetails=%s,\n' % quote_python(self.ErrorDetails).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayIpsecVpnTunnelType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'IpsecVpnPeer':
            class_obj_ = self.get_class_obj_(child_, IpsecVpnPeerType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnPeer'
        elif nodeName_ == 'IpsecVpnLocalPeer':
            obj_ = IpsecVpnLocalPeerType.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnLocalPeer'
        elif nodeName_ == 'IpsecVpnRemotePeer':
            obj_ = IpsecVpnRemotePeerType.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnRemotePeer'
        elif nodeName_ == 'IpsecVpnThirdPartyPeer':
            obj_ = IpsecVpnThirdPartyPeerType.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnThirdPartyPeer'
        elif nodeName_ == 'PeerIpAddress':
            PeerIpAddress_ = child_.text
            PeerIpAddress_ = self.gds_validate_string(PeerIpAddress_, node, 'PeerIpAddress')
            self.PeerIpAddress = PeerIpAddress_
            self.validate_IpAddressType(self.PeerIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'PeerId':
            PeerId_ = child_.text
            PeerId_ = self.gds_validate_string(PeerId_, node, 'PeerId')
            self.PeerId = PeerId_
        elif nodeName_ == 'LocalIpAddress':
            LocalIpAddress_ = child_.text
            LocalIpAddress_ = self.gds_validate_string(LocalIpAddress_, node, 'LocalIpAddress')
            self.LocalIpAddress = LocalIpAddress_
            self.validate_IpAddressType(self.LocalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'LocalId':
            LocalId_ = child_.text
            LocalId_ = self.gds_validate_string(LocalId_, node, 'LocalId')
            self.LocalId = LocalId_
        elif nodeName_ == 'LocalSubnet':
            obj_ = IpsecVpnSubnetType.factory()
            obj_.build(child_)
            self.LocalSubnet.append(obj_)
            obj_.original_tagname_ = 'LocalSubnet'
        elif nodeName_ == 'PeerSubnet':
            obj_ = IpsecVpnSubnetType.factory()
            obj_.build(child_)
            self.PeerSubnet.append(obj_)
            obj_.original_tagname_ = 'PeerSubnet'
        elif nodeName_ == 'SharedSecret':
            SharedSecret_ = child_.text
            SharedSecret_ = self.gds_validate_string(SharedSecret_, node, 'SharedSecret')
            self.SharedSecret = SharedSecret_
        elif nodeName_ == 'SharedSecretEncrypted':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SharedSecretEncrypted')
            self.SharedSecretEncrypted = ival_
        elif nodeName_ == 'EncryptionProtocol':
            EncryptionProtocol_ = child_.text
            EncryptionProtocol_ = self.gds_validate_string(EncryptionProtocol_, node, 'EncryptionProtocol')
            self.EncryptionProtocol = EncryptionProtocol_
        elif nodeName_ == 'Mtu':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Mtu')
            self.Mtu = ival_
        elif nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'IsOperational':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsOperational')
            self.IsOperational = ival_
        elif nodeName_ == 'ErrorDetails':
            ErrorDetails_ = child_.text
            ErrorDetails_ = self.gds_validate_string(ErrorDetails_, node, 'ErrorDetails')
            self.ErrorDetails = ErrorDetails_
        super(GatewayIpsecVpnTunnelType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayIpsecVpnTunnelType


class IpsecVpnSubnetType(VCloudExtensibleType):
    """5.1 Represents subnet details."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Gateway=None, Netmask=None):
        self.original_tagname_ = None
        super(IpsecVpnSubnetType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Gateway = Gateway
        self.validate_IpAddressType(self.Gateway)
        self.Netmask = Netmask
        self.validate_IpAddressType(self.Netmask)
    def factory(*args_, **kwargs_):
        if IpsecVpnSubnetType.subclass:
            return IpsecVpnSubnetType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnSubnetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Gateway(self): return self.Gateway
    def set_Gateway(self, Gateway): self.Gateway = Gateway
    def get_Netmask(self): return self.Netmask
    def set_Netmask(self, Netmask): self.Netmask = Netmask
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Gateway is not None or
            self.Netmask is not None or
            super(IpsecVpnSubnetType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnSubnetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnSubnetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnSubnetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnSubnetType'):
        super(IpsecVpnSubnetType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnSubnetType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnSubnetType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnSubnetType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Gateway is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGateway>%s</%sGateway>%s' % (namespace_, self.gds_format_string(quote_xml(self.Gateway).encode(ExternalEncoding), input_name='Gateway'), namespace_, eol_))
        if self.Netmask is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetmask>%s</%sNetmask>%s' % (namespace_, self.gds_format_string(quote_xml(self.Netmask).encode(ExternalEncoding), input_name='Netmask'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IpsecVpnSubnetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnSubnetType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnSubnetType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Gateway is not None:
            showIndent(outfile, level)
            outfile.write('Gateway=%s,\n' % quote_python(self.Gateway).encode(ExternalEncoding))
        if self.Netmask is not None:
            showIndent(outfile, level)
            outfile.write('Netmask=%s,\n' % quote_python(self.Netmask).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpsecVpnSubnetType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Gateway':
            Gateway_ = child_.text
            Gateway_ = self.gds_validate_string(Gateway_, node, 'Gateway')
            self.Gateway = Gateway_
            self.validate_IpAddressType(self.Gateway)    # validate type IpAddressType
        elif nodeName_ == 'Netmask':
            Netmask_ = child_.text
            Netmask_ = self.gds_validate_string(Netmask_, node, 'Netmask')
            self.Netmask = Netmask_
            self.validate_IpAddressType(self.Netmask)    # validate type IpAddressType
        super(IpsecVpnSubnetType, self).buildChildren(child_, node, nodeName_, True)
# end class IpsecVpnSubnetType


class NetworkConfigurationType(VCloudExtensibleType):
    """0.9 The configurations applied to a network. This is an abstract
    base type. The concrete types include those for vApp and
    Organization wide networks."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, BackwardCompatibilityMode=None, IpScope=None, IpScopes=None, ParentNetwork=None, FenceMode=None, RetainNetInfoAcrossDeployments=None, Features=None, SyslogServerSettings=None, RouterInfo=None):
        self.original_tagname_ = None
        super(NetworkConfigurationType, self).__init__(VCloudExtension, )
        self.BackwardCompatibilityMode = BackwardCompatibilityMode
        self.IpScope = IpScope
        self.IpScopes = IpScopes
        self.ParentNetwork = ParentNetwork
        self.FenceMode = FenceMode
        self.RetainNetInfoAcrossDeployments = RetainNetInfoAcrossDeployments
        self.Features = Features
        self.SyslogServerSettings = SyslogServerSettings
        self.RouterInfo = RouterInfo
    def factory(*args_, **kwargs_):
        if NetworkConfigurationType.subclass:
            return NetworkConfigurationType.subclass(*args_, **kwargs_)
        else:
            return NetworkConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BackwardCompatibilityMode(self): return self.BackwardCompatibilityMode
    def set_BackwardCompatibilityMode(self, BackwardCompatibilityMode): self.BackwardCompatibilityMode = BackwardCompatibilityMode
    def get_IpScope(self): return self.IpScope
    def set_IpScope(self, IpScope): self.IpScope = IpScope
    def get_IpScopes(self): return self.IpScopes
    def set_IpScopes(self, IpScopes): self.IpScopes = IpScopes
    def get_ParentNetwork(self): return self.ParentNetwork
    def set_ParentNetwork(self, ParentNetwork): self.ParentNetwork = ParentNetwork
    def get_FenceMode(self): return self.FenceMode
    def set_FenceMode(self, FenceMode): self.FenceMode = FenceMode
    def get_RetainNetInfoAcrossDeployments(self): return self.RetainNetInfoAcrossDeployments
    def set_RetainNetInfoAcrossDeployments(self, RetainNetInfoAcrossDeployments): self.RetainNetInfoAcrossDeployments = RetainNetInfoAcrossDeployments
    def get_Features(self): return self.Features
    def set_Features(self, Features): self.Features = Features
    def get_SyslogServerSettings(self): return self.SyslogServerSettings
    def set_SyslogServerSettings(self, SyslogServerSettings): self.SyslogServerSettings = SyslogServerSettings
    def get_RouterInfo(self): return self.RouterInfo
    def set_RouterInfo(self, RouterInfo): self.RouterInfo = RouterInfo
    def hasContent_(self):
        if (
            self.BackwardCompatibilityMode is not None or
            self.IpScope is not None or
            self.IpScopes is not None or
            self.ParentNetwork is not None or
            self.FenceMode is not None or
            self.RetainNetInfoAcrossDeployments is not None or
            self.Features is not None or
            self.SyslogServerSettings is not None or
            self.RouterInfo is not None or
            super(NetworkConfigurationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkConfigurationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConfigurationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkConfigurationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkConfigurationType'):
        super(NetworkConfigurationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConfigurationType')
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkConfigurationType', fromsubclass_=False, pretty_print=True):
        super(NetworkConfigurationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BackwardCompatibilityMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBackwardCompatibilityMode>%s</%sBackwardCompatibilityMode>%s' % (namespace_, self.gds_format_boolean(self.BackwardCompatibilityMode, input_name='BackwardCompatibilityMode'), namespace_, eol_))
        if self.IpScope is not None:
            self.IpScope.export(outfile, level, namespace_, name_='IpScope', pretty_print=pretty_print)
        if self.IpScopes is not None:
            self.IpScopes.export(outfile, level, namespace_, name_='IpScopes', pretty_print=pretty_print)
        if self.ParentNetwork is not None:
            self.ParentNetwork.export(outfile, level, namespace_, name_='ParentNetwork', pretty_print=pretty_print)
        if self.FenceMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFenceMode>%s</%sFenceMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.FenceMode).encode(ExternalEncoding), input_name='FenceMode'), namespace_, eol_))
        if self.RetainNetInfoAcrossDeployments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRetainNetInfoAcrossDeployments>%s</%sRetainNetInfoAcrossDeployments>%s' % (namespace_, self.gds_format_boolean(self.RetainNetInfoAcrossDeployments, input_name='RetainNetInfoAcrossDeployments'), namespace_, eol_))
        if self.Features is not None:
            self.Features.export(outfile, level, namespace_, name_='Features', pretty_print=pretty_print)
        if self.SyslogServerSettings is not None:
            self.SyslogServerSettings.export(outfile, level, namespace_, name_='SyslogServerSettings', pretty_print=pretty_print)
        if self.RouterInfo is not None:
            self.RouterInfo.export(outfile, level, namespace_, name_='RouterInfo', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkConfigurationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NetworkConfigurationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkConfigurationType, self).exportLiteralChildren(outfile, level, name_)
        if self.BackwardCompatibilityMode is not None:
            showIndent(outfile, level)
            outfile.write('BackwardCompatibilityMode=%s,\n' % self.BackwardCompatibilityMode)
        if self.IpScope is not None:
            showIndent(outfile, level)
            outfile.write('IpScope=model_.IpScopeType(\n')
            self.IpScope.exportLiteral(outfile, level, name_='IpScope')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IpScopes is not None:
            showIndent(outfile, level)
            outfile.write('IpScopes=model_.IpScopesType(\n')
            self.IpScopes.exportLiteral(outfile, level, name_='IpScopes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ParentNetwork is not None:
            showIndent(outfile, level)
            outfile.write('ParentNetwork=model_.ReferenceType(\n')
            self.ParentNetwork.exportLiteral(outfile, level, name_='ParentNetwork')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FenceMode is not None:
            showIndent(outfile, level)
            outfile.write('FenceMode=%s,\n' % quote_python(self.FenceMode).encode(ExternalEncoding))
        if self.RetainNetInfoAcrossDeployments is not None:
            showIndent(outfile, level)
            outfile.write('RetainNetInfoAcrossDeployments=%s,\n' % self.RetainNetInfoAcrossDeployments)
        if self.Features is not None:
            showIndent(outfile, level)
            outfile.write('Features=model_.NetworkFeaturesType(\n')
            self.Features.exportLiteral(outfile, level, name_='Features')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SyslogServerSettings is not None:
            showIndent(outfile, level)
            outfile.write('SyslogServerSettings=model_.SyslogServerSettingsType(\n')
            self.SyslogServerSettings.exportLiteral(outfile, level, name_='SyslogServerSettings')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RouterInfo is not None:
            showIndent(outfile, level)
            outfile.write('RouterInfo=model_.RouterInfoType(\n')
            self.RouterInfo.exportLiteral(outfile, level, name_='RouterInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NetworkConfigurationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BackwardCompatibilityMode':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'BackwardCompatibilityMode')
            self.BackwardCompatibilityMode = ival_
        elif nodeName_ == 'IpScope':
            obj_ = IpScopeType.factory()
            obj_.build(child_)
            self.IpScope = obj_
            obj_.original_tagname_ = 'IpScope'
        elif nodeName_ == 'IpScopes':
            obj_ = IpScopesType.factory()
            obj_.build(child_)
            self.IpScopes = obj_
            obj_.original_tagname_ = 'IpScopes'
        elif nodeName_ == 'ParentNetwork':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ParentNetwork = obj_
            obj_.original_tagname_ = 'ParentNetwork'
        elif nodeName_ == 'FenceMode':
            FenceMode_ = child_.text
            FenceMode_ = self.gds_validate_string(FenceMode_, node, 'FenceMode')
            self.FenceMode = FenceMode_
        elif nodeName_ == 'RetainNetInfoAcrossDeployments':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'RetainNetInfoAcrossDeployments')
            self.RetainNetInfoAcrossDeployments = ival_
        elif nodeName_ == 'Features':
            obj_ = NetworkFeaturesType.factory()
            obj_.build(child_)
            self.Features = obj_
            obj_.original_tagname_ = 'Features'
        elif nodeName_ == 'SyslogServerSettings':
            obj_ = SyslogServerSettingsType.factory()
            obj_.build(child_)
            self.SyslogServerSettings = obj_
            obj_.original_tagname_ = 'SyslogServerSettings'
        elif nodeName_ == 'RouterInfo':
            obj_ = RouterInfoType.factory()
            obj_.build(child_)
            self.RouterInfo = obj_
            obj_.original_tagname_ = 'RouterInfo'
        super(NetworkConfigurationType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkConfigurationType


class IpAddressesType(VCloudExtensibleType):
    """0.9 A list of IP addresses."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IpAddress=None):
        self.original_tagname_ = None
        super(IpAddressesType, self).__init__(VCloudExtension, )
        if IpAddress is None:
            self.IpAddress = []
        else:
            self.IpAddress = IpAddress
    def factory(*args_, **kwargs_):
        if IpAddressesType.subclass:
            return IpAddressesType.subclass(*args_, **kwargs_)
        else:
            return IpAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IpAddress(self): return self.IpAddress
    def set_IpAddress(self, IpAddress): self.IpAddress = IpAddress
    def add_IpAddress(self, value): self.IpAddress.append(value)
    def insert_IpAddress_at(self, index, value): self.IpAddress.insert(index, value)
    def replace_IpAddress_at(self, index, value): self.IpAddress[index] = value
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.IpAddress or
            super(IpAddressesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpAddressesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpAddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpAddressesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpAddressesType'):
        super(IpAddressesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpAddressesType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpAddressesType', fromsubclass_=False, pretty_print=True):
        super(IpAddressesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IpAddress_ in self.IpAddress:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpAddress>%s</%sIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(IpAddress_).encode(ExternalEncoding), input_name='IpAddress'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IpAddressesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpAddressesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpAddressesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('IpAddress=[\n')
        level += 1
        for IpAddress_ in self.IpAddress:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IpAddress_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpAddressesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IpAddress':
            IpAddress_ = child_.text
            IpAddress_ = self.gds_validate_string(IpAddress_, node, 'IpAddress')
            self.IpAddress.append(IpAddress_)
            self.validate_IpAddressType(self.IpAddress)    # validate type IpAddressType
        super(IpAddressesType, self).buildChildren(child_, node, nodeName_, True)
# end class IpAddressesType


class AllocatedIpAddressType(ResourceType):
    """5.1 Represents an information for allocated IP address 5.1 True if
    vApp is deployed. falsealways One of: vmAllocated (IP is
    allocated by VM), natRouted (IP is NAT routed) vsmAllocated (IP
    is allocated for vShieldManager) false"""
    subclass = None
    superclass = ResourceType
    def __init__(self, allocationType=None, isDeployed=None, IpAddress=None):
        self.original_tagname_ = None
        super(AllocatedIpAddressType, self).__init__()
        self.allocationType = _cast(None, allocationType)
        self.isDeployed = _cast(bool, isDeployed)
        self.IpAddress = IpAddress
        self.validate_IpAddressType(self.IpAddress)
    def factory(*args_, **kwargs_):
        if AllocatedIpAddressType.subclass:
            return AllocatedIpAddressType.subclass(*args_, **kwargs_)
        else:
            return AllocatedIpAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IpAddress(self): return self.IpAddress
    def set_IpAddress(self, IpAddress): self.IpAddress = IpAddress
    def get_allocationType(self): return self.allocationType
    def set_allocationType(self, allocationType): self.allocationType = allocationType
    def get_isDeployed(self): return self.isDeployed
    def set_isDeployed(self, isDeployed): self.isDeployed = isDeployed
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.IpAddress is not None or
            super(AllocatedIpAddressType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AllocatedIpAddressType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllocatedIpAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AllocatedIpAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AllocatedIpAddressType'):
        super(AllocatedIpAddressType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AllocatedIpAddressType')
        if self.allocationType is not None and 'allocationType' not in already_processed:
            already_processed.add('allocationType')
            outfile.write(' allocationType=%s' % (self.gds_format_string(quote_attrib(self.allocationType).encode(ExternalEncoding), input_name='allocationType'), ))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            outfile.write(' isDeployed="%s"' % self.gds_format_boolean(self.isDeployed, input_name='isDeployed'))
    def exportChildren(self, outfile, level, namespace_='', name_='AllocatedIpAddressType', fromsubclass_=False, pretty_print=True):
        super(AllocatedIpAddressType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpAddress>%s</%sIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IpAddress).encode(ExternalEncoding), input_name='IpAddress'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AllocatedIpAddressType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.allocationType is not None and 'allocationType' not in already_processed:
            already_processed.add('allocationType')
            showIndent(outfile, level)
            outfile.write('allocationType="%s",\n' % (self.allocationType,))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            showIndent(outfile, level)
            outfile.write('isDeployed=%s,\n' % (self.isDeployed,))
        super(AllocatedIpAddressType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AllocatedIpAddressType, self).exportLiteralChildren(outfile, level, name_)
        if self.IpAddress is not None:
            showIndent(outfile, level)
            outfile.write('IpAddress=%s,\n' % quote_python(self.IpAddress).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('allocationType', node)
        if value is not None and 'allocationType' not in already_processed:
            already_processed.add('allocationType')
            self.allocationType = value
        value = find_attr_value_('isDeployed', node)
        if value is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            if value in ('true', '1'):
                self.isDeployed = True
            elif value in ('false', '0'):
                self.isDeployed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(AllocatedIpAddressType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IpAddress':
            IpAddress_ = child_.text
            IpAddress_ = self.gds_validate_string(IpAddress_, node, 'IpAddress')
            self.IpAddress = IpAddress_
            self.validate_IpAddressType(self.IpAddress)    # validate type IpAddressType
        super(AllocatedIpAddressType, self).buildChildren(child_, node, nodeName_, True)
# end class AllocatedIpAddressType


class AllocatedIpAddressesType(ResourceType):
    """5.1A list of information for allocated IP addresses."""
    subclass = None
    superclass = ResourceType
    def __init__(self, IpAddress=None):
        self.original_tagname_ = None
        super(AllocatedIpAddressesType, self).__init__()
        if IpAddress is None:
            self.IpAddress = []
        else:
            self.IpAddress = IpAddress
    def factory(*args_, **kwargs_):
        if AllocatedIpAddressesType.subclass:
            return AllocatedIpAddressesType.subclass(*args_, **kwargs_)
        else:
            return AllocatedIpAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IpAddress(self): return self.IpAddress
    def set_IpAddress(self, IpAddress): self.IpAddress = IpAddress
    def add_IpAddress(self, value): self.IpAddress.append(value)
    def insert_IpAddress_at(self, index, value): self.IpAddress.insert(index, value)
    def replace_IpAddress_at(self, index, value): self.IpAddress[index] = value
    def hasContent_(self):
        if (
            self.IpAddress or
            super(AllocatedIpAddressesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AllocatedIpAddressesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllocatedIpAddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AllocatedIpAddressesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AllocatedIpAddressesType'):
        super(AllocatedIpAddressesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AllocatedIpAddressesType')
    def exportChildren(self, outfile, level, namespace_='', name_='AllocatedIpAddressesType', fromsubclass_=False, pretty_print=True):
        super(AllocatedIpAddressesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IpAddress_ in self.IpAddress:
            IpAddress_.export(outfile, level, namespace_, name_='IpAddress', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AllocatedIpAddressesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AllocatedIpAddressesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AllocatedIpAddressesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('IpAddress=[\n')
        level += 1
        for IpAddress_ in self.IpAddress:
            showIndent(outfile, level)
            outfile.write('model_.AllocatedIpAddressType(\n')
            IpAddress_.exportLiteral(outfile, level, name_='AllocatedIpAddressType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AllocatedIpAddressesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IpAddress':
            obj_ = AllocatedIpAddressType.factory()
            obj_.build(child_)
            self.IpAddress.append(obj_)
            obj_.original_tagname_ = 'IpAddress'
        super(AllocatedIpAddressesType, self).buildChildren(child_, node, nodeName_, True)
# end class AllocatedIpAddressesType


class SubAllocationsType(ResourceType):
    """5.1A list of IP addresses that are sub allocated to edge gateways."""
    subclass = None
    superclass = ResourceType
    def __init__(self, SubAllocation=None):
        self.original_tagname_ = None
        super(SubAllocationsType, self).__init__()
        if SubAllocation is None:
            self.SubAllocation = []
        else:
            self.SubAllocation = SubAllocation
    def factory(*args_, **kwargs_):
        if SubAllocationsType.subclass:
            return SubAllocationsType.subclass(*args_, **kwargs_)
        else:
            return SubAllocationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubAllocation(self): return self.SubAllocation
    def set_SubAllocation(self, SubAllocation): self.SubAllocation = SubAllocation
    def add_SubAllocation(self, value): self.SubAllocation.append(value)
    def insert_SubAllocation_at(self, index, value): self.SubAllocation.insert(index, value)
    def replace_SubAllocation_at(self, index, value): self.SubAllocation[index] = value
    def hasContent_(self):
        if (
            self.SubAllocation or
            super(SubAllocationsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubAllocationsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubAllocationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubAllocationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubAllocationsType'):
        super(SubAllocationsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubAllocationsType')
    def exportChildren(self, outfile, level, namespace_='', name_='SubAllocationsType', fromsubclass_=False, pretty_print=True):
        super(SubAllocationsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SubAllocation_ in self.SubAllocation:
            SubAllocation_.export(outfile, level, namespace_, name_='SubAllocation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubAllocationsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SubAllocationsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubAllocationsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('SubAllocation=[\n')
        level += 1
        for SubAllocation_ in self.SubAllocation:
            showIndent(outfile, level)
            outfile.write('model_.SubAllocationType(\n')
            SubAllocation_.exportLiteral(outfile, level, name_='SubAllocationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SubAllocationsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubAllocation':
            obj_ = SubAllocationType.factory()
            obj_.build(child_)
            self.SubAllocation.append(obj_)
            obj_.original_tagname_ = 'SubAllocation'
        super(SubAllocationsType, self).buildChildren(child_, node, nodeName_, True)
# end class SubAllocationsType


class SubAllocationType(VCloudExtensibleType):
    """IP range sub allocated to an edge gateway."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, EdgeGateway=None, IpRanges=None):
        self.original_tagname_ = None
        super(SubAllocationType, self).__init__(VCloudExtension, )
        self.EdgeGateway = EdgeGateway
        self.IpRanges = IpRanges
    def factory(*args_, **kwargs_):
        if SubAllocationType.subclass:
            return SubAllocationType.subclass(*args_, **kwargs_)
        else:
            return SubAllocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EdgeGateway(self): return self.EdgeGateway
    def set_EdgeGateway(self, EdgeGateway): self.EdgeGateway = EdgeGateway
    def get_IpRanges(self): return self.IpRanges
    def set_IpRanges(self, IpRanges): self.IpRanges = IpRanges
    def hasContent_(self):
        if (
            self.EdgeGateway is not None or
            self.IpRanges is not None or
            super(SubAllocationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubAllocationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubAllocationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubAllocationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubAllocationType'):
        super(SubAllocationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubAllocationType')
    def exportChildren(self, outfile, level, namespace_='', name_='SubAllocationType', fromsubclass_=False, pretty_print=True):
        super(SubAllocationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EdgeGateway is not None:
            self.EdgeGateway.export(outfile, level, namespace_, name_='EdgeGateway', pretty_print=pretty_print)
        if self.IpRanges is not None:
            self.IpRanges.export(outfile, level, namespace_, name_='IpRanges', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubAllocationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SubAllocationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubAllocationType, self).exportLiteralChildren(outfile, level, name_)
        if self.EdgeGateway is not None:
            showIndent(outfile, level)
            outfile.write('EdgeGateway=model_.ReferenceType(\n')
            self.EdgeGateway.exportLiteral(outfile, level, name_='EdgeGateway')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IpRanges is not None:
            showIndent(outfile, level)
            outfile.write('IpRanges=model_.IpRangesType(\n')
            self.IpRanges.exportLiteral(outfile, level, name_='IpRanges')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SubAllocationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EdgeGateway':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.EdgeGateway = obj_
            obj_.original_tagname_ = 'EdgeGateway'
        elif nodeName_ == 'IpRanges':
            obj_ = IpRangesType.factory()
            obj_.build(child_)
            self.IpRanges = obj_
            obj_.original_tagname_ = 'IpRanges'
        super(SubAllocationType, self).buildChildren(child_, node, nodeName_, True)
# end class SubAllocationType


class IpRangeType(VCloudExtensibleType):
    """0.9 Represents a range of IP addresses, start and end inclusive."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, StartAddress=None, EndAddress=None):
        self.original_tagname_ = None
        super(IpRangeType, self).__init__(VCloudExtension, )
        self.StartAddress = StartAddress
        self.validate_IpAddressType(self.StartAddress)
        self.EndAddress = EndAddress
        self.validate_IpAddressType(self.EndAddress)
    def factory(*args_, **kwargs_):
        if IpRangeType.subclass:
            return IpRangeType.subclass(*args_, **kwargs_)
        else:
            return IpRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartAddress(self): return self.StartAddress
    def set_StartAddress(self, StartAddress): self.StartAddress = StartAddress
    def get_EndAddress(self): return self.EndAddress
    def set_EndAddress(self, EndAddress): self.EndAddress = EndAddress
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.StartAddress is not None or
            self.EndAddress is not None or
            super(IpRangeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpRangeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpRangeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpRangeType'):
        super(IpRangeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpRangeType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpRangeType', fromsubclass_=False, pretty_print=True):
        super(IpRangeType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StartAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartAddress>%s</%sStartAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.StartAddress).encode(ExternalEncoding), input_name='StartAddress'), namespace_, eol_))
        if self.EndAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndAddress>%s</%sEndAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.EndAddress).encode(ExternalEncoding), input_name='EndAddress'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IpRangeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpRangeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpRangeType, self).exportLiteralChildren(outfile, level, name_)
        if self.StartAddress is not None:
            showIndent(outfile, level)
            outfile.write('StartAddress=%s,\n' % quote_python(self.StartAddress).encode(ExternalEncoding))
        if self.EndAddress is not None:
            showIndent(outfile, level)
            outfile.write('EndAddress=%s,\n' % quote_python(self.EndAddress).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpRangeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartAddress':
            StartAddress_ = child_.text
            StartAddress_ = self.gds_validate_string(StartAddress_, node, 'StartAddress')
            self.StartAddress = StartAddress_
            self.validate_IpAddressType(self.StartAddress)    # validate type IpAddressType
        elif nodeName_ == 'EndAddress':
            EndAddress_ = child_.text
            EndAddress_ = self.gds_validate_string(EndAddress_, node, 'EndAddress')
            self.EndAddress = EndAddress_
            self.validate_IpAddressType(self.EndAddress)    # validate type IpAddressType
        super(IpRangeType, self).buildChildren(child_, node, nodeName_, True)
# end class IpRangeType


class IpRangesType(VCloudExtensibleType):
    """0.9 Represents a list of IP ranges."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IpRange=None):
        self.original_tagname_ = None
        super(IpRangesType, self).__init__(VCloudExtension, )
        if IpRange is None:
            self.IpRange = []
        else:
            self.IpRange = IpRange
    def factory(*args_, **kwargs_):
        if IpRangesType.subclass:
            return IpRangesType.subclass(*args_, **kwargs_)
        else:
            return IpRangesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IpRange(self): return self.IpRange
    def set_IpRange(self, IpRange): self.IpRange = IpRange
    def add_IpRange(self, value): self.IpRange.append(value)
    def insert_IpRange_at(self, index, value): self.IpRange.insert(index, value)
    def replace_IpRange_at(self, index, value): self.IpRange[index] = value
    def hasContent_(self):
        if (
            self.IpRange or
            super(IpRangesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpRangesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpRangesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpRangesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpRangesType'):
        super(IpRangesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpRangesType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpRangesType', fromsubclass_=False, pretty_print=True):
        super(IpRangesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IpRange_ in self.IpRange:
            IpRange_.export(outfile, level, namespace_, name_='IpRange', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IpRangesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpRangesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpRangesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('IpRange=[\n')
        level += 1
        for IpRange_ in self.IpRange:
            showIndent(outfile, level)
            outfile.write('model_.IpRangeType(\n')
            IpRange_.exportLiteral(outfile, level, name_='IpRangeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpRangesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IpRange':
            obj_ = IpRangeType.factory()
            obj_.build(child_)
            self.IpRange.append(obj_)
            obj_.original_tagname_ = 'IpRange'
        super(IpRangesType, self).buildChildren(child_, node, nodeName_, True)
# end class IpRangesType


class IpScopeType(VCloudExtensibleType):
    """0.9 Specify network settings like gateway, network mask, DNS
    servers, IP ranges, etc."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsInherited=None, Gateway=None, Netmask=None, Dns1=None, Dns2=None, DnsSuffix=None, IsEnabled=None, IpRanges=None, AllocatedIpAddresses=None, SubAllocations=None):
        self.original_tagname_ = None
        super(IpScopeType, self).__init__(VCloudExtension, )
        self.IsInherited = IsInherited
        self.Gateway = Gateway
        self.validate_IpAddressType(self.Gateway)
        self.Netmask = Netmask
        self.validate_IpAddressType(self.Netmask)
        self.Dns1 = Dns1
        self.validate_IpAddressType(self.Dns1)
        self.Dns2 = Dns2
        self.validate_IpAddressType(self.Dns2)
        self.DnsSuffix = DnsSuffix
        self.IsEnabled = IsEnabled
        self.IpRanges = IpRanges
        self.AllocatedIpAddresses = AllocatedIpAddresses
        self.SubAllocations = SubAllocations
    def factory(*args_, **kwargs_):
        if IpScopeType.subclass:
            return IpScopeType.subclass(*args_, **kwargs_)
        else:
            return IpScopeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsInherited(self): return self.IsInherited
    def set_IsInherited(self, IsInherited): self.IsInherited = IsInherited
    def get_Gateway(self): return self.Gateway
    def set_Gateway(self, Gateway): self.Gateway = Gateway
    def get_Netmask(self): return self.Netmask
    def set_Netmask(self, Netmask): self.Netmask = Netmask
    def get_Dns1(self): return self.Dns1
    def set_Dns1(self, Dns1): self.Dns1 = Dns1
    def get_Dns2(self): return self.Dns2
    def set_Dns2(self, Dns2): self.Dns2 = Dns2
    def get_DnsSuffix(self): return self.DnsSuffix
    def set_DnsSuffix(self, DnsSuffix): self.DnsSuffix = DnsSuffix
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_IpRanges(self): return self.IpRanges
    def set_IpRanges(self, IpRanges): self.IpRanges = IpRanges
    def get_AllocatedIpAddresses(self): return self.AllocatedIpAddresses
    def set_AllocatedIpAddresses(self, AllocatedIpAddresses): self.AllocatedIpAddresses = AllocatedIpAddresses
    def get_SubAllocations(self): return self.SubAllocations
    def set_SubAllocations(self, SubAllocations): self.SubAllocations = SubAllocations
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.IsInherited is not None or
            self.Gateway is not None or
            self.Netmask is not None or
            self.Dns1 is not None or
            self.Dns2 is not None or
            self.DnsSuffix is not None or
            self.IsEnabled is not None or
            self.IpRanges is not None or
            self.AllocatedIpAddresses is not None or
            self.SubAllocations is not None or
            super(IpScopeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpScopeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpScopeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpScopeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpScopeType'):
        super(IpScopeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpScopeType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpScopeType', fromsubclass_=False, pretty_print=True):
        super(IpScopeType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsInherited is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsInherited>%s</%sIsInherited>%s' % (namespace_, self.gds_format_boolean(self.IsInherited, input_name='IsInherited'), namespace_, eol_))
        if self.Gateway is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGateway>%s</%sGateway>%s' % (namespace_, self.gds_format_string(quote_xml(self.Gateway).encode(ExternalEncoding), input_name='Gateway'), namespace_, eol_))
        if self.Netmask is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetmask>%s</%sNetmask>%s' % (namespace_, self.gds_format_string(quote_xml(self.Netmask).encode(ExternalEncoding), input_name='Netmask'), namespace_, eol_))
        if self.Dns1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDns1>%s</%sDns1>%s' % (namespace_, self.gds_format_string(quote_xml(self.Dns1).encode(ExternalEncoding), input_name='Dns1'), namespace_, eol_))
        if self.Dns2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDns2>%s</%sDns2>%s' % (namespace_, self.gds_format_string(quote_xml(self.Dns2).encode(ExternalEncoding), input_name='Dns2'), namespace_, eol_))
        if self.DnsSuffix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDnsSuffix>%s</%sDnsSuffix>%s' % (namespace_, self.gds_format_string(quote_xml(self.DnsSuffix).encode(ExternalEncoding), input_name='DnsSuffix'), namespace_, eol_))
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.IpRanges is not None:
            self.IpRanges.export(outfile, level, namespace_, name_='IpRanges', pretty_print=pretty_print)
        if self.AllocatedIpAddresses is not None:
            self.AllocatedIpAddresses.export(outfile, level, namespace_, name_='AllocatedIpAddresses', pretty_print=pretty_print)
        if self.SubAllocations is not None:
            self.SubAllocations.export(outfile, level, namespace_, name_='SubAllocations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IpScopeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpScopeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpScopeType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsInherited is not None:
            showIndent(outfile, level)
            outfile.write('IsInherited=%s,\n' % self.IsInherited)
        if self.Gateway is not None:
            showIndent(outfile, level)
            outfile.write('Gateway=%s,\n' % quote_python(self.Gateway).encode(ExternalEncoding))
        if self.Netmask is not None:
            showIndent(outfile, level)
            outfile.write('Netmask=%s,\n' % quote_python(self.Netmask).encode(ExternalEncoding))
        if self.Dns1 is not None:
            showIndent(outfile, level)
            outfile.write('Dns1=%s,\n' % quote_python(self.Dns1).encode(ExternalEncoding))
        if self.Dns2 is not None:
            showIndent(outfile, level)
            outfile.write('Dns2=%s,\n' % quote_python(self.Dns2).encode(ExternalEncoding))
        if self.DnsSuffix is not None:
            showIndent(outfile, level)
            outfile.write('DnsSuffix=%s,\n' % quote_python(self.DnsSuffix).encode(ExternalEncoding))
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.IpRanges is not None:
            showIndent(outfile, level)
            outfile.write('IpRanges=model_.IpRangesType(\n')
            self.IpRanges.exportLiteral(outfile, level, name_='IpRanges')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AllocatedIpAddresses is not None:
            showIndent(outfile, level)
            outfile.write('AllocatedIpAddresses=model_.IpAddressesType(\n')
            self.AllocatedIpAddresses.exportLiteral(outfile, level, name_='AllocatedIpAddresses')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubAllocations is not None:
            showIndent(outfile, level)
            outfile.write('SubAllocations=model_.SubAllocationsType(\n')
            self.SubAllocations.exportLiteral(outfile, level, name_='SubAllocations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpScopeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsInherited':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsInherited')
            self.IsInherited = ival_
        elif nodeName_ == 'Gateway':
            Gateway_ = child_.text
            Gateway_ = self.gds_validate_string(Gateway_, node, 'Gateway')
            self.Gateway = Gateway_
            self.validate_IpAddressType(self.Gateway)    # validate type IpAddressType
        elif nodeName_ == 'Netmask':
            Netmask_ = child_.text
            Netmask_ = self.gds_validate_string(Netmask_, node, 'Netmask')
            self.Netmask = Netmask_
            self.validate_IpAddressType(self.Netmask)    # validate type IpAddressType
        elif nodeName_ == 'Dns1':
            Dns1_ = child_.text
            Dns1_ = self.gds_validate_string(Dns1_, node, 'Dns1')
            self.Dns1 = Dns1_
            self.validate_IpAddressType(self.Dns1)    # validate type IpAddressType
        elif nodeName_ == 'Dns2':
            Dns2_ = child_.text
            Dns2_ = self.gds_validate_string(Dns2_, node, 'Dns2')
            self.Dns2 = Dns2_
            self.validate_IpAddressType(self.Dns2)    # validate type IpAddressType
        elif nodeName_ == 'DnsSuffix':
            DnsSuffix_ = child_.text
            DnsSuffix_ = self.gds_validate_string(DnsSuffix_, node, 'DnsSuffix')
            self.DnsSuffix = DnsSuffix_
        elif nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'IpRanges':
            obj_ = IpRangesType.factory()
            obj_.build(child_)
            self.IpRanges = obj_
            obj_.original_tagname_ = 'IpRanges'
        elif nodeName_ == 'AllocatedIpAddresses':
            obj_ = IpAddressesType.factory()
            obj_.build(child_)
            self.AllocatedIpAddresses = obj_
            obj_.original_tagname_ = 'AllocatedIpAddresses'
        elif nodeName_ == 'SubAllocations':
            obj_ = SubAllocationsType.factory()
            obj_.build(child_)
            self.SubAllocations = obj_
            obj_.original_tagname_ = 'SubAllocations'
        super(IpScopeType, self).buildChildren(child_, node, nodeName_, True)
# end class IpScopeType


class IpScopesType(VCloudExtensibleType):
    """5.1 Represents a list of IP scopes."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IpScope=None):
        self.original_tagname_ = None
        super(IpScopesType, self).__init__(VCloudExtension, )
        if IpScope is None:
            self.IpScope = []
        else:
            self.IpScope = IpScope
    def factory(*args_, **kwargs_):
        if IpScopesType.subclass:
            return IpScopesType.subclass(*args_, **kwargs_)
        else:
            return IpScopesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IpScope(self): return self.IpScope
    def set_IpScope(self, IpScope): self.IpScope = IpScope
    def add_IpScope(self, value): self.IpScope.append(value)
    def insert_IpScope_at(self, index, value): self.IpScope.insert(index, value)
    def replace_IpScope_at(self, index, value): self.IpScope[index] = value
    def hasContent_(self):
        if (
            self.IpScope or
            super(IpScopesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpScopesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpScopesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpScopesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpScopesType'):
        super(IpScopesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpScopesType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpScopesType', fromsubclass_=False, pretty_print=True):
        super(IpScopesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IpScope_ in self.IpScope:
            IpScope_.export(outfile, level, namespace_, name_='IpScope', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IpScopesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpScopesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpScopesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('IpScope=[\n')
        level += 1
        for IpScope_ in self.IpScope:
            showIndent(outfile, level)
            outfile.write('model_.IpScopeType(\n')
            IpScope_.exportLiteral(outfile, level, name_='IpScopeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpScopesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IpScope':
            obj_ = IpScopeType.factory()
            obj_.build(child_)
            self.IpScope.append(obj_)
            obj_.original_tagname_ = 'IpScope'
        super(IpScopesType, self).buildChildren(child_, node, nodeName_, True)
# end class IpScopesType


class SyslogServerSettingsType(GeneratedsSuper):
    """1.5 Syslog server settings. If logging is configured for firewall
    rules, the logs will be directed to these syslog servers."""
    subclass = None
    superclass = None
    def __init__(self, SyslogServerIp1=None, SyslogServerIp2=None):
        self.original_tagname_ = None
        self.SyslogServerIp1 = SyslogServerIp1
        self.validate_IpAddressType(self.SyslogServerIp1)
        self.SyslogServerIp2 = SyslogServerIp2
        self.validate_IpAddressType(self.SyslogServerIp2)
    def factory(*args_, **kwargs_):
        if SyslogServerSettingsType.subclass:
            return SyslogServerSettingsType.subclass(*args_, **kwargs_)
        else:
            return SyslogServerSettingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SyslogServerIp1(self): return self.SyslogServerIp1
    def set_SyslogServerIp1(self, SyslogServerIp1): self.SyslogServerIp1 = SyslogServerIp1
    def get_SyslogServerIp2(self): return self.SyslogServerIp2
    def set_SyslogServerIp2(self, SyslogServerIp2): self.SyslogServerIp2 = SyslogServerIp2
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.SyslogServerIp1 is not None or
            self.SyslogServerIp2 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SyslogServerSettingsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SyslogServerSettingsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SyslogServerSettingsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SyslogServerSettingsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SyslogServerSettingsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SyslogServerIp1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSyslogServerIp1>%s</%sSyslogServerIp1>%s' % (namespace_, self.gds_format_string(quote_xml(self.SyslogServerIp1).encode(ExternalEncoding), input_name='SyslogServerIp1'), namespace_, eol_))
        if self.SyslogServerIp2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSyslogServerIp2>%s</%sSyslogServerIp2>%s' % (namespace_, self.gds_format_string(quote_xml(self.SyslogServerIp2).encode(ExternalEncoding), input_name='SyslogServerIp2'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SyslogServerSettingsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SyslogServerIp1 is not None:
            showIndent(outfile, level)
            outfile.write('SyslogServerIp1=%s,\n' % quote_python(self.SyslogServerIp1).encode(ExternalEncoding))
        if self.SyslogServerIp2 is not None:
            showIndent(outfile, level)
            outfile.write('SyslogServerIp2=%s,\n' % quote_python(self.SyslogServerIp2).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SyslogServerIp1':
            SyslogServerIp1_ = child_.text
            SyslogServerIp1_ = self.gds_validate_string(SyslogServerIp1_, node, 'SyslogServerIp1')
            self.SyslogServerIp1 = SyslogServerIp1_
            self.validate_IpAddressType(self.SyslogServerIp1)    # validate type IpAddressType
        elif nodeName_ == 'SyslogServerIp2':
            SyslogServerIp2_ = child_.text
            SyslogServerIp2_ = self.gds_validate_string(SyslogServerIp2_, node, 'SyslogServerIp2')
            self.SyslogServerIp2 = SyslogServerIp2_
            self.validate_IpAddressType(self.SyslogServerIp2)    # validate type IpAddressType
# end class SyslogServerSettingsType


class OrgVdcNetworkType(NetworkType):
    """5.1 Represents an Org vDC network in the vCloud model. none Creation
    status of the org vDC network. One of:<br> 0 (The org vDC
    network is not completely created)<br> 1 (The org vDC network is
    ready) false"""
    subclass = None
    superclass = NetworkType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, Configuration=None, status=None, EdgeGateway=None, ServiceConfig=None, IsShared=None):
        self.original_tagname_ = None
        super(OrgVdcNetworkType, self).__init__(operationKey, id, name, Description, Tasks, Configuration, )
        self.status = _cast(int, status)
        self.EdgeGateway = EdgeGateway
        self.ServiceConfig = ServiceConfig
        self.IsShared = IsShared
    def factory(*args_, **kwargs_):
        if OrgVdcNetworkType.subclass:
            return OrgVdcNetworkType.subclass(*args_, **kwargs_)
        else:
            return OrgVdcNetworkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EdgeGateway(self): return self.EdgeGateway
    def set_EdgeGateway(self, EdgeGateway): self.EdgeGateway = EdgeGateway
    def get_ServiceConfig(self): return self.ServiceConfig
    def set_ServiceConfig(self, ServiceConfig): self.ServiceConfig = ServiceConfig
    def get_IsShared(self): return self.IsShared
    def set_IsShared(self, IsShared): self.IsShared = IsShared
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def hasContent_(self):
        if (
            self.EdgeGateway is not None or
            self.ServiceConfig is not None or
            self.IsShared is not None or
            super(OrgVdcNetworkType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrgVdcNetworkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrgVdcNetworkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrgVdcNetworkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrgVdcNetworkType'):
        super(OrgVdcNetworkType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrgVdcNetworkType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status="%s"' % self.gds_format_integer(self.status, input_name='status'))
    def exportChildren(self, outfile, level, namespace_='', name_='OrgVdcNetworkType', fromsubclass_=False, pretty_print=True):
        super(OrgVdcNetworkType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EdgeGateway is not None:
            self.EdgeGateway.export(outfile, level, namespace_, name_='EdgeGateway', pretty_print=pretty_print)
        if self.ServiceConfig is not None:
            self.ServiceConfig.export(outfile, level, namespace_, name_='ServiceConfig', pretty_print=pretty_print)
        if self.IsShared is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsShared>%s</%sIsShared>%s' % (namespace_, self.gds_format_boolean(self.IsShared, input_name='IsShared'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OrgVdcNetworkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % (self.status,))
        super(OrgVdcNetworkType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrgVdcNetworkType, self).exportLiteralChildren(outfile, level, name_)
        if self.EdgeGateway is not None:
            showIndent(outfile, level)
            outfile.write('EdgeGateway=model_.ReferenceType(\n')
            self.EdgeGateway.exportLiteral(outfile, level, name_='EdgeGateway')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ServiceConfig is not None:
            showIndent(outfile, level)
            outfile.write('ServiceConfig=model_.GatewayFeaturesType(\n')
            self.ServiceConfig.exportLiteral(outfile, level, name_='ServiceConfig')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IsShared is not None:
            showIndent(outfile, level)
            outfile.write('IsShared=%s,\n' % self.IsShared)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            try:
                self.status = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(OrgVdcNetworkType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EdgeGateway':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.EdgeGateway = obj_
            obj_.original_tagname_ = 'EdgeGateway'
        elif nodeName_ == 'ServiceConfig':
            obj_ = GatewayFeaturesType.factory()
            obj_.build(child_)
            self.ServiceConfig = obj_
            obj_.original_tagname_ = 'ServiceConfig'
        elif nodeName_ == 'IsShared':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsShared')
            self.IsShared = ival_
        super(OrgVdcNetworkType, self).buildChildren(child_, node, nodeName_, True)
# end class OrgVdcNetworkType


class GatewayType(EntityType):
    """5.1 Represents a gateway. none Creation status of the gateway. One
    of:<br> 0 (The gateway is still being created)<br> 1 (The
    gateway is ready)<br> -1 (There was an error while creating the
    gateway). false"""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, Configuration=None):
        self.original_tagname_ = None
        super(GatewayType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.status = _cast(int, status)
        self.Configuration = Configuration
    def factory(*args_, **kwargs_):
        if GatewayType.subclass:
            return GatewayType.subclass(*args_, **kwargs_)
        else:
            return GatewayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Configuration(self): return self.Configuration
    def set_Configuration(self, Configuration): self.Configuration = Configuration
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def hasContent_(self):
        if (
            self.Configuration is not None or
            super(GatewayType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayType'):
        super(GatewayType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status="%s"' % self.gds_format_integer(self.status, input_name='status'))
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayType', fromsubclass_=False, pretty_print=True):
        super(GatewayType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Configuration is not None:
            self.Configuration.export(outfile, level, namespace_, name_='Configuration', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GatewayType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % (self.status,))
        super(GatewayType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayType, self).exportLiteralChildren(outfile, level, name_)
        if self.Configuration is not None:
            showIndent(outfile, level)
            outfile.write('Configuration=model_.GatewayConfigurationType(\n')
            self.Configuration.exportLiteral(outfile, level, name_='Configuration')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            try:
                self.status = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(GatewayType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Configuration':
            obj_ = GatewayConfigurationType.factory()
            obj_.build(child_)
            self.Configuration = obj_
            obj_.original_tagname_ = 'Configuration'
        super(GatewayType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayType


class GatewayConfigurationType(VCloudExtensibleType):
    """5.1 Gateway Configuration."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, BackwardCompatibilityMode=None, GatewayBackingConfig=None, GatewayInterfaces=None, EdgeGatewayServiceConfiguration=None, HaEnabled=None, UseDefaultRouteForDnsRelay=None):
        self.original_tagname_ = None
        super(GatewayConfigurationType, self).__init__(VCloudExtension, )
        self.BackwardCompatibilityMode = BackwardCompatibilityMode
        self.GatewayBackingConfig = GatewayBackingConfig
        self.GatewayInterfaces = GatewayInterfaces
        self.EdgeGatewayServiceConfiguration = EdgeGatewayServiceConfiguration
        self.HaEnabled = HaEnabled
        self.UseDefaultRouteForDnsRelay = UseDefaultRouteForDnsRelay
    def factory(*args_, **kwargs_):
        if GatewayConfigurationType.subclass:
            return GatewayConfigurationType.subclass(*args_, **kwargs_)
        else:
            return GatewayConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BackwardCompatibilityMode(self): return self.BackwardCompatibilityMode
    def set_BackwardCompatibilityMode(self, BackwardCompatibilityMode): self.BackwardCompatibilityMode = BackwardCompatibilityMode
    def get_GatewayBackingConfig(self): return self.GatewayBackingConfig
    def set_GatewayBackingConfig(self, GatewayBackingConfig): self.GatewayBackingConfig = GatewayBackingConfig
    def get_GatewayInterfaces(self): return self.GatewayInterfaces
    def set_GatewayInterfaces(self, GatewayInterfaces): self.GatewayInterfaces = GatewayInterfaces
    def get_EdgeGatewayServiceConfiguration(self): return self.EdgeGatewayServiceConfiguration
    def set_EdgeGatewayServiceConfiguration(self, EdgeGatewayServiceConfiguration): self.EdgeGatewayServiceConfiguration = EdgeGatewayServiceConfiguration
    def get_HaEnabled(self): return self.HaEnabled
    def set_HaEnabled(self, HaEnabled): self.HaEnabled = HaEnabled
    def get_UseDefaultRouteForDnsRelay(self): return self.UseDefaultRouteForDnsRelay
    def set_UseDefaultRouteForDnsRelay(self, UseDefaultRouteForDnsRelay): self.UseDefaultRouteForDnsRelay = UseDefaultRouteForDnsRelay
    def hasContent_(self):
        if (
            self.BackwardCompatibilityMode is not None or
            self.GatewayBackingConfig is not None or
            self.GatewayInterfaces is not None or
            self.EdgeGatewayServiceConfiguration is not None or
            self.HaEnabled is not None or
            self.UseDefaultRouteForDnsRelay is not None or
            super(GatewayConfigurationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayConfigurationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayConfigurationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayConfigurationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayConfigurationType'):
        super(GatewayConfigurationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayConfigurationType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayConfigurationType', fromsubclass_=False, pretty_print=True):
        super(GatewayConfigurationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BackwardCompatibilityMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBackwardCompatibilityMode>%s</%sBackwardCompatibilityMode>%s' % (namespace_, self.gds_format_boolean(self.BackwardCompatibilityMode, input_name='BackwardCompatibilityMode'), namespace_, eol_))
        if self.GatewayBackingConfig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGatewayBackingConfig>%s</%sGatewayBackingConfig>%s' % (namespace_, self.gds_format_string(quote_xml(self.GatewayBackingConfig).encode(ExternalEncoding), input_name='GatewayBackingConfig'), namespace_, eol_))
        if self.GatewayInterfaces is not None:
            self.GatewayInterfaces.export(outfile, level, namespace_, name_='GatewayInterfaces', pretty_print=pretty_print)
        if self.EdgeGatewayServiceConfiguration is not None:
            self.EdgeGatewayServiceConfiguration.export(outfile, level, namespace_, name_='EdgeGatewayServiceConfiguration', pretty_print=pretty_print)
        if self.HaEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHaEnabled>%s</%sHaEnabled>%s' % (namespace_, self.gds_format_boolean(self.HaEnabled, input_name='HaEnabled'), namespace_, eol_))
        if self.UseDefaultRouteForDnsRelay is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUseDefaultRouteForDnsRelay>%s</%sUseDefaultRouteForDnsRelay>%s' % (namespace_, self.gds_format_boolean(self.UseDefaultRouteForDnsRelay, input_name='UseDefaultRouteForDnsRelay'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GatewayConfigurationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayConfigurationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayConfigurationType, self).exportLiteralChildren(outfile, level, name_)
        if self.BackwardCompatibilityMode is not None:
            showIndent(outfile, level)
            outfile.write('BackwardCompatibilityMode=%s,\n' % self.BackwardCompatibilityMode)
        if self.GatewayBackingConfig is not None:
            showIndent(outfile, level)
            outfile.write('GatewayBackingConfig=%s,\n' % quote_python(self.GatewayBackingConfig).encode(ExternalEncoding))
        if self.GatewayInterfaces is not None:
            showIndent(outfile, level)
            outfile.write('GatewayInterfaces=model_.GatewayInterfacesType(\n')
            self.GatewayInterfaces.exportLiteral(outfile, level, name_='GatewayInterfaces')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EdgeGatewayServiceConfiguration is not None:
            showIndent(outfile, level)
            outfile.write('EdgeGatewayServiceConfiguration=model_.GatewayFeaturesType(\n')
            self.EdgeGatewayServiceConfiguration.exportLiteral(outfile, level, name_='EdgeGatewayServiceConfiguration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HaEnabled is not None:
            showIndent(outfile, level)
            outfile.write('HaEnabled=%s,\n' % self.HaEnabled)
        if self.UseDefaultRouteForDnsRelay is not None:
            showIndent(outfile, level)
            outfile.write('UseDefaultRouteForDnsRelay=%s,\n' % self.UseDefaultRouteForDnsRelay)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayConfigurationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BackwardCompatibilityMode':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'BackwardCompatibilityMode')
            self.BackwardCompatibilityMode = ival_
        elif nodeName_ == 'GatewayBackingConfig':
            GatewayBackingConfig_ = child_.text
            GatewayBackingConfig_ = self.gds_validate_string(GatewayBackingConfig_, node, 'GatewayBackingConfig')
            self.GatewayBackingConfig = GatewayBackingConfig_
        elif nodeName_ == 'GatewayInterfaces':
            obj_ = GatewayInterfacesType.factory()
            obj_.build(child_)
            self.GatewayInterfaces = obj_
            obj_.original_tagname_ = 'GatewayInterfaces'
        elif nodeName_ == 'EdgeGatewayServiceConfiguration':
            obj_ = GatewayFeaturesType.factory()
            obj_.build(child_)
            self.EdgeGatewayServiceConfiguration = obj_
            obj_.original_tagname_ = 'EdgeGatewayServiceConfiguration'
        elif nodeName_ == 'HaEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'HaEnabled')
            self.HaEnabled = ival_
        elif nodeName_ == 'UseDefaultRouteForDnsRelay':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'UseDefaultRouteForDnsRelay')
            self.UseDefaultRouteForDnsRelay = ival_
        super(GatewayConfigurationType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayConfigurationType


class GatewayInterfacesType(VCloudExtensibleType):
    """5.1 A list of Gateway Interfaces."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, GatewayInterface=None):
        self.original_tagname_ = None
        super(GatewayInterfacesType, self).__init__(VCloudExtension, )
        if GatewayInterface is None:
            self.GatewayInterface = []
        else:
            self.GatewayInterface = GatewayInterface
    def factory(*args_, **kwargs_):
        if GatewayInterfacesType.subclass:
            return GatewayInterfacesType.subclass(*args_, **kwargs_)
        else:
            return GatewayInterfacesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GatewayInterface(self): return self.GatewayInterface
    def set_GatewayInterface(self, GatewayInterface): self.GatewayInterface = GatewayInterface
    def add_GatewayInterface(self, value): self.GatewayInterface.append(value)
    def insert_GatewayInterface_at(self, index, value): self.GatewayInterface.insert(index, value)
    def replace_GatewayInterface_at(self, index, value): self.GatewayInterface[index] = value
    def hasContent_(self):
        if (
            self.GatewayInterface or
            super(GatewayInterfacesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayInterfacesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayInterfacesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayInterfacesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayInterfacesType'):
        super(GatewayInterfacesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayInterfacesType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayInterfacesType', fromsubclass_=False, pretty_print=True):
        super(GatewayInterfacesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for GatewayInterface_ in self.GatewayInterface:
            GatewayInterface_.export(outfile, level, namespace_, name_='GatewayInterface', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GatewayInterfacesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayInterfacesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayInterfacesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('GatewayInterface=[\n')
        level += 1
        for GatewayInterface_ in self.GatewayInterface:
            showIndent(outfile, level)
            outfile.write('model_.GatewayInterfaceType(\n')
            GatewayInterface_.exportLiteral(outfile, level, name_='GatewayInterfaceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayInterfacesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GatewayInterface':
            obj_ = GatewayInterfaceType.factory()
            obj_.build(child_)
            self.GatewayInterface.append(obj_)
            obj_.original_tagname_ = 'GatewayInterface'
        super(GatewayInterfacesType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayInterfacesType


class GatewayInterfaceType(VCloudExtensibleType):
    """5.1 Gateway Interface configuration."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, DisplayName=None, Network=None, InterfaceType=None, SubnetParticipation=None, ApplyRateLimit=None, InRateLimit=None, OutRateLimit=None, UseForDefaultRoute=None):
        self.original_tagname_ = None
        super(GatewayInterfaceType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.DisplayName = DisplayName
        self.Network = Network
        self.InterfaceType = InterfaceType
        if SubnetParticipation is None:
            self.SubnetParticipation = []
        else:
            self.SubnetParticipation = SubnetParticipation
        self.ApplyRateLimit = ApplyRateLimit
        self.InRateLimit = InRateLimit
        self.OutRateLimit = OutRateLimit
        self.UseForDefaultRoute = UseForDefaultRoute
    def factory(*args_, **kwargs_):
        if GatewayInterfaceType.subclass:
            return GatewayInterfaceType.subclass(*args_, **kwargs_)
        else:
            return GatewayInterfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_DisplayName(self): return self.DisplayName
    def set_DisplayName(self, DisplayName): self.DisplayName = DisplayName
    def get_Network(self): return self.Network
    def set_Network(self, Network): self.Network = Network
    def get_InterfaceType(self): return self.InterfaceType
    def set_InterfaceType(self, InterfaceType): self.InterfaceType = InterfaceType
    def get_SubnetParticipation(self): return self.SubnetParticipation
    def set_SubnetParticipation(self, SubnetParticipation): self.SubnetParticipation = SubnetParticipation
    def add_SubnetParticipation(self, value): self.SubnetParticipation.append(value)
    def insert_SubnetParticipation_at(self, index, value): self.SubnetParticipation.insert(index, value)
    def replace_SubnetParticipation_at(self, index, value): self.SubnetParticipation[index] = value
    def get_ApplyRateLimit(self): return self.ApplyRateLimit
    def set_ApplyRateLimit(self, ApplyRateLimit): self.ApplyRateLimit = ApplyRateLimit
    def get_InRateLimit(self): return self.InRateLimit
    def set_InRateLimit(self, InRateLimit): self.InRateLimit = InRateLimit
    def get_OutRateLimit(self): return self.OutRateLimit
    def set_OutRateLimit(self, OutRateLimit): self.OutRateLimit = OutRateLimit
    def get_UseForDefaultRoute(self): return self.UseForDefaultRoute
    def set_UseForDefaultRoute(self, UseForDefaultRoute): self.UseForDefaultRoute = UseForDefaultRoute
    def hasContent_(self):
        if (
            self.Name is not None or
            self.DisplayName is not None or
            self.Network is not None or
            self.InterfaceType is not None or
            self.SubnetParticipation or
            self.ApplyRateLimit is not None or
            self.InRateLimit is not None or
            self.OutRateLimit is not None or
            self.UseForDefaultRoute is not None or
            super(GatewayInterfaceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayInterfaceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayInterfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayInterfaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayInterfaceType'):
        super(GatewayInterfaceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayInterfaceType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayInterfaceType', fromsubclass_=False, pretty_print=True):
        super(GatewayInterfaceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.DisplayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDisplayName>%s</%sDisplayName>%s' % (namespace_, self.gds_format_string(quote_xml(self.DisplayName).encode(ExternalEncoding), input_name='DisplayName'), namespace_, eol_))
        if self.Network is not None:
            self.Network.export(outfile, level, namespace_, name_='Network', pretty_print=pretty_print)
        if self.InterfaceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInterfaceType>%s</%sInterfaceType>%s' % (namespace_, self.gds_format_string(quote_xml(self.InterfaceType).encode(ExternalEncoding), input_name='InterfaceType'), namespace_, eol_))
        for SubnetParticipation_ in self.SubnetParticipation:
            SubnetParticipation_.export(outfile, level, namespace_, name_='SubnetParticipation', pretty_print=pretty_print)
        if self.ApplyRateLimit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplyRateLimit>%s</%sApplyRateLimit>%s' % (namespace_, self.gds_format_boolean(self.ApplyRateLimit, input_name='ApplyRateLimit'), namespace_, eol_))
        if self.InRateLimit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInRateLimit>%s</%sInRateLimit>%s' % (namespace_, self.gds_format_double(self.InRateLimit, input_name='InRateLimit'), namespace_, eol_))
        if self.OutRateLimit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOutRateLimit>%s</%sOutRateLimit>%s' % (namespace_, self.gds_format_double(self.OutRateLimit, input_name='OutRateLimit'), namespace_, eol_))
        if self.UseForDefaultRoute is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUseForDefaultRoute>%s</%sUseForDefaultRoute>%s' % (namespace_, self.gds_format_boolean(self.UseForDefaultRoute, input_name='UseForDefaultRoute'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GatewayInterfaceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayInterfaceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayInterfaceType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.DisplayName is not None:
            showIndent(outfile, level)
            outfile.write('DisplayName=%s,\n' % quote_python(self.DisplayName).encode(ExternalEncoding))
        if self.Network is not None:
            showIndent(outfile, level)
            outfile.write('Network=model_.ReferenceType(\n')
            self.Network.exportLiteral(outfile, level, name_='Network')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InterfaceType is not None:
            showIndent(outfile, level)
            outfile.write('InterfaceType=%s,\n' % quote_python(self.InterfaceType).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('SubnetParticipation=[\n')
        level += 1
        for SubnetParticipation_ in self.SubnetParticipation:
            showIndent(outfile, level)
            outfile.write('model_.SubnetParticipationType(\n')
            SubnetParticipation_.exportLiteral(outfile, level, name_='SubnetParticipationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ApplyRateLimit is not None:
            showIndent(outfile, level)
            outfile.write('ApplyRateLimit=%s,\n' % self.ApplyRateLimit)
        if self.InRateLimit is not None:
            showIndent(outfile, level)
            outfile.write('InRateLimit=%e,\n' % self.InRateLimit)
        if self.OutRateLimit is not None:
            showIndent(outfile, level)
            outfile.write('OutRateLimit=%e,\n' % self.OutRateLimit)
        if self.UseForDefaultRoute is not None:
            showIndent(outfile, level)
            outfile.write('UseForDefaultRoute=%s,\n' % self.UseForDefaultRoute)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayInterfaceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'DisplayName':
            DisplayName_ = child_.text
            DisplayName_ = self.gds_validate_string(DisplayName_, node, 'DisplayName')
            self.DisplayName = DisplayName_
        elif nodeName_ == 'Network':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Network = obj_
            obj_.original_tagname_ = 'Network'
        elif nodeName_ == 'InterfaceType':
            InterfaceType_ = child_.text
            InterfaceType_ = self.gds_validate_string(InterfaceType_, node, 'InterfaceType')
            self.InterfaceType = InterfaceType_
        elif nodeName_ == 'SubnetParticipation':
            obj_ = SubnetParticipationType.factory()
            obj_.build(child_)
            self.SubnetParticipation.append(obj_)
            obj_.original_tagname_ = 'SubnetParticipation'
        elif nodeName_ == 'ApplyRateLimit':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ApplyRateLimit')
            self.ApplyRateLimit = ival_
        elif nodeName_ == 'InRateLimit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'InRateLimit')
            self.InRateLimit = fval_
        elif nodeName_ == 'OutRateLimit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'OutRateLimit')
            self.OutRateLimit = fval_
        elif nodeName_ == 'UseForDefaultRoute':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'UseForDefaultRoute')
            self.UseForDefaultRoute = ival_
        super(GatewayInterfaceType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayInterfaceType


class GatewayFeaturesType(VCloudExtensibleType):
    """5.1 Represents edge gateway services."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, NetworkService=None):
        self.original_tagname_ = None
        super(GatewayFeaturesType, self).__init__(VCloudExtension, )
        if NetworkService is None:
            self.NetworkService = []
        else:
            self.NetworkService = NetworkService
    def factory(*args_, **kwargs_):
        if GatewayFeaturesType.subclass:
            return GatewayFeaturesType.subclass(*args_, **kwargs_)
        else:
            return GatewayFeaturesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NetworkService(self): return self.NetworkService
    def set_NetworkService(self, NetworkService): self.NetworkService = NetworkService
    def add_NetworkService(self, value): self.NetworkService.append(value)
    def insert_NetworkService_at(self, index, value): self.NetworkService.insert(index, value)
    def replace_NetworkService_at(self, index, value): self.NetworkService[index] = value
    def hasContent_(self):
        if (
            self.NetworkService or
            super(GatewayFeaturesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayFeaturesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayFeaturesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayFeaturesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayFeaturesType'):
        super(GatewayFeaturesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayFeaturesType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayFeaturesType', fromsubclass_=False, pretty_print=True):
        super(GatewayFeaturesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NetworkService_ in self.NetworkService:
            NetworkService_.export(outfile, level, namespace_, name_='NetworkService', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GatewayFeaturesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayFeaturesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayFeaturesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('NetworkService=[\n')
        level += 1
        for NetworkService_ in self.NetworkService:
            showIndent(outfile, level)
            outfile.write('model_.NetworkService(\n')
            NetworkService_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayFeaturesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetworkService':
            class_obj_ = self.get_class_obj_(child_, NetworkServiceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'NetworkService'
        elif nodeName_ == 'DhcpService':
            obj_ = DhcpServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'DhcpService'
        elif nodeName_ == 'FirewallService':
            obj_ = FirewallServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'FirewallService'
        elif nodeName_ == 'NatService':
            obj_ = NatServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'NatService'
        elif nodeName_ == 'IpsecVpnService':
            obj_ = IpsecVpnServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'IpsecVpnService'
        elif nodeName_ == 'StaticRoutingService':
            obj_ = StaticRoutingServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'StaticRoutingService'
        elif nodeName_ == 'GatewayIpsecVpnService':
            obj_ = GatewayIpsecVpnServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'GatewayIpsecVpnService'
        elif nodeName_ == 'LoadBalancerService':
            obj_ = LoadBalancerServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'LoadBalancerService'
        elif nodeName_ == 'GatewayDhcpService':
            obj_ = GatewayDhcpServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'GatewayDhcpService'
        super(GatewayFeaturesType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayFeaturesType


class SubnetParticipationType(VCloudExtensibleType):
    """5.1 Allows to chose which subnets a gateway can be part of"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Gateway=None, Netmask=None, IpAddress=None, IpRanges=None):
        self.original_tagname_ = None
        super(SubnetParticipationType, self).__init__(VCloudExtension, )
        self.Gateway = Gateway
        self.validate_IpAddressType(self.Gateway)
        self.Netmask = Netmask
        self.validate_IpAddressType(self.Netmask)
        self.IpAddress = IpAddress
        self.validate_IpAddressType(self.IpAddress)
        self.IpRanges = IpRanges
    def factory(*args_, **kwargs_):
        if SubnetParticipationType.subclass:
            return SubnetParticipationType.subclass(*args_, **kwargs_)
        else:
            return SubnetParticipationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Gateway(self): return self.Gateway
    def set_Gateway(self, Gateway): self.Gateway = Gateway
    def get_Netmask(self): return self.Netmask
    def set_Netmask(self, Netmask): self.Netmask = Netmask
    def get_IpAddress(self): return self.IpAddress
    def set_IpAddress(self, IpAddress): self.IpAddress = IpAddress
    def get_IpRanges(self): return self.IpRanges
    def set_IpRanges(self, IpRanges): self.IpRanges = IpRanges
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Gateway is not None or
            self.Netmask is not None or
            self.IpAddress is not None or
            self.IpRanges is not None or
            super(SubnetParticipationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubnetParticipationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubnetParticipationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubnetParticipationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubnetParticipationType'):
        super(SubnetParticipationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubnetParticipationType')
    def exportChildren(self, outfile, level, namespace_='', name_='SubnetParticipationType', fromsubclass_=False, pretty_print=True):
        super(SubnetParticipationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Gateway is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGateway>%s</%sGateway>%s' % (namespace_, self.gds_format_string(quote_xml(self.Gateway).encode(ExternalEncoding), input_name='Gateway'), namespace_, eol_))
        if self.Netmask is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetmask>%s</%sNetmask>%s' % (namespace_, self.gds_format_string(quote_xml(self.Netmask).encode(ExternalEncoding), input_name='Netmask'), namespace_, eol_))
        if self.IpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpAddress>%s</%sIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IpAddress).encode(ExternalEncoding), input_name='IpAddress'), namespace_, eol_))
        if self.IpRanges is not None:
            self.IpRanges.export(outfile, level, namespace_, name_='IpRanges', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubnetParticipationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SubnetParticipationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubnetParticipationType, self).exportLiteralChildren(outfile, level, name_)
        if self.Gateway is not None:
            showIndent(outfile, level)
            outfile.write('Gateway=%s,\n' % quote_python(self.Gateway).encode(ExternalEncoding))
        if self.Netmask is not None:
            showIndent(outfile, level)
            outfile.write('Netmask=%s,\n' % quote_python(self.Netmask).encode(ExternalEncoding))
        if self.IpAddress is not None:
            showIndent(outfile, level)
            outfile.write('IpAddress=%s,\n' % quote_python(self.IpAddress).encode(ExternalEncoding))
        if self.IpRanges is not None:
            showIndent(outfile, level)
            outfile.write('IpRanges=model_.IpRangesType(\n')
            self.IpRanges.exportLiteral(outfile, level, name_='IpRanges')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SubnetParticipationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Gateway':
            Gateway_ = child_.text
            Gateway_ = self.gds_validate_string(Gateway_, node, 'Gateway')
            self.Gateway = Gateway_
            self.validate_IpAddressType(self.Gateway)    # validate type IpAddressType
        elif nodeName_ == 'Netmask':
            Netmask_ = child_.text
            Netmask_ = self.gds_validate_string(Netmask_, node, 'Netmask')
            self.Netmask = Netmask_
            self.validate_IpAddressType(self.Netmask)    # validate type IpAddressType
        elif nodeName_ == 'IpAddress':
            IpAddress_ = child_.text
            IpAddress_ = self.gds_validate_string(IpAddress_, node, 'IpAddress')
            self.IpAddress = IpAddress_
            self.validate_IpAddressType(self.IpAddress)    # validate type IpAddressType
        elif nodeName_ == 'IpRanges':
            obj_ = IpRangesType.factory()
            obj_.build(child_)
            self.IpRanges = obj_
            obj_.original_tagname_ = 'IpRanges'
        super(SubnetParticipationType, self).buildChildren(child_, node, nodeName_, True)
# end class SubnetParticipationType


class VendorServicesType(GeneratedsSuper):
    """5.1 Vendor services available for service insertion on networks or
    edge gateways."""
    subclass = None
    superclass = None
    def __init__(self, NetworkServices=None, EdgeGatewayServices=None):
        self.original_tagname_ = None
        if NetworkServices is None:
            self.NetworkServices = []
        else:
            self.NetworkServices = NetworkServices
        if EdgeGatewayServices is None:
            self.EdgeGatewayServices = []
        else:
            self.EdgeGatewayServices = EdgeGatewayServices
    def factory(*args_, **kwargs_):
        if VendorServicesType.subclass:
            return VendorServicesType.subclass(*args_, **kwargs_)
        else:
            return VendorServicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NetworkServices(self): return self.NetworkServices
    def set_NetworkServices(self, NetworkServices): self.NetworkServices = NetworkServices
    def add_NetworkServices(self, value): self.NetworkServices.append(value)
    def insert_NetworkServices_at(self, index, value): self.NetworkServices.insert(index, value)
    def replace_NetworkServices_at(self, index, value): self.NetworkServices[index] = value
    def get_EdgeGatewayServices(self): return self.EdgeGatewayServices
    def set_EdgeGatewayServices(self, EdgeGatewayServices): self.EdgeGatewayServices = EdgeGatewayServices
    def add_EdgeGatewayServices(self, value): self.EdgeGatewayServices.append(value)
    def insert_EdgeGatewayServices_at(self, index, value): self.EdgeGatewayServices.insert(index, value)
    def replace_EdgeGatewayServices_at(self, index, value): self.EdgeGatewayServices[index] = value
    def hasContent_(self):
        if (
            self.NetworkServices or
            self.EdgeGatewayServices
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VendorServicesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VendorServicesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VendorServicesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VendorServicesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VendorServicesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NetworkServices_ in self.NetworkServices:
            NetworkServices_.export(outfile, level, namespace_, name_='NetworkServices', pretty_print=pretty_print)
        for EdgeGatewayServices_ in self.EdgeGatewayServices:
            EdgeGatewayServices_.export(outfile, level, namespace_, name_='EdgeGatewayServices', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VendorServicesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NetworkServices=[\n')
        level += 1
        for NetworkServices_ in self.NetworkServices:
            showIndent(outfile, level)
            outfile.write('model_.NetworkServiceInsertionType(\n')
            NetworkServices_.exportLiteral(outfile, level, name_='NetworkServiceInsertionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EdgeGatewayServices=[\n')
        level += 1
        for EdgeGatewayServices_ in self.EdgeGatewayServices:
            showIndent(outfile, level)
            outfile.write('model_.NetworkServiceInsertionType(\n')
            EdgeGatewayServices_.exportLiteral(outfile, level, name_='NetworkServiceInsertionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetworkServices':
            obj_ = NetworkServiceInsertionType.factory()
            obj_.build(child_)
            self.NetworkServices.append(obj_)
            obj_.original_tagname_ = 'NetworkServices'
        elif nodeName_ == 'EdgeGatewayServices':
            obj_ = NetworkServiceInsertionType.factory()
            obj_.build(child_)
            self.EdgeGatewayServices.append(obj_)
            obj_.original_tagname_ = 'EdgeGatewayServices'
# end class VendorServicesType


class NetworkServiceInsertionType(VCloudExtensibleType):
    """5.1 always Information about a network service that has been
    inserted"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Id=None, Category=None, CategoryType=None, VendorTemplates=None):
        self.original_tagname_ = None
        super(NetworkServiceInsertionType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Id = Id
        self.Category = Category
        self.CategoryType = CategoryType
        if VendorTemplates is None:
            self.VendorTemplates = []
        else:
            self.VendorTemplates = VendorTemplates
    def factory(*args_, **kwargs_):
        if NetworkServiceInsertionType.subclass:
            return NetworkServiceInsertionType.subclass(*args_, **kwargs_)
        else:
            return NetworkServiceInsertionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def get_CategoryType(self): return self.CategoryType
    def set_CategoryType(self, CategoryType): self.CategoryType = CategoryType
    def get_VendorTemplates(self): return self.VendorTemplates
    def set_VendorTemplates(self, VendorTemplates): self.VendorTemplates = VendorTemplates
    def add_VendorTemplates(self, value): self.VendorTemplates.append(value)
    def insert_VendorTemplates_at(self, index, value): self.VendorTemplates.insert(index, value)
    def replace_VendorTemplates_at(self, index, value): self.VendorTemplates[index] = value
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Id is not None or
            self.Category is not None or
            self.CategoryType is not None or
            self.VendorTemplates or
            super(NetworkServiceInsertionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkServiceInsertionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkServiceInsertionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkServiceInsertionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkServiceInsertionType'):
        super(NetworkServiceInsertionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkServiceInsertionType')
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkServiceInsertionType', fromsubclass_=False, pretty_print=True):
        super(NetworkServiceInsertionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_, eol_))
        if self.Category is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategory>%s</%sCategory>%s' % (namespace_, self.gds_format_string(quote_xml(self.Category).encode(ExternalEncoding), input_name='Category'), namespace_, eol_))
        if self.CategoryType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategoryType>%s</%sCategoryType>%s' % (namespace_, self.gds_format_string(quote_xml(self.CategoryType).encode(ExternalEncoding), input_name='CategoryType'), namespace_, eol_))
        for VendorTemplates_ in self.VendorTemplates:
            VendorTemplates_.export(outfile, level, namespace_, name_='VendorTemplates', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkServiceInsertionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NetworkServiceInsertionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkServiceInsertionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
        if self.Category is not None:
            showIndent(outfile, level)
            outfile.write('Category=%s,\n' % quote_python(self.Category).encode(ExternalEncoding))
        if self.CategoryType is not None:
            showIndent(outfile, level)
            outfile.write('CategoryType=%s,\n' % quote_python(self.CategoryType).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('VendorTemplates=[\n')
        level += 1
        for VendorTemplates_ in self.VendorTemplates:
            showIndent(outfile, level)
            outfile.write('model_.VendorTemplateType(\n')
            VendorTemplates_.exportLiteral(outfile, level, name_='VendorTemplateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NetworkServiceInsertionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'Category':
            Category_ = child_.text
            Category_ = self.gds_validate_string(Category_, node, 'Category')
            self.Category = Category_
        elif nodeName_ == 'CategoryType':
            CategoryType_ = child_.text
            CategoryType_ = self.gds_validate_string(CategoryType_, node, 'CategoryType')
            self.CategoryType = CategoryType_
        elif nodeName_ == 'VendorTemplates':
            obj_ = VendorTemplateType.factory()
            obj_.build(child_)
            self.VendorTemplates.append(obj_)
            obj_.original_tagname_ = 'VendorTemplates'
        super(NetworkServiceInsertionType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkServiceInsertionType


class VendorTemplateType(VCloudExtensibleType):
    """5.1 always Information about a vendor service template. This is
    optional."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Id=None, VendorTemplateAttributes=None):
        self.original_tagname_ = None
        super(VendorTemplateType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Id = Id
        if VendorTemplateAttributes is None:
            self.VendorTemplateAttributes = []
        else:
            self.VendorTemplateAttributes = VendorTemplateAttributes
    def factory(*args_, **kwargs_):
        if VendorTemplateType.subclass:
            return VendorTemplateType.subclass(*args_, **kwargs_)
        else:
            return VendorTemplateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_VendorTemplateAttributes(self): return self.VendorTemplateAttributes
    def set_VendorTemplateAttributes(self, VendorTemplateAttributes): self.VendorTemplateAttributes = VendorTemplateAttributes
    def add_VendorTemplateAttributes(self, value): self.VendorTemplateAttributes.append(value)
    def insert_VendorTemplateAttributes_at(self, index, value): self.VendorTemplateAttributes.insert(index, value)
    def replace_VendorTemplateAttributes_at(self, index, value): self.VendorTemplateAttributes[index] = value
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Id is not None or
            self.VendorTemplateAttributes or
            super(VendorTemplateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VendorTemplateType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VendorTemplateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VendorTemplateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VendorTemplateType'):
        super(VendorTemplateType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VendorTemplateType')
    def exportChildren(self, outfile, level, namespace_='', name_='VendorTemplateType', fromsubclass_=False, pretty_print=True):
        super(VendorTemplateType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_, eol_))
        for VendorTemplateAttributes_ in self.VendorTemplateAttributes:
            VendorTemplateAttributes_.export(outfile, level, namespace_, name_='VendorTemplateAttributes', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VendorTemplateType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VendorTemplateType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VendorTemplateType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('VendorTemplateAttributes=[\n')
        level += 1
        for VendorTemplateAttributes_ in self.VendorTemplateAttributes:
            showIndent(outfile, level)
            outfile.write('model_.VendorTemplateAttributesType(\n')
            VendorTemplateAttributes_.exportLiteral(outfile, level, name_='VendorTemplateAttributesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VendorTemplateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'VendorTemplateAttributes':
            obj_ = VendorTemplateAttributesType.factory()
            obj_.build(child_)
            self.VendorTemplateAttributes.append(obj_)
            obj_.original_tagname_ = 'VendorTemplateAttributes'
        super(VendorTemplateType, self).buildChildren(child_, node, nodeName_, True)
# end class VendorTemplateType


class VendorTemplateAttributesType(VCloudExtensibleType):
    """5.1 always Information about vendor template attributes"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Key=None, Value=None):
        self.original_tagname_ = None
        super(VendorTemplateAttributesType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Key = Key
        self.Value = Value
    def factory(*args_, **kwargs_):
        if VendorTemplateAttributesType.subclass:
            return VendorTemplateAttributesType.subclass(*args_, **kwargs_)
        else:
            return VendorTemplateAttributesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Key is not None or
            self.Value is not None or
            super(VendorTemplateAttributesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VendorTemplateAttributesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VendorTemplateAttributesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VendorTemplateAttributesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VendorTemplateAttributesType'):
        super(VendorTemplateAttributesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VendorTemplateAttributesType')
    def exportChildren(self, outfile, level, namespace_='', name_='VendorTemplateAttributesType', fromsubclass_=False, pretty_print=True):
        super(VendorTemplateAttributesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKey>%s</%sKey>%s' % (namespace_, self.gds_format_string(quote_xml(self.Key).encode(ExternalEncoding), input_name='Key'), namespace_, eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VendorTemplateAttributesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VendorTemplateAttributesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VendorTemplateAttributesType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Key is not None:
            showIndent(outfile, level)
            outfile.write('Key=%s,\n' % quote_python(self.Key).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VendorTemplateAttributesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Key':
            Key_ = child_.text
            Key_ = self.gds_validate_string(Key_, node, 'Key')
            self.Key = Key_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        super(VendorTemplateAttributesType, self).buildChildren(child_, node, nodeName_, True)
# end class VendorTemplateAttributesType


class VdcStorageProfilesType(VCloudExtensibleType):
    """5.1 Container for references to storage profiles associated with a
    vDC."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, VdcStorageProfile=None):
        self.original_tagname_ = None
        super(VdcStorageProfilesType, self).__init__(VCloudExtension, )
        if VdcStorageProfile is None:
            self.VdcStorageProfile = []
        else:
            self.VdcStorageProfile = VdcStorageProfile
    def factory(*args_, **kwargs_):
        if VdcStorageProfilesType.subclass:
            return VdcStorageProfilesType.subclass(*args_, **kwargs_)
        else:
            return VdcStorageProfilesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VdcStorageProfile(self): return self.VdcStorageProfile
    def set_VdcStorageProfile(self, VdcStorageProfile): self.VdcStorageProfile = VdcStorageProfile
    def add_VdcStorageProfile(self, value): self.VdcStorageProfile.append(value)
    def insert_VdcStorageProfile_at(self, index, value): self.VdcStorageProfile.insert(index, value)
    def replace_VdcStorageProfile_at(self, index, value): self.VdcStorageProfile[index] = value
    def hasContent_(self):
        if (
            self.VdcStorageProfile or
            super(VdcStorageProfilesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VdcStorageProfilesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VdcStorageProfilesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VdcStorageProfilesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VdcStorageProfilesType'):
        super(VdcStorageProfilesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VdcStorageProfilesType')
    def exportChildren(self, outfile, level, namespace_='', name_='VdcStorageProfilesType', fromsubclass_=False, pretty_print=True):
        super(VdcStorageProfilesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VdcStorageProfile_ in self.VdcStorageProfile:
            VdcStorageProfile_.export(outfile, level, namespace_, name_='VdcStorageProfile', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VdcStorageProfilesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VdcStorageProfilesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VdcStorageProfilesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('VdcStorageProfile=[\n')
        level += 1
        for VdcStorageProfile_ in self.VdcStorageProfile:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            VdcStorageProfile_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VdcStorageProfilesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VdcStorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VdcStorageProfile.append(obj_)
            obj_.original_tagname_ = 'VdcStorageProfile'
        super(VdcStorageProfilesType, self).buildChildren(child_, node, nodeName_, True)
# end class VdcStorageProfilesType


class VdcStorageProfileType(EntityType):
    """5.1 Represents a storage profile in an organization vDC."""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, Enabled=None, Units=None, Limit=None, Default=None):
        self.original_tagname_ = None
        super(VdcStorageProfileType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.Enabled = Enabled
        self.Units = Units
        self.Limit = Limit
        self.Default = Default
    def factory(*args_, **kwargs_):
        if VdcStorageProfileType.subclass:
            return VdcStorageProfileType.subclass(*args_, **kwargs_)
        else:
            return VdcStorageProfileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Enabled(self): return self.Enabled
    def set_Enabled(self, Enabled): self.Enabled = Enabled
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def get_Limit(self): return self.Limit
    def set_Limit(self, Limit): self.Limit = Limit
    def get_Default(self): return self.Default
    def set_Default(self, Default): self.Default = Default
    def hasContent_(self):
        if (
            self.Enabled is not None or
            self.Units is not None or
            self.Limit is not None or
            self.Default is not None or
            super(VdcStorageProfileType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VdcStorageProfileType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VdcStorageProfileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VdcStorageProfileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VdcStorageProfileType'):
        super(VdcStorageProfileType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VdcStorageProfileType')
    def exportChildren(self, outfile, level, namespace_='', name_='VdcStorageProfileType', fromsubclass_=False, pretty_print=True):
        super(VdcStorageProfileType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnabled>%s</%sEnabled>%s' % (namespace_, self.gds_format_boolean(self.Enabled, input_name='Enabled'), namespace_, eol_))
        if self.Units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnits>%s</%sUnits>%s' % (namespace_, self.gds_format_string(quote_xml(self.Units).encode(ExternalEncoding), input_name='Units'), namespace_, eol_))
        if self.Limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLimit>%s</%sLimit>%s' % (namespace_, self.gds_format_integer(self.Limit, input_name='Limit'), namespace_, eol_))
        if self.Default is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefault>%s</%sDefault>%s' % (namespace_, self.gds_format_boolean(self.Default, input_name='Default'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VdcStorageProfileType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VdcStorageProfileType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VdcStorageProfileType, self).exportLiteralChildren(outfile, level, name_)
        if self.Enabled is not None:
            showIndent(outfile, level)
            outfile.write('Enabled=%s,\n' % self.Enabled)
        if self.Units is not None:
            showIndent(outfile, level)
            outfile.write('Units=%s,\n' % quote_python(self.Units).encode(ExternalEncoding))
        if self.Limit is not None:
            showIndent(outfile, level)
            outfile.write('Limit=%d,\n' % self.Limit)
        if self.Default is not None:
            showIndent(outfile, level)
            outfile.write('Default=%s,\n' % self.Default)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VdcStorageProfileType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Enabled')
            self.Enabled = ival_
        elif nodeName_ == 'Units':
            Units_ = child_.text
            Units_ = self.gds_validate_string(Units_, node, 'Units')
            self.Units = Units_
        elif nodeName_ == 'Limit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Limit')
            self.Limit = ival_
        elif nodeName_ == 'Default':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Default')
            self.Default = ival_
        super(VdcStorageProfileType, self).buildChildren(child_, node, nodeName_, True)
# end class VdcStorageProfileType


class EnvelopeType(GeneratedsSuper):
    """Root OVF descriptor type"""
    subclass = None
    superclass = None
    def __init__(self, lang='en-US', References=None, Section=None, Content=None, Strings=None):
        self.original_tagname_ = None
        self.lang = _cast(None, lang)
        self.References = References
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
        self.Content = Content
        if Strings is None:
            self.Strings = []
        else:
            self.Strings = Strings
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if EnvelopeType.subclass:
            return EnvelopeType.subclass(*args_, **kwargs_)
        else:
            return EnvelopeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_References(self): return self.References
    def set_References(self, References): self.References = References
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def get_Content(self): return self.Content
    def set_Content(self, Content): self.Content = Content
    def get_Strings(self): return self.Strings
    def set_Strings(self, Strings): self.Strings = Strings
    def add_Strings(self, value): self.Strings.append(value)
    def insert_Strings_at(self, index, value): self.Strings.insert(index, value)
    def replace_Strings_at(self, index, value): self.Strings[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.References is not None or
            self.Section or
            self.Content is not None or
            self.Strings
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EnvelopeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnvelopeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EnvelopeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EnvelopeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EnvelopeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.References is not None:
            self.References.export(outfile, level, namespace_, name_='References', pretty_print=pretty_print)
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovf:', name_='Section', pretty_print=pretty_print)
        if self.Content is not None:
            self.Content.export(outfile, level, namespace_='ovf:', name_='Content', pretty_print=pretty_print)
        for Strings_ in self.Strings:
            Strings_.export(outfile, level, namespace_, name_='Strings', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EnvelopeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.References is not None:
            showIndent(outfile, level)
            outfile.write('References=model_.References_Type(\n')
            self.References.exportLiteral(outfile, level, name_='References')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Content is not None:
            showIndent(outfile, level)
            outfile.write('Content=model_.Content(\n')
            self.Content.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Strings=[\n')
        level += 1
        for Strings_ in self.Strings:
            showIndent(outfile, level)
            outfile.write('model_.Strings_Type(\n')
            Strings_.exportLiteral(outfile, level, name_='Strings_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'References':
            obj_ = References_Type.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'References'
        elif nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
        elif nodeName_ == 'Content':
            class_obj_ = self.get_class_obj_(child_, Content_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Content = obj_
            obj_.original_tagname_ = 'Content'
        elif nodeName_ == 'VirtualSystem':
            obj_ = VirtualSystem_Type.factory()
            obj_.build(child_)
            self.Content = obj_
            obj_.original_tagname_ = 'VirtualSystem'
        elif nodeName_ == 'VirtualSystemCollection':
            obj_ = VirtualSystemCollection_Type.factory()
            obj_.build(child_)
            self.Content = obj_
            obj_.original_tagname_ = 'VirtualSystemCollection'
        elif nodeName_ == 'Strings':
            obj_ = Strings_Type.factory()
            obj_.build(child_)
            self.Strings.append(obj_)
            obj_.original_tagname_ = 'Strings'
# end class EnvelopeType


class References_Type(GeneratedsSuper):
    """Type for list of external resources"""
    subclass = None
    superclass = None
    def __init__(self, File=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if File is None:
            self.File = []
        else:
            self.File = File
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if References_Type.subclass:
            return References_Type.subclass(*args_, **kwargs_)
        else:
            return References_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_File(self): return self.File
    def set_File(self, File): self.File = File
    def add_File(self, value): self.File.append(value)
    def insert_File_at(self, index, value): self.File.insert(index, value)
    def replace_File_at(self, index, value): self.File[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.File or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='References_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='References_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='References_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='References_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='References_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for File_ in self.File:
            File_.export(outfile, level, namespace_, name_='File', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='References_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('File=[\n')
        level += 1
        for File_ in self.File:
            showIndent(outfile, level)
            outfile.write('model_.File_Type(\n')
            File_.exportLiteral(outfile, level, name_='File_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'File':
            obj_ = File_Type.factory()
            obj_.build(child_)
            self.File.append(obj_)
            obj_.original_tagname_ = 'File'
        else:
            obj_ = self.gds_build_any(child_, 'References_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class References_Type


class File_Type(GeneratedsSuper):
    """Type for an external reference to a resourceReference key used in
    other parts of the packageLocation of external resourceSize in
    bytes of the files (if known)Compression type (gzip, bzip2, or
    none if empty or not specified)Chunk size (except for last
    chunk)"""
    subclass = None
    superclass = None
    def __init__(self, compression='', href=None, chunkSize=None, id=None, size=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.compression = _cast(None, compression)
        self.href = _cast(None, href)
        self.chunkSize = _cast(int, chunkSize)
        self.id = _cast(None, id)
        self.size = _cast(int, size)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if File_Type.subclass:
            return File_Type.subclass(*args_, **kwargs_)
        else:
            return File_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_compression(self): return self.compression
    def set_compression(self, compression): self.compression = compression
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_chunkSize(self): return self.chunkSize
    def set_chunkSize(self, chunkSize): self.chunkSize = chunkSize
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='File_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='File_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='File_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='File_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            outfile.write(' compression=%s' % (self.gds_format_string(quote_attrib(self.compression).encode(ExternalEncoding), input_name='compression'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.chunkSize is not None and 'chunkSize' not in already_processed:
            already_processed.add('chunkSize')
            outfile.write(' chunkSize="%s"' % self.gds_format_integer(self.chunkSize, input_name='chunkSize'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespace_='', name_='File_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='File_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            showIndent(outfile, level)
            outfile.write('compression="%s",\n' % (self.compression,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.chunkSize is not None and 'chunkSize' not in already_processed:
            already_processed.add('chunkSize')
            showIndent(outfile, level)
            outfile.write('chunkSize=%d,\n' % (self.chunkSize,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % (self.size,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('compression', node)
        if value is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            self.compression = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('chunkSize', node)
        if value is not None and 'chunkSize' not in already_processed:
            already_processed.add('chunkSize')
            try:
                self.chunkSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'File_Type')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class File_Type


class Content_Type(GeneratedsSuper):
    """Base class for content"""
    subclass = None
    superclass = None
    def __init__(self, id=None, Info=None, Name=None, Section=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.Info = Info
        self.Name = Name
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Content_Type.subclass:
            return Content_Type.subclass(*args_, **kwargs_)
        else:
            return Content_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Info(self): return self.Info
    def set_Info(self, Info): self.Info = Info
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Info is not None or
            self.Name is not None or
            self.Section
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Content_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Content_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Content_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Content_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Content_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Info is not None:
            self.Info.export(outfile, level, namespace_, name_='Info', pretty_print=pretty_print)
        if self.Name is not None:
            self.Name.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovf:', name_='Section', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Content_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Info is not None:
            showIndent(outfile, level)
            outfile.write('Info=model_.Msg_Type(\n')
            self.Info.exportLiteral(outfile, level, name_='Info')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=model_.Msg_Type(\n')
            self.Name.exportLiteral(outfile, level, name_='Name')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Info':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Info = obj_
            obj_.original_tagname_ = 'Info'
        elif nodeName_ == 'Name':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
# end class Content_Type


class VirtualSystem_Type(Content_Type):
    """Content describing a virtual system"""
    subclass = None
    superclass = Content_Type
    def __init__(self, id=None, Info=None, Name=None, Section=None):
        self.original_tagname_ = None
        super(VirtualSystem_Type, self).__init__(id, Info, Name, Section, )
    def factory(*args_, **kwargs_):
        if VirtualSystem_Type.subclass:
            return VirtualSystem_Type.subclass(*args_, **kwargs_)
        else:
            return VirtualSystem_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(VirtualSystem_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VirtualSystem_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualSystem_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VirtualSystem_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualSystem_Type'):
        super(VirtualSystem_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualSystem_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualSystem_Type', fromsubclass_=False, pretty_print=True):
        super(VirtualSystem_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VirtualSystem_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VirtualSystem_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VirtualSystem_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VirtualSystem_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VirtualSystem_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VirtualSystem_Type


class VirtualSystemCollection_Type(Content_Type):
    """A collection of Content."""
    subclass = None
    superclass = Content_Type
    def __init__(self, id=None, Info=None, Name=None, Section=None, Content=None):
        self.original_tagname_ = None
        super(VirtualSystemCollection_Type, self).__init__(id, Info, Name, Section, )
        if Content is None:
            self.Content = []
        else:
            self.Content = Content
    def factory(*args_, **kwargs_):
        if VirtualSystemCollection_Type.subclass:
            return VirtualSystemCollection_Type.subclass(*args_, **kwargs_)
        else:
            return VirtualSystemCollection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Content(self): return self.Content
    def set_Content(self, Content): self.Content = Content
    def add_Content(self, value): self.Content.append(value)
    def insert_Content_at(self, index, value): self.Content.insert(index, value)
    def replace_Content_at(self, index, value): self.Content[index] = value
    def hasContent_(self):
        if (
            self.Content or
            super(VirtualSystemCollection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VirtualSystemCollection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualSystemCollection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VirtualSystemCollection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualSystemCollection_Type'):
        super(VirtualSystemCollection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualSystemCollection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualSystemCollection_Type', fromsubclass_=False, pretty_print=True):
        super(VirtualSystemCollection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Content_ in self.Content:
            Content_.export(outfile, level, namespace_='ovf:', name_='Content', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VirtualSystemCollection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VirtualSystemCollection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VirtualSystemCollection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Content=[\n')
        level += 1
        for Content_ in self.Content:
            showIndent(outfile, level)
            outfile.write('model_.Content(\n')
            Content_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VirtualSystemCollection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Content':
            class_obj_ = self.get_class_obj_(child_, Content_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Content.append(obj_)
            obj_.original_tagname_ = 'Content'
        elif nodeName_ == 'VirtualSystem':
            obj_ = VirtualSystem_Type.factory()
            obj_.build(child_)
            self.Content.append(obj_)
            obj_.original_tagname_ = 'VirtualSystem'
        elif nodeName_ == 'VirtualSystemCollection':
            obj_ = VirtualSystemCollection_Type.factory()
            obj_.build(child_)
            self.Content.append(obj_)
            obj_.original_tagname_ = 'VirtualSystemCollection'
        super(VirtualSystemCollection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class VirtualSystemCollection_Type


class Strings_Type(GeneratedsSuper):
    """Type for string resource bundleLocale for this string resource
    bundleReference to external resource bundle"""
    subclass = None
    superclass = None
    def __init__(self, lang=None, fileRef=None, Msg=None):
        self.original_tagname_ = None
        self.lang = _cast(None, lang)
        self.fileRef = _cast(None, fileRef)
        if Msg is None:
            self.Msg = []
        else:
            self.Msg = Msg
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Strings_Type.subclass:
            return Strings_Type.subclass(*args_, **kwargs_)
        else:
            return Strings_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Msg(self): return self.Msg
    def set_Msg(self, Msg): self.Msg = Msg
    def add_Msg(self, value): self.Msg.append(value)
    def insert_Msg_at(self, index, value): self.Msg.insert(index, value)
    def replace_Msg_at(self, index, value): self.Msg[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_fileRef(self): return self.fileRef
    def set_fileRef(self, fileRef): self.fileRef = fileRef
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Msg
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Strings_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Strings_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Strings_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Strings_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.fileRef is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            outfile.write(' fileRef=%s' % (self.gds_format_string(quote_attrib(self.fileRef).encode(ExternalEncoding), input_name='fileRef'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Strings_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Msg_ in self.Msg:
            Msg_.export(outfile, level, namespace_, name_='Msg', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Strings_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.fileRef is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            showIndent(outfile, level)
            outfile.write('fileRef="%s",\n' % (self.fileRef,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Msg=[\n')
        level += 1
        for Msg_ in self.Msg:
            showIndent(outfile, level)
            outfile.write('model_.MsgType(\n')
            Msg_.exportLiteral(outfile, level, name_='MsgType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('fileRef', node)
        if value is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            self.fileRef = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Msg':
            obj_ = MsgType.factory()
            obj_.build(child_)
            self.Msg.append(obj_)
            obj_.original_tagname_ = 'Msg'
# end class Strings_Type


class Section_Type(GeneratedsSuper):
    """Base type for Sections, subclassing this is the most common form of
    extensibility. Subtypes define more specific elements."""
    subclass = None
    superclass = None
    def __init__(self, required=None, Info=None):
        self.original_tagname_ = None
        self.required = _cast(bool, required)
        self.Info = Info
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Section_Type.subclass:
            return Section_Type.subclass(*args_, **kwargs_)
        else:
            return Section_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Info(self): return self.Info
    def set_Info(self, Info): self.Info = Info
    def get_required(self): return self.required
    def set_required(self, required): self.required = required
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Info is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Section_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Section_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Section_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Section_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required="%s"' % self.gds_format_boolean(self.required, input_name='required'))
    def exportChildren(self, outfile, level, namespace_='', name_='Section_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Info is not None:
            self.Info.export(outfile, level, namespace_, name_='Info', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Section_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            showIndent(outfile, level)
            outfile.write('required=%s,\n' % (self.required,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Info is not None:
            showIndent(outfile, level)
            outfile.write('Info=model_.Msg_Type(\n')
            self.Info.exportLiteral(outfile, level, name_='Info')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            if value in ('true', '1'):
                self.required = True
            elif value in ('false', '0'):
                self.required = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Info':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Info = obj_
            obj_.original_tagname_ = 'Info'
# end class Section_Type


class Msg_Type(GeneratedsSuper):
    """Type for localizable stringDefault string valueIdentifier for lookup
    in string resource bundle for alternate locale"""
    subclass = None
    superclass = None
    def __init__(self, msgid='', valueOf_=None):
        self.original_tagname_ = None
        self.msgid = _cast(None, msgid)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Msg_Type.subclass:
            return Msg_Type.subclass(*args_, **kwargs_)
        else:
            return Msg_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_msgid(self): return self.msgid
    def set_msgid(self, msgid): self.msgid = msgid
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Msg_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Msg_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Msg_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Msg_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.msgid is not None and 'msgid' not in already_processed:
            already_processed.add('msgid')
            outfile.write(' msgid=%s' % (self.gds_format_string(quote_attrib(self.msgid).encode(ExternalEncoding), input_name='msgid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Msg_Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Msg_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.msgid is not None and 'msgid' not in already_processed:
            already_processed.add('msgid')
            showIndent(outfile, level)
            outfile.write('msgid="%s",\n' % (self.msgid,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('msgid', node)
        if value is not None and 'msgid' not in already_processed:
            already_processed.add('msgid')
            self.msgid = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Msg_Type


class AnnotationSection_Type(Section_Type):
    """User defined annotation"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Annotation=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(AnnotationSection_Type, self).__init__()
        self.Annotation = Annotation
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if AnnotationSection_Type.subclass:
            return AnnotationSection_Type.subclass(*args_, **kwargs_)
        else:
            return AnnotationSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Annotation(self): return self.Annotation
    def set_Annotation(self, Annotation): self.Annotation = Annotation
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Annotation is not None or
            self.anytypeobjs_ or
            super(AnnotationSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AnnotationSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnotationSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AnnotationSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AnnotationSection_Type'):
        super(AnnotationSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AnnotationSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='AnnotationSection_Type', fromsubclass_=False, pretty_print=True):
        super(AnnotationSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Annotation is not None:
            self.Annotation.export(outfile, level, namespace_, name_='Annotation', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AnnotationSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AnnotationSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AnnotationSection_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.Annotation is not None:
            showIndent(outfile, level)
            outfile.write('Annotation=model_.Msg_Type(\n')
            self.Annotation.exportLiteral(outfile, level, name_='Annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AnnotationSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Annotation':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Annotation = obj_
            obj_.original_tagname_ = 'Annotation'
        else:
            obj_ = self.gds_build_any(child_, 'AnnotationSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(AnnotationSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class AnnotationSection_Type


class ProductSection_Type(Section_Type):
    """Product information for a virtual applianceProperties for
    application-level customizationProperty identifier
    prefixProperty identifier suffix"""
    subclass = None
    superclass = Section_Type
    def __init__(self, instance='', class_='', Product=None, Vendor=None, Version=None, FullVersion=None, ProductUrl=None, VendorUrl=None, AppUrl=None, Icon=None, Category=None, Property=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(ProductSection_Type, self).__init__()
        self.instance = _cast(None, instance)
        self.class_ = _cast(None, class_)
        self.Product = Product
        self.Vendor = Vendor
        self.Version = Version
        self.FullVersion = FullVersion
        self.ProductUrl = ProductUrl
        self.VendorUrl = VendorUrl
        self.AppUrl = AppUrl
        if Icon is None:
            self.Icon = []
        else:
            self.Icon = Icon
        if Category is None:
            self.Category = []
        else:
            self.Category = Category
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if ProductSection_Type.subclass:
            return ProductSection_Type.subclass(*args_, **kwargs_)
        else:
            return ProductSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Product(self): return self.Product
    def set_Product(self, Product): self.Product = Product
    def get_Vendor(self): return self.Vendor
    def set_Vendor(self, Vendor): self.Vendor = Vendor
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_FullVersion(self): return self.FullVersion
    def set_FullVersion(self, FullVersion): self.FullVersion = FullVersion
    def get_ProductUrl(self): return self.ProductUrl
    def set_ProductUrl(self, ProductUrl): self.ProductUrl = ProductUrl
    def get_VendorUrl(self): return self.VendorUrl
    def set_VendorUrl(self, VendorUrl): self.VendorUrl = VendorUrl
    def get_AppUrl(self): return self.AppUrl
    def set_AppUrl(self, AppUrl): self.AppUrl = AppUrl
    def get_Icon(self): return self.Icon
    def set_Icon(self, Icon): self.Icon = Icon
    def add_Icon(self, value): self.Icon.append(value)
    def insert_Icon_at(self, index, value): self.Icon.insert(index, value)
    def replace_Icon_at(self, index, value): self.Icon[index] = value
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def add_Category(self, value): self.Category.append(value)
    def insert_Category_at(self, index, value): self.Category.insert(index, value)
    def replace_Category_at(self, index, value): self.Category[index] = value
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property_at(self, index, value): self.Property.insert(index, value)
    def replace_Property_at(self, index, value): self.Property[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_instance(self): return self.instance
    def set_instance(self, instance): self.instance = instance
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def hasContent_(self):
        if (
            self.Product is not None or
            self.Vendor is not None or
            self.Version is not None or
            self.FullVersion is not None or
            self.ProductUrl is not None or
            self.VendorUrl is not None or
            self.AppUrl is not None or
            self.Icon or
            self.Category or
            self.Property or
            self.anytypeobjs_ or
            super(ProductSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProductSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProductSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProductSection_Type'):
        super(ProductSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProductSection_Type')
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.add('instance')
            outfile.write(' instance=%s' % (self.gds_format_string(quote_attrib(self.instance).encode(ExternalEncoding), input_name='instance'), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.class_).encode(ExternalEncoding), input_name='class'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ProductSection_Type', fromsubclass_=False, pretty_print=True):
        super(ProductSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Product is not None:
            self.Product.export(outfile, level, namespace_, name_='Product', pretty_print=pretty_print)
        if self.Vendor is not None:
            self.Vendor.export(outfile, level, namespace_, name_='Vendor', pretty_print=pretty_print)
        if self.Version is not None:
            self.Version.export(outfile, level, namespace_, name_='Version', pretty_print=pretty_print)
        if self.FullVersion is not None:
            self.FullVersion.export(outfile, level, namespace_, name_='FullVersion', pretty_print=pretty_print)
        if self.ProductUrl is not None:
            self.ProductUrl.export(outfile, level, namespace_, name_='ProductUrl', pretty_print=pretty_print)
        if self.VendorUrl is not None:
            self.VendorUrl.export(outfile, level, namespace_, name_='VendorUrl', pretty_print=pretty_print)
        if self.AppUrl is not None:
            self.AppUrl.export(outfile, level, namespace_, name_='AppUrl', pretty_print=pretty_print)
        for Icon_ in self.Icon:
            Icon_.export(outfile, level, namespace_, name_='Icon', pretty_print=pretty_print)
        for Category_ in self.Category:
            Category_.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProductSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.add('instance')
            showIndent(outfile, level)
            outfile.write('instance="%s",\n' % (self.instance,))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            showIndent(outfile, level)
            outfile.write('class_="%s",\n' % (self.class_,))
        super(ProductSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ProductSection_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.Product is not None:
            showIndent(outfile, level)
            outfile.write('Product=model_.Msg_Type(\n')
            self.Product.exportLiteral(outfile, level, name_='Product')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Vendor is not None:
            showIndent(outfile, level)
            outfile.write('Vendor=model_.Msg_Type(\n')
            self.Vendor.exportLiteral(outfile, level, name_='Vendor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=model_.cimString(\n')
            self.Version.exportLiteral(outfile, level, name_='Version')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FullVersion is not None:
            showIndent(outfile, level)
            outfile.write('FullVersion=model_.cimString(\n')
            self.FullVersion.exportLiteral(outfile, level, name_='FullVersion')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProductUrl is not None:
            showIndent(outfile, level)
            outfile.write('ProductUrl=model_.cimString(\n')
            self.ProductUrl.exportLiteral(outfile, level, name_='ProductUrl')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VendorUrl is not None:
            showIndent(outfile, level)
            outfile.write('VendorUrl=model_.cimString(\n')
            self.VendorUrl.exportLiteral(outfile, level, name_='VendorUrl')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AppUrl is not None:
            showIndent(outfile, level)
            outfile.write('AppUrl=model_.cimString(\n')
            self.AppUrl.exportLiteral(outfile, level, name_='AppUrl')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Icon=[\n')
        level += 1
        for Icon_ in self.Icon:
            showIndent(outfile, level)
            outfile.write('model_.IconType(\n')
            Icon_.exportLiteral(outfile, level, name_='IconType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Category=[\n')
        level += 1
        for Category_ in self.Category:
            showIndent(outfile, level)
            outfile.write('model_.Msg_Type(\n')
            Category_.exportLiteral(outfile, level, name_='Msg_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.PropertyType(\n')
            Property_.exportLiteral(outfile, level, name_='PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instance', node)
        if value is not None and 'instance' not in already_processed:
            already_processed.add('instance')
            self.instance = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
        super(ProductSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Product':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Product = obj_
            obj_.original_tagname_ = 'Product'
        elif nodeName_ == 'Vendor':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Vendor = obj_
            obj_.original_tagname_ = 'Vendor'
        elif nodeName_ == 'Version':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Version = obj_
            obj_.original_tagname_ = 'Version'
        elif nodeName_ == 'FullVersion':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.FullVersion = obj_
            obj_.original_tagname_ = 'FullVersion'
        elif nodeName_ == 'ProductUrl':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ProductUrl = obj_
            obj_.original_tagname_ = 'ProductUrl'
        elif nodeName_ == 'VendorUrl':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VendorUrl = obj_
            obj_.original_tagname_ = 'VendorUrl'
        elif nodeName_ == 'AppUrl':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AppUrl = obj_
            obj_.original_tagname_ = 'AppUrl'
        elif nodeName_ == 'Icon':
            obj_ = IconType.factory()
            obj_.build(child_)
            self.Icon.append(obj_)
            obj_.original_tagname_ = 'Icon'
        elif nodeName_ == 'Category':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Category.append(obj_)
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'Property':
            obj_ = PropertyType.factory()
            obj_.build(child_)
            self.Property.append(obj_)
            obj_.original_tagname_ = 'Property'
        else:
            obj_ = self.gds_build_any(child_, 'ProductSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(ProductSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class ProductSection_Type


class PropertyConfigurationValue_Type(GeneratedsSuper):
    """Type for alternative default values for properties when
    DeploymentOptionSection is usedAlternative default property
    valueConfiguration from DeploymentOptionSection in which this
    value is default"""
    subclass = None
    superclass = None
    def __init__(self, configuration=None, value=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.configuration = _cast(None, configuration)
        self.value = _cast(None, value)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PropertyConfigurationValue_Type.subclass:
            return PropertyConfigurationValue_Type.subclass(*args_, **kwargs_)
        else:
            return PropertyConfigurationValue_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_configuration(self): return self.configuration
    def set_configuration(self, configuration): self.configuration = configuration
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertyConfigurationValue_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyConfigurationValue_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PropertyConfigurationValue_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyConfigurationValue_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.configuration is not None and 'configuration' not in already_processed:
            already_processed.add('configuration')
            outfile.write(' configuration=%s' % (self.gds_format_string(quote_attrib(self.configuration).encode(ExternalEncoding), input_name='configuration'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyConfigurationValue_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PropertyConfigurationValue_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.configuration is not None and 'configuration' not in already_processed:
            already_processed.add('configuration')
            showIndent(outfile, level)
            outfile.write('configuration="%s",\n' % (self.configuration,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('configuration', node)
        if value is not None and 'configuration' not in already_processed:
            already_processed.add('configuration')
            self.configuration = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'PropertyConfigurationValue_Type')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class PropertyConfigurationValue_Type


class NetworkSection_Type(Section_Type):
    """Descriptions of logical networks used within the package"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Network=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(NetworkSection_Type, self).__init__()
        if Network is None:
            self.Network = []
        else:
            self.Network = Network
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if NetworkSection_Type.subclass:
            return NetworkSection_Type.subclass(*args_, **kwargs_)
        else:
            return NetworkSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Network(self): return self.Network
    def set_Network(self, Network): self.Network = Network
    def add_Network(self, value): self.Network.append(value)
    def insert_Network_at(self, index, value): self.Network.insert(index, value)
    def replace_Network_at(self, index, value): self.Network[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Network or
            self.anytypeobjs_ or
            super(NetworkSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkSection_Type'):
        super(NetworkSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkSection_Type', fromsubclass_=False, pretty_print=True):
        super(NetworkSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Network_ in self.Network:
            Network_.export(outfile, level, namespace_, name_='Network', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NetworkSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkSection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Network=[\n')
        level += 1
        for Network_ in self.Network:
            showIndent(outfile, level)
            outfile.write('model_.NetworkType5(\n')
            Network_.exportLiteral(outfile, level, name_='NetworkType5')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NetworkSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Network':
            obj_ = NetworkType5.factory()
            obj_.build(child_)
            self.Network.append(obj_)
            obj_.original_tagname_ = 'Network'
        else:
            obj_ = self.gds_build_any(child_, 'NetworkSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(NetworkSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkSection_Type


class DiskSection_Type(Section_Type):
    """Descriptions of virtual disks used within the package"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Disk=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(DiskSection_Type, self).__init__()
        if Disk is None:
            self.Disk = []
        else:
            self.Disk = Disk
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if DiskSection_Type.subclass:
            return DiskSection_Type.subclass(*args_, **kwargs_)
        else:
            return DiskSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Disk(self): return self.Disk
    def set_Disk(self, Disk): self.Disk = Disk
    def add_Disk(self, value): self.Disk.append(value)
    def insert_Disk_at(self, index, value): self.Disk.insert(index, value)
    def replace_Disk_at(self, index, value): self.Disk[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Disk or
            self.anytypeobjs_ or
            super(DiskSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiskSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiskSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DiskSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiskSection_Type'):
        super(DiskSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DiskSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DiskSection_Type', fromsubclass_=False, pretty_print=True):
        super(DiskSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Disk_ in self.Disk:
            Disk_.export(outfile, level, namespace_, name_='Disk', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DiskSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DiskSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DiskSection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Disk=[\n')
        level += 1
        for Disk_ in self.Disk:
            showIndent(outfile, level)
            outfile.write('model_.VirtualDiskDesc_Type(\n')
            Disk_.exportLiteral(outfile, level, name_='VirtualDiskDesc_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DiskSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Disk':
            obj_ = VirtualDiskDesc_Type.factory()
            obj_.build(child_)
            self.Disk.append(obj_)
            obj_.original_tagname_ = 'Disk'
        else:
            obj_ = self.gds_build_any(child_, 'DiskSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(DiskSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class DiskSection_Type


class VirtualDiskDesc_Type(GeneratedsSuper):
    """Type for virtual disk descriptorIdentifier for virtual diskReference
    to virtual disk content. If not specified a blank virtual disk
    is created of size given by capacity attributeVirtual disk
    capacity, can be specified as either an xs:long size or as a
    reference to a property using ${property_name}. Unit of
    allocation for ovf:capacity. If not specified default value is
    bytes. Value shall match a recognized value for the UNITS
    qualifier in DSP0004.Format of virtual disk given as a URI that
    identifies the disk typeEstimated populated size of disk in
    bytesReference to potential parent disk"""
    subclass = None
    superclass = None
    def __init__(self, capacityAllocationUnits='byte', capacity=None, format=None, parentRef=None, fileRef=None, populatedSize=None, diskId=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.capacityAllocationUnits = _cast(None, capacityAllocationUnits)
        self.capacity = _cast(None, capacity)
        self.format = _cast(None, format)
        self.parentRef = _cast(None, parentRef)
        self.fileRef = _cast(None, fileRef)
        self.populatedSize = _cast(int, populatedSize)
        self.diskId = _cast(None, diskId)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if VirtualDiskDesc_Type.subclass:
            return VirtualDiskDesc_Type.subclass(*args_, **kwargs_)
        else:
            return VirtualDiskDesc_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_capacityAllocationUnits(self): return self.capacityAllocationUnits
    def set_capacityAllocationUnits(self, capacityAllocationUnits): self.capacityAllocationUnits = capacityAllocationUnits
    def get_capacity(self): return self.capacity
    def set_capacity(self, capacity): self.capacity = capacity
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_parentRef(self): return self.parentRef
    def set_parentRef(self, parentRef): self.parentRef = parentRef
    def get_fileRef(self): return self.fileRef
    def set_fileRef(self, fileRef): self.fileRef = fileRef
    def get_populatedSize(self): return self.populatedSize
    def set_populatedSize(self, populatedSize): self.populatedSize = populatedSize
    def get_diskId(self): return self.diskId
    def set_diskId(self, diskId): self.diskId = diskId
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VirtualDiskDesc_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualDiskDesc_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VirtualDiskDesc_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualDiskDesc_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.capacityAllocationUnits is not None and 'capacityAllocationUnits' not in already_processed:
            already_processed.add('capacityAllocationUnits')
            outfile.write(' capacityAllocationUnits=%s' % (self.gds_format_string(quote_attrib(self.capacityAllocationUnits).encode(ExternalEncoding), input_name='capacityAllocationUnits'), ))
        if self.capacity is not None and 'capacity' not in already_processed:
            already_processed.add('capacity')
            outfile.write(' capacity=%s' % (self.gds_format_string(quote_attrib(self.capacity).encode(ExternalEncoding), input_name='capacity'), ))
        if self.format is not None and 'format' not in already_processed:
            already_processed.add('format')
            outfile.write(' format=%s' % (self.gds_format_string(quote_attrib(self.format).encode(ExternalEncoding), input_name='format'), ))
        if self.parentRef is not None and 'parentRef' not in already_processed:
            already_processed.add('parentRef')
            outfile.write(' parentRef=%s' % (self.gds_format_string(quote_attrib(self.parentRef).encode(ExternalEncoding), input_name='parentRef'), ))
        if self.fileRef is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            outfile.write(' fileRef=%s' % (self.gds_format_string(quote_attrib(self.fileRef).encode(ExternalEncoding), input_name='fileRef'), ))
        if self.populatedSize is not None and 'populatedSize' not in already_processed:
            already_processed.add('populatedSize')
            outfile.write(' populatedSize="%s"' % self.gds_format_integer(self.populatedSize, input_name='populatedSize'))
        if self.diskId is not None and 'diskId' not in already_processed:
            already_processed.add('diskId')
            outfile.write(' diskId=%s' % (self.gds_format_string(quote_attrib(self.diskId).encode(ExternalEncoding), input_name='diskId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualDiskDesc_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VirtualDiskDesc_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.capacityAllocationUnits is not None and 'capacityAllocationUnits' not in already_processed:
            already_processed.add('capacityAllocationUnits')
            showIndent(outfile, level)
            outfile.write('capacityAllocationUnits="%s",\n' % (self.capacityAllocationUnits,))
        if self.capacity is not None and 'capacity' not in already_processed:
            already_processed.add('capacity')
            showIndent(outfile, level)
            outfile.write('capacity="%s",\n' % (self.capacity,))
        if self.format is not None and 'format' not in already_processed:
            already_processed.add('format')
            showIndent(outfile, level)
            outfile.write('format="%s",\n' % (self.format,))
        if self.parentRef is not None and 'parentRef' not in already_processed:
            already_processed.add('parentRef')
            showIndent(outfile, level)
            outfile.write('parentRef="%s",\n' % (self.parentRef,))
        if self.fileRef is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            showIndent(outfile, level)
            outfile.write('fileRef="%s",\n' % (self.fileRef,))
        if self.populatedSize is not None and 'populatedSize' not in already_processed:
            already_processed.add('populatedSize')
            showIndent(outfile, level)
            outfile.write('populatedSize=%d,\n' % (self.populatedSize,))
        if self.diskId is not None and 'diskId' not in already_processed:
            already_processed.add('diskId')
            showIndent(outfile, level)
            outfile.write('diskId="%s",\n' % (self.diskId,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('capacityAllocationUnits', node)
        if value is not None and 'capacityAllocationUnits' not in already_processed:
            already_processed.add('capacityAllocationUnits')
            self.capacityAllocationUnits = value
        value = find_attr_value_('capacity', node)
        if value is not None and 'capacity' not in already_processed:
            already_processed.add('capacity')
            self.capacity = value
        value = find_attr_value_('format', node)
        if value is not None and 'format' not in already_processed:
            already_processed.add('format')
            self.format = value
        value = find_attr_value_('parentRef', node)
        if value is not None and 'parentRef' not in already_processed:
            already_processed.add('parentRef')
            self.parentRef = value
        value = find_attr_value_('fileRef', node)
        if value is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            self.fileRef = value
        value = find_attr_value_('populatedSize', node)
        if value is not None and 'populatedSize' not in already_processed:
            already_processed.add('populatedSize')
            try:
                self.populatedSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('diskId', node)
        if value is not None and 'diskId' not in already_processed:
            already_processed.add('diskId')
            self.diskId = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'VirtualDiskDesc_Type')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class VirtualDiskDesc_Type


class OperatingSystemSection_Type(Section_Type):
    """Specification of the operating system installed in the
    guestIdentifier defined by the CIM_OperatingSystem.OsType
    enumerationVersion defined by the CIM_OperatingSystem.Version
    field"""
    subclass = None
    superclass = Section_Type
    def __init__(self, version=None, id=None, Description=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(OperatingSystemSection_Type, self).__init__()
        self.version = _cast(None, version)
        self.id = _cast(int, id)
        self.Description = Description
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if OperatingSystemSection_Type.subclass:
            return OperatingSystemSection_Type.subclass(*args_, **kwargs_)
        else:
            return OperatingSystemSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Description is not None or
            self.anytypeobjs_ or
            super(OperatingSystemSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OperatingSystemSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperatingSystemSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OperatingSystemSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperatingSystemSection_Type'):
        super(OperatingSystemSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OperatingSystemSection_Type')
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespace_='', name_='OperatingSystemSection_Type', fromsubclass_=False, pretty_print=True):
        super(OperatingSystemSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OperatingSystemSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % (self.id,))
        super(OperatingSystemSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OperatingSystemSection_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Msg_Type(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(OperatingSystemSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        else:
            obj_ = self.gds_build_any(child_, 'OperatingSystemSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(OperatingSystemSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class OperatingSystemSection_Type


class EulaSection_Type(Section_Type):
    """End-User License Agreement"""
    subclass = None
    superclass = Section_Type
    def __init__(self, License=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(EulaSection_Type, self).__init__()
        self.License = License
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if EulaSection_Type.subclass:
            return EulaSection_Type.subclass(*args_, **kwargs_)
        else:
            return EulaSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_License(self): return self.License
    def set_License(self, License): self.License = License
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.License is not None or
            self.anytypeobjs_ or
            super(EulaSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EulaSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EulaSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EulaSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EulaSection_Type'):
        super(EulaSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EulaSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='EulaSection_Type', fromsubclass_=False, pretty_print=True):
        super(EulaSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.License is not None:
            self.License.export(outfile, level, namespace_, name_='License', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EulaSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EulaSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EulaSection_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.License is not None:
            showIndent(outfile, level)
            outfile.write('License=model_.Msg_Type(\n')
            self.License.exportLiteral(outfile, level, name_='License')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EulaSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'License':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.License = obj_
            obj_.original_tagname_ = 'License'
        else:
            obj_ = self.gds_build_any(child_, 'EulaSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(EulaSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class EulaSection_Type


class VirtualHardwareSection_Type(Section_Type):
    """Specifies virtual hardware requirements for a virtual machineUnique
    identifier of this VirtualHardwareSection (within a
    VirtualSystem)"""
    subclass = None
    superclass = Section_Type
    def __init__(self, id='', transport=None, System=None, Item=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(VirtualHardwareSection_Type, self).__init__()
        self.id = _cast(None, id)
        self.transport = _cast(None, transport)
        self.System = System
        if Item is None:
            self.Item = []
        else:
            self.Item = Item
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if VirtualHardwareSection_Type.subclass:
            return VirtualHardwareSection_Type.subclass(*args_, **kwargs_)
        else:
            return VirtualHardwareSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_System(self): return self.System
    def set_System(self, System): self.System = System
    def get_Item(self): return self.Item
    def set_Item(self, Item): self.Item = Item
    def add_Item(self, value): self.Item.append(value)
    def insert_Item_at(self, index, value): self.Item.insert(index, value)
    def replace_Item_at(self, index, value): self.Item[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_transport(self): return self.transport
    def set_transport(self, transport): self.transport = transport
    def hasContent_(self):
        if (
            self.System is not None or
            self.Item or
            self.anytypeobjs_ or
            super(VirtualHardwareSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VirtualHardwareSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualHardwareSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VirtualHardwareSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualHardwareSection_Type'):
        super(VirtualHardwareSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualHardwareSection_Type')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.transport is not None and 'transport' not in already_processed:
            already_processed.add('transport')
            outfile.write(' transport=%s' % (self.gds_format_string(quote_attrib(self.transport).encode(ExternalEncoding), input_name='transport'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualHardwareSection_Type', fromsubclass_=False, pretty_print=True):
        super(VirtualHardwareSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.System is not None:
            self.System.export(outfile, level, namespace_, name_='System', pretty_print=pretty_print)
        for Item_ in self.Item:
            Item_.export(outfile, level, namespace_, name_='Item', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VirtualHardwareSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.transport is not None and 'transport' not in already_processed:
            already_processed.add('transport')
            showIndent(outfile, level)
            outfile.write('transport="%s",\n' % (self.transport,))
        super(VirtualHardwareSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VirtualHardwareSection_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.System is not None:
            showIndent(outfile, level)
            outfile.write('System=model_.VSSD_Type(\n')
            self.System.exportLiteral(outfile, level, name_='System')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Item=[\n')
        level += 1
        for Item_ in self.Item:
            showIndent(outfile, level)
            outfile.write('model_.RASD_Type(\n')
            Item_.exportLiteral(outfile, level, name_='RASD_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('transport', node)
        if value is not None and 'transport' not in already_processed:
            already_processed.add('transport')
            self.transport = value
        super(VirtualHardwareSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'System':
            obj_ = VSSD_Type.factory()
            obj_.build(child_)
            self.System = obj_
            obj_.original_tagname_ = 'System'
        elif nodeName_ == 'Item':
            obj_ = RASD_Type.factory()
            obj_.build(child_)
            self.Item.append(obj_)
            obj_.original_tagname_ = 'Item'
        else:
            obj_ = self.gds_build_any(child_, 'VirtualHardwareSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(VirtualHardwareSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class VirtualHardwareSection_Type


class ResourceAllocationSection_Type(Section_Type):
    """Resource constraints on a VirtualSystemCollection"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Item=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(ResourceAllocationSection_Type, self).__init__()
        if Item is None:
            self.Item = []
        else:
            self.Item = Item
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if ResourceAllocationSection_Type.subclass:
            return ResourceAllocationSection_Type.subclass(*args_, **kwargs_)
        else:
            return ResourceAllocationSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Item(self): return self.Item
    def set_Item(self, Item): self.Item = Item
    def add_Item(self, value): self.Item.append(value)
    def insert_Item_at(self, index, value): self.Item.insert(index, value)
    def replace_Item_at(self, index, value): self.Item[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Item or
            self.anytypeobjs_ or
            super(ResourceAllocationSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceAllocationSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceAllocationSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceAllocationSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceAllocationSection_Type'):
        super(ResourceAllocationSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceAllocationSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceAllocationSection_Type', fromsubclass_=False, pretty_print=True):
        super(ResourceAllocationSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Item_ in self.Item:
            Item_.export(outfile, level, namespace_, name_='Item', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResourceAllocationSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ResourceAllocationSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResourceAllocationSection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Item=[\n')
        level += 1
        for Item_ in self.Item:
            showIndent(outfile, level)
            outfile.write('model_.RASD_Type(\n')
            Item_.exportLiteral(outfile, level, name_='RASD_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResourceAllocationSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Item':
            obj_ = RASD_Type.factory()
            obj_.build(child_)
            self.Item.append(obj_)
            obj_.original_tagname_ = 'Item'
        else:
            obj_ = self.gds_build_any(child_, 'ResourceAllocationSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(ResourceAllocationSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class ResourceAllocationSection_Type


class InstallSection_Type(Section_Type):
    """If present indicates that the virtual machine needs to be initially
    booted to install and configure the softwareDelay in seconds to
    wait for power off to complete after initial boot"""
    subclass = None
    superclass = Section_Type
    def __init__(self, initialBootStopDelay=0, anytypeobjs_=None):
        self.original_tagname_ = None
        super(InstallSection_Type, self).__init__()
        self.initialBootStopDelay = _cast(int, initialBootStopDelay)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if InstallSection_Type.subclass:
            return InstallSection_Type.subclass(*args_, **kwargs_)
        else:
            return InstallSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_initialBootStopDelay(self): return self.initialBootStopDelay
    def set_initialBootStopDelay(self, initialBootStopDelay): self.initialBootStopDelay = initialBootStopDelay
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            super(InstallSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstallSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstallSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstallSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstallSection_Type'):
        super(InstallSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstallSection_Type')
        if self.initialBootStopDelay is not None and 'initialBootStopDelay' not in already_processed:
            already_processed.add('initialBootStopDelay')
            outfile.write(' initialBootStopDelay="%s"' % self.gds_format_integer(self.initialBootStopDelay, input_name='initialBootStopDelay'))
    def exportChildren(self, outfile, level, namespace_='', name_='InstallSection_Type', fromsubclass_=False, pretty_print=True):
        super(InstallSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InstallSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.initialBootStopDelay is not None and 'initialBootStopDelay' not in already_processed:
            already_processed.add('initialBootStopDelay')
            showIndent(outfile, level)
            outfile.write('initialBootStopDelay=%d,\n' % (self.initialBootStopDelay,))
        super(InstallSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstallSection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialBootStopDelay', node)
        if value is not None and 'initialBootStopDelay' not in already_processed:
            already_processed.add('initialBootStopDelay')
            try:
                self.initialBootStopDelay = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(InstallSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'InstallSection_Type')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
        super(InstallSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class InstallSection_Type


class StartupSection_Type(Section_Type):
    """Specifies the order in which entities in a VirtualSystemCollection
    are powered on and shut down"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Item=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(StartupSection_Type, self).__init__()
        if Item is None:
            self.Item = []
        else:
            self.Item = Item
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if StartupSection_Type.subclass:
            return StartupSection_Type.subclass(*args_, **kwargs_)
        else:
            return StartupSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Item(self): return self.Item
    def set_Item(self, Item): self.Item = Item
    def add_Item(self, value): self.Item.append(value)
    def insert_Item_at(self, index, value): self.Item.insert(index, value)
    def replace_Item_at(self, index, value): self.Item[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Item or
            self.anytypeobjs_ or
            super(StartupSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StartupSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StartupSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StartupSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StartupSection_Type'):
        super(StartupSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StartupSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='StartupSection_Type', fromsubclass_=False, pretty_print=True):
        super(StartupSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Item_ in self.Item:
            Item_.export(outfile, level, namespace_, name_='Item', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StartupSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StartupSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StartupSection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Item=[\n')
        level += 1
        for Item_ in self.Item:
            showIndent(outfile, level)
            outfile.write('model_.ItemType(\n')
            Item_.exportLiteral(outfile, level, name_='ItemType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StartupSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Item':
            obj_ = ItemType.factory()
            obj_.build(child_)
            self.Item.append(obj_)
            obj_.original_tagname_ = 'Item'
        else:
            obj_ = self.gds_build_any(child_, 'StartupSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(StartupSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class StartupSection_Type


class DeploymentOptionSection_Type(Section_Type):
    """Enumeration of discrete deployment options"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Configuration=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(DeploymentOptionSection_Type, self).__init__()
        if Configuration is None:
            self.Configuration = []
        else:
            self.Configuration = Configuration
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if DeploymentOptionSection_Type.subclass:
            return DeploymentOptionSection_Type.subclass(*args_, **kwargs_)
        else:
            return DeploymentOptionSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Configuration(self): return self.Configuration
    def set_Configuration(self, Configuration): self.Configuration = Configuration
    def add_Configuration(self, value): self.Configuration.append(value)
    def insert_Configuration_at(self, index, value): self.Configuration.insert(index, value)
    def replace_Configuration_at(self, index, value): self.Configuration[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Configuration or
            self.anytypeobjs_ or
            super(DeploymentOptionSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeploymentOptionSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeploymentOptionSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeploymentOptionSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeploymentOptionSection_Type'):
        super(DeploymentOptionSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeploymentOptionSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DeploymentOptionSection_Type', fromsubclass_=False, pretty_print=True):
        super(DeploymentOptionSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Configuration_ in self.Configuration:
            Configuration_.export(outfile, level, namespace_, name_='Configuration', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DeploymentOptionSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DeploymentOptionSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DeploymentOptionSection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Configuration=[\n')
        level += 1
        for Configuration_ in self.Configuration:
            showIndent(outfile, level)
            outfile.write('model_.ConfigurationType(\n')
            Configuration_.exportLiteral(outfile, level, name_='ConfigurationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DeploymentOptionSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Configuration':
            obj_ = ConfigurationType.factory()
            obj_.build(child_)
            self.Configuration.append(obj_)
            obj_.original_tagname_ = 'Configuration'
        else:
            obj_ = self.gds_build_any(child_, 'DeploymentOptionSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(DeploymentOptionSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class DeploymentOptionSection_Type


class cimDateTime(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CIM_DateTime=None, Interval=None, Date=None, Time=None, Datetime=None):
        self.original_tagname_ = None
        self.CIM_DateTime = CIM_DateTime
        self.Interval = Interval
        if isinstance(Date, basestring):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Date
        self.Date = initvalue_
        if isinstance(Time, basestring):
            initvalue_ = datetime_.datetime.strptime(Time, '%H:%M:%S').time()
        else:
            initvalue_ = Time
        self.Time = initvalue_
        if isinstance(Datetime, basestring):
            initvalue_ = datetime_.datetime.strptime(Datetime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Datetime
        self.Datetime = initvalue_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimDateTime.subclass:
            return cimDateTime.subclass(*args_, **kwargs_)
        else:
            return cimDateTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CIM_DateTime(self): return self.CIM_DateTime
    def set_CIM_DateTime(self, CIM_DateTime): self.CIM_DateTime = CIM_DateTime
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_Datetime(self): return self.Datetime
    def set_Datetime(self, Datetime): self.Datetime = Datetime
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.CIM_DateTime is not None or
            self.Interval is not None or
            self.Date is not None or
            self.Time is not None or
            self.Datetime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimDateTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimDateTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimDateTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimDateTime'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimDateTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CIM_DateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCIM_DateTime>%s</%sCIM_DateTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.CIM_DateTime).encode(ExternalEncoding), input_name='CIM_DateTime'), namespace_, eol_))
        if self.Interval is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInterval>%s</%sInterval>%s' % (namespace_, self.gds_format_string(quote_xml(self.Interval).encode(ExternalEncoding), input_name='Interval'), namespace_, eol_))
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespace_, self.gds_format_date(self.Date, input_name='Date'), namespace_, eol_))
        if self.Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTime>%s</%sTime>%s' % (namespace_, self.gds_format_time(self.Time, input_name='Time'), namespace_, eol_))
        if self.Datetime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDatetime>%s</%sDatetime>%s' % (namespace_, self.gds_format_datetime(self.Datetime, input_name='Datetime'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='cimDateTime'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CIM_DateTime is not None:
            showIndent(outfile, level)
            outfile.write('CIM_DateTime=%s,\n' % quote_python(self.CIM_DateTime).encode(ExternalEncoding))
        if self.Interval is not None:
            showIndent(outfile, level)
            outfile.write('Interval=%s,\n' % quote_python(self.Interval).encode(ExternalEncoding))
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.Date, input_name='Date'))
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=model_.GeneratedsSuper.gds_parse_time("%s"),\n' % self.gds_format_time(self.Time, input_name='Time'))
        if self.Datetime is not None:
            showIndent(outfile, level)
            outfile.write('Datetime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.Datetime, input_name='Datetime'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CIM_DateTime':
            CIM_DateTime_ = child_.text
            CIM_DateTime_ = self.gds_validate_string(CIM_DateTime_, node, 'CIM_DateTime')
            self.CIM_DateTime = CIM_DateTime_
        elif nodeName_ == 'Interval':
            Interval_ = child_.text
            Interval_ = self.gds_validate_string(Interval_, node, 'Interval')
            self.Interval = Interval_
        elif nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Date = dval_
        elif nodeName_ == 'Time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.Time = dval_
        elif nodeName_ == 'Datetime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Datetime = dval_
# end class cimDateTime


class cimUnsignedByte(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimUnsignedByte.subclass:
            return cimUnsignedByte.subclass(*args_, **kwargs_)
        else:
            return cimUnsignedByte(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimUnsignedByte', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimUnsignedByte')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimUnsignedByte', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimUnsignedByte'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimUnsignedByte', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimUnsignedByte'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimUnsignedByte


class cimByte(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimByte.subclass:
            return cimByte.subclass(*args_, **kwargs_)
        else:
            return cimByte(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimByte', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimByte')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimByte', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimByte'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimByte', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimByte'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimByte


class cimUnsignedShort(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimUnsignedShort.subclass:
            return cimUnsignedShort.subclass(*args_, **kwargs_)
        else:
            return cimUnsignedShort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimUnsignedShort', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimUnsignedShort')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimUnsignedShort', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimUnsignedShort'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimUnsignedShort', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimUnsignedShort'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimUnsignedShort


class cimShort(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimShort.subclass:
            return cimShort.subclass(*args_, **kwargs_)
        else:
            return cimShort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimShort', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimShort')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimShort', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimShort'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimShort', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimShort'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimShort


class cimUnsignedInt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cimUnsignedInt.subclass:
            return cimUnsignedInt.subclass(*args_, **kwargs_)
        else:
            return cimUnsignedInt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimUnsignedInt', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimUnsignedInt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimUnsignedInt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimUnsignedInt'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimUnsignedInt', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimUnsignedInt'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimUnsignedInt


class cimInt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimInt.subclass:
            return cimInt.subclass(*args_, **kwargs_)
        else:
            return cimInt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimInt', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimInt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimInt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimInt'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimInt', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimInt'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimInt


class cimUnsignedLong(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimUnsignedLong.subclass:
            return cimUnsignedLong.subclass(*args_, **kwargs_)
        else:
            return cimUnsignedLong(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimUnsignedLong', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimUnsignedLong')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimUnsignedLong', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimUnsignedLong'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimUnsignedLong', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimUnsignedLong'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimUnsignedLong


class cimLong(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cimLong.subclass:
            return cimLong.subclass(*args_, **kwargs_)
        else:
            return cimLong(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimLong', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimLong')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimLong', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimLong'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimLong', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimLong'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimLong


class cimString(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cimString.subclass:
            return cimString.subclass(*args_, **kwargs_)
        else:
            return cimString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimString', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimString')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimString', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimString'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimString', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimString'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimString


class cimBoolean(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cimBoolean.subclass:
            return cimBoolean.subclass(*args_, **kwargs_)
        else:
            return cimBoolean(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimBoolean', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimBoolean')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimBoolean', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimBoolean'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimBoolean', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimBoolean'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimBoolean


class cimFloat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimFloat.subclass:
            return cimFloat.subclass(*args_, **kwargs_)
        else:
            return cimFloat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimFloat', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimFloat')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimFloat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimFloat'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimFloat', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimFloat'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimFloat


class cimDouble(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimDouble.subclass:
            return cimDouble.subclass(*args_, **kwargs_)
        else:
            return cimDouble(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimDouble', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimDouble')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimDouble', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimDouble'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimDouble', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimDouble'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimDouble


class cimChar16(cimString):
    subclass = None
    superclass = cimString
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(cimChar16, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimChar16.subclass:
            return cimChar16.subclass(*args_, **kwargs_)
        else:
            return cimChar16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(cimChar16, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimChar16', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimChar16')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimChar16', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimChar16'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(cimChar16, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cimChar16')
    def exportChildren(self, outfile, level, namespace_='', name_='cimChar16', fromsubclass_=False, pretty_print=True):
        super(cimChar16, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='cimChar16'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(cimChar16, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cimChar16, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(cimChar16, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimChar16


class cimBase64Binary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimBase64Binary.subclass:
            return cimBase64Binary.subclass(*args_, **kwargs_)
        else:
            return cimBase64Binary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimBase64Binary', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimBase64Binary')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimBase64Binary', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimBase64Binary'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimBase64Binary', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimBase64Binary'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimBase64Binary


class cimReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimReference.subclass:
            return cimReference.subclass(*args_, **kwargs_)
        else:
            return cimReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimReference'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cimReference'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'cimReference')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class cimReference


class cimHexBinary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimHexBinary.subclass:
            return cimHexBinary.subclass(*args_, **kwargs_)
        else:
            return cimHexBinary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimHexBinary', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimHexBinary')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimHexBinary', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimHexBinary'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimHexBinary', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimHexBinary'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimHexBinary


class cimAnySimpleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cimAnySimpleType.subclass:
            return cimAnySimpleType.subclass(*args_, **kwargs_)
        else:
            return cimAnySimpleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimAnySimpleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimAnySimpleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimAnySimpleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimAnySimpleType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimAnySimpleType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimAnySimpleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimAnySimpleType


class qualifierString(cimString):
    subclass = None
    superclass = cimString
    def __init__(self, qualifier=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(qualifierString, self).__init__(valueOf_, extensiontype_, )
        self.qualifier = _cast(bool, qualifier)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if qualifierString.subclass:
            return qualifierString.subclass(*args_, **kwargs_)
        else:
            return qualifierString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(qualifierString, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qualifierString', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierString')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qualifierString', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qualifierString'):
        super(qualifierString, self).exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierString')
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier="%s"' % self.gds_format_boolean(self.qualifier, input_name='qualifier'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='qualifierString', fromsubclass_=False, pretty_print=True):
        super(qualifierString, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='qualifierString'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            showIndent(outfile, level)
            outfile.write('qualifier=%s,\n' % (self.qualifier,))
        super(qualifierString, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(qualifierString, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            if value in ('true', '1'):
                self.qualifier = True
            elif value in ('false', '0'):
                self.qualifier = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(qualifierString, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qualifierString


class qualifierBoolean(cimBoolean):
    subclass = None
    superclass = cimBoolean
    def __init__(self, qualifier=None, valueOf_=None):
        self.original_tagname_ = None
        super(qualifierBoolean, self).__init__(valueOf_, )
        self.qualifier = _cast(bool, qualifier)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if qualifierBoolean.subclass:
            return qualifierBoolean.subclass(*args_, **kwargs_)
        else:
            return qualifierBoolean(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(qualifierBoolean, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qualifierBoolean', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierBoolean')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qualifierBoolean', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qualifierBoolean'):
        super(qualifierBoolean, self).exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierBoolean')
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier="%s"' % self.gds_format_boolean(self.qualifier, input_name='qualifier'))
    def exportChildren(self, outfile, level, namespace_='', name_='qualifierBoolean', fromsubclass_=False, pretty_print=True):
        super(qualifierBoolean, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='qualifierBoolean'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            showIndent(outfile, level)
            outfile.write('qualifier=%s,\n' % (self.qualifier,))
        super(qualifierBoolean, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(qualifierBoolean, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            if value in ('true', '1'):
                self.qualifier = True
            elif value in ('false', '0'):
                self.qualifier = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(qualifierBoolean, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qualifierBoolean


class qualifierUInt32(cimUnsignedInt):
    subclass = None
    superclass = cimUnsignedInt
    def __init__(self, qualifier=None, valueOf_=None):
        self.original_tagname_ = None
        super(qualifierUInt32, self).__init__(valueOf_, )
        self.qualifier = _cast(bool, qualifier)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if qualifierUInt32.subclass:
            return qualifierUInt32.subclass(*args_, **kwargs_)
        else:
            return qualifierUInt32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(qualifierUInt32, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qualifierUInt32', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierUInt32')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qualifierUInt32', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qualifierUInt32'):
        super(qualifierUInt32, self).exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierUInt32')
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier="%s"' % self.gds_format_boolean(self.qualifier, input_name='qualifier'))
    def exportChildren(self, outfile, level, namespace_='', name_='qualifierUInt32', fromsubclass_=False, pretty_print=True):
        super(qualifierUInt32, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='qualifierUInt32'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            showIndent(outfile, level)
            outfile.write('qualifier=%s,\n' % (self.qualifier,))
        super(qualifierUInt32, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(qualifierUInt32, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            if value in ('true', '1'):
                self.qualifier = True
            elif value in ('false', '0'):
                self.qualifier = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(qualifierUInt32, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qualifierUInt32


class qualifierSInt64(cimLong):
    subclass = None
    superclass = cimLong
    def __init__(self, qualifier=None, valueOf_=None):
        self.original_tagname_ = None
        super(qualifierSInt64, self).__init__(valueOf_, )
        self.qualifier = _cast(bool, qualifier)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if qualifierSInt64.subclass:
            return qualifierSInt64.subclass(*args_, **kwargs_)
        else:
            return qualifierSInt64(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(qualifierSInt64, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qualifierSInt64', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierSInt64')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qualifierSInt64', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qualifierSInt64'):
        super(qualifierSInt64, self).exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierSInt64')
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier="%s"' % self.gds_format_boolean(self.qualifier, input_name='qualifier'))
    def exportChildren(self, outfile, level, namespace_='', name_='qualifierSInt64', fromsubclass_=False, pretty_print=True):
        super(qualifierSInt64, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='qualifierSInt64'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            showIndent(outfile, level)
            outfile.write('qualifier=%s,\n' % (self.qualifier,))
        super(qualifierSInt64, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(qualifierSInt64, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            if value in ('true', '1'):
                self.qualifier = True
            elif value in ('false', '0'):
                self.qualifier = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(qualifierSInt64, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qualifierSInt64


class qualifierSArray(qualifierString):
    subclass = None
    superclass = qualifierString
    def __init__(self, qualifier=None):
        self.original_tagname_ = None
        super(qualifierSArray, self).__init__(qualifier, )
    def factory(*args_, **kwargs_):
        if qualifierSArray.subclass:
            return qualifierSArray.subclass(*args_, **kwargs_)
        else:
            return qualifierSArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(qualifierSArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qualifierSArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierSArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qualifierSArray', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qualifierSArray'):
        super(qualifierSArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierSArray')
    def exportChildren(self, outfile, level, namespace_='', name_='qualifierSArray', fromsubclass_=False, pretty_print=True):
        super(qualifierSArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='qualifierSArray'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(qualifierSArray, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(qualifierSArray, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(qualifierSArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(qualifierSArray, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class qualifierSArray


class AutomaticStartupAction(cimAnySimpleType):
    subclass = None
    superclass = cimAnySimpleType
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(AutomaticStartupAction, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if AutomaticStartupAction.subclass:
            return AutomaticStartupAction.subclass(*args_, **kwargs_)
        else:
            return AutomaticStartupAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AutomaticStartupAction, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AutomaticStartupAction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticStartupAction')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AutomaticStartupAction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AutomaticStartupAction'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(AutomaticStartupAction, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticStartupAction')
    def exportChildren(self, outfile, level, namespace_='', name_='AutomaticStartupAction', fromsubclass_=False, pretty_print=True):
        super(AutomaticStartupAction, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AutomaticStartupAction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(AutomaticStartupAction, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AutomaticStartupAction, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(AutomaticStartupAction, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AutomaticStartupAction


class AutomaticShutdownAction(cimAnySimpleType):
    subclass = None
    superclass = cimAnySimpleType
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(AutomaticShutdownAction, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if AutomaticShutdownAction.subclass:
            return AutomaticShutdownAction.subclass(*args_, **kwargs_)
        else:
            return AutomaticShutdownAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AutomaticShutdownAction, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AutomaticShutdownAction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticShutdownAction')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AutomaticShutdownAction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AutomaticShutdownAction'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(AutomaticShutdownAction, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticShutdownAction')
    def exportChildren(self, outfile, level, namespace_='', name_='AutomaticShutdownAction', fromsubclass_=False, pretty_print=True):
        super(AutomaticShutdownAction, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AutomaticShutdownAction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(AutomaticShutdownAction, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AutomaticShutdownAction, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(AutomaticShutdownAction, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AutomaticShutdownAction


class AutomaticRecoveryAction(cimAnySimpleType):
    subclass = None
    superclass = cimAnySimpleType
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(AutomaticRecoveryAction, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if AutomaticRecoveryAction.subclass:
            return AutomaticRecoveryAction.subclass(*args_, **kwargs_)
        else:
            return AutomaticRecoveryAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AutomaticRecoveryAction, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AutomaticRecoveryAction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticRecoveryAction')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AutomaticRecoveryAction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AutomaticRecoveryAction'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(AutomaticRecoveryAction, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticRecoveryAction')
    def exportChildren(self, outfile, level, namespace_='', name_='AutomaticRecoveryAction', fromsubclass_=False, pretty_print=True):
        super(AutomaticRecoveryAction, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AutomaticRecoveryAction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(AutomaticRecoveryAction, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AutomaticRecoveryAction, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(AutomaticRecoveryAction, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AutomaticRecoveryAction


class Caption(cimString):
    subclass = None
    superclass = cimString
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(Caption, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Caption.subclass:
            return Caption.subclass(*args_, **kwargs_)
        else:
            return Caption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Caption, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Caption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Caption')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Caption', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Caption'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(Caption, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Caption')
    def exportChildren(self, outfile, level, namespace_='', name_='Caption', fromsubclass_=False, pretty_print=True):
        super(Caption, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='Caption'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(Caption, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Caption, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(Caption, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Caption


class CIM_VirtualSystemSettingData_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AutomaticRecoveryAction=None, AutomaticShutdownAction=None, AutomaticStartupAction=None, AutomaticStartupActionDelay=None, AutomaticStartupActionSequenceNumber=None, Caption=None, ConfigurationDataRoot=None, ConfigurationFile=None, ConfigurationID=None, CreationTime=None, Description=None, ElementName=None, InstanceID=None, LogDataRoot=None, Notes=None, RecoveryFile=None, SnapshotDataRoot=None, SuspendDataRoot=None, SwapFileDataRoot=None, VirtualSystemIdentifier=None, VirtualSystemType=None, anytypeobjs_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.AutomaticRecoveryAction = AutomaticRecoveryAction
        self.validate_AutomaticRecoveryAction(self.AutomaticRecoveryAction)
        self.AutomaticShutdownAction = AutomaticShutdownAction
        self.validate_AutomaticShutdownAction(self.AutomaticShutdownAction)
        self.AutomaticStartupAction = AutomaticStartupAction
        self.validate_AutomaticStartupAction(self.AutomaticStartupAction)
        self.AutomaticStartupActionDelay = AutomaticStartupActionDelay
        self.AutomaticStartupActionSequenceNumber = AutomaticStartupActionSequenceNumber
        self.Caption = Caption
        self.ConfigurationDataRoot = ConfigurationDataRoot
        self.ConfigurationFile = ConfigurationFile
        self.ConfigurationID = ConfigurationID
        self.CreationTime = CreationTime
        self.Description = Description
        self.ElementName = ElementName
        self.InstanceID = InstanceID
        self.LogDataRoot = LogDataRoot
        if Notes is None:
            self.Notes = []
        else:
            self.Notes = Notes
        self.RecoveryFile = RecoveryFile
        self.SnapshotDataRoot = SnapshotDataRoot
        self.SuspendDataRoot = SuspendDataRoot
        self.SwapFileDataRoot = SwapFileDataRoot
        self.VirtualSystemIdentifier = VirtualSystemIdentifier
        self.VirtualSystemType = VirtualSystemType
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CIM_VirtualSystemSettingData_Type.subclass:
            return CIM_VirtualSystemSettingData_Type.subclass(*args_, **kwargs_)
        else:
            return CIM_VirtualSystemSettingData_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AutomaticRecoveryAction(self): return self.AutomaticRecoveryAction
    def set_AutomaticRecoveryAction(self, AutomaticRecoveryAction): self.AutomaticRecoveryAction = AutomaticRecoveryAction
    def get_AutomaticShutdownAction(self): return self.AutomaticShutdownAction
    def set_AutomaticShutdownAction(self, AutomaticShutdownAction): self.AutomaticShutdownAction = AutomaticShutdownAction
    def get_AutomaticStartupAction(self): return self.AutomaticStartupAction
    def set_AutomaticStartupAction(self, AutomaticStartupAction): self.AutomaticStartupAction = AutomaticStartupAction
    def get_AutomaticStartupActionDelay(self): return self.AutomaticStartupActionDelay
    def set_AutomaticStartupActionDelay(self, AutomaticStartupActionDelay): self.AutomaticStartupActionDelay = AutomaticStartupActionDelay
    def get_AutomaticStartupActionSequenceNumber(self): return self.AutomaticStartupActionSequenceNumber
    def set_AutomaticStartupActionSequenceNumber(self, AutomaticStartupActionSequenceNumber): self.AutomaticStartupActionSequenceNumber = AutomaticStartupActionSequenceNumber
    def get_Caption(self): return self.Caption
    def set_Caption(self, Caption): self.Caption = Caption
    def get_ConfigurationDataRoot(self): return self.ConfigurationDataRoot
    def set_ConfigurationDataRoot(self, ConfigurationDataRoot): self.ConfigurationDataRoot = ConfigurationDataRoot
    def get_ConfigurationFile(self): return self.ConfigurationFile
    def set_ConfigurationFile(self, ConfigurationFile): self.ConfigurationFile = ConfigurationFile
    def get_ConfigurationID(self): return self.ConfigurationID
    def set_ConfigurationID(self, ConfigurationID): self.ConfigurationID = ConfigurationID
    def get_CreationTime(self): return self.CreationTime
    def set_CreationTime(self, CreationTime): self.CreationTime = CreationTime
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ElementName(self): return self.ElementName
    def set_ElementName(self, ElementName): self.ElementName = ElementName
    def get_InstanceID(self): return self.InstanceID
    def set_InstanceID(self, InstanceID): self.InstanceID = InstanceID
    def get_LogDataRoot(self): return self.LogDataRoot
    def set_LogDataRoot(self, LogDataRoot): self.LogDataRoot = LogDataRoot
    def get_Notes(self): return self.Notes
    def set_Notes(self, Notes): self.Notes = Notes
    def add_Notes(self, value): self.Notes.append(value)
    def insert_Notes_at(self, index, value): self.Notes.insert(index, value)
    def replace_Notes_at(self, index, value): self.Notes[index] = value
    def get_RecoveryFile(self): return self.RecoveryFile
    def set_RecoveryFile(self, RecoveryFile): self.RecoveryFile = RecoveryFile
    def get_SnapshotDataRoot(self): return self.SnapshotDataRoot
    def set_SnapshotDataRoot(self, SnapshotDataRoot): self.SnapshotDataRoot = SnapshotDataRoot
    def get_SuspendDataRoot(self): return self.SuspendDataRoot
    def set_SuspendDataRoot(self, SuspendDataRoot): self.SuspendDataRoot = SuspendDataRoot
    def get_SwapFileDataRoot(self): return self.SwapFileDataRoot
    def set_SwapFileDataRoot(self, SwapFileDataRoot): self.SwapFileDataRoot = SwapFileDataRoot
    def get_VirtualSystemIdentifier(self): return self.VirtualSystemIdentifier
    def set_VirtualSystemIdentifier(self, VirtualSystemIdentifier): self.VirtualSystemIdentifier = VirtualSystemIdentifier
    def get_VirtualSystemType(self): return self.VirtualSystemType
    def set_VirtualSystemType(self, VirtualSystemType): self.VirtualSystemType = VirtualSystemType
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_AutomaticRecoveryAction(self, value):
        # Validate type AutomaticRecoveryAction, a restriction on xs:unsignedShort.
        pass
    def validate_AutomaticShutdownAction(self, value):
        # Validate type AutomaticShutdownAction, a restriction on xs:unsignedShort.
        pass
    def validate_AutomaticStartupAction(self, value):
        # Validate type AutomaticStartupAction, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.AutomaticRecoveryAction is not None or
            self.AutomaticShutdownAction is not None or
            self.AutomaticStartupAction is not None or
            self.AutomaticStartupActionDelay is not None or
            self.AutomaticStartupActionSequenceNumber is not None or
            self.Caption is not None or
            self.ConfigurationDataRoot is not None or
            self.ConfigurationFile is not None or
            self.ConfigurationID is not None or
            self.CreationTime is not None or
            self.Description is not None or
            self.ElementName is not None or
            self.InstanceID is not None or
            self.LogDataRoot is not None or
            self.Notes or
            self.RecoveryFile is not None or
            self.SnapshotDataRoot is not None or
            self.SuspendDataRoot is not None or
            self.SwapFileDataRoot is not None or
            self.VirtualSystemIdentifier is not None or
            self.VirtualSystemType is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CIM_VirtualSystemSettingData_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CIM_VirtualSystemSettingData_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CIM_VirtualSystemSettingData_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CIM_VirtualSystemSettingData_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CIM_VirtualSystemSettingData_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AutomaticRecoveryAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAutomaticRecoveryAction>%s</%sAutomaticRecoveryAction>%s' % (namespace_, self.gds_format_integer(self.AutomaticRecoveryAction, input_name='AutomaticRecoveryAction'), namespace_, eol_))
        if self.AutomaticShutdownAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAutomaticShutdownAction>%s</%sAutomaticShutdownAction>%s' % (namespace_, self.gds_format_integer(self.AutomaticShutdownAction, input_name='AutomaticShutdownAction'), namespace_, eol_))
        if self.AutomaticStartupAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAutomaticStartupAction>%s</%sAutomaticStartupAction>%s' % (namespace_, self.gds_format_integer(self.AutomaticStartupAction, input_name='AutomaticStartupAction'), namespace_, eol_))
        if self.AutomaticStartupActionDelay is not None:
            self.AutomaticStartupActionDelay.export(outfile, level, namespace_='class:', name_='AutomaticStartupActionDelay', pretty_print=pretty_print)
        if self.AutomaticStartupActionSequenceNumber is not None:
            self.AutomaticStartupActionSequenceNumber.export(outfile, level, namespace_='class:', name_='AutomaticStartupActionSequenceNumber', pretty_print=pretty_print)
        if self.Caption is not None:
            self.Caption.export(outfile, level, namespace_='class:', name_='Caption', pretty_print=pretty_print)
        if self.ConfigurationDataRoot is not None:
            self.ConfigurationDataRoot.export(outfile, level, namespace_='class:', name_='ConfigurationDataRoot', pretty_print=pretty_print)
        if self.ConfigurationFile is not None:
            self.ConfigurationFile.export(outfile, level, namespace_='class:', name_='ConfigurationFile', pretty_print=pretty_print)
        if self.ConfigurationID is not None:
            self.ConfigurationID.export(outfile, level, namespace_='class:', name_='ConfigurationID', pretty_print=pretty_print)
        if self.CreationTime is not None:
            self.CreationTime.export(outfile, level, namespace_='class:', name_='CreationTime', pretty_print=pretty_print)
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_='class:', name_='Description', pretty_print=pretty_print)
        if self.ElementName is not None:
            self.ElementName.export(outfile, level, namespace_='class:', name_='ElementName', pretty_print=pretty_print)
        if self.InstanceID is not None:
            self.InstanceID.export(outfile, level, namespace_='class:', name_='InstanceID', pretty_print=pretty_print)
        if self.LogDataRoot is not None:
            self.LogDataRoot.export(outfile, level, namespace_='class:', name_='LogDataRoot', pretty_print=pretty_print)
        for Notes_ in self.Notes:
            Notes_.export(outfile, level, namespace_='class:', name_='Notes', pretty_print=pretty_print)
        if self.RecoveryFile is not None:
            self.RecoveryFile.export(outfile, level, namespace_='class:', name_='RecoveryFile', pretty_print=pretty_print)
        if self.SnapshotDataRoot is not None:
            self.SnapshotDataRoot.export(outfile, level, namespace_='class:', name_='SnapshotDataRoot', pretty_print=pretty_print)
        if self.SuspendDataRoot is not None:
            self.SuspendDataRoot.export(outfile, level, namespace_='class:', name_='SuspendDataRoot', pretty_print=pretty_print)
        if self.SwapFileDataRoot is not None:
            self.SwapFileDataRoot.export(outfile, level, namespace_='class:', name_='SwapFileDataRoot', pretty_print=pretty_print)
        if self.VirtualSystemIdentifier is not None:
            self.VirtualSystemIdentifier.export(outfile, level, namespace_='class:', name_='VirtualSystemIdentifier', pretty_print=pretty_print)
        if self.VirtualSystemType is not None:
            self.VirtualSystemType.export(outfile, level, namespace_='class:', name_='VirtualSystemType', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CIM_VirtualSystemSettingData_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AutomaticRecoveryAction is not None:
            showIndent(outfile, level)
            outfile.write('AutomaticRecoveryAction=%d,\n' % self.AutomaticRecoveryAction)
        if self.AutomaticShutdownAction is not None:
            showIndent(outfile, level)
            outfile.write('AutomaticShutdownAction=%d,\n' % self.AutomaticShutdownAction)
        if self.AutomaticStartupAction is not None:
            showIndent(outfile, level)
            outfile.write('AutomaticStartupAction=%d,\n' % self.AutomaticStartupAction)
        if self.AutomaticStartupActionDelay is not None:
            showIndent(outfile, level)
            outfile.write('AutomaticStartupActionDelay=model_.AutomaticStartupActionDelay(\n')
            self.AutomaticStartupActionDelay.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AutomaticStartupActionSequenceNumber is not None:
            showIndent(outfile, level)
            outfile.write('AutomaticStartupActionSequenceNumber=model_.AutomaticStartupActionSequenceNumber(\n')
            self.AutomaticStartupActionSequenceNumber.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Caption is not None:
            showIndent(outfile, level)
            outfile.write('Caption=model_.Caption(\n')
            self.Caption.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ConfigurationDataRoot is not None:
            showIndent(outfile, level)
            outfile.write('ConfigurationDataRoot=model_.ConfigurationDataRoot(\n')
            self.ConfigurationDataRoot.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ConfigurationFile is not None:
            showIndent(outfile, level)
            outfile.write('ConfigurationFile=model_.ConfigurationFile(\n')
            self.ConfigurationFile.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ConfigurationID is not None:
            showIndent(outfile, level)
            outfile.write('ConfigurationID=model_.ConfigurationID(\n')
            self.ConfigurationID.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CreationTime is not None:
            showIndent(outfile, level)
            outfile.write('CreationTime=model_.CreationTime(\n')
            self.CreationTime.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Description(\n')
            self.Description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ElementName is not None:
            showIndent(outfile, level)
            outfile.write('ElementName=model_.ElementName(\n')
            self.ElementName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InstanceID is not None:
            showIndent(outfile, level)
            outfile.write('InstanceID=model_.InstanceID(\n')
            self.InstanceID.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LogDataRoot is not None:
            showIndent(outfile, level)
            outfile.write('LogDataRoot=model_.LogDataRoot(\n')
            self.LogDataRoot.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Notes=[\n')
        level += 1
        for Notes_ in self.Notes:
            showIndent(outfile, level)
            outfile.write('model_.Notes(\n')
            Notes_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.RecoveryFile is not None:
            showIndent(outfile, level)
            outfile.write('RecoveryFile=model_.RecoveryFile(\n')
            self.RecoveryFile.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SnapshotDataRoot is not None:
            showIndent(outfile, level)
            outfile.write('SnapshotDataRoot=model_.SnapshotDataRoot(\n')
            self.SnapshotDataRoot.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SuspendDataRoot is not None:
            showIndent(outfile, level)
            outfile.write('SuspendDataRoot=model_.SuspendDataRoot(\n')
            self.SuspendDataRoot.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SwapFileDataRoot is not None:
            showIndent(outfile, level)
            outfile.write('SwapFileDataRoot=model_.SwapFileDataRoot(\n')
            self.SwapFileDataRoot.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VirtualSystemIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('VirtualSystemIdentifier=model_.VirtualSystemIdentifier(\n')
            self.VirtualSystemIdentifier.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VirtualSystemType is not None:
            showIndent(outfile, level)
            outfile.write('VirtualSystemType=model_.VirtualSystemType(\n')
            self.VirtualSystemType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AutomaticRecoveryAction':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AutomaticRecoveryAction')
            self.AutomaticRecoveryAction = ival_
            self.validate_AutomaticRecoveryAction(self.AutomaticRecoveryAction)    # validate type AutomaticRecoveryAction
        elif nodeName_ == 'AutomaticShutdownAction':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AutomaticShutdownAction')
            self.AutomaticShutdownAction = ival_
            self.validate_AutomaticShutdownAction(self.AutomaticShutdownAction)    # validate type AutomaticShutdownAction
        elif nodeName_ == 'AutomaticStartupAction':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AutomaticStartupAction')
            self.AutomaticStartupAction = ival_
            self.validate_AutomaticStartupAction(self.AutomaticStartupAction)    # validate type AutomaticStartupAction
        elif nodeName_ == 'AutomaticStartupActionDelay':
            obj_ = cimDateTime.factory()
            obj_.build(child_)
            self.AutomaticStartupActionDelay = obj_
            obj_.original_tagname_ = 'AutomaticStartupActionDelay'
        elif nodeName_ == 'AutomaticStartupActionSequenceNumber':
            obj_ = cimUnsignedShort.factory()
            obj_.build(child_)
            self.AutomaticStartupActionSequenceNumber = obj_
            obj_.original_tagname_ = 'AutomaticStartupActionSequenceNumber'
        elif nodeName_ == 'Caption':
            obj_ = Caption.factory()
            obj_.build(child_)
            self.Caption = obj_
            obj_.original_tagname_ = 'Caption'
        elif nodeName_ == 'ConfigurationDataRoot':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ConfigurationDataRoot = obj_
            obj_.original_tagname_ = 'ConfigurationDataRoot'
        elif nodeName_ == 'ConfigurationFile':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ConfigurationFile = obj_
            obj_.original_tagname_ = 'ConfigurationFile'
        elif nodeName_ == 'ConfigurationID':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ConfigurationID = obj_
            obj_.original_tagname_ = 'ConfigurationID'
        elif nodeName_ == 'CreationTime':
            obj_ = cimDateTime.factory()
            obj_.build(child_)
            self.CreationTime = obj_
            obj_.original_tagname_ = 'CreationTime'
        elif nodeName_ == 'Description':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'ElementName':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ElementName = obj_
            obj_.original_tagname_ = 'ElementName'
        elif nodeName_ == 'InstanceID':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.InstanceID = obj_
            obj_.original_tagname_ = 'InstanceID'
        elif nodeName_ == 'LogDataRoot':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.LogDataRoot = obj_
            obj_.original_tagname_ = 'LogDataRoot'
        elif nodeName_ == 'Notes':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Notes.append(obj_)
            obj_.original_tagname_ = 'Notes'
        elif nodeName_ == 'RecoveryFile':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.RecoveryFile = obj_
            obj_.original_tagname_ = 'RecoveryFile'
        elif nodeName_ == 'SnapshotDataRoot':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.SnapshotDataRoot = obj_
            obj_.original_tagname_ = 'SnapshotDataRoot'
        elif nodeName_ == 'SuspendDataRoot':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.SuspendDataRoot = obj_
            obj_.original_tagname_ = 'SuspendDataRoot'
        elif nodeName_ == 'SwapFileDataRoot':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.SwapFileDataRoot = obj_
            obj_.original_tagname_ = 'SwapFileDataRoot'
        elif nodeName_ == 'VirtualSystemIdentifier':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VirtualSystemIdentifier = obj_
            obj_.original_tagname_ = 'VirtualSystemIdentifier'
        elif nodeName_ == 'VirtualSystemType':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VirtualSystemType = obj_
            obj_.original_tagname_ = 'VirtualSystemType'
        else:
            obj_ = self.gds_build_any(child_, 'CIM_VirtualSystemSettingData_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class CIM_VirtualSystemSettingData_Type


class ConsumerVisibility(cimAnySimpleType):
    subclass = None
    superclass = cimAnySimpleType
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(ConsumerVisibility, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ConsumerVisibility.subclass:
            return ConsumerVisibility.subclass(*args_, **kwargs_)
        else:
            return ConsumerVisibility(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ConsumerVisibility, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConsumerVisibility', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConsumerVisibility')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConsumerVisibility', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConsumerVisibility'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(ConsumerVisibility, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConsumerVisibility')
    def exportChildren(self, outfile, level, namespace_='', name_='ConsumerVisibility', fromsubclass_=False, pretty_print=True):
        super(ConsumerVisibility, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ConsumerVisibility'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(ConsumerVisibility, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConsumerVisibility, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(ConsumerVisibility, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ConsumerVisibility


class MappingBehavior(cimAnySimpleType):
    subclass = None
    superclass = cimAnySimpleType
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(MappingBehavior, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if MappingBehavior.subclass:
            return MappingBehavior.subclass(*args_, **kwargs_)
        else:
            return MappingBehavior(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(MappingBehavior, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MappingBehavior', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MappingBehavior')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MappingBehavior', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MappingBehavior'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(MappingBehavior, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MappingBehavior')
    def exportChildren(self, outfile, level, namespace_='', name_='MappingBehavior', fromsubclass_=False, pretty_print=True):
        super(MappingBehavior, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='MappingBehavior'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(MappingBehavior, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MappingBehavior, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(MappingBehavior, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MappingBehavior


class CIM_ResourceAllocationSettingData_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Address=None, AddressOnParent=None, AllocationUnits=None, AutomaticAllocation=None, AutomaticDeallocation=None, Caption=None, Connection=None, ConsumerVisibility=None, Description=None, ElementName=None, HostResource=None, InstanceID=None, Limit=None, MappingBehavior=None, OtherResourceType=None, Parent=None, PoolID=None, Reservation=None, ResourceSubType=None, ResourceType=None, VirtualQuantity=None, VirtualQuantityUnits=None, Weight=None, anytypeobjs_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.Address = Address
        self.AddressOnParent = AddressOnParent
        self.AllocationUnits = AllocationUnits
        self.AutomaticAllocation = AutomaticAllocation
        self.AutomaticDeallocation = AutomaticDeallocation
        self.Caption = Caption
        if Connection is None:
            self.Connection = []
        else:
            self.Connection = Connection
        self.ConsumerVisibility = ConsumerVisibility
        self.validate_ConsumerVisibility(self.ConsumerVisibility)
        self.Description = Description
        self.ElementName = ElementName
        if HostResource is None:
            self.HostResource = []
        else:
            self.HostResource = HostResource
        self.InstanceID = InstanceID
        self.Limit = Limit
        self.MappingBehavior = MappingBehavior
        self.validate_MappingBehavior(self.MappingBehavior)
        self.OtherResourceType = OtherResourceType
        self.Parent = Parent
        self.PoolID = PoolID
        self.Reservation = Reservation
        self.ResourceSubType = ResourceSubType
        self.ResourceType = ResourceType
        self.validate_ResourceType(self.ResourceType)
        self.VirtualQuantity = VirtualQuantity
        self.VirtualQuantityUnits = VirtualQuantityUnits
        self.Weight = Weight
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CIM_ResourceAllocationSettingData_Type.subclass:
            return CIM_ResourceAllocationSettingData_Type.subclass(*args_, **kwargs_)
        else:
            return CIM_ResourceAllocationSettingData_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_AddressOnParent(self): return self.AddressOnParent
    def set_AddressOnParent(self, AddressOnParent): self.AddressOnParent = AddressOnParent
    def get_AllocationUnits(self): return self.AllocationUnits
    def set_AllocationUnits(self, AllocationUnits): self.AllocationUnits = AllocationUnits
    def get_AutomaticAllocation(self): return self.AutomaticAllocation
    def set_AutomaticAllocation(self, AutomaticAllocation): self.AutomaticAllocation = AutomaticAllocation
    def get_AutomaticDeallocation(self): return self.AutomaticDeallocation
    def set_AutomaticDeallocation(self, AutomaticDeallocation): self.AutomaticDeallocation = AutomaticDeallocation
    def get_Caption(self): return self.Caption
    def set_Caption(self, Caption): self.Caption = Caption
    def get_Connection(self): return self.Connection
    def set_Connection(self, Connection): self.Connection = Connection
    def add_Connection(self, value): self.Connection.append(value)
    def insert_Connection_at(self, index, value): self.Connection.insert(index, value)
    def replace_Connection_at(self, index, value): self.Connection[index] = value
    def get_ConsumerVisibility(self): return self.ConsumerVisibility
    def set_ConsumerVisibility(self, ConsumerVisibility): self.ConsumerVisibility = ConsumerVisibility
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ElementName(self): return self.ElementName
    def set_ElementName(self, ElementName): self.ElementName = ElementName
    def get_HostResource(self): return self.HostResource
    def set_HostResource(self, HostResource): self.HostResource = HostResource
    def add_HostResource(self, value): self.HostResource.append(value)
    def insert_HostResource_at(self, index, value): self.HostResource.insert(index, value)
    def replace_HostResource_at(self, index, value): self.HostResource[index] = value
    def get_InstanceID(self): return self.InstanceID
    def set_InstanceID(self, InstanceID): self.InstanceID = InstanceID
    def get_Limit(self): return self.Limit
    def set_Limit(self, Limit): self.Limit = Limit
    def get_MappingBehavior(self): return self.MappingBehavior
    def set_MappingBehavior(self, MappingBehavior): self.MappingBehavior = MappingBehavior
    def get_OtherResourceType(self): return self.OtherResourceType
    def set_OtherResourceType(self, OtherResourceType): self.OtherResourceType = OtherResourceType
    def get_Parent(self): return self.Parent
    def set_Parent(self, Parent): self.Parent = Parent
    def get_PoolID(self): return self.PoolID
    def set_PoolID(self, PoolID): self.PoolID = PoolID
    def get_Reservation(self): return self.Reservation
    def set_Reservation(self, Reservation): self.Reservation = Reservation
    def get_ResourceSubType(self): return self.ResourceSubType
    def set_ResourceSubType(self, ResourceSubType): self.ResourceSubType = ResourceSubType
    def get_ResourceType(self): return self.ResourceType
    def set_ResourceType(self, ResourceType): self.ResourceType = ResourceType
    def get_VirtualQuantity(self): return self.VirtualQuantity
    def set_VirtualQuantity(self, VirtualQuantity): self.VirtualQuantity = VirtualQuantity
    def get_VirtualQuantityUnits(self): return self.VirtualQuantityUnits
    def set_VirtualQuantityUnits(self, VirtualQuantityUnits): self.VirtualQuantityUnits = VirtualQuantityUnits
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ConsumerVisibility(self, value):
        # Validate type ConsumerVisibility, a restriction on xs:unsignedShort.
        pass
    def validate_MappingBehavior(self, value):
        # Validate type MappingBehavior, a restriction on xs:unsignedShort.
        pass
    def validate_ResourceType(self, value):
        # Validate type ResourceType, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.Address is not None or
            self.AddressOnParent is not None or
            self.AllocationUnits is not None or
            self.AutomaticAllocation is not None or
            self.AutomaticDeallocation is not None or
            self.Caption is not None or
            self.Connection or
            self.ConsumerVisibility is not None or
            self.Description is not None or
            self.ElementName is not None or
            self.HostResource or
            self.InstanceID is not None or
            self.Limit is not None or
            self.MappingBehavior is not None or
            self.OtherResourceType is not None or
            self.Parent is not None or
            self.PoolID is not None or
            self.Reservation is not None or
            self.ResourceSubType is not None or
            self.ResourceType is not None or
            self.VirtualQuantity is not None or
            self.VirtualQuantityUnits is not None or
            self.Weight is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CIM_ResourceAllocationSettingData_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CIM_ResourceAllocationSettingData_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CIM_ResourceAllocationSettingData_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CIM_ResourceAllocationSettingData_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CIM_ResourceAllocationSettingData_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_='class:', name_='Address', pretty_print=pretty_print)
        if self.AddressOnParent is not None:
            self.AddressOnParent.export(outfile, level, namespace_='class:', name_='AddressOnParent', pretty_print=pretty_print)
        if self.AllocationUnits is not None:
            self.AllocationUnits.export(outfile, level, namespace_='class:', name_='AllocationUnits', pretty_print=pretty_print)
        if self.AutomaticAllocation is not None:
            self.AutomaticAllocation.export(outfile, level, namespace_='class:', name_='AutomaticAllocation', pretty_print=pretty_print)
        if self.AutomaticDeallocation is not None:
            self.AutomaticDeallocation.export(outfile, level, namespace_='class:', name_='AutomaticDeallocation', pretty_print=pretty_print)
        if self.Caption is not None:
            self.Caption.export(outfile, level, namespace_='class:', name_='Caption', pretty_print=pretty_print)
        for Connection_ in self.Connection:
            Connection_.export(outfile, level, namespace_='class:', name_='Connection', pretty_print=pretty_print)
        if self.ConsumerVisibility is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConsumerVisibility>%s</%sConsumerVisibility>%s' % (namespace_, self.gds_format_integer(self.ConsumerVisibility, input_name='ConsumerVisibility'), namespace_, eol_))
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_='class:', name_='Description', pretty_print=pretty_print)
        if self.ElementName is not None:
            self.ElementName.export(outfile, level, namespace_='class:', name_='ElementName', pretty_print=pretty_print)
        for HostResource_ in self.HostResource:
            HostResource_.export(outfile, level, namespace_='class:', name_='HostResource', pretty_print=pretty_print)
        if self.InstanceID is not None:
            self.InstanceID.export(outfile, level, namespace_='class:', name_='InstanceID', pretty_print=pretty_print)
        if self.Limit is not None:
            self.Limit.export(outfile, level, namespace_='class:', name_='Limit', pretty_print=pretty_print)
        if self.MappingBehavior is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMappingBehavior>%s</%sMappingBehavior>%s' % (namespace_, self.gds_format_integer(self.MappingBehavior, input_name='MappingBehavior'), namespace_, eol_))
        if self.OtherResourceType is not None:
            self.OtherResourceType.export(outfile, level, namespace_='class:', name_='OtherResourceType', pretty_print=pretty_print)
        if self.Parent is not None:
            self.Parent.export(outfile, level, namespace_='class:', name_='Parent', pretty_print=pretty_print)
        if self.PoolID is not None:
            self.PoolID.export(outfile, level, namespace_='class:', name_='PoolID', pretty_print=pretty_print)
        if self.Reservation is not None:
            self.Reservation.export(outfile, level, namespace_='class:', name_='Reservation', pretty_print=pretty_print)
        if self.ResourceSubType is not None:
            self.ResourceSubType.export(outfile, level, namespace_='class:', name_='ResourceSubType', pretty_print=pretty_print)
        if self.ResourceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceType>%s</%sResourceType>%s' % (namespace_, self.gds_format_integer(self.ResourceType, input_name='ResourceType'), namespace_, eol_))
        if self.VirtualQuantity is not None:
            self.VirtualQuantity.export(outfile, level, namespace_='class:', name_='VirtualQuantity', pretty_print=pretty_print)
        if self.VirtualQuantityUnits is not None:
            self.VirtualQuantityUnits.export(outfile, level, namespace_='class:', name_='VirtualQuantityUnits', pretty_print=pretty_print)
        if self.Weight is not None:
            self.Weight.export(outfile, level, namespace_='class:', name_='Weight', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CIM_ResourceAllocationSettingData_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Address is not None:
            showIndent(outfile, level)
            outfile.write('Address=model_.Address(\n')
            self.Address.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AddressOnParent is not None:
            showIndent(outfile, level)
            outfile.write('AddressOnParent=model_.AddressOnParent(\n')
            self.AddressOnParent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AllocationUnits is not None:
            showIndent(outfile, level)
            outfile.write('AllocationUnits=model_.AllocationUnits(\n')
            self.AllocationUnits.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AutomaticAllocation is not None:
            showIndent(outfile, level)
            outfile.write('AutomaticAllocation=model_.AutomaticAllocation(\n')
            self.AutomaticAllocation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AutomaticDeallocation is not None:
            showIndent(outfile, level)
            outfile.write('AutomaticDeallocation=model_.AutomaticDeallocation(\n')
            self.AutomaticDeallocation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Caption is not None:
            showIndent(outfile, level)
            outfile.write('Caption=model_.Caption(\n')
            self.Caption.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Connection=[\n')
        level += 1
        for Connection_ in self.Connection:
            showIndent(outfile, level)
            outfile.write('model_.Connection(\n')
            Connection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ConsumerVisibility is not None:
            showIndent(outfile, level)
            outfile.write('ConsumerVisibility=%d,\n' % self.ConsumerVisibility)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Description(\n')
            self.Description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ElementName is not None:
            showIndent(outfile, level)
            outfile.write('ElementName=model_.ElementName(\n')
            self.ElementName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('HostResource=[\n')
        level += 1
        for HostResource_ in self.HostResource:
            showIndent(outfile, level)
            outfile.write('model_.HostResource(\n')
            HostResource_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.InstanceID is not None:
            showIndent(outfile, level)
            outfile.write('InstanceID=model_.InstanceID(\n')
            self.InstanceID.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Limit is not None:
            showIndent(outfile, level)
            outfile.write('Limit=model_.Limit(\n')
            self.Limit.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MappingBehavior is not None:
            showIndent(outfile, level)
            outfile.write('MappingBehavior=%d,\n' % self.MappingBehavior)
        if self.OtherResourceType is not None:
            showIndent(outfile, level)
            outfile.write('OtherResourceType=model_.OtherResourceType(\n')
            self.OtherResourceType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Parent is not None:
            showIndent(outfile, level)
            outfile.write('Parent=model_.Parent(\n')
            self.Parent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PoolID is not None:
            showIndent(outfile, level)
            outfile.write('PoolID=model_.PoolID(\n')
            self.PoolID.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Reservation is not None:
            showIndent(outfile, level)
            outfile.write('Reservation=model_.Reservation(\n')
            self.Reservation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ResourceSubType is not None:
            showIndent(outfile, level)
            outfile.write('ResourceSubType=model_.ResourceSubType(\n')
            self.ResourceSubType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ResourceType is not None:
            showIndent(outfile, level)
            outfile.write('ResourceType=%d,\n' % self.ResourceType)
        if self.VirtualQuantity is not None:
            showIndent(outfile, level)
            outfile.write('VirtualQuantity=model_.VirtualQuantity(\n')
            self.VirtualQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VirtualQuantityUnits is not None:
            showIndent(outfile, level)
            outfile.write('VirtualQuantityUnits=model_.VirtualQuantityUnits(\n')
            self.VirtualQuantityUnits.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Weight is not None:
            showIndent(outfile, level)
            outfile.write('Weight=model_.Weight(\n')
            self.Weight.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'AddressOnParent':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AddressOnParent = obj_
            obj_.original_tagname_ = 'AddressOnParent'
        elif nodeName_ == 'AllocationUnits':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AllocationUnits = obj_
            obj_.original_tagname_ = 'AllocationUnits'
        elif nodeName_ == 'AutomaticAllocation':
            class_obj_ = self.get_class_obj_(child_, cimBoolean)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AutomaticAllocation = obj_
            obj_.original_tagname_ = 'AutomaticAllocation'
        elif nodeName_ == 'AutomaticDeallocation':
            class_obj_ = self.get_class_obj_(child_, cimBoolean)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AutomaticDeallocation = obj_
            obj_.original_tagname_ = 'AutomaticDeallocation'
        elif nodeName_ == 'Caption':
            obj_ = Caption.factory()
            obj_.build(child_)
            self.Caption = obj_
            obj_.original_tagname_ = 'Caption'
        elif nodeName_ == 'Connection':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Connection.append(obj_)
            obj_.original_tagname_ = 'Connection'
        elif nodeName_ == 'ConsumerVisibility':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ConsumerVisibility')
            self.ConsumerVisibility = ival_
            self.validate_ConsumerVisibility(self.ConsumerVisibility)    # validate type ConsumerVisibility
        elif nodeName_ == 'Description':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'ElementName':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ElementName = obj_
            obj_.original_tagname_ = 'ElementName'
        elif nodeName_ == 'HostResource':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.HostResource.append(obj_)
            obj_.original_tagname_ = 'HostResource'
        elif nodeName_ == 'InstanceID':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.InstanceID = obj_
            obj_.original_tagname_ = 'InstanceID'
        elif nodeName_ == 'Limit':
            obj_ = cimUnsignedLong.factory()
            obj_.build(child_)
            self.Limit = obj_
            obj_.original_tagname_ = 'Limit'
        elif nodeName_ == 'MappingBehavior':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MappingBehavior')
            self.MappingBehavior = ival_
            self.validate_MappingBehavior(self.MappingBehavior)    # validate type MappingBehavior
        elif nodeName_ == 'OtherResourceType':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.OtherResourceType = obj_
            obj_.original_tagname_ = 'OtherResourceType'
        elif nodeName_ == 'Parent':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Parent = obj_
            obj_.original_tagname_ = 'Parent'
        elif nodeName_ == 'PoolID':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.PoolID = obj_
            obj_.original_tagname_ = 'PoolID'
        elif nodeName_ == 'Reservation':
            obj_ = cimUnsignedLong.factory()
            obj_.build(child_)
            self.Reservation = obj_
            obj_.original_tagname_ = 'Reservation'
        elif nodeName_ == 'ResourceSubType':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ResourceSubType = obj_
            obj_.original_tagname_ = 'ResourceSubType'
        elif nodeName_ == 'ResourceType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ResourceType')
            self.ResourceType = ival_
            self.validate_ResourceType(self.ResourceType)    # validate type ResourceType
        elif nodeName_ == 'VirtualQuantity':
            obj_ = cimUnsignedLong.factory()
            obj_.build(child_)
            self.VirtualQuantity = obj_
            obj_.original_tagname_ = 'VirtualQuantity'
        elif nodeName_ == 'VirtualQuantityUnits':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VirtualQuantityUnits = obj_
            obj_.original_tagname_ = 'VirtualQuantityUnits'
        elif nodeName_ == 'Weight':
            class_obj_ = self.get_class_obj_(child_, cimUnsignedInt)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Weight = obj_
            obj_.original_tagname_ = 'Weight'
        else:
            obj_ = self.gds_build_any(child_, 'CIM_ResourceAllocationSettingData_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class CIM_ResourceAllocationSettingData_Type


class Environment_Type(GeneratedsSuper):
    """Type for root OVF environmentIdentifier matching recipient of this
    environment"""
    subclass = None
    superclass = None
    def __init__(self, id='', Section=None, Entity=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
        if Entity is None:
            self.Entity = []
        else:
            self.Entity = Entity
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Environment_Type.subclass:
            return Environment_Type.subclass(*args_, **kwargs_)
        else:
            return Environment_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def get_Entity(self): return self.Entity
    def set_Entity(self, Entity): self.Entity = Entity
    def add_Entity(self, value): self.Entity.append(value)
    def insert_Entity_at(self, index, value): self.Entity.insert(index, value)
    def replace_Entity_at(self, index, value): self.Entity[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Section or
            self.Entity or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Environment_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Environment_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Environment_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Environment_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Environment_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovfenv:', name_='Section', pretty_print=pretty_print)
        for Entity_ in self.Entity:
            Entity_.export(outfile, level, namespace_, name_='Entity', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Environment_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Entity=[\n')
        level += 1
        for Entity_ in self.Entity:
            showIndent(outfile, level)
            outfile.write('model_.Entity_Type(\n')
            Entity_.exportLiteral(outfile, level, name_='Entity_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
        elif nodeName_ == 'Entity':
            obj_ = Entity_Type.factory()
            obj_.build(child_)
            self.Entity.append(obj_)
            obj_.original_tagname_ = 'Entity'
        else:
            obj_ = self.gds_build_any(child_, 'Environment_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class Environment_Type


class Entity_Type(GeneratedsSuper):
    """Container of sections for a specific entity Entity identifier"""
    subclass = None
    superclass = None
    def __init__(self, id=None, Section=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Entity_Type.subclass:
            return Entity_Type.subclass(*args_, **kwargs_)
        else:
            return Entity_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Section or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Entity_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Entity_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Entity_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Entity_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Entity_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovfenv:', name_='Section', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Entity_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
        else:
            obj_ = self.gds_build_any(child_, 'Entity_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class Entity_Type


class PropertySection_Type(Section_Type):
    """Key/value pairs of assigned properties for an entity"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Property=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(PropertySection_Type, self).__init__()
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if PropertySection_Type.subclass:
            return PropertySection_Type.subclass(*args_, **kwargs_)
        else:
            return PropertySection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property_at(self, index, value): self.Property.insert(index, value)
    def replace_Property_at(self, index, value): self.Property[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Property or
            self.anytypeobjs_ or
            super(PropertySection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertySection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertySection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PropertySection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertySection_Type'):
        super(PropertySection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PropertySection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='PropertySection_Type', fromsubclass_=False, pretty_print=True):
        super(PropertySection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PropertySection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PropertySection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PropertySection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.PropertyType6(\n')
            Property_.exportLiteral(outfile, level, name_='PropertyType6')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PropertySection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property':
            obj_ = PropertyType6.factory()
            obj_.build(child_)
            self.Property.append(obj_)
            obj_.original_tagname_ = 'Property'
        else:
            obj_ = self.gds_build_any(child_, 'PropertySection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(PropertySection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class PropertySection_Type


class PlatformSection_Type(Section_Type):
    """Information about deployment platform"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Kind=None, Version=None, Vendor=None, Locale=None, Timezone=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(PlatformSection_Type, self).__init__()
        self.Kind = Kind
        self.Version = Version
        self.Vendor = Vendor
        self.Locale = Locale
        self.Timezone = Timezone
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if PlatformSection_Type.subclass:
            return PlatformSection_Type.subclass(*args_, **kwargs_)
        else:
            return PlatformSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Vendor(self): return self.Vendor
    def set_Vendor(self, Vendor): self.Vendor = Vendor
    def get_Locale(self): return self.Locale
    def set_Locale(self, Locale): self.Locale = Locale
    def get_Timezone(self): return self.Timezone
    def set_Timezone(self, Timezone): self.Timezone = Timezone
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Kind is not None or
            self.Version is not None or
            self.Vendor is not None or
            self.Locale is not None or
            self.Timezone is not None or
            self.anytypeobjs_ or
            super(PlatformSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PlatformSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PlatformSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PlatformSection_Type'):
        super(PlatformSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='PlatformSection_Type', fromsubclass_=False, pretty_print=True):
        super(PlatformSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Kind is not None:
            self.Kind.export(outfile, level, namespace_, name_='Kind', pretty_print=pretty_print)
        if self.Version is not None:
            self.Version.export(outfile, level, namespace_, name_='Version', pretty_print=pretty_print)
        if self.Vendor is not None:
            self.Vendor.export(outfile, level, namespace_, name_='Vendor', pretty_print=pretty_print)
        if self.Locale is not None:
            self.Locale.export(outfile, level, namespace_, name_='Locale', pretty_print=pretty_print)
        if self.Timezone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimezone>%s</%sTimezone>%s' % (namespace_, self.gds_format_integer(self.Timezone, input_name='Timezone'), namespace_, eol_))
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PlatformSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PlatformSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PlatformSection_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.Kind is not None:
            showIndent(outfile, level)
            outfile.write('Kind=model_.cimString(\n')
            self.Kind.exportLiteral(outfile, level, name_='Kind')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=model_.cimString(\n')
            self.Version.exportLiteral(outfile, level, name_='Version')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Vendor is not None:
            showIndent(outfile, level)
            outfile.write('Vendor=model_.cimString(\n')
            self.Vendor.exportLiteral(outfile, level, name_='Vendor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Locale is not None:
            showIndent(outfile, level)
            outfile.write('Locale=model_.cimString(\n')
            self.Locale.exportLiteral(outfile, level, name_='Locale')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Timezone is not None:
            showIndent(outfile, level)
            outfile.write('Timezone=%d,\n' % self.Timezone)
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PlatformSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Kind':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Kind = obj_
            obj_.original_tagname_ = 'Kind'
        elif nodeName_ == 'Version':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Version = obj_
            obj_.original_tagname_ = 'Version'
        elif nodeName_ == 'Vendor':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Vendor = obj_
            obj_.original_tagname_ = 'Vendor'
        elif nodeName_ == 'Locale':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Locale = obj_
            obj_.original_tagname_ = 'Locale'
        elif nodeName_ == 'Timezone':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Timezone')
            self.Timezone = ival_
        else:
            obj_ = self.gds_build_any(child_, 'PlatformSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(PlatformSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class PlatformSection_Type


class IpAssignmentSection_Type(Section_Type):
    """Specifies the IP Assignment policy that is supportedList of
    supported IP assignment schemes. Valid values are: dhcp and
    ovfenvList of supported IP protocols. Valid values are: IPv4 and
    IPv6"""
    subclass = None
    superclass = Section_Type
    def __init__(self, schemes='', protocols='IPv4'):
        self.original_tagname_ = None
        super(IpAssignmentSection_Type, self).__init__()
        self.schemes = _cast(None, schemes)
        self.protocols = _cast(None, protocols)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if IpAssignmentSection_Type.subclass:
            return IpAssignmentSection_Type.subclass(*args_, **kwargs_)
        else:
            return IpAssignmentSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_schemes(self): return self.schemes
    def set_schemes(self, schemes): self.schemes = schemes
    def get_protocols(self): return self.protocols
    def set_protocols(self, protocols): self.protocols = protocols
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            super(IpAssignmentSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpAssignmentSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpAssignmentSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpAssignmentSection_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpAssignmentSection_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(IpAssignmentSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpAssignmentSection_Type')
        if self.schemes is not None and 'schemes' not in already_processed:
            already_processed.add('schemes')
            outfile.write(' schemes=%s' % (self.gds_format_string(quote_attrib(self.schemes).encode(ExternalEncoding), input_name='schemes'), ))
        if self.protocols is not None and 'protocols' not in already_processed:
            already_processed.add('protocols')
            outfile.write(' protocols=%s' % (self.gds_format_string(quote_attrib(self.protocols).encode(ExternalEncoding), input_name='protocols'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IpAssignmentSection_Type', fromsubclass_=False, pretty_print=True):
        super(IpAssignmentSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='IpAssignmentSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.schemes is not None and 'schemes' not in already_processed:
            already_processed.add('schemes')
            showIndent(outfile, level)
            outfile.write('schemes="%s",\n' % (self.schemes,))
        if self.protocols is not None and 'protocols' not in already_processed:
            already_processed.add('protocols')
            showIndent(outfile, level)
            outfile.write('protocols="%s",\n' % (self.protocols,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(IpAssignmentSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpAssignmentSection_Type, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('schemes', node)
        if value is not None and 'schemes' not in already_processed:
            already_processed.add('schemes')
            self.schemes = value
        value = find_attr_value_('protocols', node)
        if value is not None and 'protocols' not in already_processed:
            already_processed.add('protocols')
            self.protocols = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(IpAssignmentSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IpAssignmentSection_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IpAssignmentSection_Type


class CpuCompatibilitySection_Type(Section_Type):
    """CPU Architecture requirements for guest software"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Level=None):
        self.original_tagname_ = None
        super(CpuCompatibilitySection_Type, self).__init__()
        if Level is None:
            self.Level = []
        else:
            self.Level = Level
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CpuCompatibilitySection_Type.subclass:
            return CpuCompatibilitySection_Type.subclass(*args_, **kwargs_)
        else:
            return CpuCompatibilitySection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Level(self): return self.Level
    def set_Level(self, Level): self.Level = Level
    def add_Level(self, value): self.Level.append(value)
    def insert_Level_at(self, index, value): self.Level.insert(index, value)
    def replace_Level_at(self, index, value): self.Level[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Level or
            super(CpuCompatibilitySection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CpuCompatibilitySection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CpuCompatibilitySection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CpuCompatibilitySection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CpuCompatibilitySection_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(CpuCompatibilitySection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CpuCompatibilitySection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='CpuCompatibilitySection_Type', fromsubclass_=False, pretty_print=True):
        super(CpuCompatibilitySection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Level_ in self.Level:
            Level_.export(outfile, level, namespace_, name_='Level', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CpuCompatibilitySection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(CpuCompatibilitySection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CpuCompatibilitySection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Level=[\n')
        level += 1
        for Level_ in self.Level:
            showIndent(outfile, level)
            outfile.write('model_.LevelType(\n')
            Level_.exportLiteral(outfile, level, name_='LevelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(CpuCompatibilitySection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Level':
            obj_ = LevelType.factory()
            obj_.build(child_)
            self.Level.append(obj_)
            obj_.original_tagname_ = 'Level'
        super(CpuCompatibilitySection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CpuCompatibilitySection_Type


class BootOrderSection_Type(Section_Type):
    """Specifies the boot device for this VirtualSystemType of bootable
    device. Supported values are: cdrom, floppy, net, or disk
    Instance ID of ethernet card if boot device type is net."""
    subclass = None
    superclass = Section_Type
    def __init__(self, instanceId=None, type_=''):
        self.original_tagname_ = None
        super(BootOrderSection_Type, self).__init__()
        self.instanceId = _cast(int, instanceId)
        self.type_ = _cast(None, type_)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if BootOrderSection_Type.subclass:
            return BootOrderSection_Type.subclass(*args_, **kwargs_)
        else:
            return BootOrderSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instanceId(self): return self.instanceId
    def set_instanceId(self, instanceId): self.instanceId = instanceId
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            super(BootOrderSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BootOrderSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BootOrderSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BootOrderSection_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BootOrderSection_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(BootOrderSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BootOrderSection_Type')
        if self.instanceId is not None and 'instanceId' not in already_processed:
            already_processed.add('instanceId')
            outfile.write(' instanceId="%s"' % self.gds_format_integer(self.instanceId, input_name='instanceId'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BootOrderSection_Type', fromsubclass_=False, pretty_print=True):
        super(BootOrderSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='BootOrderSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instanceId is not None and 'instanceId' not in already_processed:
            already_processed.add('instanceId')
            showIndent(outfile, level)
            outfile.write('instanceId=%d,\n' % (self.instanceId,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(BootOrderSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BootOrderSection_Type, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instanceId', node)
        if value is not None and 'instanceId' not in already_processed:
            already_processed.add('instanceId')
            try:
                self.instanceId = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(BootOrderSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BootOrderSection_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BootOrderSection_Type


class ConfigKeyValue_Type(GeneratedsSuper):
    """Config keyConfig value"""
    subclass = None
    superclass = None
    def __init__(self, required=None, value=None, key=None, extensiontype_=None):
        self.original_tagname_ = None
        self.required = _cast(bool, required)
        self.value = _cast(None, value)
        self.key = _cast(None, key)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ConfigKeyValue_Type.subclass:
            return ConfigKeyValue_Type.subclass(*args_, **kwargs_)
        else:
            return ConfigKeyValue_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_required(self): return self.required
    def set_required(self, required): self.required = required
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConfigKeyValue_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConfigKeyValue_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConfigKeyValue_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConfigKeyValue_Type'):
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required="%s"' % self.gds_format_boolean(self.required, input_name='required'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ConfigKeyValue_Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ConfigKeyValue_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            showIndent(outfile, level)
            outfile.write('required=%s,\n' % (self.required,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            showIndent(outfile, level)
            outfile.write('key="%s",\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            if value in ('true', '1'):
                self.required = True
            elif value in ('false', '0'):
                self.required = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            self.key = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ConfigKeyValue_Type


class Config_Type(ConfigKeyValue_Type):
    """Config element"""
    subclass = None
    superclass = ConfigKeyValue_Type
    def __init__(self, required=None, value=None, key=None):
        self.original_tagname_ = None
        super(Config_Type, self).__init__(required, value, key, )
    def factory(*args_, **kwargs_):
        if Config_Type.subclass:
            return Config_Type.subclass(*args_, **kwargs_)
        else:
            return Config_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Config_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Config_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Config_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Config_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Config_Type'):
        super(Config_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Config_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='Config_Type', fromsubclass_=False, pretty_print=True):
        super(Config_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='Config_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Config_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Config_Type, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Config_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Config_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Config_Type


class ExtraConfig_Type(ConfigKeyValue_Type):
    """ExtraConfig element"""
    subclass = None
    superclass = ConfigKeyValue_Type
    def __init__(self, required=None, value=None, key=None):
        self.original_tagname_ = None
        super(ExtraConfig_Type, self).__init__(required, value, key, )
    def factory(*args_, **kwargs_):
        if ExtraConfig_Type.subclass:
            return ExtraConfig_Type.subclass(*args_, **kwargs_)
        else:
            return ExtraConfig_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ExtraConfig_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExtraConfig_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExtraConfig_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExtraConfig_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExtraConfig_Type'):
        super(ExtraConfig_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExtraConfig_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='ExtraConfig_Type', fromsubclass_=False, pretty_print=True):
        super(ExtraConfig_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ExtraConfig_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ExtraConfig_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ExtraConfig_Type, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExtraConfig_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ExtraConfig_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExtraConfig_Type


class CoresPerSocket_Type(cimUnsignedInt):
    """5.5Type for CoresPerSocket element"""
    subclass = None
    superclass = cimUnsignedInt
    def __init__(self, required=None, valueOf_=None):
        self.original_tagname_ = None
        super(CoresPerSocket_Type, self).__init__(valueOf_, )
        self.required = _cast(bool, required)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CoresPerSocket_Type.subclass:
            return CoresPerSocket_Type.subclass(*args_, **kwargs_)
        else:
            return CoresPerSocket_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_required(self): return self.required
    def set_required(self, required): self.required = required
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(CoresPerSocket_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoresPerSocket_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoresPerSocket_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoresPerSocket_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoresPerSocket_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(CoresPerSocket_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CoresPerSocket_Type')
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required="%s"' % self.gds_format_boolean(self.required, input_name='required'))
    def exportChildren(self, outfile, level, namespace_='', name_='CoresPerSocket_Type', fromsubclass_=False, pretty_print=True):
        super(CoresPerSocket_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='CoresPerSocket_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            showIndent(outfile, level)
            outfile.write('required=%s,\n' % (self.required,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(CoresPerSocket_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CoresPerSocket_Type, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            if value in ('true', '1'):
                self.required = True
            elif value in ('false', '0'):
                self.required = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(CoresPerSocket_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoresPerSocket_Type


class VMWareToolsType(GeneratedsSuper):
    """none The version of VMmware tools installed on this virtual machine."""
    subclass = None
    superclass = None
    def __init__(self, version=None):
        self.original_tagname_ = None
        self.version = _cast(None, version)
    def factory(*args_, **kwargs_):
        if VMWareToolsType.subclass:
            return VMWareToolsType.subclass(*args_, **kwargs_)
        else:
            return VMWareToolsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMWareToolsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMWareToolsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMWareToolsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMWareToolsType'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VMWareToolsType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='VMWareToolsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VMWareToolsType


class EntryType(GeneratedsSuper):
    """always VM BIOS UUID as described in the OVF Virtual System always
    Datastore path of replicated VM's vmx file. always Destination
    storage profile to associate with VM. This must be a valid
    profile for the given datastore path."""
    subclass = None
    superclass = None
    def __init__(self, storageProfile=None, datastorePath=None, biosUuid=None):
        self.original_tagname_ = None
        self.storageProfile = _cast(None, storageProfile)
        self.datastorePath = _cast(None, datastorePath)
        self.biosUuid = _cast(None, biosUuid)
    def factory(*args_, **kwargs_):
        if EntryType.subclass:
            return EntryType.subclass(*args_, **kwargs_)
        else:
            return EntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_storageProfile(self): return self.storageProfile
    def set_storageProfile(self, storageProfile): self.storageProfile = storageProfile
    def get_datastorePath(self): return self.datastorePath
    def set_datastorePath(self, datastorePath): self.datastorePath = datastorePath
    def get_biosUuid(self): return self.biosUuid
    def set_biosUuid(self, biosUuid): self.biosUuid = biosUuid
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntryType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntryType'):
        if self.storageProfile is not None and 'storageProfile' not in already_processed:
            already_processed.add('storageProfile')
            outfile.write(' storageProfile=%s' % (self.gds_format_string(quote_attrib(self.storageProfile).encode(ExternalEncoding), input_name='storageProfile'), ))
        if self.datastorePath is not None and 'datastorePath' not in already_processed:
            already_processed.add('datastorePath')
            outfile.write(' datastorePath=%s' % (self.gds_format_string(quote_attrib(self.datastorePath).encode(ExternalEncoding), input_name='datastorePath'), ))
        if self.biosUuid is not None and 'biosUuid' not in already_processed:
            already_processed.add('biosUuid')
            outfile.write(' biosUuid=%s' % (self.gds_format_string(quote_attrib(self.biosUuid).encode(ExternalEncoding), input_name='biosUuid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntryType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EntryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.storageProfile is not None and 'storageProfile' not in already_processed:
            already_processed.add('storageProfile')
            showIndent(outfile, level)
            outfile.write('storageProfile="%s",\n' % (self.storageProfile,))
        if self.datastorePath is not None and 'datastorePath' not in already_processed:
            already_processed.add('datastorePath')
            showIndent(outfile, level)
            outfile.write('datastorePath="%s",\n' % (self.datastorePath,))
        if self.biosUuid is not None and 'biosUuid' not in already_processed:
            already_processed.add('biosUuid')
            showIndent(outfile, level)
            outfile.write('biosUuid="%s",\n' % (self.biosUuid,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('storageProfile', node)
        if value is not None and 'storageProfile' not in already_processed:
            already_processed.add('storageProfile')
            self.storageProfile = value
        value = find_attr_value_('datastorePath', node)
        if value is not None and 'datastorePath' not in already_processed:
            already_processed.add('datastorePath')
            self.datastorePath = value
        value = find_attr_value_('biosUuid', node)
        if value is not None and 'biosUuid' not in already_processed:
            already_processed.add('biosUuid')
            self.biosUuid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntryType


class EntryType1(GeneratedsSuper):
    """always OVF network name. always Name of organization network."""
    subclass = None
    superclass = None
    def __init__(self, vdcNetwork=None, ovfNetwork=None):
        self.original_tagname_ = None
        self.vdcNetwork = _cast(None, vdcNetwork)
        self.ovfNetwork = _cast(None, ovfNetwork)
    def factory(*args_, **kwargs_):
        if EntryType1.subclass:
            return EntryType1.subclass(*args_, **kwargs_)
        else:
            return EntryType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vdcNetwork(self): return self.vdcNetwork
    def set_vdcNetwork(self, vdcNetwork): self.vdcNetwork = vdcNetwork
    def get_ovfNetwork(self): return self.ovfNetwork
    def set_ovfNetwork(self, ovfNetwork): self.ovfNetwork = ovfNetwork
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntryType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntryType1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntryType1'):
        if self.vdcNetwork is not None and 'vdcNetwork' not in already_processed:
            already_processed.add('vdcNetwork')
            outfile.write(' vdcNetwork=%s' % (self.gds_format_string(quote_attrib(self.vdcNetwork).encode(ExternalEncoding), input_name='vdcNetwork'), ))
        if self.ovfNetwork is not None and 'ovfNetwork' not in already_processed:
            already_processed.add('ovfNetwork')
            outfile.write(' ovfNetwork=%s' % (self.gds_format_string(quote_attrib(self.ovfNetwork).encode(ExternalEncoding), input_name='ovfNetwork'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntryType1', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EntryType1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vdcNetwork is not None and 'vdcNetwork' not in already_processed:
            already_processed.add('vdcNetwork')
            showIndent(outfile, level)
            outfile.write('vdcNetwork="%s",\n' % (self.vdcNetwork,))
        if self.ovfNetwork is not None and 'ovfNetwork' not in already_processed:
            already_processed.add('ovfNetwork')
            showIndent(outfile, level)
            outfile.write('ovfNetwork="%s",\n' % (self.ovfNetwork,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vdcNetwork', node)
        if value is not None and 'vdcNetwork' not in already_processed:
            already_processed.add('vdcNetwork')
            self.vdcNetwork = value
        value = find_attr_value_('ovfNetwork', node)
        if value is not None and 'ovfNetwork' not in already_processed:
            already_processed.add('ovfNetwork')
            self.ovfNetwork = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntryType1


class EntryType2(GeneratedsSuper):
    """always External NAT IP address on source site. always External NAT
    IP address on destination site."""
    subclass = None
    superclass = None
    def __init__(self, destinationNatIp=None, sourceNatIp=None):
        self.original_tagname_ = None
        self.destinationNatIp = _cast(None, destinationNatIp)
        self.sourceNatIp = _cast(None, sourceNatIp)
    def factory(*args_, **kwargs_):
        if EntryType2.subclass:
            return EntryType2.subclass(*args_, **kwargs_)
        else:
            return EntryType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_destinationNatIp(self): return self.destinationNatIp
    def set_destinationNatIp(self, destinationNatIp): self.destinationNatIp = destinationNatIp
    def get_sourceNatIp(self): return self.sourceNatIp
    def set_sourceNatIp(self, sourceNatIp): self.sourceNatIp = sourceNatIp
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntryType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntryType2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntryType2'):
        if self.destinationNatIp is not None and 'destinationNatIp' not in already_processed:
            already_processed.add('destinationNatIp')
            outfile.write(' destinationNatIp=%s' % (self.gds_format_string(quote_attrib(self.destinationNatIp).encode(ExternalEncoding), input_name='destinationNatIp'), ))
        if self.sourceNatIp is not None and 'sourceNatIp' not in already_processed:
            already_processed.add('sourceNatIp')
            outfile.write(' sourceNatIp=%s' % (self.gds_format_string(quote_attrib(self.sourceNatIp).encode(ExternalEncoding), input_name='sourceNatIp'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntryType2', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EntryType2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.destinationNatIp is not None and 'destinationNatIp' not in already_processed:
            already_processed.add('destinationNatIp')
            showIndent(outfile, level)
            outfile.write('destinationNatIp="%s",\n' % (self.destinationNatIp,))
        if self.sourceNatIp is not None and 'sourceNatIp' not in already_processed:
            already_processed.add('sourceNatIp')
            showIndent(outfile, level)
            outfile.write('sourceNatIp="%s",\n' % (self.sourceNatIp,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('destinationNatIp', node)
        if value is not None and 'destinationNatIp' not in already_processed:
            already_processed.add('destinationNatIp')
            self.destinationNatIp = value
        value = find_attr_value_('sourceNatIp', node)
        if value is not None and 'sourceNatIp' not in already_processed:
            already_processed.add('sourceNatIp')
            self.sourceNatIp = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntryType2


class EntryType3(GeneratedsSuper):
    """always Source site NIC IP address. always Destination site NIC IP
    address."""
    subclass = None
    superclass = None
    def __init__(self, sourceNicIp=None, destinationNicIp=None):
        self.original_tagname_ = None
        self.sourceNicIp = _cast(None, sourceNicIp)
        self.destinationNicIp = _cast(None, destinationNicIp)
    def factory(*args_, **kwargs_):
        if EntryType3.subclass:
            return EntryType3.subclass(*args_, **kwargs_)
        else:
            return EntryType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sourceNicIp(self): return self.sourceNicIp
    def set_sourceNicIp(self, sourceNicIp): self.sourceNicIp = sourceNicIp
    def get_destinationNicIp(self): return self.destinationNicIp
    def set_destinationNicIp(self, destinationNicIp): self.destinationNicIp = destinationNicIp
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntryType3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntryType3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntryType3'):
        if self.sourceNicIp is not None and 'sourceNicIp' not in already_processed:
            already_processed.add('sourceNicIp')
            outfile.write(' sourceNicIp=%s' % (self.gds_format_string(quote_attrib(self.sourceNicIp).encode(ExternalEncoding), input_name='sourceNicIp'), ))
        if self.destinationNicIp is not None and 'destinationNicIp' not in already_processed:
            already_processed.add('destinationNicIp')
            outfile.write(' destinationNicIp=%s' % (self.gds_format_string(quote_attrib(self.destinationNicIp).encode(ExternalEncoding), input_name='destinationNicIp'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntryType3', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EntryType3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sourceNicIp is not None and 'sourceNicIp' not in already_processed:
            already_processed.add('sourceNicIp')
            showIndent(outfile, level)
            outfile.write('sourceNicIp="%s",\n' % (self.sourceNicIp,))
        if self.destinationNicIp is not None and 'destinationNicIp' not in already_processed:
            already_processed.add('destinationNicIp')
            showIndent(outfile, level)
            outfile.write('destinationNicIp="%s",\n' % (self.destinationNicIp,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sourceNicIp', node)
        if value is not None and 'sourceNicIp' not in already_processed:
            already_processed.add('sourceNicIp')
            self.sourceNicIp = value
        value = find_attr_value_('destinationNicIp', node)
        if value is not None and 'destinationNicIp' not in already_processed:
            already_processed.add('destinationNicIp')
            self.destinationNicIp = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntryType3


class DiskType4(VCloudExtensibleType):
    """always Identifies a specific disk of the virtual machine. This must
    match the InstanceId in the disk RASD element. 5.5true"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, instanceId=None, Size=None):
        self.original_tagname_ = None
        super(DiskType4, self).__init__(VCloudExtension, )
        self.instanceId = _cast(None, instanceId)
        self.Size = Size
    def factory(*args_, **kwargs_):
        if DiskType4.subclass:
            return DiskType4.subclass(*args_, **kwargs_)
        else:
            return DiskType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Size(self): return self.Size
    def set_Size(self, Size): self.Size = Size
    def get_instanceId(self): return self.instanceId
    def set_instanceId(self, instanceId): self.instanceId = instanceId
    def hasContent_(self):
        if (
            self.Size is not None or
            super(DiskType4, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiskType4', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiskType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DiskType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiskType4'):
        super(DiskType4, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DiskType4')
        if self.instanceId is not None and 'instanceId' not in already_processed:
            already_processed.add('instanceId')
            outfile.write(' instanceId=%s' % (self.gds_format_string(quote_attrib(self.instanceId).encode(ExternalEncoding), input_name='instanceId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DiskType4', fromsubclass_=False, pretty_print=True):
        super(DiskType4, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSize>%s</%sSize>%s' % (namespace_, self.gds_format_integer(self.Size, input_name='Size'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DiskType4'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instanceId is not None and 'instanceId' not in already_processed:
            already_processed.add('instanceId')
            showIndent(outfile, level)
            outfile.write('instanceId="%s",\n' % (self.instanceId,))
        super(DiskType4, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DiskType4, self).exportLiteralChildren(outfile, level, name_)
        if self.Size is not None:
            showIndent(outfile, level)
            outfile.write('Size=%d,\n' % self.Size)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instanceId', node)
        if value is not None and 'instanceId' not in already_processed:
            already_processed.add('instanceId')
            self.instanceId = value
        super(DiskType4, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Size')
            self.Size = ival_
        super(DiskType4, self).buildChildren(child_, node, nodeName_, True)
# end class DiskType4


class ProtocolsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tcp=None, Udp=None, Icmp=None, Any=None, Other=None):
        self.original_tagname_ = None
        self.Tcp = Tcp
        self.Udp = Udp
        self.Icmp = Icmp
        self.Any = Any
        self.Other = Other
    def factory(*args_, **kwargs_):
        if ProtocolsType.subclass:
            return ProtocolsType.subclass(*args_, **kwargs_)
        else:
            return ProtocolsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tcp(self): return self.Tcp
    def set_Tcp(self, Tcp): self.Tcp = Tcp
    def get_Udp(self): return self.Udp
    def set_Udp(self, Udp): self.Udp = Udp
    def get_Icmp(self): return self.Icmp
    def set_Icmp(self, Icmp): self.Icmp = Icmp
    def get_Any(self): return self.Any
    def set_Any(self, Any): self.Any = Any
    def get_Other(self): return self.Other
    def set_Other(self, Other): self.Other = Other
    def hasContent_(self):
        if (
            self.Tcp is not None or
            self.Udp is not None or
            self.Icmp is not None or
            self.Any is not None or
            self.Other is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProtocolsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProtocolsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProtocolsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProtocolsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProtocolsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tcp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTcp>%s</%sTcp>%s' % (namespace_, self.gds_format_boolean(self.Tcp, input_name='Tcp'), namespace_, eol_))
        if self.Udp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUdp>%s</%sUdp>%s' % (namespace_, self.gds_format_boolean(self.Udp, input_name='Udp'), namespace_, eol_))
        if self.Icmp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIcmp>%s</%sIcmp>%s' % (namespace_, self.gds_format_boolean(self.Icmp, input_name='Icmp'), namespace_, eol_))
        if self.Any is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAny>%s</%sAny>%s' % (namespace_, self.gds_format_boolean(self.Any, input_name='Any'), namespace_, eol_))
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_format_string(quote_xml(self.Other).encode(ExternalEncoding), input_name='Other'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ProtocolsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Tcp is not None:
            showIndent(outfile, level)
            outfile.write('Tcp=%s,\n' % self.Tcp)
        if self.Udp is not None:
            showIndent(outfile, level)
            outfile.write('Udp=%s,\n' % self.Udp)
        if self.Icmp is not None:
            showIndent(outfile, level)
            outfile.write('Icmp=%s,\n' % self.Icmp)
        if self.Any is not None:
            showIndent(outfile, level)
            outfile.write('Any=%s,\n' % self.Any)
        if self.Other is not None:
            showIndent(outfile, level)
            outfile.write('Other=%s,\n' % quote_python(self.Other).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tcp':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Tcp')
            self.Tcp = ival_
        elif nodeName_ == 'Udp':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Udp')
            self.Udp = ival_
        elif nodeName_ == 'Icmp':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Icmp')
            self.Icmp = ival_
        elif nodeName_ == 'Any':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Any')
            self.Any = ival_
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
# end class ProtocolsType


class MsgType(GeneratedsSuper):
    """String element valueString element identifier"""
    subclass = None
    superclass = None
    def __init__(self, msgid=None, valueOf_=None):
        self.original_tagname_ = None
        self.msgid = _cast(None, msgid)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if MsgType.subclass:
            return MsgType.subclass(*args_, **kwargs_)
        else:
            return MsgType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_msgid(self): return self.msgid
    def set_msgid(self, msgid): self.msgid = msgid
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MsgType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MsgType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MsgType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MsgType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.msgid is not None and 'msgid' not in already_processed:
            already_processed.add('msgid')
            outfile.write(' msgid=%s' % (self.gds_format_string(quote_attrib(self.msgid).encode(ExternalEncoding), input_name='msgid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MsgType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='MsgType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.msgid is not None and 'msgid' not in already_processed:
            already_processed.add('msgid')
            showIndent(outfile, level)
            outfile.write('msgid="%s",\n' % (self.msgid,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('msgid', node)
        if value is not None and 'msgid' not in already_processed:
            already_processed.add('msgid')
            self.msgid = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MsgType


class IconType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mimeType=None, width=None, fileRef=None, height=None):
        self.original_tagname_ = None
        self.mimeType = _cast(None, mimeType)
        self.width = _cast(int, width)
        self.fileRef = _cast(None, fileRef)
        self.height = _cast(int, height)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if IconType.subclass:
            return IconType.subclass(*args_, **kwargs_)
        else:
            return IconType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mimeType(self): return self.mimeType
    def set_mimeType(self, mimeType): self.mimeType = mimeType
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_fileRef(self): return self.fileRef
    def set_fileRef(self, fileRef): self.fileRef = fileRef
    def get_height(self): return self.height
    def set_height(self, height): self.height = height
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IconType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IconType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IconType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IconType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.mimeType is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            outfile.write(' mimeType=%s' % (self.gds_format_string(quote_attrib(self.mimeType).encode(ExternalEncoding), input_name='mimeType'), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_integer(self.width, input_name='width'))
        if self.fileRef is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            outfile.write(' fileRef=%s' % (self.gds_format_string(quote_attrib(self.fileRef).encode(ExternalEncoding), input_name='fileRef'), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_integer(self.height, input_name='height'))
    def exportChildren(self, outfile, level, namespace_='', name_='IconType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='IconType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mimeType is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            showIndent(outfile, level)
            outfile.write('mimeType="%s",\n' % (self.mimeType,))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            showIndent(outfile, level)
            outfile.write('width=%d,\n' % (self.width,))
        if self.fileRef is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            showIndent(outfile, level)
            outfile.write('fileRef="%s",\n' % (self.fileRef,))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            showIndent(outfile, level)
            outfile.write('height=%d,\n' % (self.height,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mimeType', node)
        if value is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            self.mimeType = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('fileRef', node)
        if value is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            self.fileRef = value
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IconType


class PropertyType(GeneratedsSuper):
    """Property identifierProperty typeA comma-separated set of type
    qualifiersDetermines whether the property value is configurable
    during installationDefault value for propertyDetermines whether
    the property value should be obscured during deployment"""
    subclass = None
    superclass = None
    def __init__(self, userConfigurable=False, value='', key=None, password=False, type_=None, qualifiers=None, Label=None, Description=None, Value=None):
        self.original_tagname_ = None
        self.userConfigurable = _cast(bool, userConfigurable)
        self.value = _cast(None, value)
        self.key = _cast(None, key)
        self.password = _cast(bool, password)
        self.type_ = _cast(None, type_)
        self.qualifiers = _cast(None, qualifiers)
        self.Label = Label
        self.Description = Description
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PropertyType.subclass:
            return PropertyType.subclass(*args_, **kwargs_)
        else:
            return PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value_at(self, index, value): self.Value.insert(index, value)
    def replace_Value_at(self, index, value): self.Value[index] = value
    def get_userConfigurable(self): return self.userConfigurable
    def set_userConfigurable(self, userConfigurable): self.userConfigurable = userConfigurable
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_password(self): return self.password
    def set_password(self, password): self.password = password
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_qualifiers(self): return self.qualifiers
    def set_qualifiers(self, qualifiers): self.qualifiers = qualifiers
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Label is not None or
            self.Description is not None or
            self.Value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.userConfigurable is not None and 'userConfigurable' not in already_processed:
            already_processed.add('userConfigurable')
            outfile.write(' userConfigurable="%s"' % self.gds_format_boolean(self.userConfigurable, input_name='userConfigurable'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
        if self.password is not None and 'password' not in already_processed:
            already_processed.add('password')
            outfile.write(' password="%s"' % self.gds_format_boolean(self.password, input_name='password'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.qualifiers is not None and 'qualifiers' not in already_processed:
            already_processed.add('qualifiers')
            outfile.write(' qualifiers=%s' % (self.gds_format_string(quote_attrib(self.qualifiers).encode(ExternalEncoding), input_name='qualifiers'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Label is not None:
            self.Label.export(outfile, level, namespace_, name_='Label', pretty_print=pretty_print)
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for Value_ in self.Value:
            Value_.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.userConfigurable is not None and 'userConfigurable' not in already_processed:
            already_processed.add('userConfigurable')
            showIndent(outfile, level)
            outfile.write('userConfigurable=%s,\n' % (self.userConfigurable,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            showIndent(outfile, level)
            outfile.write('key="%s",\n' % (self.key,))
        if self.password is not None and 'password' not in already_processed:
            already_processed.add('password')
            showIndent(outfile, level)
            outfile.write('password=%s,\n' % (self.password,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.qualifiers is not None and 'qualifiers' not in already_processed:
            already_processed.add('qualifiers')
            showIndent(outfile, level)
            outfile.write('qualifiers="%s",\n' % (self.qualifiers,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Label is not None:
            showIndent(outfile, level)
            outfile.write('Label=model_.Msg_Type(\n')
            self.Label.exportLiteral(outfile, level, name_='Label')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Msg_Type(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('model_.PropertyConfigurationValue_Type(\n')
            Value_.exportLiteral(outfile, level, name_='PropertyConfigurationValue_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('userConfigurable', node)
        if value is not None and 'userConfigurable' not in already_processed:
            already_processed.add('userConfigurable')
            if value in ('true', '1'):
                self.userConfigurable = True
            elif value in ('false', '0'):
                self.userConfigurable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            self.key = value
        value = find_attr_value_('password', node)
        if value is not None and 'password' not in already_processed:
            already_processed.add('password')
            if value in ('true', '1'):
                self.password = True
            elif value in ('false', '0'):
                self.password = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('qualifiers', node)
        if value is not None and 'qualifiers' not in already_processed:
            already_processed.add('qualifiers')
            self.qualifiers = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Label':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Label = obj_
            obj_.original_tagname_ = 'Label'
        elif nodeName_ == 'Description':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Value':
            obj_ = PropertyConfigurationValue_Type.factory()
            obj_.build(child_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
# end class PropertyType


class NetworkType5(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, Description=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.Description = Description
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NetworkType5.subclass:
            return NetworkType5.subclass(*args_, **kwargs_)
        else:
            return NetworkType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkType5', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkType5'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkType5'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Msg_Type(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
# end class NetworkType5


class ItemType(GeneratedsSuper):
    """Unique identifier of the content (within a VirtualSystemCollection)
    Startup order. Entities are started up starting with lower-
    numbers first, starting from 0. Items with same order identifier
    may be started up concurrently or in any order. The order is
    reversed for shutdown.Delay in seconds to wait for power on to
    completeResumes power-on sequence if guest software reports
    okDelay in seconds to wait for power off to completeStart action
    to use, valid values are: 'powerOn', 'none' Stop action to use,
    valid values are: ''powerOff' , 'guestShutdown', 'none'"""
    subclass = None
    superclass = None
    def __init__(self, stopDelay=0, order=None, startAction='powerOn', startDelay=0, waitingForGuest=False, stopAction='powerOff', id=None):
        self.original_tagname_ = None
        self.stopDelay = _cast(int, stopDelay)
        self.order = _cast(int, order)
        self.startAction = _cast(None, startAction)
        self.startDelay = _cast(int, startDelay)
        self.waitingForGuest = _cast(bool, waitingForGuest)
        self.stopAction = _cast(None, stopAction)
        self.id = _cast(None, id)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ItemType.subclass:
            return ItemType.subclass(*args_, **kwargs_)
        else:
            return ItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stopDelay(self): return self.stopDelay
    def set_stopDelay(self, stopDelay): self.stopDelay = stopDelay
    def get_order(self): return self.order
    def set_order(self, order): self.order = order
    def get_startAction(self): return self.startAction
    def set_startAction(self, startAction): self.startAction = startAction
    def get_startDelay(self): return self.startDelay
    def set_startDelay(self, startDelay): self.startDelay = startDelay
    def get_waitingForGuest(self): return self.waitingForGuest
    def set_waitingForGuest(self, waitingForGuest): self.waitingForGuest = waitingForGuest
    def get_stopAction(self): return self.stopAction
    def set_stopAction(self, stopAction): self.stopAction = stopAction
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ItemType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ItemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ItemType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.stopDelay is not None and 'stopDelay' not in already_processed:
            already_processed.add('stopDelay')
            outfile.write(' stopDelay="%s"' % self.gds_format_integer(self.stopDelay, input_name='stopDelay'))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_integer(self.order, input_name='order'))
        if self.startAction is not None and 'startAction' not in already_processed:
            already_processed.add('startAction')
            outfile.write(' startAction=%s' % (self.gds_format_string(quote_attrib(self.startAction).encode(ExternalEncoding), input_name='startAction'), ))
        if self.startDelay is not None and 'startDelay' not in already_processed:
            already_processed.add('startDelay')
            outfile.write(' startDelay="%s"' % self.gds_format_integer(self.startDelay, input_name='startDelay'))
        if self.waitingForGuest is not None and 'waitingForGuest' not in already_processed:
            already_processed.add('waitingForGuest')
            outfile.write(' waitingForGuest="%s"' % self.gds_format_boolean(self.waitingForGuest, input_name='waitingForGuest'))
        if self.stopAction is not None and 'stopAction' not in already_processed:
            already_processed.add('stopAction')
            outfile.write(' stopAction=%s' % (self.gds_format_string(quote_attrib(self.stopAction).encode(ExternalEncoding), input_name='stopAction'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ItemType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ItemType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.stopDelay is not None and 'stopDelay' not in already_processed:
            already_processed.add('stopDelay')
            showIndent(outfile, level)
            outfile.write('stopDelay=%d,\n' % (self.stopDelay,))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            showIndent(outfile, level)
            outfile.write('order=%d,\n' % (self.order,))
        if self.startAction is not None and 'startAction' not in already_processed:
            already_processed.add('startAction')
            showIndent(outfile, level)
            outfile.write('startAction="%s",\n' % (self.startAction,))
        if self.startDelay is not None and 'startDelay' not in already_processed:
            already_processed.add('startDelay')
            showIndent(outfile, level)
            outfile.write('startDelay=%d,\n' % (self.startDelay,))
        if self.waitingForGuest is not None and 'waitingForGuest' not in already_processed:
            already_processed.add('waitingForGuest')
            showIndent(outfile, level)
            outfile.write('waitingForGuest=%s,\n' % (self.waitingForGuest,))
        if self.stopAction is not None and 'stopAction' not in already_processed:
            already_processed.add('stopAction')
            showIndent(outfile, level)
            outfile.write('stopAction="%s",\n' % (self.stopAction,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('stopDelay', node)
        if value is not None and 'stopDelay' not in already_processed:
            already_processed.add('stopDelay')
            try:
                self.stopDelay = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            try:
                self.order = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('startAction', node)
        if value is not None and 'startAction' not in already_processed:
            already_processed.add('startAction')
            self.startAction = value
        value = find_attr_value_('startDelay', node)
        if value is not None and 'startDelay' not in already_processed:
            already_processed.add('startDelay')
            try:
                self.startDelay = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('waitingForGuest', node)
        if value is not None and 'waitingForGuest' not in already_processed:
            already_processed.add('waitingForGuest')
            if value in ('true', '1'):
                self.waitingForGuest = True
            elif value in ('false', '0'):
                self.waitingForGuest = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('stopAction', node)
        if value is not None and 'stopAction' not in already_processed:
            already_processed.add('stopAction')
            self.stopAction = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ItemType


class ConfigurationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, default=False, id=None, Label=None, Description=None):
        self.original_tagname_ = None
        self.default = _cast(bool, default)
        self.id = _cast(None, id)
        self.Label = Label
        self.Description = Description
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ConfigurationType.subclass:
            return ConfigurationType.subclass(*args_, **kwargs_)
        else:
            return ConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Label is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConfigurationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConfigurationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConfigurationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConfigurationType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_boolean(self.default, input_name='default'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ConfigurationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Label is not None:
            self.Label.export(outfile, level, namespace_, name_='Label', pretty_print=pretty_print)
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ConfigurationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            showIndent(outfile, level)
            outfile.write('default=%s,\n' % (self.default,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Label is not None:
            showIndent(outfile, level)
            outfile.write('Label=model_.Msg_Type(\n')
            self.Label.exportLiteral(outfile, level, name_='Label')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Msg_Type(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            if value in ('true', '1'):
                self.default = True
            elif value in ('false', '0'):
                self.default = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Label':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Label = obj_
            obj_.original_tagname_ = 'Label'
        elif nodeName_ == 'Description':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
# end class ConfigurationType


class PropertyType6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, key=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.key = _cast(None, key)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PropertyType6.subclass:
            return PropertyType6.subclass(*args_, **kwargs_)
        else:
            return PropertyType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertyType6', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyType6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PropertyType6', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyType6'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyType6', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PropertyType6'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            showIndent(outfile, level)
            outfile.write('key="%s",\n' % (self.key,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            self.key = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PropertyType6


class LevelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vendor='', level=None, eax=None, edx=None, ebx=None, ecx=None):
        self.original_tagname_ = None
        self.vendor = _cast(None, vendor)
        self.level = _cast(None, level)
        self.eax = _cast(None, eax)
        self.edx = _cast(None, edx)
        self.ebx = _cast(None, ebx)
        self.ecx = _cast(None, ecx)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LevelType.subclass:
            return LevelType.subclass(*args_, **kwargs_)
        else:
            return LevelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def get_eax(self): return self.eax
    def set_eax(self, eax): self.eax = eax
    def get_edx(self): return self.edx
    def set_edx(self, edx): self.edx = edx
    def get_ebx(self): return self.ebx
    def set_ebx(self, ebx): self.ebx = ebx
    def get_ecx(self): return self.ecx
    def set_ecx(self, ecx): self.ecx = ecx
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LevelType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LevelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LevelType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LevelType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            outfile.write(' vendor=%s' % (self.gds_format_string(quote_attrib(self.vendor).encode(ExternalEncoding), input_name='vendor'), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
        if self.eax is not None and 'eax' not in already_processed:
            already_processed.add('eax')
            outfile.write(' eax=%s' % (self.gds_format_string(quote_attrib(self.eax).encode(ExternalEncoding), input_name='eax'), ))
        if self.edx is not None and 'edx' not in already_processed:
            already_processed.add('edx')
            outfile.write(' edx=%s' % (self.gds_format_string(quote_attrib(self.edx).encode(ExternalEncoding), input_name='edx'), ))
        if self.ebx is not None and 'ebx' not in already_processed:
            already_processed.add('ebx')
            outfile.write(' ebx=%s' % (self.gds_format_string(quote_attrib(self.ebx).encode(ExternalEncoding), input_name='ebx'), ))
        if self.ecx is not None and 'ecx' not in already_processed:
            already_processed.add('ecx')
            outfile.write(' ecx=%s' % (self.gds_format_string(quote_attrib(self.ecx).encode(ExternalEncoding), input_name='ecx'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LevelType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LevelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            showIndent(outfile, level)
            outfile.write('vendor="%s",\n' % (self.vendor,))
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            showIndent(outfile, level)
            outfile.write('level=%s,\n' % (self.level,))
        if self.eax is not None and 'eax' not in already_processed:
            already_processed.add('eax')
            showIndent(outfile, level)
            outfile.write('eax="%s",\n' % (self.eax,))
        if self.edx is not None and 'edx' not in already_processed:
            already_processed.add('edx')
            showIndent(outfile, level)
            outfile.write('edx="%s",\n' % (self.edx,))
        if self.ebx is not None and 'ebx' not in already_processed:
            already_processed.add('ebx')
            showIndent(outfile, level)
            outfile.write('ebx="%s",\n' % (self.ebx,))
        if self.ecx is not None and 'ecx' not in already_processed:
            already_processed.add('ecx')
            showIndent(outfile, level)
            outfile.write('ecx="%s",\n' % (self.ecx,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vendor', node)
        if value is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            self.vendor = value
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = value
        value = find_attr_value_('eax', node)
        if value is not None and 'eax' not in already_processed:
            already_processed.add('eax')
            self.eax = value
        value = find_attr_value_('edx', node)
        if value is not None and 'edx' not in already_processed:
            already_processed.add('edx')
            self.edx = value
        value = find_attr_value_('ebx', node)
        if value is not None and 'ebx' not in already_processed:
            already_processed.add('ebx')
            self.ebx = value
        value = find_attr_value_('ecx', node)
        if value is not None and 'ecx' not in already_processed:
            already_processed.add('ecx')
            self.ecx = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LevelType


class RASD_Type(CIM_ResourceAllocationSettingData_Type):
    """Wrapper for CIM_ResourceAllocationSettingData_TypeDetermines whether
    import should fail if entry is not understoodConfiguration from
    DeploymentOptionSection this entry is valid forStates that this
    entry is a range marker"""
    subclass = None
    superclass = CIM_ResourceAllocationSettingData_Type
    def __init__(self, Address=None, AddressOnParent=None, AllocationUnits=None, AutomaticAllocation=None, AutomaticDeallocation=None, Caption=None, Connection=None, ConsumerVisibility=None, Description=None, ElementName=None, HostResource=None, InstanceID=None, Limit=None, MappingBehavior=None, OtherResourceType=None, Parent=None, PoolID=None, Reservation=None, ResourceSubType=None, ResourceType=None, VirtualQuantity=None, VirtualQuantityUnits=None, Weight=None, anytypeobjs_=None, required=True, bound=None, configuration=None):
        self.original_tagname_ = None
        super(RASD_Type, self).__init__(Address, AddressOnParent, AllocationUnits, AutomaticAllocation, AutomaticDeallocation, Caption, Connection, ConsumerVisibility, Description, ElementName, HostResource, InstanceID, Limit, MappingBehavior, OtherResourceType, Parent, PoolID, Reservation, ResourceSubType, ResourceType, VirtualQuantity, VirtualQuantityUnits, Weight, anytypeobjs_, )
        self.required = _cast(bool, required)
        self.bound = _cast(None, bound)
        self.configuration = _cast(None, configuration)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if RASD_Type.subclass:
            return RASD_Type.subclass(*args_, **kwargs_)
        else:
            return RASD_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_required(self): return self.required
    def set_required(self, required): self.required = required
    def get_bound(self): return self.bound
    def set_bound(self, bound): self.bound = bound
    def get_configuration(self): return self.configuration
    def set_configuration(self, configuration): self.configuration = configuration
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            super(RASD_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RASD_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RASD_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RASD_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RASD_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(RASD_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RASD_Type')
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required="%s"' % self.gds_format_boolean(self.required, input_name='required'))
        if self.bound is not None and 'bound' not in already_processed:
            already_processed.add('bound')
            outfile.write(' bound=%s' % (self.gds_format_string(quote_attrib(self.bound).encode(ExternalEncoding), input_name='bound'), ))
        if self.configuration is not None and 'configuration' not in already_processed:
            already_processed.add('configuration')
            outfile.write(' configuration=%s' % (self.gds_format_string(quote_attrib(self.configuration).encode(ExternalEncoding), input_name='configuration'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RASD_Type', fromsubclass_=False, pretty_print=True):
        super(RASD_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RASD_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            showIndent(outfile, level)
            outfile.write('required=%s,\n' % (self.required,))
        if self.bound is not None and 'bound' not in already_processed:
            already_processed.add('bound')
            showIndent(outfile, level)
            outfile.write('bound="%s",\n' % (self.bound,))
        if self.configuration is not None and 'configuration' not in already_processed:
            already_processed.add('configuration')
            showIndent(outfile, level)
            outfile.write('configuration="%s",\n' % (self.configuration,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(RASD_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RASD_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            if value in ('true', '1'):
                self.required = True
            elif value in ('false', '0'):
                self.required = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('bound', node)
        if value is not None and 'bound' not in already_processed:
            already_processed.add('bound')
            self.bound = value
        value = find_attr_value_('configuration', node)
        if value is not None and 'configuration' not in already_processed:
            already_processed.add('configuration')
            self.configuration = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(RASD_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RASD_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RASD_Type


class VSSD_Type(CIM_VirtualSystemSettingData_Type):
    """Wrapper for CIM_VirtualSystemSettingData_Type"""
    subclass = None
    superclass = CIM_VirtualSystemSettingData_Type
    def __init__(self, AutomaticRecoveryAction=None, AutomaticShutdownAction=None, AutomaticStartupAction=None, AutomaticStartupActionDelay=None, AutomaticStartupActionSequenceNumber=None, Caption=None, ConfigurationDataRoot=None, ConfigurationFile=None, ConfigurationID=None, CreationTime=None, Description=None, ElementName=None, InstanceID=None, LogDataRoot=None, Notes=None, RecoveryFile=None, SnapshotDataRoot=None, SuspendDataRoot=None, SwapFileDataRoot=None, VirtualSystemIdentifier=None, VirtualSystemType=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(VSSD_Type, self).__init__(AutomaticRecoveryAction, AutomaticShutdownAction, AutomaticStartupAction, AutomaticStartupActionDelay, AutomaticStartupActionSequenceNumber, Caption, ConfigurationDataRoot, ConfigurationFile, ConfigurationID, CreationTime, Description, ElementName, InstanceID, LogDataRoot, Notes, RecoveryFile, SnapshotDataRoot, SuspendDataRoot, SwapFileDataRoot, VirtualSystemIdentifier, VirtualSystemType, anytypeobjs_, )
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if VSSD_Type.subclass:
            return VSSD_Type.subclass(*args_, **kwargs_)
        else:
            return VSSD_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            super(VSSD_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VSSD_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VSSD_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VSSD_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VSSD_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(VSSD_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VSSD_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='VSSD_Type', fromsubclass_=False, pretty_print=True):
        super(VSSD_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VSSD_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(VSSD_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VSSD_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(VSSD_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VSSD_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VSSD_Type


class DefaultStorageProfileSection_Type(Section_Type):
    """5.1 Name of the storage profile that will be specified for this
    virtual machine. The named storage profile must exist in the
    organization vDC that contains the virtual machine. If not
    specified, the default storage profile for the vDC is used."""
    subclass = None
    superclass = Section_Type
    def __init__(self, StorageProfile=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(DefaultStorageProfileSection_Type, self).__init__()
        self.StorageProfile = StorageProfile
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if DefaultStorageProfileSection_Type.subclass:
            return DefaultStorageProfileSection_Type.subclass(*args_, **kwargs_)
        else:
            return DefaultStorageProfileSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StorageProfile(self): return self.StorageProfile
    def set_StorageProfile(self, StorageProfile): self.StorageProfile = StorageProfile
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.StorageProfile is not None or
            self.anytypeobjs_ or
            super(DefaultStorageProfileSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DefaultStorageProfileSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefaultStorageProfileSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DefaultStorageProfileSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DefaultStorageProfileSection_Type'):
        super(DefaultStorageProfileSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DefaultStorageProfileSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DefaultStorageProfileSection_Type', fromsubclass_=False, pretty_print=True):
        super(DefaultStorageProfileSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StorageProfile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStorageProfile>%s</%sStorageProfile>%s' % (namespace_, self.gds_format_string(quote_xml(self.StorageProfile).encode(ExternalEncoding), input_name='StorageProfile'), namespace_, eol_))
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DefaultStorageProfileSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DefaultStorageProfileSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DefaultStorageProfileSection_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.StorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('StorageProfile=%s,\n' % quote_python(self.StorageProfile).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DefaultStorageProfileSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StorageProfile':
            StorageProfile_ = child_.text
            StorageProfile_ = self.gds_validate_string(StorageProfile_, node, 'StorageProfile')
            self.StorageProfile = StorageProfile_
        else:
            obj_ = self.gds_build_any(child_, 'DefaultStorageProfileSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(DefaultStorageProfileSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class DefaultStorageProfileSection_Type


class SnapshotSectionType(Section_Type):
    """5.1 Represents information about vApp and virtual machine snapshots.
    5.1none A reference to the section in URL format. false5.1none
    The MIME type of the section. false"""
    subclass = None
    superclass = Section_Type
    def __init__(self, href=None, type_=None, Link=None, Snapshot=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(SnapshotSectionType, self).__init__()
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
        self.Snapshot = Snapshot
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if SnapshotSectionType.subclass:
            return SnapshotSectionType.subclass(*args_, **kwargs_)
        else:
            return SnapshotSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def add_Link(self, value): self.Link.append(value)
    def insert_Link_at(self, index, value): self.Link.insert(index, value)
    def replace_Link_at(self, index, value): self.Link[index] = value
    def get_Snapshot(self): return self.Snapshot
    def set_Snapshot(self, Snapshot): self.Snapshot = Snapshot
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.Link or
            self.Snapshot is not None or
            self.anytypeobjs_ or
            super(SnapshotSectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SnapshotSectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SnapshotSectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SnapshotSectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SnapshotSectionType'):
        super(SnapshotSectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SnapshotSectionType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SnapshotSectionType', fromsubclass_=False, pretty_print=True):
        super(SnapshotSectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
        if self.Snapshot is not None:
            self.Snapshot.export(outfile, level, namespace_, name_='Snapshot', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SnapshotSectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(SnapshotSectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SnapshotSectionType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            Link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Snapshot is not None:
            showIndent(outfile, level)
            outfile.write('Snapshot=model_.SnapshotType(\n')
            self.Snapshot.exportLiteral(outfile, level, name_='Snapshot')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(SnapshotSectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.Link.append(obj_)
            obj_.original_tagname_ = 'Link'
        elif nodeName_ == 'Snapshot':
            obj_ = SnapshotType.factory()
            obj_.build(child_)
            self.Snapshot = obj_
            obj_.original_tagname_ = 'Snapshot'
        else:
            obj_ = self.gds_build_any(child_, 'SnapshotSectionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(SnapshotSectionType, self).buildChildren(child_, node, nodeName_, True)
# end class SnapshotSectionType


class GuestCustomizationSectionType(Section_Type):
    """1.0 Represents a guest customization settings. none A reference to
    the section in URL format. falsenone The MIME type of the
    section. false"""
    subclass = None
    superclass = Section_Type
    def __init__(self, href=None, type_=None, Enabled=None, ChangeSid=None, VirtualMachineId=None, JoinDomainEnabled=None, UseOrgSettings=None, DomainName=None, DomainUserName=None, DomainUserPassword=None, MachineObjectOU=None, AdminPasswordEnabled=None, AdminPasswordAuto=None, AdminPassword=None, AdminAutoLogonEnabled=None, AdminAutoLogonCount=None, ResetPasswordRequired=None, CustomizationScript=None, ComputerName=None, Link=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(GuestCustomizationSectionType, self).__init__()
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        self.Enabled = Enabled
        self.ChangeSid = ChangeSid
        self.VirtualMachineId = VirtualMachineId
        self.JoinDomainEnabled = JoinDomainEnabled
        self.UseOrgSettings = UseOrgSettings
        self.DomainName = DomainName
        self.DomainUserName = DomainUserName
        self.DomainUserPassword = DomainUserPassword
        self.MachineObjectOU = MachineObjectOU
        self.AdminPasswordEnabled = AdminPasswordEnabled
        self.AdminPasswordAuto = AdminPasswordAuto
        self.AdminPassword = AdminPassword
        self.AdminAutoLogonEnabled = AdminAutoLogonEnabled
        self.AdminAutoLogonCount = AdminAutoLogonCount
        self.ResetPasswordRequired = ResetPasswordRequired
        self.CustomizationScript = CustomizationScript
        self.ComputerName = ComputerName
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if GuestCustomizationSectionType.subclass:
            return GuestCustomizationSectionType.subclass(*args_, **kwargs_)
        else:
            return GuestCustomizationSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Enabled(self): return self.Enabled
    def set_Enabled(self, Enabled): self.Enabled = Enabled
    def get_ChangeSid(self): return self.ChangeSid
    def set_ChangeSid(self, ChangeSid): self.ChangeSid = ChangeSid
    def get_VirtualMachineId(self): return self.VirtualMachineId
    def set_VirtualMachineId(self, VirtualMachineId): self.VirtualMachineId = VirtualMachineId
    def get_JoinDomainEnabled(self): return self.JoinDomainEnabled
    def set_JoinDomainEnabled(self, JoinDomainEnabled): self.JoinDomainEnabled = JoinDomainEnabled
    def get_UseOrgSettings(self): return self.UseOrgSettings
    def set_UseOrgSettings(self, UseOrgSettings): self.UseOrgSettings = UseOrgSettings
    def get_DomainName(self): return self.DomainName
    def set_DomainName(self, DomainName): self.DomainName = DomainName
    def get_DomainUserName(self): return self.DomainUserName
    def set_DomainUserName(self, DomainUserName): self.DomainUserName = DomainUserName
    def get_DomainUserPassword(self): return self.DomainUserPassword
    def set_DomainUserPassword(self, DomainUserPassword): self.DomainUserPassword = DomainUserPassword
    def get_MachineObjectOU(self): return self.MachineObjectOU
    def set_MachineObjectOU(self, MachineObjectOU): self.MachineObjectOU = MachineObjectOU
    def get_AdminPasswordEnabled(self): return self.AdminPasswordEnabled
    def set_AdminPasswordEnabled(self, AdminPasswordEnabled): self.AdminPasswordEnabled = AdminPasswordEnabled
    def get_AdminPasswordAuto(self): return self.AdminPasswordAuto
    def set_AdminPasswordAuto(self, AdminPasswordAuto): self.AdminPasswordAuto = AdminPasswordAuto
    def get_AdminPassword(self): return self.AdminPassword
    def set_AdminPassword(self, AdminPassword): self.AdminPassword = AdminPassword
    def get_AdminAutoLogonEnabled(self): return self.AdminAutoLogonEnabled
    def set_AdminAutoLogonEnabled(self, AdminAutoLogonEnabled): self.AdminAutoLogonEnabled = AdminAutoLogonEnabled
    def get_AdminAutoLogonCount(self): return self.AdminAutoLogonCount
    def set_AdminAutoLogonCount(self, AdminAutoLogonCount): self.AdminAutoLogonCount = AdminAutoLogonCount
    def get_ResetPasswordRequired(self): return self.ResetPasswordRequired
    def set_ResetPasswordRequired(self, ResetPasswordRequired): self.ResetPasswordRequired = ResetPasswordRequired
    def get_CustomizationScript(self): return self.CustomizationScript
    def set_CustomizationScript(self, CustomizationScript): self.CustomizationScript = CustomizationScript
    def get_ComputerName(self): return self.ComputerName
    def set_ComputerName(self, ComputerName): self.ComputerName = ComputerName
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def add_Link(self, value): self.Link.append(value)
    def insert_Link_at(self, index, value): self.Link.insert(index, value)
    def replace_Link_at(self, index, value): self.Link[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.Enabled is not None or
            self.ChangeSid is not None or
            self.VirtualMachineId is not None or
            self.JoinDomainEnabled is not None or
            self.UseOrgSettings is not None or
            self.DomainName is not None or
            self.DomainUserName is not None or
            self.DomainUserPassword is not None or
            self.MachineObjectOU is not None or
            self.AdminPasswordEnabled is not None or
            self.AdminPasswordAuto is not None or
            self.AdminPassword is not None or
            self.AdminAutoLogonEnabled is not None or
            self.AdminAutoLogonCount is not None or
            self.ResetPasswordRequired is not None or
            self.CustomizationScript is not None or
            self.ComputerName is not None or
            self.Link or
            self.anytypeobjs_ or
            super(GuestCustomizationSectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GuestCustomizationSectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GuestCustomizationSectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GuestCustomizationSectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GuestCustomizationSectionType'):
        super(GuestCustomizationSectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GuestCustomizationSectionType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GuestCustomizationSectionType', fromsubclass_=False, pretty_print=True):
        super(GuestCustomizationSectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnabled>%s</%sEnabled>%s' % (namespace_, self.gds_format_boolean(self.Enabled, input_name='Enabled'), namespace_, eol_))
        if self.ChangeSid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChangeSid>%s</%sChangeSid>%s' % (namespace_, self.gds_format_boolean(self.ChangeSid, input_name='ChangeSid'), namespace_, eol_))
        if self.VirtualMachineId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVirtualMachineId>%s</%sVirtualMachineId>%s' % (namespace_, self.gds_format_string(quote_xml(self.VirtualMachineId).encode(ExternalEncoding), input_name='VirtualMachineId'), namespace_, eol_))
        if self.JoinDomainEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJoinDomainEnabled>%s</%sJoinDomainEnabled>%s' % (namespace_, self.gds_format_boolean(self.JoinDomainEnabled, input_name='JoinDomainEnabled'), namespace_, eol_))
        if self.UseOrgSettings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUseOrgSettings>%s</%sUseOrgSettings>%s' % (namespace_, self.gds_format_boolean(self.UseOrgSettings, input_name='UseOrgSettings'), namespace_, eol_))
        if self.DomainName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDomainName>%s</%sDomainName>%s' % (namespace_, self.gds_format_string(quote_xml(self.DomainName).encode(ExternalEncoding), input_name='DomainName'), namespace_, eol_))
        if self.DomainUserName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDomainUserName>%s</%sDomainUserName>%s' % (namespace_, self.gds_format_string(quote_xml(self.DomainUserName).encode(ExternalEncoding), input_name='DomainUserName'), namespace_, eol_))
        if self.DomainUserPassword is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDomainUserPassword>%s</%sDomainUserPassword>%s' % (namespace_, self.gds_format_string(quote_xml(self.DomainUserPassword).encode(ExternalEncoding), input_name='DomainUserPassword'), namespace_, eol_))
        if self.MachineObjectOU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMachineObjectOU>%s</%sMachineObjectOU>%s' % (namespace_, self.gds_format_string(quote_xml(self.MachineObjectOU).encode(ExternalEncoding), input_name='MachineObjectOU'), namespace_, eol_))
        if self.AdminPasswordEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdminPasswordEnabled>%s</%sAdminPasswordEnabled>%s' % (namespace_, self.gds_format_boolean(self.AdminPasswordEnabled, input_name='AdminPasswordEnabled'), namespace_, eol_))
        if self.AdminPasswordAuto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdminPasswordAuto>%s</%sAdminPasswordAuto>%s' % (namespace_, self.gds_format_boolean(self.AdminPasswordAuto, input_name='AdminPasswordAuto'), namespace_, eol_))
        if self.AdminPassword is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdminPassword>%s</%sAdminPassword>%s' % (namespace_, self.gds_format_string(quote_xml(self.AdminPassword).encode(ExternalEncoding), input_name='AdminPassword'), namespace_, eol_))
        if self.AdminAutoLogonEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdminAutoLogonEnabled>%s</%sAdminAutoLogonEnabled>%s' % (namespace_, self.gds_format_boolean(self.AdminAutoLogonEnabled, input_name='AdminAutoLogonEnabled'), namespace_, eol_))
        if self.AdminAutoLogonCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdminAutoLogonCount>%s</%sAdminAutoLogonCount>%s' % (namespace_, self.gds_format_integer(self.AdminAutoLogonCount, input_name='AdminAutoLogonCount'), namespace_, eol_))
        if self.ResetPasswordRequired is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResetPasswordRequired>%s</%sResetPasswordRequired>%s' % (namespace_, self.gds_format_boolean(self.ResetPasswordRequired, input_name='ResetPasswordRequired'), namespace_, eol_))
        if self.CustomizationScript is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustomizationScript>%s</%sCustomizationScript>%s' % (namespace_, self.gds_format_string(quote_xml(self.CustomizationScript).encode(ExternalEncoding), input_name='CustomizationScript'), namespace_, eol_))
        if self.ComputerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComputerName>%s</%sComputerName>%s' % (namespace_, self.gds_format_string(quote_xml(self.ComputerName).encode(ExternalEncoding), input_name='ComputerName'), namespace_, eol_))
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GuestCustomizationSectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(GuestCustomizationSectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GuestCustomizationSectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Enabled is not None:
            showIndent(outfile, level)
            outfile.write('Enabled=%s,\n' % self.Enabled)
        if self.ChangeSid is not None:
            showIndent(outfile, level)
            outfile.write('ChangeSid=%s,\n' % self.ChangeSid)
        if self.VirtualMachineId is not None:
            showIndent(outfile, level)
            outfile.write('VirtualMachineId=%s,\n' % quote_python(self.VirtualMachineId).encode(ExternalEncoding))
        if self.JoinDomainEnabled is not None:
            showIndent(outfile, level)
            outfile.write('JoinDomainEnabled=%s,\n' % self.JoinDomainEnabled)
        if self.UseOrgSettings is not None:
            showIndent(outfile, level)
            outfile.write('UseOrgSettings=%s,\n' % self.UseOrgSettings)
        if self.DomainName is not None:
            showIndent(outfile, level)
            outfile.write('DomainName=%s,\n' % quote_python(self.DomainName).encode(ExternalEncoding))
        if self.DomainUserName is not None:
            showIndent(outfile, level)
            outfile.write('DomainUserName=%s,\n' % quote_python(self.DomainUserName).encode(ExternalEncoding))
        if self.DomainUserPassword is not None:
            showIndent(outfile, level)
            outfile.write('DomainUserPassword=%s,\n' % quote_python(self.DomainUserPassword).encode(ExternalEncoding))
        if self.MachineObjectOU is not None:
            showIndent(outfile, level)
            outfile.write('MachineObjectOU=%s,\n' % quote_python(self.MachineObjectOU).encode(ExternalEncoding))
        if self.AdminPasswordEnabled is not None:
            showIndent(outfile, level)
            outfile.write('AdminPasswordEnabled=%s,\n' % self.AdminPasswordEnabled)
        if self.AdminPasswordAuto is not None:
            showIndent(outfile, level)
            outfile.write('AdminPasswordAuto=%s,\n' % self.AdminPasswordAuto)
        if self.AdminPassword is not None:
            showIndent(outfile, level)
            outfile.write('AdminPassword=%s,\n' % quote_python(self.AdminPassword).encode(ExternalEncoding))
        if self.AdminAutoLogonEnabled is not None:
            showIndent(outfile, level)
            outfile.write('AdminAutoLogonEnabled=%s,\n' % self.AdminAutoLogonEnabled)
        if self.AdminAutoLogonCount is not None:
            showIndent(outfile, level)
            outfile.write('AdminAutoLogonCount=%d,\n' % self.AdminAutoLogonCount)
        if self.ResetPasswordRequired is not None:
            showIndent(outfile, level)
            outfile.write('ResetPasswordRequired=%s,\n' % self.ResetPasswordRequired)
        if self.CustomizationScript is not None:
            showIndent(outfile, level)
            outfile.write('CustomizationScript=%s,\n' % quote_python(self.CustomizationScript).encode(ExternalEncoding))
        if self.ComputerName is not None:
            showIndent(outfile, level)
            outfile.write('ComputerName=%s,\n' % quote_python(self.ComputerName).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            Link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(GuestCustomizationSectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Enabled')
            self.Enabled = ival_
        elif nodeName_ == 'ChangeSid':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ChangeSid')
            self.ChangeSid = ival_
        elif nodeName_ == 'VirtualMachineId':
            VirtualMachineId_ = child_.text
            VirtualMachineId_ = self.gds_validate_string(VirtualMachineId_, node, 'VirtualMachineId')
            self.VirtualMachineId = VirtualMachineId_
        elif nodeName_ == 'JoinDomainEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'JoinDomainEnabled')
            self.JoinDomainEnabled = ival_
        elif nodeName_ == 'UseOrgSettings':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'UseOrgSettings')
            self.UseOrgSettings = ival_
        elif nodeName_ == 'DomainName':
            DomainName_ = child_.text
            DomainName_ = self.gds_validate_string(DomainName_, node, 'DomainName')
            self.DomainName = DomainName_
        elif nodeName_ == 'DomainUserName':
            DomainUserName_ = child_.text
            DomainUserName_ = self.gds_validate_string(DomainUserName_, node, 'DomainUserName')
            self.DomainUserName = DomainUserName_
        elif nodeName_ == 'DomainUserPassword':
            DomainUserPassword_ = child_.text
            DomainUserPassword_ = self.gds_validate_string(DomainUserPassword_, node, 'DomainUserPassword')
            self.DomainUserPassword = DomainUserPassword_
        elif nodeName_ == 'MachineObjectOU':
            MachineObjectOU_ = child_.text
            MachineObjectOU_ = self.gds_validate_string(MachineObjectOU_, node, 'MachineObjectOU')
            self.MachineObjectOU = MachineObjectOU_
        elif nodeName_ == 'AdminPasswordEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AdminPasswordEnabled')
            self.AdminPasswordEnabled = ival_
        elif nodeName_ == 'AdminPasswordAuto':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AdminPasswordAuto')
            self.AdminPasswordAuto = ival_
        elif nodeName_ == 'AdminPassword':
            AdminPassword_ = child_.text
            AdminPassword_ = self.gds_validate_string(AdminPassword_, node, 'AdminPassword')
            self.AdminPassword = AdminPassword_
        elif nodeName_ == 'AdminAutoLogonEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AdminAutoLogonEnabled')
            self.AdminAutoLogonEnabled = ival_
        elif nodeName_ == 'AdminAutoLogonCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AdminAutoLogonCount')
            self.AdminAutoLogonCount = ival_
        elif nodeName_ == 'ResetPasswordRequired':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ResetPasswordRequired')
            self.ResetPasswordRequired = ival_
        elif nodeName_ == 'CustomizationScript':
            CustomizationScript_ = child_.text
            CustomizationScript_ = self.gds_validate_string(CustomizationScript_, node, 'CustomizationScript')
            self.CustomizationScript = CustomizationScript_
        elif nodeName_ == 'ComputerName':
            ComputerName_ = child_.text
            ComputerName_ = self.gds_validate_string(ComputerName_, node, 'ComputerName')
            self.ComputerName = ComputerName_
        elif nodeName_ == 'Link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.Link.append(obj_)
            obj_.original_tagname_ = 'Link'
        else:
            obj_ = self.gds_build_any(child_, 'GuestCustomizationSectionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(GuestCustomizationSectionType, self).buildChildren(child_, node, nodeName_, True)
# end class GuestCustomizationSectionType


class RuntimeInfoSectionType(Section_Type):
    """1.5 VMware Tools and other runtime information for this virtual
    machine."""
    subclass = None
    superclass = Section_Type
    def __init__(self, VMWareTools=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(RuntimeInfoSectionType, self).__init__()
        self.VMWareTools = VMWareTools
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if RuntimeInfoSectionType.subclass:
            return RuntimeInfoSectionType.subclass(*args_, **kwargs_)
        else:
            return RuntimeInfoSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VMWareTools(self): return self.VMWareTools
    def set_VMWareTools(self, VMWareTools): self.VMWareTools = VMWareTools
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.VMWareTools is not None or
            self.anytypeobjs_ or
            super(RuntimeInfoSectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RuntimeInfoSectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RuntimeInfoSectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RuntimeInfoSectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RuntimeInfoSectionType'):
        super(RuntimeInfoSectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RuntimeInfoSectionType')
    def exportChildren(self, outfile, level, namespace_='', name_='RuntimeInfoSectionType', fromsubclass_=False, pretty_print=True):
        super(RuntimeInfoSectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VMWareTools is not None:
            self.VMWareTools.export(outfile, level, namespace_, name_='VMWareTools', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RuntimeInfoSectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RuntimeInfoSectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RuntimeInfoSectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.VMWareTools is not None:
            showIndent(outfile, level)
            outfile.write('VMWareTools=model_.VMWareToolsType(\n')
            self.VMWareTools.exportLiteral(outfile, level, name_='VMWareTools')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RuntimeInfoSectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VMWareTools':
            obj_ = VMWareToolsType.factory()
            obj_.build(child_)
            self.VMWareTools = obj_
            obj_.original_tagname_ = 'VMWareTools'
        else:
            obj_ = self.gds_build_any(child_, 'RuntimeInfoSectionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(RuntimeInfoSectionType, self).buildChildren(child_, node, nodeName_, True)
# end class RuntimeInfoSectionType


class NetworkConnectionSectionType(Section_Type):
    """0.9 Container for the network connections of this virtual machine.
    none A reference to the section in URL format. falsenone The
    MIME type of the section. false"""
    subclass = None
    superclass = Section_Type
    def __init__(self, href=None, type_=None, PrimaryNetworkConnectionIndex=None, NetworkConnection=None, Link=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(NetworkConnectionSectionType, self).__init__()
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        self.PrimaryNetworkConnectionIndex = PrimaryNetworkConnectionIndex
        if NetworkConnection is None:
            self.NetworkConnection = []
        else:
            self.NetworkConnection = NetworkConnection
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if NetworkConnectionSectionType.subclass:
            return NetworkConnectionSectionType.subclass(*args_, **kwargs_)
        else:
            return NetworkConnectionSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PrimaryNetworkConnectionIndex(self): return self.PrimaryNetworkConnectionIndex
    def set_PrimaryNetworkConnectionIndex(self, PrimaryNetworkConnectionIndex): self.PrimaryNetworkConnectionIndex = PrimaryNetworkConnectionIndex
    def get_NetworkConnection(self): return self.NetworkConnection
    def set_NetworkConnection(self, NetworkConnection): self.NetworkConnection = NetworkConnection
    def add_NetworkConnection(self, value): self.NetworkConnection.append(value)
    def insert_NetworkConnection_at(self, index, value): self.NetworkConnection.insert(index, value)
    def replace_NetworkConnection_at(self, index, value): self.NetworkConnection[index] = value
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def add_Link(self, value): self.Link.append(value)
    def insert_Link_at(self, index, value): self.Link.insert(index, value)
    def replace_Link_at(self, index, value): self.Link[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.PrimaryNetworkConnectionIndex is not None or
            self.NetworkConnection or
            self.Link or
            self.anytypeobjs_ or
            super(NetworkConnectionSectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkConnectionSectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConnectionSectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkConnectionSectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkConnectionSectionType'):
        super(NetworkConnectionSectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConnectionSectionType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkConnectionSectionType', fromsubclass_=False, pretty_print=True):
        super(NetworkConnectionSectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PrimaryNetworkConnectionIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryNetworkConnectionIndex>%s</%sPrimaryNetworkConnectionIndex>%s' % (namespace_, self.gds_format_integer(self.PrimaryNetworkConnectionIndex, input_name='PrimaryNetworkConnectionIndex'), namespace_, eol_))
        for NetworkConnection_ in self.NetworkConnection:
            NetworkConnection_.export(outfile, level, namespace_, name_='NetworkConnection', pretty_print=pretty_print)
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkConnectionSectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(NetworkConnectionSectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkConnectionSectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.PrimaryNetworkConnectionIndex is not None:
            showIndent(outfile, level)
            outfile.write('PrimaryNetworkConnectionIndex=%d,\n' % self.PrimaryNetworkConnectionIndex)
        showIndent(outfile, level)
        outfile.write('NetworkConnection=[\n')
        level += 1
        for NetworkConnection_ in self.NetworkConnection:
            showIndent(outfile, level)
            outfile.write('model_.NetworkConnectionType(\n')
            NetworkConnection_.exportLiteral(outfile, level, name_='NetworkConnectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            Link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(NetworkConnectionSectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PrimaryNetworkConnectionIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PrimaryNetworkConnectionIndex')
            self.PrimaryNetworkConnectionIndex = ival_
        elif nodeName_ == 'NetworkConnection':
            obj_ = NetworkConnectionType.factory()
            obj_.build(child_)
            self.NetworkConnection.append(obj_)
            obj_.original_tagname_ = 'NetworkConnection'
        elif nodeName_ == 'Link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.Link.append(obj_)
            obj_.original_tagname_ = 'Link'
        else:
            obj_ = self.gds_build_any(child_, 'NetworkConnectionSectionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(NetworkConnectionSectionType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkConnectionSectionType


class LeaseSettingsSectionType(Section_Type):
    """0.9 Represents vApp lease settings. none A reference to the section
    in URL format. falsenone The MIME type of the section. false"""
    subclass = None
    superclass = Section_Type
    def __init__(self, href=None, type_=None, Link=None, DeploymentLeaseInSeconds=None, StorageLeaseInSeconds=None, DeploymentLeaseExpiration=None, StorageLeaseExpiration=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(LeaseSettingsSectionType, self).__init__()
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
        self.DeploymentLeaseInSeconds = DeploymentLeaseInSeconds
        self.StorageLeaseInSeconds = StorageLeaseInSeconds
        if isinstance(DeploymentLeaseExpiration, basestring):
            initvalue_ = datetime_.datetime.strptime(DeploymentLeaseExpiration, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DeploymentLeaseExpiration
        self.DeploymentLeaseExpiration = initvalue_
        if isinstance(StorageLeaseExpiration, basestring):
            initvalue_ = datetime_.datetime.strptime(StorageLeaseExpiration, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = StorageLeaseExpiration
        self.StorageLeaseExpiration = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if LeaseSettingsSectionType.subclass:
            return LeaseSettingsSectionType.subclass(*args_, **kwargs_)
        else:
            return LeaseSettingsSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def add_Link(self, value): self.Link.append(value)
    def insert_Link_at(self, index, value): self.Link.insert(index, value)
    def replace_Link_at(self, index, value): self.Link[index] = value
    def get_DeploymentLeaseInSeconds(self): return self.DeploymentLeaseInSeconds
    def set_DeploymentLeaseInSeconds(self, DeploymentLeaseInSeconds): self.DeploymentLeaseInSeconds = DeploymentLeaseInSeconds
    def get_StorageLeaseInSeconds(self): return self.StorageLeaseInSeconds
    def set_StorageLeaseInSeconds(self, StorageLeaseInSeconds): self.StorageLeaseInSeconds = StorageLeaseInSeconds
    def get_DeploymentLeaseExpiration(self): return self.DeploymentLeaseExpiration
    def set_DeploymentLeaseExpiration(self, DeploymentLeaseExpiration): self.DeploymentLeaseExpiration = DeploymentLeaseExpiration
    def get_StorageLeaseExpiration(self): return self.StorageLeaseExpiration
    def set_StorageLeaseExpiration(self, StorageLeaseExpiration): self.StorageLeaseExpiration = StorageLeaseExpiration
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.Link or
            self.DeploymentLeaseInSeconds is not None or
            self.StorageLeaseInSeconds is not None or
            self.DeploymentLeaseExpiration is not None or
            self.StorageLeaseExpiration is not None or
            self.anytypeobjs_ or
            super(LeaseSettingsSectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LeaseSettingsSectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LeaseSettingsSectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LeaseSettingsSectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LeaseSettingsSectionType'):
        super(LeaseSettingsSectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LeaseSettingsSectionType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LeaseSettingsSectionType', fromsubclass_=False, pretty_print=True):
        super(LeaseSettingsSectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
        if self.DeploymentLeaseInSeconds is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeploymentLeaseInSeconds>%s</%sDeploymentLeaseInSeconds>%s' % (namespace_, self.gds_format_integer(self.DeploymentLeaseInSeconds, input_name='DeploymentLeaseInSeconds'), namespace_, eol_))
        if self.StorageLeaseInSeconds is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStorageLeaseInSeconds>%s</%sStorageLeaseInSeconds>%s' % (namespace_, self.gds_format_integer(self.StorageLeaseInSeconds, input_name='StorageLeaseInSeconds'), namespace_, eol_))
        if self.DeploymentLeaseExpiration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeploymentLeaseExpiration>%s</%sDeploymentLeaseExpiration>%s' % (namespace_, self.gds_format_datetime(self.DeploymentLeaseExpiration, input_name='DeploymentLeaseExpiration'), namespace_, eol_))
        if self.StorageLeaseExpiration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStorageLeaseExpiration>%s</%sStorageLeaseExpiration>%s' % (namespace_, self.gds_format_datetime(self.StorageLeaseExpiration, input_name='StorageLeaseExpiration'), namespace_, eol_))
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LeaseSettingsSectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(LeaseSettingsSectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LeaseSettingsSectionType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            Link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DeploymentLeaseInSeconds is not None:
            showIndent(outfile, level)
            outfile.write('DeploymentLeaseInSeconds=%d,\n' % self.DeploymentLeaseInSeconds)
        if self.StorageLeaseInSeconds is not None:
            showIndent(outfile, level)
            outfile.write('StorageLeaseInSeconds=%d,\n' % self.StorageLeaseInSeconds)
        if self.DeploymentLeaseExpiration is not None:
            showIndent(outfile, level)
            outfile.write('DeploymentLeaseExpiration=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.DeploymentLeaseExpiration, input_name='DeploymentLeaseExpiration'))
        if self.StorageLeaseExpiration is not None:
            showIndent(outfile, level)
            outfile.write('StorageLeaseExpiration=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.StorageLeaseExpiration, input_name='StorageLeaseExpiration'))
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(LeaseSettingsSectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.Link.append(obj_)
            obj_.original_tagname_ = 'Link'
        elif nodeName_ == 'DeploymentLeaseInSeconds':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DeploymentLeaseInSeconds')
            self.DeploymentLeaseInSeconds = ival_
        elif nodeName_ == 'StorageLeaseInSeconds':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StorageLeaseInSeconds')
            self.StorageLeaseInSeconds = ival_
        elif nodeName_ == 'DeploymentLeaseExpiration':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DeploymentLeaseExpiration = dval_
        elif nodeName_ == 'StorageLeaseExpiration':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.StorageLeaseExpiration = dval_
        else:
            obj_ = self.gds_build_any(child_, 'LeaseSettingsSectionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(LeaseSettingsSectionType, self).buildChildren(child_, node, nodeName_, True)
# end class LeaseSettingsSectionType


class NetworkConfigSectionType(Section_Type):
    """0.9 Container for vApp networks. none A reference to the section in
    URL format. falsenone The MIME type of the section. false"""
    subclass = None
    superclass = Section_Type
    def __init__(self, href=None, type_=None, Link=None, NetworkConfig=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(NetworkConfigSectionType, self).__init__()
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
        if NetworkConfig is None:
            self.NetworkConfig = []
        else:
            self.NetworkConfig = NetworkConfig
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if NetworkConfigSectionType.subclass:
            return NetworkConfigSectionType.subclass(*args_, **kwargs_)
        else:
            return NetworkConfigSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def add_Link(self, value): self.Link.append(value)
    def insert_Link_at(self, index, value): self.Link.insert(index, value)
    def replace_Link_at(self, index, value): self.Link[index] = value
    def get_NetworkConfig(self): return self.NetworkConfig
    def set_NetworkConfig(self, NetworkConfig): self.NetworkConfig = NetworkConfig
    def add_NetworkConfig(self, value): self.NetworkConfig.append(value)
    def insert_NetworkConfig_at(self, index, value): self.NetworkConfig.insert(index, value)
    def replace_NetworkConfig_at(self, index, value): self.NetworkConfig[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.Link or
            self.NetworkConfig or
            self.anytypeobjs_ or
            super(NetworkConfigSectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkConfigSectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConfigSectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkConfigSectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkConfigSectionType'):
        super(NetworkConfigSectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConfigSectionType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkConfigSectionType', fromsubclass_=False, pretty_print=True):
        super(NetworkConfigSectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
        for NetworkConfig_ in self.NetworkConfig:
            NetworkConfig_.export(outfile, level, namespace_, name_='NetworkConfig', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkConfigSectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(NetworkConfigSectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkConfigSectionType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            Link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NetworkConfig=[\n')
        level += 1
        for NetworkConfig_ in self.NetworkConfig:
            showIndent(outfile, level)
            outfile.write('model_.VAppNetworkConfigurationType(\n')
            NetworkConfig_.exportLiteral(outfile, level, name_='VAppNetworkConfigurationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(NetworkConfigSectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.Link.append(obj_)
            obj_.original_tagname_ = 'Link'
        elif nodeName_ == 'NetworkConfig':
            obj_ = VAppNetworkConfigurationType.factory()
            obj_.build(child_)
            self.NetworkConfig.append(obj_)
            obj_.original_tagname_ = 'NetworkConfig'
        else:
            obj_ = self.gds_build_any(child_, 'NetworkConfigSectionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(NetworkConfigSectionType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkConfigSectionType


class TaskType(EntityType):
    """0.9 Represents an asynchronous operation in vCloud Director. none
    The execution status of the task. One of:<br> <b>queued</b> (The
    task has been queued for execution)<br> <b>preRunning</b> (The
    task is awaiting preprocessing or administrative action.)<br>
    <b>running</b> (The task is running.)<br> <b>success</b> (The
    task completed with a status of success.)<br> <b>error</b> (The
    task encountered an error while running.)<br> <b>canceled</b>
    (The task was canceled by the owner or an administrator.)<br>
    <b>aborted</b> (The task was aborted by an administrative
    action.) truealways A message describing the operation that is
    tracked by this task. falsenone The short name of the operation
    that is tracked by this task. false5.1createtrue Identifier of
    the service that created the task. It must not start with
    com.vmware.vcloud and the length must be between 1 and 128
    symbols. none The date and time the system started executing the
    task. May not be present if the task has not been executed yet.
    falsenone The date and time that processing of the task was
    completed. May not be present if the task is still being
    executed. falsenone The date and time at which the task resource
    will be destroyed and no longer available for retrieval. May not
    be present if the task has not been executed or is still being
    executed. false5.1nonefalse Whether user has requested this
    processing to be canceled."""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, operationName=None, expiryTime=None, cancelRequested=None, startTime=None, operation=None, endTime=None, serviceNamespace=None, Owner=None, Error=None, User=None, Organization=None, Progress=None, Params=None, Details=None):
        self.original_tagname_ = None
        super(TaskType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.status = _cast(None, status)
        self.operationName = _cast(None, operationName)
        if isinstance(expiryTime, basestring):
            initvalue_ = datetime_.datetime.strptime(expiryTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expiryTime
        self.expiryTime = initvalue_
        self.cancelRequested = _cast(bool, cancelRequested)
        if isinstance(startTime, basestring):
            initvalue_ = datetime_.datetime.strptime(startTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = startTime
        self.startTime = initvalue_
        self.operation = _cast(None, operation)
        if isinstance(endTime, basestring):
            initvalue_ = datetime_.datetime.strptime(endTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = endTime
        self.endTime = initvalue_
        self.serviceNamespace = _cast(None, serviceNamespace)
        self.Owner = Owner
        self.Error = Error
        self.User = User
        self.Organization = Organization
        self.Progress = Progress
        self.Params = Params
        self.Details = Details
    def factory(*args_, **kwargs_):
        if TaskType.subclass:
            return TaskType.subclass(*args_, **kwargs_)
        else:
            return TaskType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Owner(self): return self.Owner
    def set_Owner(self, Owner): self.Owner = Owner
    def get_Error(self): return self.Error
    def set_Error(self, Error): self.Error = Error
    def get_User(self): return self.User
    def set_User(self, User): self.User = User
    def get_Organization(self): return self.Organization
    def set_Organization(self, Organization): self.Organization = Organization
    def get_Progress(self): return self.Progress
    def set_Progress(self, Progress): self.Progress = Progress
    def get_Params(self): return self.Params
    def set_Params(self, Params): self.Params = Params
    def get_Details(self): return self.Details
    def set_Details(self, Details): self.Details = Details
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_operationName(self): return self.operationName
    def set_operationName(self, operationName): self.operationName = operationName
    def get_expiryTime(self): return self.expiryTime
    def set_expiryTime(self, expiryTime): self.expiryTime = expiryTime
    def get_cancelRequested(self): return self.cancelRequested
    def set_cancelRequested(self, cancelRequested): self.cancelRequested = cancelRequested
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def get_operation(self): return self.operation
    def set_operation(self, operation): self.operation = operation
    def get_endTime(self): return self.endTime
    def set_endTime(self, endTime): self.endTime = endTime
    def get_serviceNamespace(self): return self.serviceNamespace
    def set_serviceNamespace(self, serviceNamespace): self.serviceNamespace = serviceNamespace
    def hasContent_(self):
        if (
            self.Owner is not None or
            self.Error is not None or
            self.User is not None or
            self.Organization is not None or
            self.Progress is not None or
            self.Params is not None or
            self.Details is not None or
            super(TaskType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TaskType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaskType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TaskType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TaskType'):
        super(TaskType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TaskType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.operationName is not None and 'operationName' not in already_processed:
            already_processed.add('operationName')
            outfile.write(' operationName=%s' % (self.gds_format_string(quote_attrib(self.operationName).encode(ExternalEncoding), input_name='operationName'), ))
        if self.expiryTime is not None and 'expiryTime' not in already_processed:
            already_processed.add('expiryTime')
            outfile.write(' expiryTime="%s"' % self.gds_format_datetime(self.expiryTime, input_name='expiryTime'))
        if self.cancelRequested is not None and 'cancelRequested' not in already_processed:
            already_processed.add('cancelRequested')
            outfile.write(' cancelRequested="%s"' % self.gds_format_boolean(self.cancelRequested, input_name='cancelRequested'))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            outfile.write(' startTime="%s"' % self.gds_format_datetime(self.startTime, input_name='startTime'))
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            outfile.write(' operation=%s' % (self.gds_format_string(quote_attrib(self.operation).encode(ExternalEncoding), input_name='operation'), ))
        if self.endTime is not None and 'endTime' not in already_processed:
            already_processed.add('endTime')
            outfile.write(' endTime="%s"' % self.gds_format_datetime(self.endTime, input_name='endTime'))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            outfile.write(' serviceNamespace=%s' % (self.gds_format_string(quote_attrib(self.serviceNamespace).encode(ExternalEncoding), input_name='serviceNamespace'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TaskType', fromsubclass_=False, pretty_print=True):
        super(TaskType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Owner is not None:
            self.Owner.export(outfile, level, namespace_, name_='Owner', pretty_print=pretty_print)
        if self.Error is not None:
            self.Error.export(outfile, level, namespace_, name_='Error', pretty_print=pretty_print)
        if self.User is not None:
            self.User.export(outfile, level, namespace_, name_='User', pretty_print=pretty_print)
        if self.Organization is not None:
            self.Organization.export(outfile, level, namespace_, name_='Organization', pretty_print=pretty_print)
        if self.Progress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProgress>%s</%sProgress>%s' % (namespace_, self.gds_format_integer(self.Progress, input_name='Progress'), namespace_, eol_))
        if self.Params is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sParams>%s</%sParams>%s' % (namespace_, self.gds_format_string(quote_xml(self.Params).encode(ExternalEncoding), input_name='Params'), namespace_, eol_))
        if self.Details is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDetails>%s</%sDetails>%s' % (namespace_, self.gds_format_string(quote_xml(self.Details).encode(ExternalEncoding), input_name='Details'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TaskType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.operationName is not None and 'operationName' not in already_processed:
            already_processed.add('operationName')
            showIndent(outfile, level)
            outfile.write('operationName="%s",\n' % (self.operationName,))
        if self.expiryTime is not None and 'expiryTime' not in already_processed:
            already_processed.add('expiryTime')
            showIndent(outfile, level)
            outfile.write('expiryTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.expiryTime, input_name='expiryTime'))
        if self.cancelRequested is not None and 'cancelRequested' not in already_processed:
            already_processed.add('cancelRequested')
            showIndent(outfile, level)
            outfile.write('cancelRequested=%s,\n' % (self.cancelRequested,))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            showIndent(outfile, level)
            outfile.write('startTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.startTime, input_name='startTime'))
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            showIndent(outfile, level)
            outfile.write('operation="%s",\n' % (self.operation,))
        if self.endTime is not None and 'endTime' not in already_processed:
            already_processed.add('endTime')
            showIndent(outfile, level)
            outfile.write('endTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.endTime, input_name='endTime'))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            showIndent(outfile, level)
            outfile.write('serviceNamespace="%s",\n' % (self.serviceNamespace,))
        super(TaskType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TaskType, self).exportLiteralChildren(outfile, level, name_)
        if self.Owner is not None:
            showIndent(outfile, level)
            outfile.write('Owner=model_.ReferenceType(\n')
            self.Owner.exportLiteral(outfile, level, name_='Owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Error is not None:
            showIndent(outfile, level)
            outfile.write('Error=model_.ErrorType(\n')
            self.Error.exportLiteral(outfile, level, name_='Error')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.User is not None:
            showIndent(outfile, level)
            outfile.write('User=model_.ReferenceType(\n')
            self.User.exportLiteral(outfile, level, name_='User')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Organization is not None:
            showIndent(outfile, level)
            outfile.write('Organization=model_.ReferenceType(\n')
            self.Organization.exportLiteral(outfile, level, name_='Organization')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Progress is not None:
            showIndent(outfile, level)
            outfile.write('Progress=%d,\n' % self.Progress)
        if self.Params is not None:
            showIndent(outfile, level)
            outfile.write('Params=%s,\n' % quote_python(self.Params).encode(ExternalEncoding))
        if self.Details is not None:
            showIndent(outfile, level)
            outfile.write('Details=%s,\n' % quote_python(self.Details).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('operationName', node)
        if value is not None and 'operationName' not in already_processed:
            already_processed.add('operationName')
            self.operationName = value
        value = find_attr_value_('expiryTime', node)
        if value is not None and 'expiryTime' not in already_processed:
            already_processed.add('expiryTime')
            try:
                self.expiryTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (expiryTime): %s' % exp)
        value = find_attr_value_('cancelRequested', node)
        if value is not None and 'cancelRequested' not in already_processed:
            already_processed.add('cancelRequested')
            if value in ('true', '1'):
                self.cancelRequested = True
            elif value in ('false', '0'):
                self.cancelRequested = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('startTime', node)
        if value is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            try:
                self.startTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (startTime): %s' % exp)
        value = find_attr_value_('operation', node)
        if value is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            self.operation = value
        value = find_attr_value_('endTime', node)
        if value is not None and 'endTime' not in already_processed:
            already_processed.add('endTime')
            try:
                self.endTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (endTime): %s' % exp)
        value = find_attr_value_('serviceNamespace', node)
        if value is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            self.serviceNamespace = value
        super(TaskType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Owner':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Owner = obj_
            obj_.original_tagname_ = 'Owner'
        elif nodeName_ == 'Error':
            obj_ = ErrorType.factory()
            obj_.build(child_)
            self.Error = obj_
            obj_.original_tagname_ = 'Error'
        elif nodeName_ == 'User':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.User = obj_
            obj_.original_tagname_ = 'User'
        elif nodeName_ == 'Organization':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Organization = obj_
            obj_.original_tagname_ = 'Organization'
        elif nodeName_ == 'Progress':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Progress')
            self.Progress = ival_
        elif nodeName_ == 'Params':
            Params_ = child_.text
            Params_ = self.gds_validate_string(Params_, node, 'Params')
            self.Params = Params_
        elif nodeName_ == 'Details':
            Details_ = child_.text
            Details_ = self.gds_validate_string(Details_, node, 'Details')
            self.Details = Details_
        super(TaskType, self).buildChildren(child_, node, nodeName_, True)
# end class TaskType


class LinkType(ReferenceType):
    """0.9 Extends reference type by adding relation attribute. Defines a
    hyper-link with a relationship, hyper-link reference, and an
    optional MIME type. always Defines the relationship of the link
    to the object that contains it. A relationship can be the name
    of an operation on the object, a reference to a contained or
    containing object, or a reference to an alternate representation
    of the object. The relationship value implies the HTTP verb to
    use when you use the link's href as a request URL. See the
    vCloud API Programming Guide for a list of links and link
    relations. true"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, VCloudExtension=None, href=None, type_=None, id=None, name=None, rel=None):
        self.original_tagname_ = None
        super(LinkType, self).__init__(VCloudExtension, href, type_, id, name, )
        self.rel = _cast(None, rel)
    def factory(*args_, **kwargs_):
        if LinkType.subclass:
            return LinkType.subclass(*args_, **kwargs_)
        else:
            return LinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rel(self): return self.rel
    def set_rel(self, rel): self.rel = rel
    def hasContent_(self):
        if (
            super(LinkType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkType'):
        super(LinkType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LinkType')
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            outfile.write(' rel=%s' % (self.gds_format_string(quote_attrib(self.rel).encode(ExternalEncoding), input_name='rel'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LinkType', fromsubclass_=False, pretty_print=True):
        super(LinkType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LinkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            showIndent(outfile, level)
            outfile.write('rel="%s",\n' % (self.rel,))
        super(LinkType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LinkType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rel', node)
        if value is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            self.rel = value
        super(LinkType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LinkType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LinkType


class DiskAttachOrDetachParamsType(VCloudExtensibleType):
    """5.1 Parameters for attaching or detaching an independent disk."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Disk=None, BusNumber=None, UnitNumber=None):
        self.original_tagname_ = None
        super(DiskAttachOrDetachParamsType, self).__init__(VCloudExtension, )
        self.Disk = Disk
        self.BusNumber = BusNumber
        self.UnitNumber = UnitNumber
    def factory(*args_, **kwargs_):
        if DiskAttachOrDetachParamsType.subclass:
            return DiskAttachOrDetachParamsType.subclass(*args_, **kwargs_)
        else:
            return DiskAttachOrDetachParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Disk(self): return self.Disk
    def set_Disk(self, Disk): self.Disk = Disk
    def get_BusNumber(self): return self.BusNumber
    def set_BusNumber(self, BusNumber): self.BusNumber = BusNumber
    def get_UnitNumber(self): return self.UnitNumber
    def set_UnitNumber(self, UnitNumber): self.UnitNumber = UnitNumber
    def hasContent_(self):
        if (
            self.Disk is not None or
            self.BusNumber is not None or
            self.UnitNumber is not None or
            super(DiskAttachOrDetachParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiskAttachOrDetachParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiskAttachOrDetachParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DiskAttachOrDetachParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiskAttachOrDetachParamsType'):
        super(DiskAttachOrDetachParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DiskAttachOrDetachParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='DiskAttachOrDetachParamsType', fromsubclass_=False, pretty_print=True):
        super(DiskAttachOrDetachParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Disk is not None:
            self.Disk.export(outfile, level, namespace_, name_='Disk', pretty_print=pretty_print)
        if self.BusNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBusNumber>%s</%sBusNumber>%s' % (namespace_, self.gds_format_integer(self.BusNumber, input_name='BusNumber'), namespace_, eol_))
        if self.UnitNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitNumber>%s</%sUnitNumber>%s' % (namespace_, self.gds_format_integer(self.UnitNumber, input_name='UnitNumber'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DiskAttachOrDetachParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DiskAttachOrDetachParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DiskAttachOrDetachParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Disk is not None:
            showIndent(outfile, level)
            outfile.write('Disk=model_.ReferenceType(\n')
            self.Disk.exportLiteral(outfile, level, name_='Disk')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BusNumber is not None:
            showIndent(outfile, level)
            outfile.write('BusNumber=%d,\n' % self.BusNumber)
        if self.UnitNumber is not None:
            showIndent(outfile, level)
            outfile.write('UnitNumber=%d,\n' % self.UnitNumber)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DiskAttachOrDetachParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Disk':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Disk = obj_
            obj_.original_tagname_ = 'Disk'
        elif nodeName_ == 'BusNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BusNumber')
            self.BusNumber = ival_
        elif nodeName_ == 'UnitNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UnitNumber')
            self.UnitNumber = ival_
        super(DiskAttachOrDetachParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class DiskAttachOrDetachParamsType


class DiskCreateParamsType(VCloudExtensibleType):
    """5.1 Parameters for creating or updating an independent disk."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Disk=None, Locality=None):
        self.original_tagname_ = None
        super(DiskCreateParamsType, self).__init__(VCloudExtension, )
        self.Disk = Disk
        self.Locality = Locality
    def factory(*args_, **kwargs_):
        if DiskCreateParamsType.subclass:
            return DiskCreateParamsType.subclass(*args_, **kwargs_)
        else:
            return DiskCreateParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Disk(self): return self.Disk
    def set_Disk(self, Disk): self.Disk = Disk
    def get_Locality(self): return self.Locality
    def set_Locality(self, Locality): self.Locality = Locality
    def hasContent_(self):
        if (
            self.Disk is not None or
            self.Locality is not None or
            super(DiskCreateParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiskCreateParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiskCreateParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DiskCreateParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiskCreateParamsType'):
        super(DiskCreateParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DiskCreateParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='DiskCreateParamsType', fromsubclass_=False, pretty_print=True):
        super(DiskCreateParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Disk is not None:
            self.Disk.export(outfile, level, namespace_, name_='Disk', pretty_print=pretty_print)
        if self.Locality is not None:
            self.Locality.export(outfile, level, namespace_, name_='Locality', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DiskCreateParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DiskCreateParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DiskCreateParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Disk is not None:
            showIndent(outfile, level)
            outfile.write('Disk=model_.DiskType(\n')
            self.Disk.exportLiteral(outfile, level, name_='Disk')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Locality is not None:
            showIndent(outfile, level)
            outfile.write('Locality=model_.ReferenceType(\n')
            self.Locality.exportLiteral(outfile, level, name_='Locality')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DiskCreateParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Disk':
            obj_ = DiskType.factory()
            obj_.build(child_)
            self.Disk = obj_
            obj_.original_tagname_ = 'Disk'
        elif nodeName_ == 'Locality':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Locality = obj_
            obj_.original_tagname_ = 'Locality'
        super(DiskCreateParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class DiskCreateParamsType


class DiskType(ResourceEntityType):
    """5.1 Represents an independent disk. none Size of the disk in MB.<br>
    <br> You must supply this attribute in an update request, but
    you cannot change its value after the object has been created.
    truenone Disk bus type expressed as a number. One of:<br>
    <b>5</b> IDE bus<br> <b>6</b> SCSI bus (default)<br> <b>20</b>
    SATA bus<br> <br> You must supply this attribute in an update
    request, but you cannot change its value after the object has
    been created. falsenone Disk bus subtype expressed as a string.
    One of:<br> "" (null)&nbsp;&nbsp;IDE, requires busType 5<br>
    <b>buslogic</b>&nbsp;&nbsp;BusLogic Parallel SCSI controller,
    requires busType 6<br> <b>lsilogic</b>&nbsp;&nbsp;LSI Logic
    Parallel SCSI controller, requires busType 6<br>
    <b>lsilogicsas</b>&nbsp;&nbsp;LSI Logic SAS SCSI controller,
    requires busType 6<br> <b>VirtualSCSI</b>&nbsp;&nbsp;Paravirtual
    SCSI controller, requires busType 6<br>
    <b>vmware.sata.ahci</b>&nbsp;&nbsp;SATA controller, requires
    busType 20<br> <br> You must supply this attribute in an update
    request, but you cannot change its value after the object has
    been created. false"""
    subclass = None
    superclass = ResourceEntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, Files=None, busType=None, busSubType=None, size=None, StorageProfile=None, Owner=None):
        self.original_tagname_ = None
        super(DiskType, self).__init__(operationKey, id, name, Description, Tasks, status, Files, )
        self.busType = _cast(None, busType)
        self.busSubType = _cast(None, busSubType)
        self.size = _cast(int, size)
        self.StorageProfile = StorageProfile
        self.Owner = Owner
    def factory(*args_, **kwargs_):
        if DiskType.subclass:
            return DiskType.subclass(*args_, **kwargs_)
        else:
            return DiskType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StorageProfile(self): return self.StorageProfile
    def set_StorageProfile(self, StorageProfile): self.StorageProfile = StorageProfile
    def get_Owner(self): return self.Owner
    def set_Owner(self, Owner): self.Owner = Owner
    def get_busType(self): return self.busType
    def set_busType(self, busType): self.busType = busType
    def get_busSubType(self): return self.busSubType
    def set_busSubType(self, busSubType): self.busSubType = busSubType
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            self.StorageProfile is not None or
            self.Owner is not None or
            super(DiskType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiskType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiskType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DiskType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiskType'):
        super(DiskType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DiskType')
        if self.busType is not None and 'busType' not in already_processed:
            already_processed.add('busType')
            outfile.write(' busType=%s' % (self.gds_format_string(quote_attrib(self.busType).encode(ExternalEncoding), input_name='busType'), ))
        if self.busSubType is not None and 'busSubType' not in already_processed:
            already_processed.add('busSubType')
            outfile.write(' busSubType=%s' % (self.gds_format_string(quote_attrib(self.busSubType).encode(ExternalEncoding), input_name='busSubType'), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespace_='', name_='DiskType', fromsubclass_=False, pretty_print=True):
        super(DiskType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StorageProfile is not None:
            self.StorageProfile.export(outfile, level, namespace_, name_='StorageProfile', pretty_print=pretty_print)
        if self.Owner is not None:
            self.Owner.export(outfile, level, namespace_, name_='Owner', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DiskType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.busType is not None and 'busType' not in already_processed:
            already_processed.add('busType')
            showIndent(outfile, level)
            outfile.write('busType="%s",\n' % (self.busType,))
        if self.busSubType is not None and 'busSubType' not in already_processed:
            already_processed.add('busSubType')
            showIndent(outfile, level)
            outfile.write('busSubType="%s",\n' % (self.busSubType,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % (self.size,))
        super(DiskType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DiskType, self).exportLiteralChildren(outfile, level, name_)
        if self.StorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('StorageProfile=model_.ReferenceType(\n')
            self.StorageProfile.exportLiteral(outfile, level, name_='StorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Owner is not None:
            showIndent(outfile, level)
            outfile.write('Owner=model_.OwnerType(\n')
            self.Owner.exportLiteral(outfile, level, name_='Owner')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('busType', node)
        if value is not None and 'busType' not in already_processed:
            already_processed.add('busType')
            self.busType = value
        value = find_attr_value_('busSubType', node)
        if value is not None and 'busSubType' not in already_processed:
            already_processed.add('busSubType')
            self.busSubType = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(DiskType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.StorageProfile = obj_
            obj_.original_tagname_ = 'StorageProfile'
        elif nodeName_ == 'Owner':
            obj_ = OwnerType.factory()
            obj_.build(child_)
            self.Owner = obj_
            obj_.original_tagname_ = 'Owner'
        super(DiskType, self).buildChildren(child_, node, nodeName_, True)
# end class DiskType


GDSClassesMapping = {
    'Category': Msg_Type,
    'Msg': MsgType,
    'ExternalNatIpMap': ExternalNatIpMapType,
    'VdcStorageProfile': VdcStorageProfileType,
    'ControlAccessParams': ControlAccessParamsType,
    'InstallSection': InstallSection_Type,
    'SourcedVmInstantiationParams': SourcedVmInstantiationParamsType,
    'IpsecVpnService': IpsecVpnServiceType,
    'SnapshotSection': SnapshotSectionType,
    'CoresPerSocket': CoresPerSocket_Type,
    'SubnetParticipation': SubnetParticipationType,
    'HostResource': cimString,
    'CreateItem': VmType,
    'NetworkSection': NetworkSection_Type,
    'Metadata': MetadataType,
    'Files': FilesListType,
    'LocalSubnet': IpsecVpnSubnetType,
    'VendorUrl': cimString,
    'Parent': cimString,
    'NetworkConnectionSection': NetworkConnectionSectionType,
    'RuntimeInfoSection': RuntimeInfoSectionType,
    'ProductUrl': cimString,
    'CaptureVAppParams': CaptureVAppParamsType,
    'RecomposeVAppParams': RecomposeVAppParamsType,
    'IpsecVpnRemotePeer': IpsecVpnRemotePeerType,
    'LogDataRoot': cimString,
    'VendorTemplates': VendorTemplateType,
    'GatewayIpsecVpnService': GatewayIpsecVpnServiceType,
    'Annotation': Msg_Type,
    'Protocols': ProtocolsType,
    'Icon': IconType,
    'Task': TaskType,
    'ConfigurationDataRoot': cimString,
    'LoadBalancerService': LoadBalancerServiceType,
    'OneToOneBasicRule': NatOneToOneBasicRuleType,
    'Address': cimString,
    'NetworkConfig': VAppNetworkConfigurationType,
    'CIM_ResourceAllocationSettingData': CIM_ResourceAllocationSettingData_Type,
    'Choices': VmQuestionAnswerChoiceType,
    'Interface': ReferenceType,
    'Limit': cimUnsignedLong,
    'DhcpService': DhcpServiceType,
    'Reservation': cimUnsignedLong,
    'Organization': ReferenceType,
    'SourceVm': VmSelectionType,
    'NicIpMap': NicIpMapType,
    'VmRule': NatVmRuleType,
    'Environment': Environment_Type,
    'VdcStorageProfiles': VdcStorageProfilesType,
    'ServiceConfig': GatewayFeaturesType,
    'Reference': ReferenceType,
    'GuestCustomizationSection': GuestCustomizationSectionType,
    'IpAssignmentSection': IpAssignmentSection_Type,
    'Connection': cimString,
    'ResourceSubType': cimString,
    'Entity': Entity_Type,
    'OrgVdcNetwork': OrgVdcNetworkType,
    'VirtualHardwareSection': VirtualHardwareSection_Type,
    'MediaInsertOrEjectParams': MediaInsertOrEjectParamsType,
    'EdgeGateway': GatewayType,
    'Datastore': ReferenceType,
    'Disk': VirtualDiskDesc_Type,
    'Subject': ReferenceType,
    'SnapshotDataRoot': cimString,
    'Network': NetworkType5,
    'IpsecVpnTunnel': IpsecVpnTunnelType,
    'GatewayInterface': GatewayInterfaceType,
    'NatRule': NatRuleType,
    'System': VSSD_Type,
    'StaticRoute': StaticRouteType,
    'BootOrderSection': BootOrderSection_Type,
    'AllowedExternalIpAddresses': IpAddressesType,
    'Source': ReferenceType,
    'RasdItemsList': RasdItemsListType,
    'NatService': NatServiceType,
    'TypedValue': MetadataTypedValue,
    'ProductSection': ProductSection_Type,
    'MetadataValue': MetadataValueType,
    'Vendor': cimString,
    'UndeployVAppParams': UndeployVAppParamsType,
    'DeployVAppParams': DeployVAppParamsType,
    'Config': Config_Type,
    'AutomaticDeallocation': cimBoolean,
    'FirewallService': FirewallServiceType,
    'ConfigurationFile': cimString,
    'VsToVmxMap': VsToVmxMapType,
    'Link': LinkType,
    'IpsecVpnPeer': IpsecVpnPeerType,
    'GatewayInterfaces': GatewayInterfacesType,
    'ComputeCapacity': ComputeCapacityType,
    'NetworkServices': NetworkServiceInsertionType,
    'Configuration': ConfigurationType,
    'LoadBalancerTemplates': VendorTemplateType,
    'VCloudExtension': VCloudExtensionType,
    'Info': Msg_Type,
    'DiskCreateParams': DiskCreateParamsType,
    'Kind': cimString,
    'NetworkServiceInsertion': NetworkServiceInsertionType,
    'Tunnel': GatewayIpsecVpnTunnelType,
    'HealthCheck': LBPoolHealthCheckType,
    'ConfigurationID': cimString,
    'DiskAttachOrDetachParams': DiskAttachOrDetachParamsType,
    'ElementName': cimString,
    'LeaseSettingsSection': LeaseSettingsSectionType,
    'IpScopes': IpScopesType,
    'RouterInfo': RouterInfoType,
    'SourcedItem': SourcedCompositionItemParamType,
    'InstantiateVAppTemplateParams': InstantiateVAppTemplateParamsType,
    'Property': PropertyType6,
    'Cpu': CapacityWithUsageType,
    'Domain': MetadataDomainTagType,
    'Tasks': TasksInProgressType,
    'RegisterVAppParams': RegisterVAppParamsType,
    'FirewallRule': FirewallRuleType,
    'AccessSetting': AccessSettingType,
    'DeploymentOptionSection': DeploymentOptionSection_Type,
    'DiskSection': DiskSection_Type,
    'OvfToVdcNetworkMap': OvfToVdcNetworkMapType,
    'PortForwardingRule': NatPortForwardingRuleType,
    'SuspendDataRoot': cimString,
    'AnnotationSection': AnnotationSection_Type,
    'VirtualSystemType': cimString,
    'Owner': OwnerType,
    'VMWareTools': VMWareToolsType,
    'ResourceEntity': ResourceReferenceType,
    'VmQuestionAnswer': VmQuestionAnswerType,
    'IpsecVpnLocalPeer': IpsecVpnLocalPeerType,
    'VAppNetwork': VAppNetworkType,
    'EdgeGatewayServiceConfiguration': GatewayFeaturesType,
    'VendorTemplateAttributes': VendorTemplateAttributesType,
    'Locality': ReferenceType,
    'StorageProfile': ReferenceType,
    'OtherResourceType': cimString,
    'AutomaticStartupActionSequenceNumber': cimUnsignedShort,
    'QueryList': QueryListType,
    'Member': LBPoolMemberType,
    'AutomaticAllocation': cimBoolean,
    'ResourceEntities': ResourceEntitiesType,
    'TargetCatalogItem': ReferenceType,
    'InstantiationParams': InstantiationParamsType,
    'SwapFileDataRoot': cimString,
    'VmGeneralParams': VmGeneralParamsType,
    'InstantiateOvfProperty': InstantiateOvfPropertyType,
    'ComposeVAppParams': ComposeVAppParamsType,
    'IpScope': IpScopeType,
    'FullVersion': cimString,
    'StartupSection': StartupSection_Type,
    'CloneVAppParams': CloneVAppParamsType,
    'Strings': Strings_Type,
    'VirtualQuantity': cimUnsignedLong,
    'User': ReferenceType,
    'CreateSnapshotParams': CreateSnapshotParamsType,
    'PeerSubnet': IpsecVpnSubnetType,
    'PropertySection': PropertySection_Type,
    'Section': Section_Type,
    'CreationTime': cimDateTime,
    'AccessSettings': AccessSettingsType,
    'AllocationUnits': cimString,
    'GatewayDhcpService': GatewayDhcpServiceType,
    'DestinationVm': VmSelectionType,
    'CpuCompatibilitySection': CpuCompatibilitySection_Type,
    'StorageCapacity': CapacityWithUsageType,
    'VAppParent': ReferenceType,
    'Vdc': VdcType,
    'Snapshot': SnapshotType,
    'NetworkConnection': NetworkConnectionType,
    'NetworkConfigSection': NetworkConfigSectionType,
    'Label': Msg_Type,
    'CIM_VirtualSystemSettingData': CIM_VirtualSystemSettingData_Type,
    'NetworkPool': ReferenceType,
    'Features': NetworkFeaturesType,
    'SubAllocations': SubAllocationsType,
    'MetadataEntry': MetadataEntryType,
    'ParentNetwork': ReferenceType,
    'Version': cimString,
    'References': References_Type,
    'Pool': LoadBalancerPoolType,
    'NetworkMapping': NetworkMappingType,
    'AllocatedIpAddresses': IpAddressesType,
    'Name': Msg_Type,
    'Children': VAppChildrenType,
    'ComplianceResult': ComplianceResultType,
    'AppUrl': cimString,
    'ExtraConfig': ExtraConfig_Type,
    'OperatingSystemSection': OperatingSystemSection_Type,
    'InstanceID': cimString,
    'Media': ReferenceType,
    'ServiceProfile': LBVirtualServerServiceProfileType,
    'StaticRoutingService': StaticRoutingServiceType,
    'Capabilities': CapabilitiesType,
    'Content': Content_Type,
    'AvailableNetworks': AvailableNetworksType,
    'VirtualServer': LoadBalancerVirtualServerType,
    'Memory': CapacityWithUsageType,
    'ResourceAllocationSection': ResourceAllocationSection_Type,
    'IpAddress': AllocatedIpAddressType,
    'Persistence': LBPersistenceType,
    'NetworkService': NetworkServiceType,
    'Product': Msg_Type,
    'VmCapabilities': VmCapabilitiesType,
    'Description': Msg_Type,
    'HardwareCustomization': InstantiateVmHardwareCustomizationParamsType,
    'OneToOneVmRule': NatOneToOneVmRuleType,
    'GatewayNatRule': GatewayNatRuleType,
    'Envelope': EnvelopeType,
    'IpRanges': IpRangesType,
    'Error': ErrorType,
    'AddressOnParent': cimString,
    'InstantiateOvfParams': InstantiateOvfParamsType,
    'PoolID': cimString,
    'SyslogServerSettings': SyslogServerSettingsType,
    'VirtualQuantityUnits': cimString,
    'Notes': cimString,
    'DeleteItem': ReferenceType,
    'EulaSection': EulaSection_Type,
    'PlatformSection': PlatformSection_Type,
    'Endpoint': GatewayIpsecVpnEndpointType,
    'RelocateParams': RelocateParamsType,
    'License': Msg_Type,
    'VirtualSystemCollection': VirtualSystemCollection_Type,
    'EdgeGatewayServices': NetworkServiceInsertionType,
    'Level': LevelType,
    'Item': ItemType,
    'Value': PropertyConfigurationValue_Type,
    'Entry': EntryType3,
    'VirtualSystem': VirtualSystem_Type,
    'IpRange': IpRangeType,
    'DefaultStorageProfileSection': DefaultStorageProfileSection_Type,
    'VApp': VAppType,
    'LocalityParams': LocalityParamsType,
    'Locale': cimString,
    'AutomaticStartupActionDelay': cimDateTime,
    'Vm': VmType,
    'ServicePort': LBPoolServicePortType,
    'NetworkAssignment': NetworkAssignmentType,
    'Weight': cimUnsignedInt,
    'SupportedHardwareVersions': SupportedHardwareVersionsType,
    'IpsecVpnThirdPartyPeer': IpsecVpnThirdPartyPeerType,
    'File': File_Type,
    'VmPendingQuestion': VmPendingQuestionType,
    'InstantiateVmParams': InstantiateVmParamsType,
    'RecoveryFile': cimString,
    'VirtualSystemIdentifier': cimString,
    'SubAllocation': SubAllocationType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DiskType'
        rootClass = DiskType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DiskType'
        rootClass = DiskType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from io import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DiskType'
        rootClass = DiskType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DiskType'
        rootClass = DiskType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from diskType import *\n\n')
        sys.stdout.write('import diskType as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AbstractVAppType",
    "AccessSettingType",
    "AccessSettingsType",
    "AllocatedIpAddressType",
    "AllocatedIpAddressesType",
    "AnnotationSection_Type",
    "AutomaticRecoveryAction",
    "AutomaticShutdownAction",
    "AutomaticStartupAction",
    "AvailableNetworksType",
    "BootOrderSection_Type",
    "CIM_ResourceAllocationSettingData_Type",
    "CIM_VirtualSystemSettingData_Type",
    "CapabilitiesType",
    "CapacityType",
    "CapacityWithUsageType",
    "Caption",
    "CaptureVAppParamsType",
    "CloneVAppParamsType",
    "ComplianceResultType",
    "ComposeVAppParamsType",
    "ComputeCapacityType",
    "ConfigKeyValue_Type",
    "Config_Type",
    "ConfigurationType",
    "ConsumerVisibility",
    "ContainerType",
    "Content_Type",
    "ControlAccessParamsType",
    "CoresPerSocket_Type",
    "CpuCompatibilitySection_Type",
    "CreateSnapshotParamsType",
    "DefaultStorageProfileSection_Type",
    "DeployVAppParamsType",
    "DeploymentOptionSection_Type",
    "DhcpPoolServiceType",
    "DhcpServiceType",
    "DiskAttachOrDetachParamsType",
    "DiskCreateParamsType",
    "DiskSection_Type",
    "DiskType",
    "DiskType4",
    "EntityLinkType",
    "EntityReferenceType",
    "EntityType",
    "Entity_Type",
    "EntryType",
    "EntryType1",
    "EntryType2",
    "EntryType3",
    "EnvelopeType",
    "Environment_Type",
    "ErrorType",
    "EulaSection_Type",
    "ExternalNatIpMapType",
    "ExtraConfig_Type",
    "FileType",
    "FileUploadParamsType",
    "FileUploadSocketType",
    "File_Type",
    "FilesListType",
    "FirewallRuleType",
    "FirewallServiceType",
    "GatewayConfigurationType",
    "GatewayDhcpServiceType",
    "GatewayFeaturesType",
    "GatewayInterfaceType",
    "GatewayInterfacesType",
    "GatewayIpsecVpnEndpointType",
    "GatewayIpsecVpnServiceType",
    "GatewayIpsecVpnTunnelType",
    "GatewayNatRuleType",
    "GatewayType",
    "GuestCustomizationSectionType",
    "IconType",
    "IdentifiableResourceType",
    "InstallSection_Type",
    "InstantiateOvfParamsType",
    "InstantiateOvfPropertyType",
    "InstantiateVAppParamsType",
    "InstantiateVAppTemplateParamsType",
    "InstantiateVmHardwareCustomizationParamsType",
    "InstantiateVmParamsType",
    "InstantiationParamsType",
    "IpAddressesType",
    "IpAssignmentSection_Type",
    "IpRangeType",
    "IpRangesType",
    "IpScopeType",
    "IpScopesType",
    "IpsecVpnLocalPeerType",
    "IpsecVpnManagedPeerType",
    "IpsecVpnPeerType",
    "IpsecVpnRemotePeerType",
    "IpsecVpnServiceType",
    "IpsecVpnSubnetType",
    "IpsecVpnThirdPartyPeerType",
    "IpsecVpnTunnelType",
    "IpsecVpnUnmanagedPeerType",
    "ItemType",
    "LBPersistenceType",
    "LBPoolHealthCheckType",
    "LBPoolMemberType",
    "LBPoolServicePortType",
    "LBVirtualServerServiceProfileType",
    "LeaseSettingsSectionType",
    "LevelType",
    "LinkType",
    "LoadBalancerPoolType",
    "LoadBalancerServiceType",
    "LoadBalancerVirtualServerType",
    "LocalityParamsType",
    "MappingBehavior",
    "MediaInsertOrEjectParamsType",
    "MetadataBooleanValue",
    "MetadataDateTimeValue",
    "MetadataDomainTagType",
    "MetadataEntryType",
    "MetadataNumberValue",
    "MetadataStringValue",
    "MetadataType",
    "MetadataTypedValue",
    "MetadataValueType",
    "MsgType",
    "Msg_Type",
    "NatOneToOneBasicRuleType",
    "NatOneToOneVmRuleType",
    "NatPortForwardingRuleType",
    "NatRuleType",
    "NatServiceType",
    "NatVmRuleType",
    "NetworkAssignmentType",
    "NetworkConfigSectionType",
    "NetworkConfigurationType",
    "NetworkConnectionSectionType",
    "NetworkConnectionType",
    "NetworkFeaturesType",
    "NetworkMappingType",
    "NetworkSection_Type",
    "NetworkServiceInsertionType",
    "NetworkServiceType",
    "NetworkType",
    "NetworkType5",
    "NicIpMapType",
    "OperatingSystemSection_Type",
    "OrgNetworkType",
    "OrgVdcNetworkType",
    "OvfToVdcNetworkMapType",
    "OwnerType",
    "ParamsType",
    "PlatformSection_Type",
    "ProductSection_Type",
    "PropertyConfigurationValue_Type",
    "PropertySection_Type",
    "PropertyType",
    "PropertyType6",
    "ProtocolsType",
    "QueryListType",
    "RASD_Type",
    "RasdItemsListType",
    "RecomposeVAppParamsType",
    "ReferenceType",
    "ReferencesType",
    "References_Type",
    "RegisterVAppParamsType",
    "RelocateParamsType",
    "ResourceAllocationSection_Type",
    "ResourceEntitiesType",
    "ResourceEntityType",
    "ResourceReferenceType",
    "ResourceType",
    "RouterInfoType",
    "RuntimeInfoSectionType",
    "Section_Type",
    "SnapshotSectionType",
    "SnapshotType",
    "SourcedCompositionItemParamType",
    "SourcedVmInstantiationParamsType",
    "StartupSection_Type",
    "StaticRouteType",
    "StaticRoutingServiceType",
    "Strings_Type",
    "SubAllocationType",
    "SubAllocationsType",
    "SubnetParticipationType",
    "SupportedHardwareVersionsType",
    "SyslogServerSettingsType",
    "TaskOperationListType",
    "TaskType",
    "TasksInProgressType",
    "UndeployVAppParamsType",
    "VAppChildrenType",
    "VAppCreationParamsType",
    "VAppNetworkConfigurationType",
    "VAppNetworkType",
    "VAppType",
    "VCloudExtensibleType",
    "VCloudExtensionType",
    "VMWareToolsType",
    "VSSD_Type",
    "VdcStorageProfileType",
    "VdcStorageProfilesType",
    "VdcType",
    "VdcsType",
    "VendorServicesType",
    "VendorTemplateAttributesType",
    "VendorTemplateType",
    "VirtualDiskDesc_Type",
    "VirtualHardwareSection_Type",
    "VirtualSystemCollection_Type",
    "VirtualSystem_Type",
    "VmCapabilitiesType",
    "VmGeneralParamsType",
    "VmPendingQuestionType",
    "VmQuestionAnswerChoiceType",
    "VmQuestionAnswerType",
    "VmSelectionType",
    "VmType",
    "VsToVmxMapType",
    "cimAnySimpleType",
    "cimBase64Binary",
    "cimBoolean",
    "cimByte",
    "cimChar16",
    "cimDateTime",
    "cimDouble",
    "cimFloat",
    "cimHexBinary",
    "cimInt",
    "cimLong",
    "cimReference",
    "cimShort",
    "cimString",
    "cimUnsignedByte",
    "cimUnsignedInt",
    "cimUnsignedLong",
    "cimUnsignedShort",
    "qualifierBoolean",
    "qualifierSArray",
    "qualifierSInt64",
    "qualifierString",
    "qualifierUInt32"
]
