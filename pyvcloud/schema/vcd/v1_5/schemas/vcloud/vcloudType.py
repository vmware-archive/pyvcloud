# VMware vCloud Python SDK
# Copyright (c) 2014 VMware, Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Nov  3 21:30:10 2014 by generateDS.py version 2.13a.
#
# Command line options:
#   ('-o', 'schema/vcd/v1.5/schemas/vcloud/vcloudType.py')
#
# Command line arguments:
#   schema/vcd/v1.5/schemas/vcloud/vcloud.xsd
#
# Command line:
#   ../env/bin/generateDS.py -o "schema/vcd/v1.5/schemas/vcloud/vcloudType.py" schema/vcd/v1.5/schemas/vcloud/vcloud.xsd
#
# Current working directory (os.getcwd()):
#   src
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class VCloudExtensionType(GeneratedsSuper):
    """0.9 General purpose extension element. Not related to extension
    services. always True if the request should fail when the server
    does not understand the extension. false"""
    subclass = None
    superclass = None
    def __init__(self, required=True, anytypeobjs_=None):
        self.original_tagname_ = None
        self.required = _cast(bool, required)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if VCloudExtensionType.subclass:
            return VCloudExtensionType.subclass(*args_, **kwargs_)
        else:
            return VCloudExtensionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_required(self): return self.required
    def set_required(self, required): self.required = required
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VCloudExtensionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VCloudExtensionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VCloudExtensionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VCloudExtensionType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required="%s"' % self.gds_format_boolean(self.required, input_name='required'))
    def exportChildren(self, outfile, level, namespace_='', name_='VCloudExtensionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VCloudExtensionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            showIndent(outfile, level)
            outfile.write('required=%s,\n' % (self.required,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            if value in ('true', '1'):
                self.required = True
            elif value in ('false', '0'):
                self.required = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'VCloudExtensionType')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class VCloudExtensionType


class VCloudExtensibleType(GeneratedsSuper):
    """0.9 A base abstract type for all complex types that support
    extensions."""
    subclass = None
    superclass = None
    def __init__(self, VCloudExtension=None, extensiontype_=None):
        self.original_tagname_ = None
        if VCloudExtension is None:
            self.VCloudExtension = []
        else:
            self.VCloudExtension = VCloudExtension
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if VCloudExtensibleType.subclass:
            return VCloudExtensibleType.subclass(*args_, **kwargs_)
        else:
            return VCloudExtensibleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VCloudExtension(self): return self.VCloudExtension
    def set_VCloudExtension(self, VCloudExtension): self.VCloudExtension = VCloudExtension
    def add_VCloudExtension(self, value): self.VCloudExtension.append(value)
    def insert_VCloudExtension_at(self, index, value): self.VCloudExtension.insert(index, value)
    def replace_VCloudExtension_at(self, index, value): self.VCloudExtension[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.VCloudExtension
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VCloudExtensibleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VCloudExtensibleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VCloudExtensibleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VCloudExtensibleType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VCloudExtensibleType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VCloudExtension_ in self.VCloudExtension:
            VCloudExtension_.export(outfile, level, namespace_, name_='VCloudExtension', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VCloudExtensibleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('VCloudExtension=[\n')
        level += 1
        for VCloudExtension_ in self.VCloudExtension:
            showIndent(outfile, level)
            outfile.write('model_.VCloudExtensionType(\n')
            VCloudExtension_.exportLiteral(outfile, level, name_='VCloudExtensionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VCloudExtension':
            obj_ = VCloudExtensionType.factory()
            obj_.build(child_)
            self.VCloudExtension.append(obj_)
            obj_.original_tagname_ = 'VCloudExtension'
# end class VCloudExtensibleType


class ErrorType(VCloudExtensibleType):
    """0.9 The standard error message type used in the vCloud REST API.
    none An one line, human-readable message describing the error
    that occurred. truenone The class of the error. Matches the HTTP
    status code. truenone Resource-specific error code. truenone A
    vendor- or implementation-specific error code that can reference
    specific modules or source lines for diagnostic purposes.
    false1.0none The stack trace of the exception. false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, vendorSpecificErrorCode=None, stackTrace=None, message=None, minorErrorCode=None, majorErrorCode=None):
        self.original_tagname_ = None
        super(ErrorType, self).__init__(VCloudExtension, )
        self.vendorSpecificErrorCode = _cast(None, vendorSpecificErrorCode)
        self.stackTrace = _cast(None, stackTrace)
        self.message = _cast(None, message)
        self.minorErrorCode = _cast(None, minorErrorCode)
        self.majorErrorCode = _cast(int, majorErrorCode)
    def factory(*args_, **kwargs_):
        if ErrorType.subclass:
            return ErrorType.subclass(*args_, **kwargs_)
        else:
            return ErrorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendorSpecificErrorCode(self): return self.vendorSpecificErrorCode
    def set_vendorSpecificErrorCode(self, vendorSpecificErrorCode): self.vendorSpecificErrorCode = vendorSpecificErrorCode
    def get_stackTrace(self): return self.stackTrace
    def set_stackTrace(self, stackTrace): self.stackTrace = stackTrace
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_minorErrorCode(self): return self.minorErrorCode
    def set_minorErrorCode(self, minorErrorCode): self.minorErrorCode = minorErrorCode
    def get_majorErrorCode(self): return self.majorErrorCode
    def set_majorErrorCode(self, majorErrorCode): self.majorErrorCode = majorErrorCode
    def hasContent_(self):
        if (
            super(ErrorType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ErrorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ErrorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ErrorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ErrorType'):
        super(ErrorType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ErrorType')
        if self.vendorSpecificErrorCode is not None and 'vendorSpecificErrorCode' not in already_processed:
            already_processed.add('vendorSpecificErrorCode')
            outfile.write(' vendorSpecificErrorCode=%s' % (self.gds_format_string(quote_attrib(self.vendorSpecificErrorCode).encode(ExternalEncoding), input_name='vendorSpecificErrorCode'), ))
        if self.stackTrace is not None and 'stackTrace' not in already_processed:
            already_processed.add('stackTrace')
            outfile.write(' stackTrace=%s' % (self.gds_format_string(quote_attrib(self.stackTrace).encode(ExternalEncoding), input_name='stackTrace'), ))
        if self.message is not None and 'message' not in already_processed:
            already_processed.add('message')
            outfile.write(' message=%s' % (self.gds_format_string(quote_attrib(self.message).encode(ExternalEncoding), input_name='message'), ))
        if self.minorErrorCode is not None and 'minorErrorCode' not in already_processed:
            already_processed.add('minorErrorCode')
            outfile.write(' minorErrorCode=%s' % (self.gds_format_string(quote_attrib(self.minorErrorCode).encode(ExternalEncoding), input_name='minorErrorCode'), ))
        if self.majorErrorCode is not None and 'majorErrorCode' not in already_processed:
            already_processed.add('majorErrorCode')
            outfile.write(' majorErrorCode="%s"' % self.gds_format_integer(self.majorErrorCode, input_name='majorErrorCode'))
    def exportChildren(self, outfile, level, namespace_='', name_='ErrorType', fromsubclass_=False, pretty_print=True):
        super(ErrorType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ErrorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vendorSpecificErrorCode is not None and 'vendorSpecificErrorCode' not in already_processed:
            already_processed.add('vendorSpecificErrorCode')
            showIndent(outfile, level)
            outfile.write('vendorSpecificErrorCode="%s",\n' % (self.vendorSpecificErrorCode,))
        if self.stackTrace is not None and 'stackTrace' not in already_processed:
            already_processed.add('stackTrace')
            showIndent(outfile, level)
            outfile.write('stackTrace="%s",\n' % (self.stackTrace,))
        if self.message is not None and 'message' not in already_processed:
            already_processed.add('message')
            showIndent(outfile, level)
            outfile.write('message="%s",\n' % (self.message,))
        if self.minorErrorCode is not None and 'minorErrorCode' not in already_processed:
            already_processed.add('minorErrorCode')
            showIndent(outfile, level)
            outfile.write('minorErrorCode="%s",\n' % (self.minorErrorCode,))
        if self.majorErrorCode is not None and 'majorErrorCode' not in already_processed:
            already_processed.add('majorErrorCode')
            showIndent(outfile, level)
            outfile.write('majorErrorCode=%d,\n' % (self.majorErrorCode,))
        super(ErrorType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ErrorType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vendorSpecificErrorCode', node)
        if value is not None and 'vendorSpecificErrorCode' not in already_processed:
            already_processed.add('vendorSpecificErrorCode')
            self.vendorSpecificErrorCode = value
        value = find_attr_value_('stackTrace', node)
        if value is not None and 'stackTrace' not in already_processed:
            already_processed.add('stackTrace')
            self.stackTrace = value
        value = find_attr_value_('message', node)
        if value is not None and 'message' not in already_processed:
            already_processed.add('message')
            self.message = value
        value = find_attr_value_('minorErrorCode', node)
        if value is not None and 'minorErrorCode' not in already_processed:
            already_processed.add('minorErrorCode')
            self.minorErrorCode = value
        value = find_attr_value_('majorErrorCode', node)
        if value is not None and 'majorErrorCode' not in already_processed:
            already_processed.add('majorErrorCode')
            try:
                self.majorErrorCode = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(ErrorType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ErrorType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ErrorType


class ResourceType(VCloudExtensibleType):
    """0.9 The base type for all objects in the vCloud model. Has an
    optional list of links and href and type attributes. always The
    URI of the entity. falsealways The MIME type of the entity.
    false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, href=None, type_=None, Link=None):
        self.original_tagname_ = None
        super(ResourceType, self).__init__(VCloudExtension, )
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
    def factory(*args_, **kwargs_):
        if ResourceType.subclass:
            return ResourceType.subclass(*args_, **kwargs_)
        else:
            return ResourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def add_Link(self, value): self.Link.append(value)
    def insert_Link_at(self, index, value): self.Link.insert(index, value)
    def replace_Link_at(self, index, value): self.Link[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.Link or
            super(ResourceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceType'):
        super(ResourceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceType', fromsubclass_=False, pretty_print=True):
        super(ResourceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResourceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(ResourceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResourceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            Link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(ResourceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.Link.append(obj_)
            obj_.original_tagname_ = 'Link'
        super(ResourceType, self).buildChildren(child_, node, nodeName_, True)
# end class ResourceType


class IdentifiableResourceType(ResourceType):
    """0.9 The base type for all resource types which contain an id
    attribute. none The entity identifier, expressed in URN format.
    The value of this attribute uniquely identifies the entity,
    persists for the life of the entity, and is never reused.
    falsecreate Optional unique identifier to support idempotent
    semantics for create and delete operations. false"""
    subclass = None
    superclass = ResourceType
    def __init__(self, operationKey=None, id=None, extensiontype_=None):
        self.original_tagname_ = None
        super(IdentifiableResourceType, self).__init__(extensiontype_, )
        self.operationKey = _cast(None, operationKey)
        self.id = _cast(None, id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if IdentifiableResourceType.subclass:
            return IdentifiableResourceType.subclass(*args_, **kwargs_)
        else:
            return IdentifiableResourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_operationKey(self): return self.operationKey
    def set_operationKey(self, operationKey): self.operationKey = operationKey
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(IdentifiableResourceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiableResourceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiableResourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiableResourceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiableResourceType'):
        super(IdentifiableResourceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiableResourceType')
        if self.operationKey is not None and 'operationKey' not in already_processed:
            already_processed.add('operationKey')
            outfile.write(' operationKey=%s' % (self.gds_format_string(quote_attrib(self.operationKey).encode(ExternalEncoding), input_name='operationKey'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiableResourceType', fromsubclass_=False, pretty_print=True):
        super(IdentifiableResourceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='IdentifiableResourceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.operationKey is not None and 'operationKey' not in already_processed:
            already_processed.add('operationKey')
            showIndent(outfile, level)
            outfile.write('operationKey="%s",\n' % (self.operationKey,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        super(IdentifiableResourceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IdentifiableResourceType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('operationKey', node)
        if value is not None and 'operationKey' not in already_processed:
            already_processed.add('operationKey')
            self.operationKey = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IdentifiableResourceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IdentifiableResourceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IdentifiableResourceType


class ParamsType(VCloudExtensibleType):
    """0.9 A basic type used to specify request parameters. always
    Typically used to name or identify the subject of the request.
    For example, the name of the object being created or modified.
    false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, name=None, Description=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ParamsType, self).__init__(VCloudExtension, extensiontype_, )
        self.name = _cast(None, name)
        self.Description = Description
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ParamsType.subclass:
            return ParamsType.subclass(*args_, **kwargs_)
        else:
            return ParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Description is not None or
            super(ParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ParamsType'):
        super(ParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ParamsType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ParamsType', fromsubclass_=False, pretty_print=True):
        super(ParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(ParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        super(ParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class ParamsType


class ReferenceType(VCloudExtensibleType):
    """0.9 A reference to a resource. Contains an href attribute and
    optional name and type attributes. always Contains the URI to
    the entity. truealways The resource identifier, expressed in URN
    format. The value of this attribute uniquely identifies the
    resource, persists for the life of the resource, and is never
    reused. falsealways Contains the type of the the entity.
    falsealways Contains the name of the the entity. false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, href=None, type_=None, id=None, name=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ReferenceType, self).__init__(VCloudExtension, extensiontype_, )
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(ReferenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceType'):
        super(ReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        super(ReferenceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(ReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReferenceType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ReferenceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ReferenceType


class ResourceReferenceType(ReferenceType):
    """0.9 Represents a reference to a resource. Contains an href
    attribute, a resource status attribute, and optional name and
    type attributes. none Status of a resource. false"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, VCloudExtension=None, href=None, type_=None, id=None, name=None, status=None):
        self.original_tagname_ = None
        super(ResourceReferenceType, self).__init__(VCloudExtension, href, type_, id, name, )
        self.status = _cast(int, status)
    def factory(*args_, **kwargs_):
        if ResourceReferenceType.subclass:
            return ResourceReferenceType.subclass(*args_, **kwargs_)
        else:
            return ResourceReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def hasContent_(self):
        if (
            super(ResourceReferenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceReferenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceReferenceType'):
        super(ResourceReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceReferenceType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status="%s"' % self.gds_format_integer(self.status, input_name='status'))
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceReferenceType', fromsubclass_=False, pretty_print=True):
        super(ResourceReferenceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResourceReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % (self.status,))
        super(ResourceReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResourceReferenceType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            try:
                self.status = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(ResourceReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ResourceReferenceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ResourceReferenceType


class ContainerType(ResourceType):
    """Container for query result sets. none Query name that generated this
    result set. falsenone Page of the result set that this container
    holds. The first page is page number 1. falsenone Page size, as
    a number of records or references. falsenone Total number of
    records or references in the container. false"""
    subclass = None
    superclass = ResourceType
    def __init__(self, total=None, name=None, pageSize=None, page=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ContainerType, self).__init__(extensiontype_, )
        self.total = _cast(int, total)
        self.name = _cast(None, name)
        self.pageSize = _cast(int, pageSize)
        self.page = _cast(int, page)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ContainerType.subclass:
            return ContainerType.subclass(*args_, **kwargs_)
        else:
            return ContainerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_total(self): return self.total
    def set_total(self, total): self.total = total
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_pageSize(self): return self.pageSize
    def set_pageSize(self, pageSize): self.pageSize = pageSize
    def get_page(self): return self.page
    def set_page(self, page): self.page = page
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(ContainerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ContainerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContainerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ContainerType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ContainerType'):
        super(ContainerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ContainerType')
        if self.total is not None and 'total' not in already_processed:
            already_processed.add('total')
            outfile.write(' total="%s"' % self.gds_format_integer(self.total, input_name='total'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.pageSize is not None and 'pageSize' not in already_processed:
            already_processed.add('pageSize')
            outfile.write(' pageSize="%s"' % self.gds_format_integer(self.pageSize, input_name='pageSize'))
        if self.page is not None and 'page' not in already_processed:
            already_processed.add('page')
            outfile.write(' page="%s"' % self.gds_format_integer(self.page, input_name='page'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ContainerType', fromsubclass_=False, pretty_print=True):
        super(ContainerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ContainerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.total is not None and 'total' not in already_processed:
            already_processed.add('total')
            showIndent(outfile, level)
            outfile.write('total=%d,\n' % (self.total,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.pageSize is not None and 'pageSize' not in already_processed:
            already_processed.add('pageSize')
            showIndent(outfile, level)
            outfile.write('pageSize=%d,\n' % (self.pageSize,))
        if self.page is not None and 'page' not in already_processed:
            already_processed.add('page')
            showIndent(outfile, level)
            outfile.write('page=%d,\n' % (self.page,))
        super(ContainerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ContainerType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('total', node)
        if value is not None and 'total' not in already_processed:
            already_processed.add('total')
            try:
                self.total = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('pageSize', node)
        if value is not None and 'pageSize' not in already_processed:
            already_processed.add('pageSize')
            try:
                self.pageSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('page', node)
        if value is not None and 'page' not in already_processed:
            already_processed.add('page')
            try:
                self.page = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ContainerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ContainerType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ContainerType


class CapacityType(VCloudExtensibleType):
    """0.9 Represents the capacity of a given resource."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Units=None, Allocated=None, Limit=None, extensiontype_=None):
        self.original_tagname_ = None
        super(CapacityType, self).__init__(VCloudExtension, extensiontype_, )
        self.Units = Units
        self.Allocated = Allocated
        self.Limit = Limit
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CapacityType.subclass:
            return CapacityType.subclass(*args_, **kwargs_)
        else:
            return CapacityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def get_Allocated(self): return self.Allocated
    def set_Allocated(self, Allocated): self.Allocated = Allocated
    def get_Limit(self): return self.Limit
    def set_Limit(self, Limit): self.Limit = Limit
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Units is not None or
            self.Allocated is not None or
            self.Limit is not None or
            super(CapacityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CapacityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CapacityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CapacityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CapacityType'):
        super(CapacityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CapacityType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='CapacityType', fromsubclass_=False, pretty_print=True):
        super(CapacityType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnits>%s</%sUnits>%s' % (namespace_, self.gds_format_string(quote_xml(self.Units).encode(ExternalEncoding), input_name='Units'), namespace_, eol_))
        if self.Allocated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllocated>%s</%sAllocated>%s' % (namespace_, self.gds_format_integer(self.Allocated, input_name='Allocated'), namespace_, eol_))
        if self.Limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLimit>%s</%sLimit>%s' % (namespace_, self.gds_format_integer(self.Limit, input_name='Limit'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CapacityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CapacityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CapacityType, self).exportLiteralChildren(outfile, level, name_)
        if self.Units is not None:
            showIndent(outfile, level)
            outfile.write('Units=%s,\n' % quote_python(self.Units).encode(ExternalEncoding))
        if self.Allocated is not None:
            showIndent(outfile, level)
            outfile.write('Allocated=%d,\n' % self.Allocated)
        if self.Limit is not None:
            showIndent(outfile, level)
            outfile.write('Limit=%d,\n' % self.Limit)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CapacityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Units':
            Units_ = child_.text
            Units_ = self.gds_validate_string(Units_, node, 'Units')
            self.Units = Units_
        elif nodeName_ == 'Allocated':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Allocated')
            self.Allocated = ival_
        elif nodeName_ == 'Limit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Limit')
            self.Limit = ival_
        super(CapacityType, self).buildChildren(child_, node, nodeName_, True)
# end class CapacityType


class CapacityWithUsageType(CapacityType):
    """0.9 Represents a capacity and usage of a given resource."""
    subclass = None
    superclass = CapacityType
    def __init__(self, VCloudExtension=None, Units=None, Allocated=None, Limit=None, Reserved=None, Used=None, Overhead=None):
        self.original_tagname_ = None
        super(CapacityWithUsageType, self).__init__(VCloudExtension, Units, Allocated, Limit, )
        self.Reserved = Reserved
        self.Used = Used
        self.Overhead = Overhead
    def factory(*args_, **kwargs_):
        if CapacityWithUsageType.subclass:
            return CapacityWithUsageType.subclass(*args_, **kwargs_)
        else:
            return CapacityWithUsageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reserved(self): return self.Reserved
    def set_Reserved(self, Reserved): self.Reserved = Reserved
    def get_Used(self): return self.Used
    def set_Used(self, Used): self.Used = Used
    def get_Overhead(self): return self.Overhead
    def set_Overhead(self, Overhead): self.Overhead = Overhead
    def hasContent_(self):
        if (
            self.Reserved is not None or
            self.Used is not None or
            self.Overhead is not None or
            super(CapacityWithUsageType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CapacityWithUsageType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CapacityWithUsageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CapacityWithUsageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CapacityWithUsageType'):
        super(CapacityWithUsageType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CapacityWithUsageType')
    def exportChildren(self, outfile, level, namespace_='', name_='CapacityWithUsageType', fromsubclass_=False, pretty_print=True):
        super(CapacityWithUsageType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Reserved is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReserved>%s</%sReserved>%s' % (namespace_, self.gds_format_integer(self.Reserved, input_name='Reserved'), namespace_, eol_))
        if self.Used is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUsed>%s</%sUsed>%s' % (namespace_, self.gds_format_integer(self.Used, input_name='Used'), namespace_, eol_))
        if self.Overhead is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOverhead>%s</%sOverhead>%s' % (namespace_, self.gds_format_integer(self.Overhead, input_name='Overhead'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CapacityWithUsageType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CapacityWithUsageType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CapacityWithUsageType, self).exportLiteralChildren(outfile, level, name_)
        if self.Reserved is not None:
            showIndent(outfile, level)
            outfile.write('Reserved=%d,\n' % self.Reserved)
        if self.Used is not None:
            showIndent(outfile, level)
            outfile.write('Used=%d,\n' % self.Used)
        if self.Overhead is not None:
            showIndent(outfile, level)
            outfile.write('Overhead=%d,\n' % self.Overhead)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CapacityWithUsageType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reserved':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Reserved')
            self.Reserved = ival_
        elif nodeName_ == 'Used':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Used')
            self.Used = ival_
        elif nodeName_ == 'Overhead':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Overhead')
            self.Overhead = ival_
        super(CapacityWithUsageType, self).buildChildren(child_, node, nodeName_, True)
# end class CapacityWithUsageType


class AccessSettingType(VCloudExtensibleType):
    """0.9 Controls access to the resource."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Subject=None, AccessLevel=None):
        self.original_tagname_ = None
        super(AccessSettingType, self).__init__(VCloudExtension, )
        self.Subject = Subject
        self.AccessLevel = AccessLevel
    def factory(*args_, **kwargs_):
        if AccessSettingType.subclass:
            return AccessSettingType.subclass(*args_, **kwargs_)
        else:
            return AccessSettingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Subject(self): return self.Subject
    def set_Subject(self, Subject): self.Subject = Subject
    def get_AccessLevel(self): return self.AccessLevel
    def set_AccessLevel(self, AccessLevel): self.AccessLevel = AccessLevel
    def hasContent_(self):
        if (
            self.Subject is not None or
            self.AccessLevel is not None or
            super(AccessSettingType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccessSettingType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccessSettingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccessSettingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccessSettingType'):
        super(AccessSettingType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AccessSettingType')
    def exportChildren(self, outfile, level, namespace_='', name_='AccessSettingType', fromsubclass_=False, pretty_print=True):
        super(AccessSettingType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Subject is not None:
            self.Subject.export(outfile, level, namespace_, name_='Subject', pretty_print=pretty_print)
        if self.AccessLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAccessLevel>%s</%sAccessLevel>%s' % (namespace_, self.gds_format_string(quote_xml(self.AccessLevel).encode(ExternalEncoding), input_name='AccessLevel'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AccessSettingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AccessSettingType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AccessSettingType, self).exportLiteralChildren(outfile, level, name_)
        if self.Subject is not None:
            showIndent(outfile, level)
            outfile.write('Subject=model_.ReferenceType(\n')
            self.Subject.exportLiteral(outfile, level, name_='Subject')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AccessLevel is not None:
            showIndent(outfile, level)
            outfile.write('AccessLevel=%s,\n' % quote_python(self.AccessLevel).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AccessSettingType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Subject':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Subject = obj_
            obj_.original_tagname_ = 'Subject'
        elif nodeName_ == 'AccessLevel':
            AccessLevel_ = child_.text
            AccessLevel_ = self.gds_validate_string(AccessLevel_, node, 'AccessLevel')
            self.AccessLevel = AccessLevel_
        super(AccessSettingType, self).buildChildren(child_, node, nodeName_, True)
# end class AccessSettingType


class AccessSettingsType(VCloudExtensibleType):
    """0.9 A list of access settings for a resource."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, AccessSetting=None):
        self.original_tagname_ = None
        super(AccessSettingsType, self).__init__(VCloudExtension, )
        if AccessSetting is None:
            self.AccessSetting = []
        else:
            self.AccessSetting = AccessSetting
    def factory(*args_, **kwargs_):
        if AccessSettingsType.subclass:
            return AccessSettingsType.subclass(*args_, **kwargs_)
        else:
            return AccessSettingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AccessSetting(self): return self.AccessSetting
    def set_AccessSetting(self, AccessSetting): self.AccessSetting = AccessSetting
    def add_AccessSetting(self, value): self.AccessSetting.append(value)
    def insert_AccessSetting_at(self, index, value): self.AccessSetting.insert(index, value)
    def replace_AccessSetting_at(self, index, value): self.AccessSetting[index] = value
    def hasContent_(self):
        if (
            self.AccessSetting or
            super(AccessSettingsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccessSettingsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccessSettingsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccessSettingsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccessSettingsType'):
        super(AccessSettingsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AccessSettingsType')
    def exportChildren(self, outfile, level, namespace_='', name_='AccessSettingsType', fromsubclass_=False, pretty_print=True):
        super(AccessSettingsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AccessSetting_ in self.AccessSetting:
            AccessSetting_.export(outfile, level, namespace_, name_='AccessSetting', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AccessSettingsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AccessSettingsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AccessSettingsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('AccessSetting=[\n')
        level += 1
        for AccessSetting_ in self.AccessSetting:
            showIndent(outfile, level)
            outfile.write('model_.AccessSettingType(\n')
            AccessSetting_.exportLiteral(outfile, level, name_='AccessSettingType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AccessSettingsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AccessSetting':
            obj_ = AccessSettingType.factory()
            obj_.build(child_)
            self.AccessSetting.append(obj_)
            obj_.original_tagname_ = 'AccessSetting'
        super(AccessSettingsType, self).buildChildren(child_, node, nodeName_, True)
# end class AccessSettingsType


class ControlAccessParamsType(VCloudExtensibleType):
    """0.9 Specifies access controls for a resource."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsSharedToEveryone=None, EveryoneAccessLevel=None, AccessSettings=None):
        self.original_tagname_ = None
        super(ControlAccessParamsType, self).__init__(VCloudExtension, )
        self.IsSharedToEveryone = IsSharedToEveryone
        self.EveryoneAccessLevel = EveryoneAccessLevel
        self.AccessSettings = AccessSettings
    def factory(*args_, **kwargs_):
        if ControlAccessParamsType.subclass:
            return ControlAccessParamsType.subclass(*args_, **kwargs_)
        else:
            return ControlAccessParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsSharedToEveryone(self): return self.IsSharedToEveryone
    def set_IsSharedToEveryone(self, IsSharedToEveryone): self.IsSharedToEveryone = IsSharedToEveryone
    def get_EveryoneAccessLevel(self): return self.EveryoneAccessLevel
    def set_EveryoneAccessLevel(self, EveryoneAccessLevel): self.EveryoneAccessLevel = EveryoneAccessLevel
    def get_AccessSettings(self): return self.AccessSettings
    def set_AccessSettings(self, AccessSettings): self.AccessSettings = AccessSettings
    def hasContent_(self):
        if (
            self.IsSharedToEveryone is not None or
            self.EveryoneAccessLevel is not None or
            self.AccessSettings is not None or
            super(ControlAccessParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ControlAccessParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ControlAccessParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ControlAccessParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ControlAccessParamsType'):
        super(ControlAccessParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ControlAccessParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='ControlAccessParamsType', fromsubclass_=False, pretty_print=True):
        super(ControlAccessParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsSharedToEveryone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsSharedToEveryone>%s</%sIsSharedToEveryone>%s' % (namespace_, self.gds_format_boolean(self.IsSharedToEveryone, input_name='IsSharedToEveryone'), namespace_, eol_))
        if self.EveryoneAccessLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEveryoneAccessLevel>%s</%sEveryoneAccessLevel>%s' % (namespace_, self.gds_format_string(quote_xml(self.EveryoneAccessLevel).encode(ExternalEncoding), input_name='EveryoneAccessLevel'), namespace_, eol_))
        if self.AccessSettings is not None:
            self.AccessSettings.export(outfile, level, namespace_, name_='AccessSettings', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ControlAccessParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ControlAccessParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ControlAccessParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsSharedToEveryone is not None:
            showIndent(outfile, level)
            outfile.write('IsSharedToEveryone=%s,\n' % self.IsSharedToEveryone)
        if self.EveryoneAccessLevel is not None:
            showIndent(outfile, level)
            outfile.write('EveryoneAccessLevel=%s,\n' % quote_python(self.EveryoneAccessLevel).encode(ExternalEncoding))
        if self.AccessSettings is not None:
            showIndent(outfile, level)
            outfile.write('AccessSettings=model_.AccessSettingsType(\n')
            self.AccessSettings.exportLiteral(outfile, level, name_='AccessSettings')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ControlAccessParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsSharedToEveryone':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsSharedToEveryone')
            self.IsSharedToEveryone = ival_
        elif nodeName_ == 'EveryoneAccessLevel':
            EveryoneAccessLevel_ = child_.text
            EveryoneAccessLevel_ = self.gds_validate_string(EveryoneAccessLevel_, node, 'EveryoneAccessLevel')
            self.EveryoneAccessLevel = EveryoneAccessLevel_
        elif nodeName_ == 'AccessSettings':
            obj_ = AccessSettingsType.factory()
            obj_.build(child_)
            self.AccessSettings = obj_
            obj_.original_tagname_ = 'AccessSettings'
        super(ControlAccessParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class ControlAccessParamsType


class OwnerType(ResourceType):
    """1.5 Represents the owner of this entity."""
    subclass = None
    superclass = ResourceType
    def __init__(self, User=None):
        self.original_tagname_ = None
        super(OwnerType, self).__init__()
        self.User = User
    def factory(*args_, **kwargs_):
        if OwnerType.subclass:
            return OwnerType.subclass(*args_, **kwargs_)
        else:
            return OwnerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_User(self): return self.User
    def set_User(self, User): self.User = User
    def hasContent_(self):
        if (
            self.User is not None or
            super(OwnerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OwnerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OwnerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OwnerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OwnerType'):
        super(OwnerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OwnerType')
    def exportChildren(self, outfile, level, namespace_='', name_='OwnerType', fromsubclass_=False, pretty_print=True):
        super(OwnerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.User is not None:
            self.User.export(outfile, level, namespace_, name_='User', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OwnerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OwnerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OwnerType, self).exportLiteralChildren(outfile, level, name_)
        if self.User is not None:
            showIndent(outfile, level)
            outfile.write('User=model_.ReferenceType(\n')
            self.User.exportLiteral(outfile, level, name_='User')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OwnerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'User':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.User = obj_
            obj_.original_tagname_ = 'User'
        super(OwnerType, self).buildChildren(child_, node, nodeName_, True)
# end class OwnerType


class ReferencesType(ContainerType):
    """Container for query results returned in references format."""
    subclass = None
    superclass = ContainerType
    def __init__(self, total=None, name=None, pageSize=None, page=None, Reference=None):
        self.original_tagname_ = None
        super(ReferencesType, self).__init__(total, name, pageSize, page, )
        if Reference is None:
            self.Reference = []
        else:
            self.Reference = Reference
    def factory(*args_, **kwargs_):
        if ReferencesType.subclass:
            return ReferencesType.subclass(*args_, **kwargs_)
        else:
            return ReferencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reference(self): return self.Reference
    def set_Reference(self, Reference): self.Reference = Reference
    def add_Reference(self, value): self.Reference.append(value)
    def insert_Reference_at(self, index, value): self.Reference.insert(index, value)
    def replace_Reference_at(self, index, value): self.Reference[index] = value
    def hasContent_(self):
        if (
            self.Reference or
            super(ReferencesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferencesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferencesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferencesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferencesType'):
        super(ReferencesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReferencesType')
    def exportChildren(self, outfile, level, namespace_='', name_='ReferencesType', fromsubclass_=False, pretty_print=True):
        super(ReferencesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reference_ in self.Reference:
            Reference_.export(outfile, level, namespace_, name_='Reference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferencesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ReferencesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReferencesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Reference=[\n')
        level += 1
        for Reference_ in self.Reference:
            showIndent(outfile, level)
            outfile.write('model_.Reference(\n')
            Reference_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReferencesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'Reference'
        elif nodeName_ == 'OrgReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'OrgReference'
        elif nodeName_ == 'OrgVdcReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'OrgVdcReference'
        elif nodeName_ == 'MediaReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'MediaReference'
        elif nodeName_ == 'VAppTemplateReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'VAppTemplateReference'
        elif nodeName_ == 'VAppReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'VAppReference'
        elif nodeName_ == 'VMReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'VMReference'
        elif nodeName_ == 'OrgNetworkReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'OrgNetworkReference'
        elif nodeName_ == 'VAppNetworkReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'VAppNetworkReference'
        elif nodeName_ == 'CatalogReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'CatalogReference'
        elif nodeName_ == 'AdminVdcReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'AdminVdcReference'
        elif nodeName_ == 'VMWProviderVdcReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'VMWProviderVdcReference'
        elif nodeName_ == 'NetworkReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'NetworkReference'
        elif nodeName_ == 'GroupReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'GroupReference'
        elif nodeName_ == 'UserReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'UserReference'
        elif nodeName_ == 'RoleReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'RoleReference'
        elif nodeName_ == 'DatastoreReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'DatastoreReference'
        elif nodeName_ == 'NetworkPoolReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'NetworkPoolReference'
        elif nodeName_ == 'VirtualCenterReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'VirtualCenterReference'
        elif nodeName_ == 'HostReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'HostReference'
        elif nodeName_ == 'RightReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'RightReference'
        elif nodeName_ == 'VAppOrgNetworkRelationReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'VAppOrgNetworkRelationReference'
        elif nodeName_ == 'CatalogItemReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'CatalogItemReference'
        elif nodeName_ == 'TaskReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'TaskReference'
        elif nodeName_ == 'BlockingTaskReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'BlockingTaskReference'
        elif nodeName_ == 'DiskReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'DiskReference'
        elif nodeName_ == 'AdminDiskReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'AdminDiskReference'
        elif nodeName_ == 'AdminEventReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'AdminEventReference'
        elif nodeName_ == 'StrandedItemReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'StrandedItemReference'
        elif nodeName_ == 'AdminServiceReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'AdminServiceReference'
        elif nodeName_ == 'ServiceReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'ServiceReference'
        elif nodeName_ == 'ServiceLinkReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'ServiceLinkReference'
        elif nodeName_ == 'OrgVdcStorageProfileReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'OrgVdcStorageProfileReference'
        elif nodeName_ == 'AdminOrgVdcStorageProfileReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'AdminOrgVdcStorageProfileReference'
        elif nodeName_ == 'ProviderVdcStorageProfileReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'ProviderVdcStorageProfileReference'
        elif nodeName_ == 'ApiFilterReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'ApiFilterReference'
        elif nodeName_ == 'AdminApiDefinitionReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'AdminApiDefinitionReference'
        elif nodeName_ == 'ApiDefinitionReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'ApiDefinitionReference'
        elif nodeName_ == 'AdminFileDescriptorReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'AdminFileDescriptorReference'
        elif nodeName_ == 'ResourceClassActionReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'ResourceClassActionReference'
        elif nodeName_ == 'AclRuleReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'AclRuleReference'
        elif nodeName_ == 'ResourceClassReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'ResourceClassReference'
        elif nodeName_ == 'ServiceResourceResourceReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'ServiceResourceResourceReference'
        elif nodeName_ == 'EdgeGatewayReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'EdgeGatewayReference'
        elif nodeName_ == 'OrgVdcNetworkReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'OrgVdcNetworkReference'
        elif nodeName_ == 'VAppOrgVdcNetworkRelationReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'VAppOrgVdcNetworkRelationReference'
        elif nodeName_ == 'ToCloudTunnelReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Reference.append(obj_)
            obj_.original_tagname_ = 'ToCloudTunnelReference'
        super(ReferencesType, self).buildChildren(child_, node, nodeName_, True)
# end class ReferencesType


class QueryListType(ContainerType):
    """Container for the list of typed queries available to the requesting
    user."""
    subclass = None
    superclass = ContainerType
    def __init__(self, total=None, name=None, pageSize=None, page=None):
        self.original_tagname_ = None
        super(QueryListType, self).__init__(total, name, pageSize, page, )
    def factory(*args_, **kwargs_):
        if QueryListType.subclass:
            return QueryListType.subclass(*args_, **kwargs_)
        else:
            return QueryListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(QueryListType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryListType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryListType'):
        super(QueryListType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryListType')
    def exportChildren(self, outfile, level, namespace_='', name_='QueryListType', fromsubclass_=False, pretty_print=True):
        super(QueryListType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='QueryListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryListType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryListType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(QueryListType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryListType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryListType


class MetadataDomainTagType(GeneratedsSuper):
    """A value of SYSTEM places this MetadataEntry in the SYSTEM domain.
    Omit or leave empty to place this MetadataEntry in the GENERAL
    domain. true One of:<br> PRIVATE<br> READONLY"""
    subclass = None
    superclass = None
    def __init__(self, visibility=None, valueOf_=None):
        self.original_tagname_ = None
        self.visibility = _cast(None, visibility)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if MetadataDomainTagType.subclass:
            return MetadataDomainTagType.subclass(*args_, **kwargs_)
        else:
            return MetadataDomainTagType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_visibility(self): return self.visibility
    def set_visibility(self, visibility): self.visibility = visibility
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataDomainTagType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataDomainTagType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataDomainTagType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataDomainTagType'):
        if self.visibility is not None and 'visibility' not in already_processed:
            already_processed.add('visibility')
            outfile.write(' visibility=%s' % (self.gds_format_string(quote_attrib(self.visibility).encode(ExternalEncoding), input_name='visibility'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataDomainTagType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='MetadataDomainTagType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.visibility is not None and 'visibility' not in already_processed:
            already_processed.add('visibility')
            showIndent(outfile, level)
            outfile.write('visibility="%s",\n' % (self.visibility,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('visibility', node)
        if value is not None and 'visibility' not in already_processed:
            already_processed.add('visibility')
            self.visibility = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MetadataDomainTagType


class MetadataEntryType(ResourceType):
    subclass = None
    superclass = ResourceType
    def __init__(self, Domain=None, Key=None, Value=None, TypedValue=None):
        self.original_tagname_ = None
        super(MetadataEntryType, self).__init__()
        self.Domain = Domain
        self.Key = Key
        self.Value = Value
        self.TypedValue = TypedValue
    def factory(*args_, **kwargs_):
        if MetadataEntryType.subclass:
            return MetadataEntryType.subclass(*args_, **kwargs_)
        else:
            return MetadataEntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Domain(self): return self.Domain
    def set_Domain(self, Domain): self.Domain = Domain
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_TypedValue(self): return self.TypedValue
    def set_TypedValue(self, TypedValue): self.TypedValue = TypedValue
    def hasContent_(self):
        if (
            self.Domain is not None or
            self.Key is not None or
            self.Value is not None or
            self.TypedValue is not None or
            super(MetadataEntryType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataEntryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataEntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataEntryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataEntryType'):
        super(MetadataEntryType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataEntryType')
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataEntryType', fromsubclass_=False, pretty_print=True):
        super(MetadataEntryType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Domain is not None:
            self.Domain.export(outfile, level, namespace_, name_='Domain', pretty_print=pretty_print)
        if self.Key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKey>%s</%sKey>%s' % (namespace_, self.gds_format_string(quote_xml(self.Key).encode(ExternalEncoding), input_name='Key'), namespace_, eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
        if self.TypedValue is not None:
            self.TypedValue.export(outfile, level, namespace_, name_='TypedValue', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataEntryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataEntryType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataEntryType, self).exportLiteralChildren(outfile, level, name_)
        if self.Domain is not None:
            showIndent(outfile, level)
            outfile.write('Domain=model_.MetadataDomainTagType(\n')
            self.Domain.exportLiteral(outfile, level, name_='Domain')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Key is not None:
            showIndent(outfile, level)
            outfile.write('Key=%s,\n' % quote_python(self.Key).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
        if self.MetadataTypedValue is not None:
            showIndent(outfile, level)
            outfile.write('MetadataTypedValue=model_.MetadataTypedValue(\n')
            self.MetadataTypedValue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataEntryType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Domain':
            obj_ = MetadataDomainTagType.factory()
            obj_.build(child_)
            self.Domain = obj_
            obj_.original_tagname_ = 'Domain'
        elif nodeName_ == 'Key':
            Key_ = child_.text
            Key_ = self.gds_validate_string(Key_, node, 'Key')
            self.Key = Key_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        elif nodeName_ == 'TypedValue':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <TypedValue> element')
            self.TypedValue = obj_
            obj_.original_tagname_ = 'TypedValue'
        super(MetadataEntryType, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataEntryType


class MetadataTypedValue(GeneratedsSuper):
    """One of:<br> MetadataStringValue<br> MetadataNumberValue<br>
    MetadataBooleanValue<br> MetadataDateTimeValue"""
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MetadataTypedValue.subclass:
            return MetadataTypedValue.subclass(*args_, **kwargs_)
        else:
            return MetadataTypedValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataTypedValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataTypedValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataTypedValue', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataTypedValue'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataTypedValue', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='MetadataTypedValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MetadataTypedValue


class MetadataStringValue(MetadataTypedValue):
    """UTF-8 character set. Strings longer than 1000 characters cannot be
    searched for in a query."""
    subclass = None
    superclass = MetadataTypedValue
    def __init__(self, Value=None):
        self.original_tagname_ = None
        super(MetadataStringValue, self).__init__()
        self.Value = Value
    def factory(*args_, **kwargs_):
        if MetadataStringValue.subclass:
            return MetadataStringValue.subclass(*args_, **kwargs_)
        else:
            return MetadataStringValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(MetadataStringValue, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataStringValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataStringValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataStringValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataStringValue'):
        super(MetadataStringValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataStringValue')
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataStringValue', fromsubclass_=False, pretty_print=True):
        super(MetadataStringValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MetadataStringValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataStringValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataStringValue, self).exportLiteralChildren(outfile, level, name_)
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataStringValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        super(MetadataStringValue, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataStringValue


class MetadataNumberValue(MetadataTypedValue):
    """A signed 8-byte integer."""
    subclass = None
    superclass = MetadataTypedValue
    def __init__(self, Value=None):
        self.original_tagname_ = None
        super(MetadataNumberValue, self).__init__()
        self.Value = Value
    def factory(*args_, **kwargs_):
        if MetadataNumberValue.subclass:
            return MetadataNumberValue.subclass(*args_, **kwargs_)
        else:
            return MetadataNumberValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(MetadataNumberValue, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataNumberValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataNumberValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataNumberValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataNumberValue'):
        super(MetadataNumberValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataNumberValue')
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataNumberValue', fromsubclass_=False, pretty_print=True):
        super(MetadataNumberValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_integer(self.Value, input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MetadataNumberValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataNumberValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataNumberValue, self).exportLiteralChildren(outfile, level, name_)
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%d,\n' % self.Value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataNumberValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Value')
            self.Value = ival_
        super(MetadataNumberValue, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataNumberValue


class MetadataBooleanValue(MetadataTypedValue):
    """One of: 1, 0, true, false"""
    subclass = None
    superclass = MetadataTypedValue
    def __init__(self, Value=None):
        self.original_tagname_ = None
        super(MetadataBooleanValue, self).__init__()
        self.Value = Value
    def factory(*args_, **kwargs_):
        if MetadataBooleanValue.subclass:
            return MetadataBooleanValue.subclass(*args_, **kwargs_)
        else:
            return MetadataBooleanValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(MetadataBooleanValue, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataBooleanValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataBooleanValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataBooleanValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataBooleanValue'):
        super(MetadataBooleanValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataBooleanValue')
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataBooleanValue', fromsubclass_=False, pretty_print=True):
        super(MetadataBooleanValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_boolean(self.Value, input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MetadataBooleanValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataBooleanValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataBooleanValue, self).exportLiteralChildren(outfile, level, name_)
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % self.Value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataBooleanValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Value')
            self.Value = ival_
        super(MetadataBooleanValue, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataBooleanValue


class MetadataDateTimeValue(MetadataTypedValue):
    """UTC format. For example 2012-06-18T12:00:00-05:00"""
    subclass = None
    superclass = MetadataTypedValue
    def __init__(self, Value=None):
        self.original_tagname_ = None
        super(MetadataDateTimeValue, self).__init__()
        if isinstance(Value, basestring):
            initvalue_ = datetime_.datetime.strptime(Value, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Value
        self.Value = initvalue_
    def factory(*args_, **kwargs_):
        if MetadataDateTimeValue.subclass:
            return MetadataDateTimeValue.subclass(*args_, **kwargs_)
        else:
            return MetadataDateTimeValue(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None or
            super(MetadataDateTimeValue, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataDateTimeValue', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataDateTimeValue')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataDateTimeValue', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataDateTimeValue'):
        super(MetadataDateTimeValue, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataDateTimeValue')
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataDateTimeValue', fromsubclass_=False, pretty_print=True):
        super(MetadataDateTimeValue, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_datetime(self.Value, input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MetadataDateTimeValue'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataDateTimeValue, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataDateTimeValue, self).exportLiteralChildren(outfile, level, name_)
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.Value, input_name='Value'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataDateTimeValue, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Value = dval_
        super(MetadataDateTimeValue, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataDateTimeValue


class MetadataType(ResourceType):
    """User-defined metadata associated with with an object."""
    subclass = None
    superclass = ResourceType
    def __init__(self, MetadataEntry=None):
        self.original_tagname_ = None
        super(MetadataType, self).__init__()
        if MetadataEntry is None:
            self.MetadataEntry = []
        else:
            self.MetadataEntry = MetadataEntry
    def factory(*args_, **kwargs_):
        if MetadataType.subclass:
            return MetadataType.subclass(*args_, **kwargs_)
        else:
            return MetadataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MetadataEntry(self): return self.MetadataEntry
    def set_MetadataEntry(self, MetadataEntry): self.MetadataEntry = MetadataEntry
    def add_MetadataEntry(self, value): self.MetadataEntry.append(value)
    def insert_MetadataEntry_at(self, index, value): self.MetadataEntry.insert(index, value)
    def replace_MetadataEntry_at(self, index, value): self.MetadataEntry[index] = value
    def hasContent_(self):
        if (
            self.MetadataEntry or
            super(MetadataType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataType'):
        super(MetadataType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataType')
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataType', fromsubclass_=False, pretty_print=True):
        super(MetadataType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MetadataEntry_ in self.MetadataEntry:
            MetadataEntry_.export(outfile, level, namespace_, name_='MetadataEntry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('MetadataEntry=[\n')
        level += 1
        for MetadataEntry_ in self.MetadataEntry:
            showIndent(outfile, level)
            outfile.write('model_.MetadataEntryType(\n')
            MetadataEntry_.exportLiteral(outfile, level, name_='MetadataEntryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MetadataEntry':
            obj_ = MetadataEntryType.factory()
            obj_.build(child_)
            self.MetadataEntry.append(obj_)
            obj_.original_tagname_ = 'MetadataEntry'
        super(MetadataType, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataType


class MetadataValueType(ResourceType):
    subclass = None
    superclass = ResourceType
    def __init__(self, Domain=None, Value=None, TypedValue=None):
        self.original_tagname_ = None
        super(MetadataValueType, self).__init__()
        self.Domain = Domain
        self.Value = Value
        self.TypedValue = TypedValue
    def factory(*args_, **kwargs_):
        if MetadataValueType.subclass:
            return MetadataValueType.subclass(*args_, **kwargs_)
        else:
            return MetadataValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Domain(self): return self.Domain
    def set_Domain(self, Domain): self.Domain = Domain
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def get_TypedValue(self): return self.TypedValue
    def set_TypedValue(self, TypedValue): self.TypedValue = TypedValue
    def hasContent_(self):
        if (
            self.Domain is not None or
            self.Value is not None or
            self.TypedValue is not None or
            super(MetadataValueType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MetadataValueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MetadataValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MetadataValueType'):
        super(MetadataValueType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataValueType')
    def exportChildren(self, outfile, level, namespace_='', name_='MetadataValueType', fromsubclass_=False, pretty_print=True):
        super(MetadataValueType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Domain is not None:
            self.Domain.export(outfile, level, namespace_, name_='Domain', pretty_print=pretty_print)
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
        if self.TypedValue is not None:
            self.TypedValue.export(outfile, level, namespace_, name_='TypedValue', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataValueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataValueType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataValueType, self).exportLiteralChildren(outfile, level, name_)
        if self.Domain is not None:
            showIndent(outfile, level)
            outfile.write('Domain=model_.MetadataDomainTagType(\n')
            self.Domain.exportLiteral(outfile, level, name_='Domain')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
        if self.MetadataTypedValue is not None:
            showIndent(outfile, level)
            outfile.write('MetadataTypedValue=model_.MetadataTypedValue(\n')
            self.MetadataTypedValue.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataValueType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Domain':
            obj_ = MetadataDomainTagType.factory()
            obj_.build(child_)
            self.Domain = obj_
            obj_.original_tagname_ = 'Domain'
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        elif nodeName_ == 'TypedValue':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <TypedValue> element')
            self.TypedValue = obj_
            obj_.original_tagname_ = 'TypedValue'
        super(MetadataValueType, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataValueType


class FileUploadParamsType(VCloudExtensibleType):
    """5.1 Parameters for initializing file upload session. create Size in
    bytes of the file which will be uploaded. true"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, fileSize=None):
        self.original_tagname_ = None
        super(FileUploadParamsType, self).__init__(VCloudExtension, )
        self.fileSize = _cast(int, fileSize)
    def factory(*args_, **kwargs_):
        if FileUploadParamsType.subclass:
            return FileUploadParamsType.subclass(*args_, **kwargs_)
        else:
            return FileUploadParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fileSize(self): return self.fileSize
    def set_fileSize(self, fileSize): self.fileSize = fileSize
    def hasContent_(self):
        if (
            super(FileUploadParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FileUploadParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FileUploadParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FileUploadParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FileUploadParamsType'):
        super(FileUploadParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FileUploadParamsType')
        if self.fileSize is not None and 'fileSize' not in already_processed:
            already_processed.add('fileSize')
            outfile.write(' fileSize="%s"' % self.gds_format_integer(self.fileSize, input_name='fileSize'))
    def exportChildren(self, outfile, level, namespace_='', name_='FileUploadParamsType', fromsubclass_=False, pretty_print=True):
        super(FileUploadParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FileUploadParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.fileSize is not None and 'fileSize' not in already_processed:
            already_processed.add('fileSize')
            showIndent(outfile, level)
            outfile.write('fileSize=%d,\n' % (self.fileSize,))
        super(FileUploadParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FileUploadParamsType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fileSize', node)
        if value is not None and 'fileSize' not in already_processed:
            already_processed.add('fileSize')
            try:
                self.fileSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(FileUploadParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FileUploadParamsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FileUploadParamsType


class FileUploadSocketType(VCloudExtensibleType):
    """5.1 Parameters for initiating file upload. none URL where the file
    must be uploaded. false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, uploadLocation=None, Task=None):
        self.original_tagname_ = None
        super(FileUploadSocketType, self).__init__(VCloudExtension, )
        self.uploadLocation = _cast(None, uploadLocation)
        self.Task = Task
    def factory(*args_, **kwargs_):
        if FileUploadSocketType.subclass:
            return FileUploadSocketType.subclass(*args_, **kwargs_)
        else:
            return FileUploadSocketType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Task(self): return self.Task
    def set_Task(self, Task): self.Task = Task
    def get_uploadLocation(self): return self.uploadLocation
    def set_uploadLocation(self, uploadLocation): self.uploadLocation = uploadLocation
    def hasContent_(self):
        if (
            self.Task is not None or
            super(FileUploadSocketType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FileUploadSocketType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FileUploadSocketType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FileUploadSocketType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FileUploadSocketType'):
        super(FileUploadSocketType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FileUploadSocketType')
        if self.uploadLocation is not None and 'uploadLocation' not in already_processed:
            already_processed.add('uploadLocation')
            outfile.write(' uploadLocation=%s' % (self.gds_format_string(quote_attrib(self.uploadLocation).encode(ExternalEncoding), input_name='uploadLocation'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FileUploadSocketType', fromsubclass_=False, pretty_print=True):
        super(FileUploadSocketType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Task is not None:
            self.Task.export(outfile, level, namespace_, name_='Task', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FileUploadSocketType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.uploadLocation is not None and 'uploadLocation' not in already_processed:
            already_processed.add('uploadLocation')
            showIndent(outfile, level)
            outfile.write('uploadLocation="%s",\n' % (self.uploadLocation,))
        super(FileUploadSocketType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FileUploadSocketType, self).exportLiteralChildren(outfile, level, name_)
        if self.Task is not None:
            showIndent(outfile, level)
            outfile.write('Task=model_.TaskType(\n')
            self.Task.exportLiteral(outfile, level, name_='Task')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('uploadLocation', node)
        if value is not None and 'uploadLocation' not in already_processed:
            already_processed.add('uploadLocation')
            self.uploadLocation = value
        super(FileUploadSocketType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Task':
            obj_ = TaskType.factory()
            obj_.build(child_)
            self.Task = obj_
            obj_.original_tagname_ = 'Task'
        super(FileUploadSocketType, self).buildChildren(child_, node, nodeName_, True)
# end class FileUploadSocketType


class TaskOperationListType(ResourceType):
    """List of operation names. 1.5"""
    subclass = None
    superclass = ResourceType
    def __init__(self, Operation=None):
        self.original_tagname_ = None
        super(TaskOperationListType, self).__init__()
        if Operation is None:
            self.Operation = []
        else:
            self.Operation = Operation
    def factory(*args_, **kwargs_):
        if TaskOperationListType.subclass:
            return TaskOperationListType.subclass(*args_, **kwargs_)
        else:
            return TaskOperationListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Operation(self): return self.Operation
    def set_Operation(self, Operation): self.Operation = Operation
    def add_Operation(self, value): self.Operation.append(value)
    def insert_Operation_at(self, index, value): self.Operation.insert(index, value)
    def replace_Operation_at(self, index, value): self.Operation[index] = value
    def hasContent_(self):
        if (
            self.Operation or
            super(TaskOperationListType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TaskOperationListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaskOperationListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TaskOperationListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TaskOperationListType'):
        super(TaskOperationListType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TaskOperationListType')
    def exportChildren(self, outfile, level, namespace_='', name_='TaskOperationListType', fromsubclass_=False, pretty_print=True):
        super(TaskOperationListType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Operation_ in self.Operation:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOperation>%s</%sOperation>%s' % (namespace_, self.gds_format_string(quote_xml(Operation_).encode(ExternalEncoding), input_name='Operation'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TaskOperationListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TaskOperationListType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TaskOperationListType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Operation=[\n')
        level += 1
        for Operation_ in self.Operation:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Operation_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TaskOperationListType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Operation':
            Operation_ = child_.text
            Operation_ = self.gds_validate_string(Operation_, node, 'Operation')
            self.Operation.append(Operation_)
        super(TaskOperationListType, self).buildChildren(child_, node, nodeName_, True)
# end class TaskOperationListType


class EntityType(IdentifiableResourceType):
    """0.9 Basic entity type in the vCloud object model. Includes a name,
    an optional description, and an optional list of links. always
    The name of the entity. true"""
    subclass = None
    superclass = IdentifiableResourceType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, extensiontype_=None):
        self.original_tagname_ = None
        super(EntityType, self).__init__(operationKey, id, extensiontype_, )
        self.name = _cast(None, name)
        self.Description = Description
        self.Tasks = Tasks
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EntityType.subclass:
            return EntityType.subclass(*args_, **kwargs_)
        else:
            return EntityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Tasks(self): return self.Tasks
    def set_Tasks(self, Tasks): self.Tasks = Tasks
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Tasks is not None or
            super(EntityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityType'):
        super(EntityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='EntityType', fromsubclass_=False, pretty_print=True):
        super(EntityType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.Tasks is not None:
            self.Tasks.export(outfile, level, namespace_, name_='Tasks', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EntityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(EntityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityType, self).exportLiteralChildren(outfile, level, name_)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Tasks is not None:
            showIndent(outfile, level)
            outfile.write('Tasks=model_.TasksInProgressType(\n')
            self.Tasks.exportLiteral(outfile, level, name_='Tasks')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EntityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Tasks':
            obj_ = TasksInProgressType.factory()
            obj_.build(child_)
            self.Tasks = obj_
            obj_.original_tagname_ = 'Tasks'
        super(EntityType, self).buildChildren(child_, node, nodeName_, True)
# end class EntityType


class EntityReferenceType(VCloudExtensibleType):
    """1.5 A reference to a vCloud entity. none The object identifier,
    expressed in URN format. The value of this attribute uniquely
    identifies the object, persists for the life of the object, and
    is never reused. This context-free identifier can apply to any
    object in any system. truealways The type of the the referenced
    object. falsealways The name of the referenced object. false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, type_=None, id=None, name=None, extensiontype_=None):
        self.original_tagname_ = None
        super(EntityReferenceType, self).__init__(VCloudExtension, extensiontype_, )
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        self.name = _cast(None, name)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EntityReferenceType.subclass:
            return EntityReferenceType.subclass(*args_, **kwargs_)
        else:
            return EntityReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(EntityReferenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityReferenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityReferenceType'):
        super(EntityReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityReferenceType')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='EntityReferenceType', fromsubclass_=False, pretty_print=True):
        super(EntityReferenceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EntityReferenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(EntityReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityReferenceType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(EntityReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EntityReferenceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EntityReferenceType


class EntityLinkType(EntityReferenceType):
    """1.5 Extends EntityReference type by adding relation attribute.
    always Defines the relationship of the link to the object that
    contains it. A relationship can be the name of an operation on
    the object, a reference to a contained or containing object, or
    a reference to an alternate representation of the object. The
    relationship value implies the HTTP verb to use when you use the
    link's href value as a request URL. true"""
    subclass = None
    superclass = EntityReferenceType
    def __init__(self, VCloudExtension=None, type_=None, id=None, name=None, rel=None):
        self.original_tagname_ = None
        super(EntityLinkType, self).__init__(VCloudExtension, type_, id, name, )
        self.rel = _cast(None, rel)
    def factory(*args_, **kwargs_):
        if EntityLinkType.subclass:
            return EntityLinkType.subclass(*args_, **kwargs_)
        else:
            return EntityLinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rel(self): return self.rel
    def set_rel(self, rel): self.rel = rel
    def hasContent_(self):
        if (
            super(EntityLinkType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntityLinkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntityLinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntityLinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntityLinkType'):
        super(EntityLinkType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntityLinkType')
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            outfile.write(' rel=%s' % (self.gds_format_string(quote_attrib(self.rel).encode(ExternalEncoding), input_name='rel'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntityLinkType', fromsubclass_=False, pretty_print=True):
        super(EntityLinkType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EntityLinkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            showIndent(outfile, level)
            outfile.write('rel="%s",\n' % (self.rel,))
        super(EntityLinkType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntityLinkType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rel', node)
        if value is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            self.rel = value
        super(EntityLinkType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EntityLinkType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EntityLinkType


class TasksInProgressType(VCloudExtensibleType):
    """0.9 A list of queued, running, or recently completed tasks."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Task=None):
        self.original_tagname_ = None
        super(TasksInProgressType, self).__init__(VCloudExtension, )
        if Task is None:
            self.Task = []
        else:
            self.Task = Task
    def factory(*args_, **kwargs_):
        if TasksInProgressType.subclass:
            return TasksInProgressType.subclass(*args_, **kwargs_)
        else:
            return TasksInProgressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Task(self): return self.Task
    def set_Task(self, Task): self.Task = Task
    def add_Task(self, value): self.Task.append(value)
    def insert_Task_at(self, index, value): self.Task.insert(index, value)
    def replace_Task_at(self, index, value): self.Task[index] = value
    def hasContent_(self):
        if (
            self.Task or
            super(TasksInProgressType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TasksInProgressType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TasksInProgressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TasksInProgressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TasksInProgressType'):
        super(TasksInProgressType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TasksInProgressType')
    def exportChildren(self, outfile, level, namespace_='', name_='TasksInProgressType', fromsubclass_=False, pretty_print=True):
        super(TasksInProgressType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Task_ in self.Task:
            Task_.export(outfile, level, namespace_, name_='Task', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TasksInProgressType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TasksInProgressType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TasksInProgressType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Task=[\n')
        level += 1
        for Task_ in self.Task:
            showIndent(outfile, level)
            outfile.write('model_.TaskType(\n')
            Task_.exportLiteral(outfile, level, name_='TaskType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TasksInProgressType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Task':
            obj_ = TaskType.factory()
            obj_.build(child_)
            self.Task.append(obj_)
            obj_.original_tagname_ = 'Task'
        super(TasksInProgressType, self).buildChildren(child_, node, nodeName_, True)
# end class TasksInProgressType


class CatalogItemType(EntityType):
    """0.9 Contains a reference to a VappTemplate or Media object and
    related metadata. create5.5 Size of the catalog item, in bytes.
    It is optional for a vApp template. false"""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, size=None, Entity=None, Property=None, DateCreated=None, VersionNumber=None):
        self.original_tagname_ = None
        super(CatalogItemType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.size = _cast(int, size)
        self.Entity = Entity
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
        if isinstance(DateCreated, basestring):
            initvalue_ = datetime_.datetime.strptime(DateCreated, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DateCreated
        self.DateCreated = initvalue_
        self.VersionNumber = VersionNumber
    def factory(*args_, **kwargs_):
        if CatalogItemType.subclass:
            return CatalogItemType.subclass(*args_, **kwargs_)
        else:
            return CatalogItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Entity(self): return self.Entity
    def set_Entity(self, Entity): self.Entity = Entity
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property_at(self, index, value): self.Property.insert(index, value)
    def replace_Property_at(self, index, value): self.Property[index] = value
    def get_DateCreated(self): return self.DateCreated
    def set_DateCreated(self, DateCreated): self.DateCreated = DateCreated
    def get_VersionNumber(self): return self.VersionNumber
    def set_VersionNumber(self, VersionNumber): self.VersionNumber = VersionNumber
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            self.Entity is not None or
            self.Property or
            self.DateCreated is not None or
            self.VersionNumber is not None or
            super(CatalogItemType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CatalogItemType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CatalogItemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CatalogItemType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CatalogItemType'):
        super(CatalogItemType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CatalogItemType')
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespace_='', name_='CatalogItemType', fromsubclass_=False, pretty_print=True):
        super(CatalogItemType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Entity is not None:
            self.Entity.export(outfile, level, namespace_, name_='Entity', pretty_print=pretty_print)
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property', pretty_print=pretty_print)
        if self.DateCreated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateCreated>%s</%sDateCreated>%s' % (namespace_, self.gds_format_datetime(self.DateCreated, input_name='DateCreated'), namespace_, eol_))
        if self.VersionNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersionNumber>%s</%sVersionNumber>%s' % (namespace_, self.gds_format_integer(self.VersionNumber, input_name='VersionNumber'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CatalogItemType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % (self.size,))
        super(CatalogItemType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CatalogItemType, self).exportLiteralChildren(outfile, level, name_)
        if self.Entity is not None:
            showIndent(outfile, level)
            outfile.write('Entity=model_.ReferenceType(\n')
            self.Entity.exportLiteral(outfile, level, name_='Entity')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.PropertyType(\n')
            Property_.exportLiteral(outfile, level, name_='PropertyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DateCreated is not None:
            showIndent(outfile, level)
            outfile.write('DateCreated=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.DateCreated, input_name='DateCreated'))
        if self.VersionNumber is not None:
            showIndent(outfile, level)
            outfile.write('VersionNumber=%d,\n' % self.VersionNumber)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(CatalogItemType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Entity':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Entity = obj_
            obj_.original_tagname_ = 'Entity'
        elif nodeName_ == 'Property':
            obj_ = PropertyType.factory()
            obj_.build(child_)
            self.Property.append(obj_)
            obj_.original_tagname_ = 'Property'
        elif nodeName_ == 'DateCreated':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DateCreated = dval_
        elif nodeName_ == 'VersionNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VersionNumber')
            self.VersionNumber = ival_
        super(CatalogItemType, self).buildChildren(child_, node, nodeName_, True)
# end class CatalogItemType


class CatalogItemsType(VCloudExtensibleType):
    """0.9 Container for references to catalog items."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, CatalogItem=None):
        self.original_tagname_ = None
        super(CatalogItemsType, self).__init__(VCloudExtension, )
        if CatalogItem is None:
            self.CatalogItem = []
        else:
            self.CatalogItem = CatalogItem
    def factory(*args_, **kwargs_):
        if CatalogItemsType.subclass:
            return CatalogItemsType.subclass(*args_, **kwargs_)
        else:
            return CatalogItemsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CatalogItem(self): return self.CatalogItem
    def set_CatalogItem(self, CatalogItem): self.CatalogItem = CatalogItem
    def add_CatalogItem(self, value): self.CatalogItem.append(value)
    def insert_CatalogItem_at(self, index, value): self.CatalogItem.insert(index, value)
    def replace_CatalogItem_at(self, index, value): self.CatalogItem[index] = value
    def hasContent_(self):
        if (
            self.CatalogItem or
            super(CatalogItemsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CatalogItemsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CatalogItemsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CatalogItemsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CatalogItemsType'):
        super(CatalogItemsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CatalogItemsType')
    def exportChildren(self, outfile, level, namespace_='', name_='CatalogItemsType', fromsubclass_=False, pretty_print=True):
        super(CatalogItemsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CatalogItem_ in self.CatalogItem:
            CatalogItem_.export(outfile, level, namespace_, name_='CatalogItem', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CatalogItemsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CatalogItemsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CatalogItemsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('CatalogItem=[\n')
        level += 1
        for CatalogItem_ in self.CatalogItem:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            CatalogItem_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CatalogItemsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CatalogItem':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.CatalogItem.append(obj_)
            obj_.original_tagname_ = 'CatalogItem'
        super(CatalogItemsType, self).buildChildren(child_, node, nodeName_, True)
# end class CatalogItemsType


class PropertyType(GeneratedsSuper):
    """0.9 Contains key/value pair as property. always The key of the
    property. true"""
    subclass = None
    superclass = None
    def __init__(self, key=None, valueOf_=None):
        self.original_tagname_ = None
        self.key = _cast(None, key)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PropertyType.subclass:
            return PropertyType.subclass(*args_, **kwargs_)
        else:
            return PropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PropertyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyType'):
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            showIndent(outfile, level)
            outfile.write('key="%s",\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            self.key = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PropertyType


class DiskCreateParamsType(VCloudExtensibleType):
    """5.1 Parameters for creating or updating an independent disk."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Disk=None, Locality=None):
        self.original_tagname_ = None
        super(DiskCreateParamsType, self).__init__(VCloudExtension, )
        self.Disk = Disk
        self.Locality = Locality
    def factory(*args_, **kwargs_):
        if DiskCreateParamsType.subclass:
            return DiskCreateParamsType.subclass(*args_, **kwargs_)
        else:
            return DiskCreateParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Disk(self): return self.Disk
    def set_Disk(self, Disk): self.Disk = Disk
    def get_Locality(self): return self.Locality
    def set_Locality(self, Locality): self.Locality = Locality
    def hasContent_(self):
        if (
            self.Disk is not None or
            self.Locality is not None or
            super(DiskCreateParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiskCreateParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiskCreateParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DiskCreateParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiskCreateParamsType'):
        super(DiskCreateParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DiskCreateParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='DiskCreateParamsType', fromsubclass_=False, pretty_print=True):
        super(DiskCreateParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Disk is not None:
            self.Disk.export(outfile, level, namespace_, name_='Disk', pretty_print=pretty_print)
        if self.Locality is not None:
            self.Locality.export(outfile, level, namespace_, name_='Locality', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DiskCreateParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DiskCreateParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DiskCreateParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Disk is not None:
            showIndent(outfile, level)
            outfile.write('Disk=model_.DiskType(\n')
            self.Disk.exportLiteral(outfile, level, name_='Disk')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Locality is not None:
            showIndent(outfile, level)
            outfile.write('Locality=model_.ReferenceType(\n')
            self.Locality.exportLiteral(outfile, level, name_='Locality')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DiskCreateParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Disk':
            obj_ = DiskType.factory()
            obj_.build(child_)
            self.Disk = obj_
            obj_.original_tagname_ = 'Disk'
        elif nodeName_ == 'Locality':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Locality = obj_
            obj_.original_tagname_ = 'Locality'
        super(DiskCreateParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class DiskCreateParamsType


class DiskAttachOrDetachParamsType(VCloudExtensibleType):
    """5.1 Parameters for attaching or detaching an independent disk."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Disk=None, BusNumber=None, UnitNumber=None):
        self.original_tagname_ = None
        super(DiskAttachOrDetachParamsType, self).__init__(VCloudExtension, )
        self.Disk = Disk
        self.BusNumber = BusNumber
        self.UnitNumber = UnitNumber
    def factory(*args_, **kwargs_):
        if DiskAttachOrDetachParamsType.subclass:
            return DiskAttachOrDetachParamsType.subclass(*args_, **kwargs_)
        else:
            return DiskAttachOrDetachParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Disk(self): return self.Disk
    def set_Disk(self, Disk): self.Disk = Disk
    def get_BusNumber(self): return self.BusNumber
    def set_BusNumber(self, BusNumber): self.BusNumber = BusNumber
    def get_UnitNumber(self): return self.UnitNumber
    def set_UnitNumber(self, UnitNumber): self.UnitNumber = UnitNumber
    def hasContent_(self):
        if (
            self.Disk is not None or
            self.BusNumber is not None or
            self.UnitNumber is not None or
            super(DiskAttachOrDetachParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiskAttachOrDetachParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiskAttachOrDetachParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DiskAttachOrDetachParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiskAttachOrDetachParamsType'):
        super(DiskAttachOrDetachParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DiskAttachOrDetachParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='DiskAttachOrDetachParamsType', fromsubclass_=False, pretty_print=True):
        super(DiskAttachOrDetachParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Disk is not None:
            self.Disk.export(outfile, level, namespace_, name_='Disk', pretty_print=pretty_print)
        if self.BusNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBusNumber>%s</%sBusNumber>%s' % (namespace_, self.gds_format_integer(self.BusNumber, input_name='BusNumber'), namespace_, eol_))
        if self.UnitNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnitNumber>%s</%sUnitNumber>%s' % (namespace_, self.gds_format_integer(self.UnitNumber, input_name='UnitNumber'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DiskAttachOrDetachParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DiskAttachOrDetachParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DiskAttachOrDetachParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Disk is not None:
            showIndent(outfile, level)
            outfile.write('Disk=model_.ReferenceType(\n')
            self.Disk.exportLiteral(outfile, level, name_='Disk')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BusNumber is not None:
            showIndent(outfile, level)
            outfile.write('BusNumber=%d,\n' % self.BusNumber)
        if self.UnitNumber is not None:
            showIndent(outfile, level)
            outfile.write('UnitNumber=%d,\n' % self.UnitNumber)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DiskAttachOrDetachParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Disk':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Disk = obj_
            obj_.original_tagname_ = 'Disk'
        elif nodeName_ == 'BusNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BusNumber')
            self.BusNumber = ival_
        elif nodeName_ == 'UnitNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UnitNumber')
            self.UnitNumber = ival_
        super(DiskAttachOrDetachParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class DiskAttachOrDetachParamsType


class ResourceEntityType(EntityType):
    """0.9 Base type that represents a resource entity such as a vApp
    template or virtual media. none Creation status of the resource
    entity. false"""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, Files=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ResourceEntityType, self).__init__(operationKey, id, name, Description, Tasks, extensiontype_, )
        self.status = _cast(int, status)
        self.Files = Files
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ResourceEntityType.subclass:
            return ResourceEntityType.subclass(*args_, **kwargs_)
        else:
            return ResourceEntityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Files(self): return self.Files
    def set_Files(self, Files): self.Files = Files
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Files is not None or
            super(ResourceEntityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceEntityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceEntityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceEntityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceEntityType'):
        super(ResourceEntityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceEntityType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status="%s"' % self.gds_format_integer(self.status, input_name='status'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceEntityType', fromsubclass_=False, pretty_print=True):
        super(ResourceEntityType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Files is not None:
            self.Files.export(outfile, level, namespace_, name_='Files', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResourceEntityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % (self.status,))
        super(ResourceEntityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResourceEntityType, self).exportLiteralChildren(outfile, level, name_)
        if self.Files is not None:
            showIndent(outfile, level)
            outfile.write('Files=model_.FilesListType(\n')
            self.Files.exportLiteral(outfile, level, name_='Files')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            try:
                self.status = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ResourceEntityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Files':
            obj_ = FilesListType.factory()
            obj_.build(child_)
            self.Files = obj_
            obj_.original_tagname_ = 'Files'
        super(ResourceEntityType, self).buildChildren(child_, node, nodeName_, True)
# end class ResourceEntityType


class FilesListType(VCloudExtensibleType):
    """0.9 Represents a list of files to be transferred (uploaded or
    downloaded)."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, File=None):
        self.original_tagname_ = None
        super(FilesListType, self).__init__(VCloudExtension, )
        if File is None:
            self.File = []
        else:
            self.File = File
    def factory(*args_, **kwargs_):
        if FilesListType.subclass:
            return FilesListType.subclass(*args_, **kwargs_)
        else:
            return FilesListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_File(self): return self.File
    def set_File(self, File): self.File = File
    def add_File(self, value): self.File.append(value)
    def insert_File_at(self, index, value): self.File.insert(index, value)
    def replace_File_at(self, index, value): self.File[index] = value
    def hasContent_(self):
        if (
            self.File or
            super(FilesListType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FilesListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FilesListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FilesListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FilesListType'):
        super(FilesListType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FilesListType')
    def exportChildren(self, outfile, level, namespace_='', name_='FilesListType', fromsubclass_=False, pretty_print=True):
        super(FilesListType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for File_ in self.File:
            File_.export(outfile, level, namespace_, name_='File', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FilesListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FilesListType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FilesListType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('File=[\n')
        level += 1
        for File_ in self.File:
            showIndent(outfile, level)
            outfile.write('model_.FileType(\n')
            File_.exportLiteral(outfile, level, name_='FileType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FilesListType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'File':
            obj_ = FileType.factory()
            obj_.build(child_)
            self.File.append(obj_)
            obj_.original_tagname_ = 'File'
        super(FilesListType, self).buildChildren(child_, node, nodeName_, True)
# end class FilesListType


class FileType(EntityType):
    """0.9 Represents a file to be transferred (uploaded or downloaded).
    none File size in bytes. falsenone Bytes that have been
    transferred. falsenone The checksum of the file. false"""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, checksum=None, bytesTransferred=None, size=None):
        self.original_tagname_ = None
        super(FileType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.checksum = _cast(None, checksum)
        self.bytesTransferred = _cast(int, bytesTransferred)
        self.size = _cast(int, size)
    def factory(*args_, **kwargs_):
        if FileType.subclass:
            return FileType.subclass(*args_, **kwargs_)
        else:
            return FileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_checksum(self): return self.checksum
    def set_checksum(self, checksum): self.checksum = checksum
    def get_bytesTransferred(self): return self.bytesTransferred
    def set_bytesTransferred(self, bytesTransferred): self.bytesTransferred = bytesTransferred
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            super(FileType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FileType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FileType'):
        super(FileType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FileType')
        if self.checksum is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            outfile.write(' checksum=%s' % (self.gds_format_string(quote_attrib(self.checksum).encode(ExternalEncoding), input_name='checksum'), ))
        if self.bytesTransferred is not None and 'bytesTransferred' not in already_processed:
            already_processed.add('bytesTransferred')
            outfile.write(' bytesTransferred="%s"' % self.gds_format_integer(self.bytesTransferred, input_name='bytesTransferred'))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespace_='', name_='FileType', fromsubclass_=False, pretty_print=True):
        super(FileType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FileType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.checksum is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            showIndent(outfile, level)
            outfile.write('checksum="%s",\n' % (self.checksum,))
        if self.bytesTransferred is not None and 'bytesTransferred' not in already_processed:
            already_processed.add('bytesTransferred')
            showIndent(outfile, level)
            outfile.write('bytesTransferred=%d,\n' % (self.bytesTransferred,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % (self.size,))
        super(FileType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FileType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('checksum', node)
        if value is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            self.checksum = value
        value = find_attr_value_('bytesTransferred', node)
        if value is not None and 'bytesTransferred' not in already_processed:
            already_processed.add('bytesTransferred')
            try:
                self.bytesTransferred = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(FileType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FileType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FileType


class AbstractVAppType(ResourceEntityType):
    """0.9 Represents a base type for VAppType and VmType. 1.0none True if
    the virtual machine is deployed. false"""
    subclass = None
    superclass = ResourceEntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, Files=None, deployed=None, VAppParent=None, Section=None, DateCreated=None, extensiontype_=None):
        self.original_tagname_ = None
        super(AbstractVAppType, self).__init__(operationKey, id, name, Description, Tasks, status, Files, extensiontype_, )
        self.deployed = _cast(bool, deployed)
        self.VAppParent = VAppParent
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
        if isinstance(DateCreated, basestring):
            initvalue_ = datetime_.datetime.strptime(DateCreated, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DateCreated
        self.DateCreated = initvalue_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AbstractVAppType.subclass:
            return AbstractVAppType.subclass(*args_, **kwargs_)
        else:
            return AbstractVAppType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VAppParent(self): return self.VAppParent
    def set_VAppParent(self, VAppParent): self.VAppParent = VAppParent
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def get_DateCreated(self): return self.DateCreated
    def set_DateCreated(self, DateCreated): self.DateCreated = DateCreated
    def get_deployed(self): return self.deployed
    def set_deployed(self, deployed): self.deployed = deployed
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.VAppParent is not None or
            self.Section or
            self.DateCreated is not None or
            super(AbstractVAppType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AbstractVAppType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractVAppType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AbstractVAppType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractVAppType'):
        super(AbstractVAppType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractVAppType')
        if self.deployed is not None and 'deployed' not in already_processed:
            already_processed.add('deployed')
            outfile.write(' deployed="%s"' % self.gds_format_boolean(self.deployed, input_name='deployed'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractVAppType', fromsubclass_=False, pretty_print=True):
        super(AbstractVAppType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VAppParent is not None:
            self.VAppParent.export(outfile, level, namespace_, name_='VAppParent', pretty_print=pretty_print)
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovf:', name_='Section', pretty_print=pretty_print)
        if self.DateCreated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateCreated>%s</%sDateCreated>%s' % (namespace_, self.gds_format_datetime(self.DateCreated, input_name='DateCreated'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AbstractVAppType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deployed is not None and 'deployed' not in already_processed:
            already_processed.add('deployed')
            showIndent(outfile, level)
            outfile.write('deployed=%s,\n' % (self.deployed,))
        super(AbstractVAppType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractVAppType, self).exportLiteralChildren(outfile, level, name_)
        if self.VAppParent is not None:
            showIndent(outfile, level)
            outfile.write('VAppParent=model_.ReferenceType(\n')
            self.VAppParent.exportLiteral(outfile, level, name_='VAppParent')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DateCreated is not None:
            showIndent(outfile, level)
            outfile.write('DateCreated=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.DateCreated, input_name='DateCreated'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deployed', node)
        if value is not None and 'deployed' not in already_processed:
            already_processed.add('deployed')
            if value in ('true', '1'):
                self.deployed = True
            elif value in ('false', '0'):
                self.deployed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(AbstractVAppType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VAppParent':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VAppParent = obj_
            obj_.original_tagname_ = 'VAppParent'
        elif nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
        elif nodeName_ == 'CustomizationSection':
            obj_ = CustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CustomizationSection'
        elif nodeName_ == 'DateCreated':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DateCreated = dval_
        super(AbstractVAppType, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractVAppType


class VmType(AbstractVAppType):
    """0.9 Represents a virtual machine. none True if this virtual machine
    needs customization. falsenone True if hardware-assisted CPU
    virtualization capabilities in the host should be exposed to the
    guest operating system. false"""
    subclass = None
    superclass = AbstractVAppType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, Files=None, deployed=None, VAppParent=None, Section=None, DateCreated=None, needsCustomization=None, nestedHypervisorEnabled=None, VAppScopedLocalId=None, Environment=None, VmCapabilities=None, StorageProfile=None):
        self.original_tagname_ = None
        super(VmType, self).__init__(operationKey, id, name, Description, Tasks, status, Files, deployed, VAppParent, Section, DateCreated, )
        self.needsCustomization = _cast(bool, needsCustomization)
        self.nestedHypervisorEnabled = _cast(bool, nestedHypervisorEnabled)
        self.VAppScopedLocalId = VAppScopedLocalId
        self.Environment = Environment
        self.VmCapabilities = VmCapabilities
        self.StorageProfile = StorageProfile
    def factory(*args_, **kwargs_):
        if VmType.subclass:
            return VmType.subclass(*args_, **kwargs_)
        else:
            return VmType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VAppScopedLocalId(self): return self.VAppScopedLocalId
    def set_VAppScopedLocalId(self, VAppScopedLocalId): self.VAppScopedLocalId = VAppScopedLocalId
    def get_Environment(self): return self.Environment
    def set_Environment(self, Environment): self.Environment = Environment
    def get_VmCapabilities(self): return self.VmCapabilities
    def set_VmCapabilities(self, VmCapabilities): self.VmCapabilities = VmCapabilities
    def get_StorageProfile(self): return self.StorageProfile
    def set_StorageProfile(self, StorageProfile): self.StorageProfile = StorageProfile
    def get_needsCustomization(self): return self.needsCustomization
    def set_needsCustomization(self, needsCustomization): self.needsCustomization = needsCustomization
    def get_nestedHypervisorEnabled(self): return self.nestedHypervisorEnabled
    def set_nestedHypervisorEnabled(self, nestedHypervisorEnabled): self.nestedHypervisorEnabled = nestedHypervisorEnabled
    def hasContent_(self):
        if (
            self.VAppScopedLocalId is not None or
            self.Environment is not None or
            self.VmCapabilities is not None or
            self.StorageProfile is not None or
            super(VmType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmType'):
        super(VmType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmType')
        if self.needsCustomization is not None and 'needsCustomization' not in already_processed:
            already_processed.add('needsCustomization')
            outfile.write(' needsCustomization="%s"' % self.gds_format_boolean(self.needsCustomization, input_name='needsCustomization'))
        if self.nestedHypervisorEnabled is not None and 'nestedHypervisorEnabled' not in already_processed:
            already_processed.add('nestedHypervisorEnabled')
            outfile.write(' nestedHypervisorEnabled="%s"' % self.gds_format_boolean(self.nestedHypervisorEnabled, input_name='nestedHypervisorEnabled'))
    def exportChildren(self, outfile, level, namespace_='', name_='VmType', fromsubclass_=False, pretty_print=True):
        super(VmType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VAppScopedLocalId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVAppScopedLocalId>%s</%sVAppScopedLocalId>%s' % (namespace_, self.gds_format_string(quote_xml(self.VAppScopedLocalId).encode(ExternalEncoding), input_name='VAppScopedLocalId'), namespace_, eol_))
        if self.Environment is not None:
            self.Environment.export(outfile, level, namespace_='ovfenv:', name_='Environment', pretty_print=pretty_print)
        if self.VmCapabilities is not None:
            self.VmCapabilities.export(outfile, level, namespace_, name_='VmCapabilities', pretty_print=pretty_print)
        if self.StorageProfile is not None:
            self.StorageProfile.export(outfile, level, namespace_, name_='StorageProfile', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VmType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.needsCustomization is not None and 'needsCustomization' not in already_processed:
            already_processed.add('needsCustomization')
            showIndent(outfile, level)
            outfile.write('needsCustomization=%s,\n' % (self.needsCustomization,))
        if self.nestedHypervisorEnabled is not None and 'nestedHypervisorEnabled' not in already_processed:
            already_processed.add('nestedHypervisorEnabled')
            showIndent(outfile, level)
            outfile.write('nestedHypervisorEnabled=%s,\n' % (self.nestedHypervisorEnabled,))
        super(VmType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmType, self).exportLiteralChildren(outfile, level, name_)
        if self.VAppScopedLocalId is not None:
            showIndent(outfile, level)
            outfile.write('VAppScopedLocalId=%s,\n' % quote_python(self.VAppScopedLocalId).encode(ExternalEncoding))
        if self.Environment is not None:
            showIndent(outfile, level)
            outfile.write('Environment=model_.Environment(\n')
            self.Environment.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VmCapabilities is not None:
            showIndent(outfile, level)
            outfile.write('VmCapabilities=model_.VmCapabilitiesType(\n')
            self.VmCapabilities.exportLiteral(outfile, level, name_='VmCapabilities')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('StorageProfile=model_.ReferenceType(\n')
            self.StorageProfile.exportLiteral(outfile, level, name_='StorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('needsCustomization', node)
        if value is not None and 'needsCustomization' not in already_processed:
            already_processed.add('needsCustomization')
            if value in ('true', '1'):
                self.needsCustomization = True
            elif value in ('false', '0'):
                self.needsCustomization = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('nestedHypervisorEnabled', node)
        if value is not None and 'nestedHypervisorEnabled' not in already_processed:
            already_processed.add('nestedHypervisorEnabled')
            if value in ('true', '1'):
                self.nestedHypervisorEnabled = True
            elif value in ('false', '0'):
                self.nestedHypervisorEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(VmType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VAppScopedLocalId':
            VAppScopedLocalId_ = child_.text
            VAppScopedLocalId_ = self.gds_validate_string(VAppScopedLocalId_, node, 'VAppScopedLocalId')
            self.VAppScopedLocalId = VAppScopedLocalId_
        elif nodeName_ == 'Environment':
            obj_ = Environment_Type.factory()
            obj_.build(child_)
            self.Environment = obj_
            obj_.original_tagname_ = 'Environment'
        elif nodeName_ == 'VmCapabilities':
            obj_ = VmCapabilitiesType.factory()
            obj_.build(child_)
            self.VmCapabilities = obj_
            obj_.original_tagname_ = 'VmCapabilities'
        elif nodeName_ == 'StorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.StorageProfile = obj_
            obj_.original_tagname_ = 'StorageProfile'
        super(VmType, self).buildChildren(child_, node, nodeName_, True)
# end class VmType


class VmCapabilitiesType(ResourceType):
    """5.1 Allows you to specify certain capabilities of this virtual
    machine."""
    subclass = None
    superclass = ResourceType
    def __init__(self, MemoryHotAddEnabled=None, CpuHotAddEnabled=None):
        self.original_tagname_ = None
        super(VmCapabilitiesType, self).__init__()
        self.MemoryHotAddEnabled = MemoryHotAddEnabled
        self.CpuHotAddEnabled = CpuHotAddEnabled
    def factory(*args_, **kwargs_):
        if VmCapabilitiesType.subclass:
            return VmCapabilitiesType.subclass(*args_, **kwargs_)
        else:
            return VmCapabilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MemoryHotAddEnabled(self): return self.MemoryHotAddEnabled
    def set_MemoryHotAddEnabled(self, MemoryHotAddEnabled): self.MemoryHotAddEnabled = MemoryHotAddEnabled
    def get_CpuHotAddEnabled(self): return self.CpuHotAddEnabled
    def set_CpuHotAddEnabled(self, CpuHotAddEnabled): self.CpuHotAddEnabled = CpuHotAddEnabled
    def hasContent_(self):
        if (
            self.MemoryHotAddEnabled is not None or
            self.CpuHotAddEnabled is not None or
            super(VmCapabilitiesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmCapabilitiesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmCapabilitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmCapabilitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmCapabilitiesType'):
        super(VmCapabilitiesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmCapabilitiesType')
    def exportChildren(self, outfile, level, namespace_='', name_='VmCapabilitiesType', fromsubclass_=False, pretty_print=True):
        super(VmCapabilitiesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MemoryHotAddEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMemoryHotAddEnabled>%s</%sMemoryHotAddEnabled>%s' % (namespace_, self.gds_format_boolean(self.MemoryHotAddEnabled, input_name='MemoryHotAddEnabled'), namespace_, eol_))
        if self.CpuHotAddEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCpuHotAddEnabled>%s</%sCpuHotAddEnabled>%s' % (namespace_, self.gds_format_boolean(self.CpuHotAddEnabled, input_name='CpuHotAddEnabled'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VmCapabilitiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmCapabilitiesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmCapabilitiesType, self).exportLiteralChildren(outfile, level, name_)
        if self.MemoryHotAddEnabled is not None:
            showIndent(outfile, level)
            outfile.write('MemoryHotAddEnabled=%s,\n' % self.MemoryHotAddEnabled)
        if self.CpuHotAddEnabled is not None:
            showIndent(outfile, level)
            outfile.write('CpuHotAddEnabled=%s,\n' % self.CpuHotAddEnabled)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VmCapabilitiesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MemoryHotAddEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'MemoryHotAddEnabled')
            self.MemoryHotAddEnabled = ival_
        elif nodeName_ == 'CpuHotAddEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CpuHotAddEnabled')
            self.CpuHotAddEnabled = ival_
        super(VmCapabilitiesType, self).buildChildren(child_, node, nodeName_, True)
# end class VmCapabilitiesType


class VAppType(AbstractVAppType):
    """0.9 Represents a vApp. none Read-only indicator that the OVF
    descriptor for this vApp has been uploaded. false"""
    subclass = None
    superclass = AbstractVAppType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, Files=None, deployed=None, VAppParent=None, Section=None, DateCreated=None, ovfDescriptorUploaded=None, Owner=None, InMaintenanceMode=None, Children=None):
        self.original_tagname_ = None
        super(VAppType, self).__init__(operationKey, id, name, Description, Tasks, status, Files, deployed, VAppParent, Section, DateCreated, )
        self.ovfDescriptorUploaded = _cast(bool, ovfDescriptorUploaded)
        self.Owner = Owner
        self.InMaintenanceMode = InMaintenanceMode
        self.Children = Children
    def factory(*args_, **kwargs_):
        if VAppType.subclass:
            return VAppType.subclass(*args_, **kwargs_)
        else:
            return VAppType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Owner(self): return self.Owner
    def set_Owner(self, Owner): self.Owner = Owner
    def get_InMaintenanceMode(self): return self.InMaintenanceMode
    def set_InMaintenanceMode(self, InMaintenanceMode): self.InMaintenanceMode = InMaintenanceMode
    def get_Children(self): return self.Children
    def set_Children(self, Children): self.Children = Children
    def get_ovfDescriptorUploaded(self): return self.ovfDescriptorUploaded
    def set_ovfDescriptorUploaded(self, ovfDescriptorUploaded): self.ovfDescriptorUploaded = ovfDescriptorUploaded
    def hasContent_(self):
        if (
            self.Owner is not None or
            self.InMaintenanceMode is not None or
            self.Children is not None or
            super(VAppType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VAppType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VAppType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VAppType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VAppType'):
        super(VAppType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VAppType')
        if self.ovfDescriptorUploaded is not None and 'ovfDescriptorUploaded' not in already_processed:
            already_processed.add('ovfDescriptorUploaded')
            outfile.write(' ovfDescriptorUploaded="%s"' % self.gds_format_boolean(self.ovfDescriptorUploaded, input_name='ovfDescriptorUploaded'))
    def exportChildren(self, outfile, level, namespace_='', name_='VAppType', fromsubclass_=False, pretty_print=True):
        super(VAppType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Owner is not None:
            self.Owner.export(outfile, level, namespace_, name_='Owner', pretty_print=pretty_print)
        if self.InMaintenanceMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInMaintenanceMode>%s</%sInMaintenanceMode>%s' % (namespace_, self.gds_format_boolean(self.InMaintenanceMode, input_name='InMaintenanceMode'), namespace_, eol_))
        if self.Children is not None:
            self.Children.export(outfile, level, namespace_, name_='Children', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VAppType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ovfDescriptorUploaded is not None and 'ovfDescriptorUploaded' not in already_processed:
            already_processed.add('ovfDescriptorUploaded')
            showIndent(outfile, level)
            outfile.write('ovfDescriptorUploaded=%s,\n' % (self.ovfDescriptorUploaded,))
        super(VAppType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VAppType, self).exportLiteralChildren(outfile, level, name_)
        if self.Owner is not None:
            showIndent(outfile, level)
            outfile.write('Owner=model_.OwnerType(\n')
            self.Owner.exportLiteral(outfile, level, name_='Owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InMaintenanceMode is not None:
            showIndent(outfile, level)
            outfile.write('InMaintenanceMode=%s,\n' % self.InMaintenanceMode)
        if self.Children is not None:
            showIndent(outfile, level)
            outfile.write('Children=model_.VAppChildrenType(\n')
            self.Children.exportLiteral(outfile, level, name_='Children')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ovfDescriptorUploaded', node)
        if value is not None and 'ovfDescriptorUploaded' not in already_processed:
            already_processed.add('ovfDescriptorUploaded')
            if value in ('true', '1'):
                self.ovfDescriptorUploaded = True
            elif value in ('false', '0'):
                self.ovfDescriptorUploaded = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(VAppType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Owner':
            obj_ = OwnerType.factory()
            obj_.build(child_)
            self.Owner = obj_
            obj_.original_tagname_ = 'Owner'
        elif nodeName_ == 'InMaintenanceMode':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'InMaintenanceMode')
            self.InMaintenanceMode = ival_
        elif nodeName_ == 'Children':
            obj_ = VAppChildrenType.factory()
            obj_.build(child_)
            self.Children = obj_
            obj_.original_tagname_ = 'Children'
        super(VAppType, self).buildChildren(child_, node, nodeName_, True)
# end class VAppType


class VAppChildrenType(VCloudExtensibleType):
    """0.9 Container for virtual machines included in this vApp."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, VApp=None, Vm=None):
        self.original_tagname_ = None
        super(VAppChildrenType, self).__init__(VCloudExtension, )
        if VApp is None:
            self.VApp = []
        else:
            self.VApp = VApp
        if Vm is None:
            self.Vm = []
        else:
            self.Vm = Vm
    def factory(*args_, **kwargs_):
        if VAppChildrenType.subclass:
            return VAppChildrenType.subclass(*args_, **kwargs_)
        else:
            return VAppChildrenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VApp(self): return self.VApp
    def set_VApp(self, VApp): self.VApp = VApp
    def add_VApp(self, value): self.VApp.append(value)
    def insert_VApp_at(self, index, value): self.VApp.insert(index, value)
    def replace_VApp_at(self, index, value): self.VApp[index] = value
    def get_Vm(self): return self.Vm
    def set_Vm(self, Vm): self.Vm = Vm
    def add_Vm(self, value): self.Vm.append(value)
    def insert_Vm_at(self, index, value): self.Vm.insert(index, value)
    def replace_Vm_at(self, index, value): self.Vm[index] = value
    def hasContent_(self):
        if (
            self.VApp or
            self.Vm or
            super(VAppChildrenType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VAppChildrenType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VAppChildrenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VAppChildrenType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VAppChildrenType'):
        super(VAppChildrenType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VAppChildrenType')
    def exportChildren(self, outfile, level, namespace_='', name_='VAppChildrenType', fromsubclass_=False, pretty_print=True):
        super(VAppChildrenType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VApp_ in self.VApp:
            VApp_.export(outfile, level, namespace_, name_='VApp', pretty_print=pretty_print)
        for Vm_ in self.Vm:
            Vm_.export(outfile, level, namespace_, name_='Vm', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VAppChildrenType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VAppChildrenType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VAppChildrenType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('VApp=[\n')
        level += 1
        for VApp_ in self.VApp:
            showIndent(outfile, level)
            outfile.write('model_.VApp(\n')
            VApp_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Vm=[\n')
        level += 1
        for Vm_ in self.Vm:
            showIndent(outfile, level)
            outfile.write('model_.Vm(\n')
            Vm_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VAppChildrenType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VApp':
            obj_ = VAppType.factory()
            obj_.build(child_)
            self.VApp.append(obj_)
            obj_.original_tagname_ = 'VApp'
        elif nodeName_ == 'Vm':
            obj_ = VmType.factory()
            obj_.build(child_)
            self.Vm.append(obj_)
            obj_.original_tagname_ = 'Vm'
        super(VAppChildrenType, self).buildChildren(child_, node, nodeName_, True)
# end class VAppChildrenType


class RasdItemsListType(ResourceType):
    """0.9 Represents a list of RASD items specifying a group of related
    DMTF Resource Allocation Setting Data properties of this virtual
    machine."""
    subclass = None
    superclass = ResourceType
    def __init__(self, Item=None):
        self.original_tagname_ = None
        super(RasdItemsListType, self).__init__()
        if Item is None:
            self.Item = []
        else:
            self.Item = Item
    def factory(*args_, **kwargs_):
        if RasdItemsListType.subclass:
            return RasdItemsListType.subclass(*args_, **kwargs_)
        else:
            return RasdItemsListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Item(self): return self.Item
    def set_Item(self, Item): self.Item = Item
    def add_Item(self, value): self.Item.append(value)
    def insert_Item_at(self, index, value): self.Item.insert(index, value)
    def replace_Item_at(self, index, value): self.Item[index] = value
    def hasContent_(self):
        if (
            self.Item or
            super(RasdItemsListType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RasdItemsListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RasdItemsListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RasdItemsListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RasdItemsListType'):
        super(RasdItemsListType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RasdItemsListType')
    def exportChildren(self, outfile, level, namespace_='', name_='RasdItemsListType', fromsubclass_=False, pretty_print=True):
        super(RasdItemsListType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Item_ in self.Item:
            Item_.export(outfile, level, namespace_, name_='Item', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RasdItemsListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RasdItemsListType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RasdItemsListType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Item=[\n')
        level += 1
        for Item_ in self.Item:
            showIndent(outfile, level)
            outfile.write('model_.Item(\n')
            Item_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RasdItemsListType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Item':
            obj_ = RASD_Type.factory()
            obj_.build(child_)
            self.Item.append(obj_)
            obj_.original_tagname_ = 'Item'
        super(RasdItemsListType, self).buildChildren(child_, node, nodeName_, True)
# end class RasdItemsListType


class InstantiationParamsType(VCloudExtensibleType):
    """0.9 Container for ovf:Section_Type elements that specify vApp
    configuration on instantiate, compose, or recompose."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Section=None):
        self.original_tagname_ = None
        super(InstantiationParamsType, self).__init__(VCloudExtension, )
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
    def factory(*args_, **kwargs_):
        if InstantiationParamsType.subclass:
            return InstantiationParamsType.subclass(*args_, **kwargs_)
        else:
            return InstantiationParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def hasContent_(self):
        if (
            self.Section or
            super(InstantiationParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstantiationParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiationParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstantiationParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstantiationParamsType'):
        super(InstantiationParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiationParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='InstantiationParamsType', fromsubclass_=False, pretty_print=True):
        super(InstantiationParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovf:', name_='Section', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InstantiationParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(InstantiationParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstantiationParamsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InstantiationParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
        elif nodeName_ == 'CustomizationSection':
            obj_ = CustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CustomizationSection'
        super(InstantiationParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class InstantiationParamsType


class VAppNetworkConfigurationType(ResourceType):
    """0.9 Represents a vApp network configuration. always The name of the
    vApp network. true"""
    subclass = None
    superclass = ResourceType
    def __init__(self, networkName=None, Description=None, Configuration=None, IsDeployed=None):
        self.original_tagname_ = None
        super(VAppNetworkConfigurationType, self).__init__()
        self.networkName = _cast(None, networkName)
        self.Description = Description
        self.Configuration = Configuration
        self.IsDeployed = IsDeployed
    def factory(*args_, **kwargs_):
        if VAppNetworkConfigurationType.subclass:
            return VAppNetworkConfigurationType.subclass(*args_, **kwargs_)
        else:
            return VAppNetworkConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Configuration(self): return self.Configuration
    def set_Configuration(self, Configuration): self.Configuration = Configuration
    def get_IsDeployed(self): return self.IsDeployed
    def set_IsDeployed(self, IsDeployed): self.IsDeployed = IsDeployed
    def get_networkName(self): return self.networkName
    def set_networkName(self, networkName): self.networkName = networkName
    def hasContent_(self):
        if (
            self.Description is not None or
            self.Configuration is not None or
            self.IsDeployed is not None or
            super(VAppNetworkConfigurationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VAppNetworkConfigurationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VAppNetworkConfigurationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VAppNetworkConfigurationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VAppNetworkConfigurationType'):
        super(VAppNetworkConfigurationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VAppNetworkConfigurationType')
        if self.networkName is not None and 'networkName' not in already_processed:
            already_processed.add('networkName')
            outfile.write(' networkName=%s' % (self.gds_format_string(quote_attrib(self.networkName).encode(ExternalEncoding), input_name='networkName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VAppNetworkConfigurationType', fromsubclass_=False, pretty_print=True):
        super(VAppNetworkConfigurationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.Configuration is not None:
            self.Configuration.export(outfile, level, namespace_, name_='Configuration', pretty_print=pretty_print)
        if self.IsDeployed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsDeployed>%s</%sIsDeployed>%s' % (namespace_, self.gds_format_boolean(self.IsDeployed, input_name='IsDeployed'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VAppNetworkConfigurationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.networkName is not None and 'networkName' not in already_processed:
            already_processed.add('networkName')
            showIndent(outfile, level)
            outfile.write('networkName="%s",\n' % (self.networkName,))
        super(VAppNetworkConfigurationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VAppNetworkConfigurationType, self).exportLiteralChildren(outfile, level, name_)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Configuration is not None:
            showIndent(outfile, level)
            outfile.write('Configuration=model_.NetworkConfigurationType(\n')
            self.Configuration.exportLiteral(outfile, level, name_='Configuration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IsDeployed is not None:
            showIndent(outfile, level)
            outfile.write('IsDeployed=%s,\n' % self.IsDeployed)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('networkName', node)
        if value is not None and 'networkName' not in already_processed:
            already_processed.add('networkName')
            self.networkName = value
        super(VAppNetworkConfigurationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Configuration':
            obj_ = NetworkConfigurationType.factory()
            obj_.build(child_)
            self.Configuration = obj_
            obj_.original_tagname_ = 'Configuration'
        elif nodeName_ == 'IsDeployed':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsDeployed')
            self.IsDeployed = ival_
        super(VAppNetworkConfigurationType, self).buildChildren(child_, node, nodeName_, True)
# end class VAppNetworkConfigurationType


class NetworkConnectionType(VCloudExtensibleType):
    """0.9 Represents a network connection in the virtual machine. always
    Name of the network to which this NIC is connected. truenone
    True if this NIC needs customization. false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, needsCustomization=None, network=None, NetworkConnectionIndex=None, IpAddress=None, ExternalIpAddress=None, IsConnected=None, MACAddress=None, IpAddressAllocationMode=None):
        self.original_tagname_ = None
        super(NetworkConnectionType, self).__init__(VCloudExtension, )
        self.needsCustomization = _cast(bool, needsCustomization)
        self.network = _cast(None, network)
        self.NetworkConnectionIndex = NetworkConnectionIndex
        self.IpAddress = IpAddress
        self.ExternalIpAddress = ExternalIpAddress
        self.IsConnected = IsConnected
        self.MACAddress = MACAddress
        self.IpAddressAllocationMode = IpAddressAllocationMode
    def factory(*args_, **kwargs_):
        if NetworkConnectionType.subclass:
            return NetworkConnectionType.subclass(*args_, **kwargs_)
        else:
            return NetworkConnectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NetworkConnectionIndex(self): return self.NetworkConnectionIndex
    def set_NetworkConnectionIndex(self, NetworkConnectionIndex): self.NetworkConnectionIndex = NetworkConnectionIndex
    def get_IpAddress(self): return self.IpAddress
    def set_IpAddress(self, IpAddress): self.IpAddress = IpAddress
    def get_ExternalIpAddress(self): return self.ExternalIpAddress
    def set_ExternalIpAddress(self, ExternalIpAddress): self.ExternalIpAddress = ExternalIpAddress
    def get_IsConnected(self): return self.IsConnected
    def set_IsConnected(self, IsConnected): self.IsConnected = IsConnected
    def get_MACAddress(self): return self.MACAddress
    def set_MACAddress(self, MACAddress): self.MACAddress = MACAddress
    def get_IpAddressAllocationMode(self): return self.IpAddressAllocationMode
    def set_IpAddressAllocationMode(self, IpAddressAllocationMode): self.IpAddressAllocationMode = IpAddressAllocationMode
    def get_needsCustomization(self): return self.needsCustomization
    def set_needsCustomization(self, needsCustomization): self.needsCustomization = needsCustomization
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.NetworkConnectionIndex is not None or
            self.IpAddress is not None or
            self.ExternalIpAddress is not None or
            self.IsConnected is not None or
            self.MACAddress is not None or
            self.IpAddressAllocationMode is not None or
            super(NetworkConnectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkConnectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConnectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkConnectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkConnectionType'):
        super(NetworkConnectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConnectionType')
        if self.needsCustomization is not None and 'needsCustomization' not in already_processed:
            already_processed.add('needsCustomization')
            outfile.write(' needsCustomization="%s"' % self.gds_format_boolean(self.needsCustomization, input_name='needsCustomization'))
        if self.network is not None and 'network' not in already_processed:
            already_processed.add('network')
            outfile.write(' network=%s' % (self.gds_format_string(quote_attrib(self.network).encode(ExternalEncoding), input_name='network'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkConnectionType', fromsubclass_=False, pretty_print=True):
        super(NetworkConnectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NetworkConnectionIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetworkConnectionIndex>%s</%sNetworkConnectionIndex>%s' % (namespace_, self.gds_format_integer(self.NetworkConnectionIndex, input_name='NetworkConnectionIndex'), namespace_, eol_))
        if self.IpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpAddress>%s</%sIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IpAddress).encode(ExternalEncoding), input_name='IpAddress'), namespace_, eol_))
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIpAddress>%s</%sExternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIpAddress).encode(ExternalEncoding), input_name='ExternalIpAddress'), namespace_, eol_))
        if self.IsConnected is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsConnected>%s</%sIsConnected>%s' % (namespace_, self.gds_format_boolean(self.IsConnected, input_name='IsConnected'), namespace_, eol_))
        if self.MACAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMACAddress>%s</%sMACAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.MACAddress).encode(ExternalEncoding), input_name='MACAddress'), namespace_, eol_))
        if self.IpAddressAllocationMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpAddressAllocationMode>%s</%sIpAddressAllocationMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.IpAddressAllocationMode).encode(ExternalEncoding), input_name='IpAddressAllocationMode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NetworkConnectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.needsCustomization is not None and 'needsCustomization' not in already_processed:
            already_processed.add('needsCustomization')
            showIndent(outfile, level)
            outfile.write('needsCustomization=%s,\n' % (self.needsCustomization,))
        if self.network is not None and 'network' not in already_processed:
            already_processed.add('network')
            showIndent(outfile, level)
            outfile.write('network="%s",\n' % (self.network,))
        super(NetworkConnectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkConnectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.NetworkConnectionIndex is not None:
            showIndent(outfile, level)
            outfile.write('NetworkConnectionIndex=%d,\n' % self.NetworkConnectionIndex)
        if self.IpAddress is not None:
            showIndent(outfile, level)
            outfile.write('IpAddress=%s,\n' % quote_python(self.IpAddress).encode(ExternalEncoding))
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIpAddress=%s,\n' % quote_python(self.ExternalIpAddress).encode(ExternalEncoding))
        if self.IsConnected is not None:
            showIndent(outfile, level)
            outfile.write('IsConnected=%s,\n' % self.IsConnected)
        if self.MACAddress is not None:
            showIndent(outfile, level)
            outfile.write('MACAddress=%s,\n' % quote_python(self.MACAddress).encode(ExternalEncoding))
        if self.IpAddressAllocationMode is not None:
            showIndent(outfile, level)
            outfile.write('IpAddressAllocationMode=%s,\n' % quote_python(self.IpAddressAllocationMode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('needsCustomization', node)
        if value is not None and 'needsCustomization' not in already_processed:
            already_processed.add('needsCustomization')
            if value in ('true', '1'):
                self.needsCustomization = True
            elif value in ('false', '0'):
                self.needsCustomization = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('network', node)
        if value is not None and 'network' not in already_processed:
            already_processed.add('network')
            self.network = value
        super(NetworkConnectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetworkConnectionIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NetworkConnectionIndex')
            self.NetworkConnectionIndex = ival_
        elif nodeName_ == 'IpAddress':
            IpAddress_ = child_.text
            IpAddress_ = self.gds_validate_string(IpAddress_, node, 'IpAddress')
            self.IpAddress = IpAddress_
            self.validate_IpAddressType(self.IpAddress)    # validate type IpAddressType
        elif nodeName_ == 'ExternalIpAddress':
            ExternalIpAddress_ = child_.text
            ExternalIpAddress_ = self.gds_validate_string(ExternalIpAddress_, node, 'ExternalIpAddress')
            self.ExternalIpAddress = ExternalIpAddress_
            self.validate_IpAddressType(self.ExternalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'IsConnected':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsConnected')
            self.IsConnected = ival_
        elif nodeName_ == 'MACAddress':
            MACAddress_ = child_.text
            MACAddress_ = self.gds_validate_string(MACAddress_, node, 'MACAddress')
            self.MACAddress = MACAddress_
        elif nodeName_ == 'IpAddressAllocationMode':
            IpAddressAllocationMode_ = child_.text
            IpAddressAllocationMode_ = self.gds_validate_string(IpAddressAllocationMode_, node, 'IpAddressAllocationMode')
            self.IpAddressAllocationMode = IpAddressAllocationMode_
        super(NetworkConnectionType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkConnectionType


class SnapshotType(VCloudExtensibleType):
    """5.1 Represents a virtual machine snapshot. none True if the virtual
    machine was powered on when the snapshot was created. truenone
    Creation date/time of the snapshot. truenone Size of the
    snapshot. true"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, poweredOn=None, size=None, created=None):
        self.original_tagname_ = None
        super(SnapshotType, self).__init__(VCloudExtension, )
        self.poweredOn = _cast(bool, poweredOn)
        self.size = _cast(int, size)
        if isinstance(created, basestring):
            initvalue_ = datetime_.datetime.strptime(created, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = created
        self.created = initvalue_
    def factory(*args_, **kwargs_):
        if SnapshotType.subclass:
            return SnapshotType.subclass(*args_, **kwargs_)
        else:
            return SnapshotType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_poweredOn(self): return self.poweredOn
    def set_poweredOn(self, poweredOn): self.poweredOn = poweredOn
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_created(self): return self.created
    def set_created(self, created): self.created = created
    def hasContent_(self):
        if (
            super(SnapshotType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SnapshotType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SnapshotType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SnapshotType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SnapshotType'):
        super(SnapshotType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SnapshotType')
        if self.poweredOn is not None and 'poweredOn' not in already_processed:
            already_processed.add('poweredOn')
            outfile.write(' poweredOn="%s"' % self.gds_format_boolean(self.poweredOn, input_name='poweredOn'))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
        if self.created is not None and 'created' not in already_processed:
            already_processed.add('created')
            outfile.write(' created="%s"' % self.gds_format_datetime(self.created, input_name='created'))
    def exportChildren(self, outfile, level, namespace_='', name_='SnapshotType', fromsubclass_=False, pretty_print=True):
        super(SnapshotType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SnapshotType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.poweredOn is not None and 'poweredOn' not in already_processed:
            already_processed.add('poweredOn')
            showIndent(outfile, level)
            outfile.write('poweredOn=%s,\n' % (self.poweredOn,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % (self.size,))
        if self.created is not None and 'created' not in already_processed:
            already_processed.add('created')
            showIndent(outfile, level)
            outfile.write('created=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.created, input_name='created'))
        super(SnapshotType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SnapshotType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('poweredOn', node)
        if value is not None and 'poweredOn' not in already_processed:
            already_processed.add('poweredOn')
            if value in ('true', '1'):
                self.poweredOn = True
            elif value in ('false', '0'):
                self.poweredOn = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('created', node)
        if value is not None and 'created' not in already_processed:
            already_processed.add('created')
            try:
                self.created = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (created): %s' % exp)
        super(SnapshotType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SnapshotType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SnapshotType


class NetworkAssignmentType(VCloudExtensibleType):
    """0.9 Maps a network name specified in a Vm to the network name of a
    vApp network defined in the VApp that contains the Vm always
    Name of the network as specified in the Vm. truealways Name of
    the vApp network to map to. true"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, containerNetwork=None, innerNetwork=None):
        self.original_tagname_ = None
        super(NetworkAssignmentType, self).__init__(VCloudExtension, )
        self.containerNetwork = _cast(None, containerNetwork)
        self.innerNetwork = _cast(None, innerNetwork)
    def factory(*args_, **kwargs_):
        if NetworkAssignmentType.subclass:
            return NetworkAssignmentType.subclass(*args_, **kwargs_)
        else:
            return NetworkAssignmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_containerNetwork(self): return self.containerNetwork
    def set_containerNetwork(self, containerNetwork): self.containerNetwork = containerNetwork
    def get_innerNetwork(self): return self.innerNetwork
    def set_innerNetwork(self, innerNetwork): self.innerNetwork = innerNetwork
    def hasContent_(self):
        if (
            super(NetworkAssignmentType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkAssignmentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkAssignmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkAssignmentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkAssignmentType'):
        super(NetworkAssignmentType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkAssignmentType')
        if self.containerNetwork is not None and 'containerNetwork' not in already_processed:
            already_processed.add('containerNetwork')
            outfile.write(' containerNetwork=%s' % (self.gds_format_string(quote_attrib(self.containerNetwork).encode(ExternalEncoding), input_name='containerNetwork'), ))
        if self.innerNetwork is not None and 'innerNetwork' not in already_processed:
            already_processed.add('innerNetwork')
            outfile.write(' innerNetwork=%s' % (self.gds_format_string(quote_attrib(self.innerNetwork).encode(ExternalEncoding), input_name='innerNetwork'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkAssignmentType', fromsubclass_=False, pretty_print=True):
        super(NetworkAssignmentType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkAssignmentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.containerNetwork is not None and 'containerNetwork' not in already_processed:
            already_processed.add('containerNetwork')
            showIndent(outfile, level)
            outfile.write('containerNetwork="%s",\n' % (self.containerNetwork,))
        if self.innerNetwork is not None and 'innerNetwork' not in already_processed:
            already_processed.add('innerNetwork')
            showIndent(outfile, level)
            outfile.write('innerNetwork="%s",\n' % (self.innerNetwork,))
        super(NetworkAssignmentType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkAssignmentType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('containerNetwork', node)
        if value is not None and 'containerNetwork' not in already_processed:
            already_processed.add('containerNetwork')
            self.containerNetwork = value
        value = find_attr_value_('innerNetwork', node)
        if value is not None and 'innerNetwork' not in already_processed:
            already_processed.add('innerNetwork')
            self.innerNetwork = value
        super(NetworkAssignmentType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NetworkAssignmentType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NetworkAssignmentType


class VAppCreationParamsType(ParamsType):
    """0.9 Represents vApp creation parameters. always True if the vApp
    should be deployed at instantiation. Defaults to true.
    falsealways True if the vApp should be powered-on at
    instantiation. Defaults to true. false"""
    subclass = None
    superclass = ParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, powerOn=None, deploy=None, VAppParent=None, InstantiationParams=None, extensiontype_=None):
        self.original_tagname_ = None
        super(VAppCreationParamsType, self).__init__(VCloudExtension, name, Description, extensiontype_, )
        self.powerOn = _cast(bool, powerOn)
        self.deploy = _cast(bool, deploy)
        self.VAppParent = VAppParent
        self.InstantiationParams = InstantiationParams
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if VAppCreationParamsType.subclass:
            return VAppCreationParamsType.subclass(*args_, **kwargs_)
        else:
            return VAppCreationParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VAppParent(self): return self.VAppParent
    def set_VAppParent(self, VAppParent): self.VAppParent = VAppParent
    def get_InstantiationParams(self): return self.InstantiationParams
    def set_InstantiationParams(self, InstantiationParams): self.InstantiationParams = InstantiationParams
    def get_powerOn(self): return self.powerOn
    def set_powerOn(self, powerOn): self.powerOn = powerOn
    def get_deploy(self): return self.deploy
    def set_deploy(self, deploy): self.deploy = deploy
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.VAppParent is not None or
            self.InstantiationParams is not None or
            super(VAppCreationParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VAppCreationParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VAppCreationParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VAppCreationParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VAppCreationParamsType'):
        super(VAppCreationParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VAppCreationParamsType')
        if self.powerOn is not None and 'powerOn' not in already_processed:
            already_processed.add('powerOn')
            outfile.write(' powerOn="%s"' % self.gds_format_boolean(self.powerOn, input_name='powerOn'))
        if self.deploy is not None and 'deploy' not in already_processed:
            already_processed.add('deploy')
            outfile.write(' deploy="%s"' % self.gds_format_boolean(self.deploy, input_name='deploy'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='VAppCreationParamsType', fromsubclass_=False, pretty_print=True):
        super(VAppCreationParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VAppParent is not None:
            self.VAppParent.export(outfile, level, namespace_, name_='VAppParent', pretty_print=pretty_print)
        if self.InstantiationParams is not None:
            self.InstantiationParams.export(outfile, level, namespace_, name_='InstantiationParams', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VAppCreationParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.powerOn is not None and 'powerOn' not in already_processed:
            already_processed.add('powerOn')
            showIndent(outfile, level)
            outfile.write('powerOn=%s,\n' % (self.powerOn,))
        if self.deploy is not None and 'deploy' not in already_processed:
            already_processed.add('deploy')
            showIndent(outfile, level)
            outfile.write('deploy=%s,\n' % (self.deploy,))
        super(VAppCreationParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VAppCreationParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.VAppParent is not None:
            showIndent(outfile, level)
            outfile.write('VAppParent=model_.ReferenceType(\n')
            self.VAppParent.exportLiteral(outfile, level, name_='VAppParent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InstantiationParams is not None:
            showIndent(outfile, level)
            outfile.write('InstantiationParams=model_.InstantiationParamsType(\n')
            self.InstantiationParams.exportLiteral(outfile, level, name_='InstantiationParams')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('powerOn', node)
        if value is not None and 'powerOn' not in already_processed:
            already_processed.add('powerOn')
            if value in ('true', '1'):
                self.powerOn = True
            elif value in ('false', '0'):
                self.powerOn = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('deploy', node)
        if value is not None and 'deploy' not in already_processed:
            already_processed.add('deploy')
            if value in ('true', '1'):
                self.deploy = True
            elif value in ('false', '0'):
                self.deploy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(VAppCreationParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VAppParent':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VAppParent = obj_
            obj_.original_tagname_ = 'VAppParent'
        elif nodeName_ == 'InstantiationParams':
            obj_ = InstantiationParamsType.factory()
            obj_.build(child_)
            self.InstantiationParams = obj_
            obj_.original_tagname_ = 'InstantiationParams'
        super(VAppCreationParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class VAppCreationParamsType


class SourcedCompositionItemParamType(VCloudExtensibleType):
    """0.9 Represents a vApp, vApp template or Vm to include in a composed
    vApp. 1.0always True if the source item should be deleted after
    composition is complete. false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, sourceDelete=None, Source=None, VmGeneralParams=None, VAppScopedLocalId=None, InstantiationParams=None, NetworkAssignment=None, StorageProfile=None, LocalityParams=None):
        self.original_tagname_ = None
        super(SourcedCompositionItemParamType, self).__init__(VCloudExtension, )
        self.sourceDelete = _cast(bool, sourceDelete)
        self.Source = Source
        self.VmGeneralParams = VmGeneralParams
        self.VAppScopedLocalId = VAppScopedLocalId
        self.InstantiationParams = InstantiationParams
        if NetworkAssignment is None:
            self.NetworkAssignment = []
        else:
            self.NetworkAssignment = NetworkAssignment
        self.StorageProfile = StorageProfile
        self.LocalityParams = LocalityParams
    def factory(*args_, **kwargs_):
        if SourcedCompositionItemParamType.subclass:
            return SourcedCompositionItemParamType.subclass(*args_, **kwargs_)
        else:
            return SourcedCompositionItemParamType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_VmGeneralParams(self): return self.VmGeneralParams
    def set_VmGeneralParams(self, VmGeneralParams): self.VmGeneralParams = VmGeneralParams
    def get_VAppScopedLocalId(self): return self.VAppScopedLocalId
    def set_VAppScopedLocalId(self, VAppScopedLocalId): self.VAppScopedLocalId = VAppScopedLocalId
    def get_InstantiationParams(self): return self.InstantiationParams
    def set_InstantiationParams(self, InstantiationParams): self.InstantiationParams = InstantiationParams
    def get_NetworkAssignment(self): return self.NetworkAssignment
    def set_NetworkAssignment(self, NetworkAssignment): self.NetworkAssignment = NetworkAssignment
    def add_NetworkAssignment(self, value): self.NetworkAssignment.append(value)
    def insert_NetworkAssignment_at(self, index, value): self.NetworkAssignment.insert(index, value)
    def replace_NetworkAssignment_at(self, index, value): self.NetworkAssignment[index] = value
    def get_StorageProfile(self): return self.StorageProfile
    def set_StorageProfile(self, StorageProfile): self.StorageProfile = StorageProfile
    def get_LocalityParams(self): return self.LocalityParams
    def set_LocalityParams(self, LocalityParams): self.LocalityParams = LocalityParams
    def get_sourceDelete(self): return self.sourceDelete
    def set_sourceDelete(self, sourceDelete): self.sourceDelete = sourceDelete
    def hasContent_(self):
        if (
            self.Source is not None or
            self.VmGeneralParams is not None or
            self.VAppScopedLocalId is not None or
            self.InstantiationParams is not None or
            self.NetworkAssignment or
            self.StorageProfile is not None or
            self.LocalityParams is not None or
            super(SourcedCompositionItemParamType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SourcedCompositionItemParamType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourcedCompositionItemParamType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SourcedCompositionItemParamType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SourcedCompositionItemParamType'):
        super(SourcedCompositionItemParamType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SourcedCompositionItemParamType')
        if self.sourceDelete is not None and 'sourceDelete' not in already_processed:
            already_processed.add('sourceDelete')
            outfile.write(' sourceDelete="%s"' % self.gds_format_boolean(self.sourceDelete, input_name='sourceDelete'))
    def exportChildren(self, outfile, level, namespace_='', name_='SourcedCompositionItemParamType', fromsubclass_=False, pretty_print=True):
        super(SourcedCompositionItemParamType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Source is not None:
            self.Source.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
        if self.VmGeneralParams is not None:
            self.VmGeneralParams.export(outfile, level, namespace_, name_='VmGeneralParams', pretty_print=pretty_print)
        if self.VAppScopedLocalId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVAppScopedLocalId>%s</%sVAppScopedLocalId>%s' % (namespace_, self.gds_format_string(quote_xml(self.VAppScopedLocalId).encode(ExternalEncoding), input_name='VAppScopedLocalId'), namespace_, eol_))
        if self.InstantiationParams is not None:
            self.InstantiationParams.export(outfile, level, namespace_, name_='InstantiationParams', pretty_print=pretty_print)
        for NetworkAssignment_ in self.NetworkAssignment:
            NetworkAssignment_.export(outfile, level, namespace_, name_='NetworkAssignment', pretty_print=pretty_print)
        if self.StorageProfile is not None:
            self.StorageProfile.export(outfile, level, namespace_, name_='StorageProfile', pretty_print=pretty_print)
        if self.LocalityParams is not None:
            self.LocalityParams.export(outfile, level, namespace_, name_='LocalityParams', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SourcedCompositionItemParamType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sourceDelete is not None and 'sourceDelete' not in already_processed:
            already_processed.add('sourceDelete')
            showIndent(outfile, level)
            outfile.write('sourceDelete=%s,\n' % (self.sourceDelete,))
        super(SourcedCompositionItemParamType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SourcedCompositionItemParamType, self).exportLiteralChildren(outfile, level, name_)
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.ReferenceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VmGeneralParams is not None:
            showIndent(outfile, level)
            outfile.write('VmGeneralParams=model_.VmGeneralParamsType(\n')
            self.VmGeneralParams.exportLiteral(outfile, level, name_='VmGeneralParams')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VAppScopedLocalId is not None:
            showIndent(outfile, level)
            outfile.write('VAppScopedLocalId=%s,\n' % quote_python(self.VAppScopedLocalId).encode(ExternalEncoding))
        if self.InstantiationParams is not None:
            showIndent(outfile, level)
            outfile.write('InstantiationParams=model_.InstantiationParamsType(\n')
            self.InstantiationParams.exportLiteral(outfile, level, name_='InstantiationParams')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('NetworkAssignment=[\n')
        level += 1
        for NetworkAssignment_ in self.NetworkAssignment:
            showIndent(outfile, level)
            outfile.write('model_.NetworkAssignmentType(\n')
            NetworkAssignment_.exportLiteral(outfile, level, name_='NetworkAssignmentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.StorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('StorageProfile=model_.ReferenceType(\n')
            self.StorageProfile.exportLiteral(outfile, level, name_='StorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalityParams is not None:
            showIndent(outfile, level)
            outfile.write('LocalityParams=model_.LocalityParamsType(\n')
            self.LocalityParams.exportLiteral(outfile, level, name_='LocalityParams')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sourceDelete', node)
        if value is not None and 'sourceDelete' not in already_processed:
            already_processed.add('sourceDelete')
            if value in ('true', '1'):
                self.sourceDelete = True
            elif value in ('false', '0'):
                self.sourceDelete = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(SourcedCompositionItemParamType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Source = obj_
            obj_.original_tagname_ = 'Source'
        elif nodeName_ == 'VmGeneralParams':
            obj_ = VmGeneralParamsType.factory()
            obj_.build(child_)
            self.VmGeneralParams = obj_
            obj_.original_tagname_ = 'VmGeneralParams'
        elif nodeName_ == 'VAppScopedLocalId':
            VAppScopedLocalId_ = child_.text
            VAppScopedLocalId_ = self.gds_validate_string(VAppScopedLocalId_, node, 'VAppScopedLocalId')
            self.VAppScopedLocalId = VAppScopedLocalId_
        elif nodeName_ == 'InstantiationParams':
            obj_ = InstantiationParamsType.factory()
            obj_.build(child_)
            self.InstantiationParams = obj_
            obj_.original_tagname_ = 'InstantiationParams'
        elif nodeName_ == 'NetworkAssignment':
            obj_ = NetworkAssignmentType.factory()
            obj_.build(child_)
            self.NetworkAssignment.append(obj_)
            obj_.original_tagname_ = 'NetworkAssignment'
        elif nodeName_ == 'StorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.StorageProfile = obj_
            obj_.original_tagname_ = 'StorageProfile'
        elif nodeName_ == 'LocalityParams':
            obj_ = LocalityParamsType.factory()
            obj_.build(child_)
            self.LocalityParams = obj_
            obj_.original_tagname_ = 'LocalityParams'
        super(SourcedCompositionItemParamType, self).buildChildren(child_, node, nodeName_, True)
# end class SourcedCompositionItemParamType


class VmGeneralParamsType(VCloudExtensibleType):
    """5.6 A set of overrides to source VM properties to apply to target VM
    during copying."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Description=None, NeedsCustomization=None):
        self.original_tagname_ = None
        super(VmGeneralParamsType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Description = Description
        self.NeedsCustomization = NeedsCustomization
    def factory(*args_, **kwargs_):
        if VmGeneralParamsType.subclass:
            return VmGeneralParamsType.subclass(*args_, **kwargs_)
        else:
            return VmGeneralParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_NeedsCustomization(self): return self.NeedsCustomization
    def set_NeedsCustomization(self, NeedsCustomization): self.NeedsCustomization = NeedsCustomization
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Description is not None or
            self.NeedsCustomization is not None or
            super(VmGeneralParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmGeneralParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmGeneralParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmGeneralParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmGeneralParamsType'):
        super(VmGeneralParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmGeneralParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='VmGeneralParamsType', fromsubclass_=False, pretty_print=True):
        super(VmGeneralParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.NeedsCustomization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNeedsCustomization>%s</%sNeedsCustomization>%s' % (namespace_, self.gds_format_boolean(self.NeedsCustomization, input_name='NeedsCustomization'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VmGeneralParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmGeneralParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmGeneralParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.NeedsCustomization is not None:
            showIndent(outfile, level)
            outfile.write('NeedsCustomization=%s,\n' % self.NeedsCustomization)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VmGeneralParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'NeedsCustomization':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'NeedsCustomization')
            self.NeedsCustomization = ival_
        super(VmGeneralParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class VmGeneralParamsType


class ComposeVAppParamsType(VAppCreationParamsType):
    """0.9 Represents vApp composition parameters. always Reserved.
    Unimplemented. false"""
    subclass = None
    superclass = VAppCreationParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, powerOn=None, deploy=None, VAppParent=None, InstantiationParams=None, linkedClone=None, SourcedItem=None, AllEULAsAccepted=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ComposeVAppParamsType, self).__init__(VCloudExtension, name, Description, powerOn, deploy, VAppParent, InstantiationParams, extensiontype_, )
        self.linkedClone = _cast(bool, linkedClone)
        if SourcedItem is None:
            self.SourcedItem = []
        else:
            self.SourcedItem = SourcedItem
        self.AllEULAsAccepted = AllEULAsAccepted
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ComposeVAppParamsType.subclass:
            return ComposeVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return ComposeVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SourcedItem(self): return self.SourcedItem
    def set_SourcedItem(self, SourcedItem): self.SourcedItem = SourcedItem
    def add_SourcedItem(self, value): self.SourcedItem.append(value)
    def insert_SourcedItem_at(self, index, value): self.SourcedItem.insert(index, value)
    def replace_SourcedItem_at(self, index, value): self.SourcedItem[index] = value
    def get_AllEULAsAccepted(self): return self.AllEULAsAccepted
    def set_AllEULAsAccepted(self, AllEULAsAccepted): self.AllEULAsAccepted = AllEULAsAccepted
    def get_linkedClone(self): return self.linkedClone
    def set_linkedClone(self, linkedClone): self.linkedClone = linkedClone
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.SourcedItem or
            self.AllEULAsAccepted is not None or
            super(ComposeVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ComposeVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComposeVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ComposeVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ComposeVAppParamsType'):
        super(ComposeVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ComposeVAppParamsType')
        if self.linkedClone is not None and 'linkedClone' not in already_processed:
            already_processed.add('linkedClone')
            outfile.write(' linkedClone="%s"' % self.gds_format_boolean(self.linkedClone, input_name='linkedClone'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ComposeVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(ComposeVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SourcedItem_ in self.SourcedItem:
            SourcedItem_.export(outfile, level, namespace_, name_='SourcedItem', pretty_print=pretty_print)
        if self.AllEULAsAccepted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllEULAsAccepted>%s</%sAllEULAsAccepted>%s' % (namespace_, self.gds_format_boolean(self.AllEULAsAccepted, input_name='AllEULAsAccepted'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ComposeVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.linkedClone is not None and 'linkedClone' not in already_processed:
            already_processed.add('linkedClone')
            showIndent(outfile, level)
            outfile.write('linkedClone=%s,\n' % (self.linkedClone,))
        super(ComposeVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ComposeVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('SourcedItem=[\n')
        level += 1
        for SourcedItem_ in self.SourcedItem:
            showIndent(outfile, level)
            outfile.write('model_.SourcedCompositionItemParamType(\n')
            SourcedItem_.exportLiteral(outfile, level, name_='SourcedCompositionItemParamType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.AllEULAsAccepted is not None:
            showIndent(outfile, level)
            outfile.write('AllEULAsAccepted=%s,\n' % self.AllEULAsAccepted)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('linkedClone', node)
        if value is not None and 'linkedClone' not in already_processed:
            already_processed.add('linkedClone')
            if value in ('true', '1'):
                self.linkedClone = True
            elif value in ('false', '0'):
                self.linkedClone = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ComposeVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SourcedItem':
            obj_ = SourcedCompositionItemParamType.factory()
            obj_.build(child_)
            self.SourcedItem.append(obj_)
            obj_.original_tagname_ = 'SourcedItem'
        elif nodeName_ == 'AllEULAsAccepted':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AllEULAsAccepted')
            self.AllEULAsAccepted = ival_
        super(ComposeVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class ComposeVAppParamsType


class RecomposeVAppParamsType(ComposeVAppParamsType):
    """1.0 Parameters for a recompose vApp request."""
    subclass = None
    superclass = ComposeVAppParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, powerOn=None, deploy=None, VAppParent=None, InstantiationParams=None, linkedClone=None, SourcedItem=None, AllEULAsAccepted=None, CreateItem=None, DeleteItem=None):
        self.original_tagname_ = None
        super(RecomposeVAppParamsType, self).__init__(VCloudExtension, name, Description, powerOn, deploy, VAppParent, InstantiationParams, linkedClone, SourcedItem, AllEULAsAccepted, )
        if CreateItem is None:
            self.CreateItem = []
        else:
            self.CreateItem = CreateItem
        if DeleteItem is None:
            self.DeleteItem = []
        else:
            self.DeleteItem = DeleteItem
    def factory(*args_, **kwargs_):
        if RecomposeVAppParamsType.subclass:
            return RecomposeVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return RecomposeVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CreateItem(self): return self.CreateItem
    def set_CreateItem(self, CreateItem): self.CreateItem = CreateItem
    def add_CreateItem(self, value): self.CreateItem.append(value)
    def insert_CreateItem_at(self, index, value): self.CreateItem.insert(index, value)
    def replace_CreateItem_at(self, index, value): self.CreateItem[index] = value
    def get_DeleteItem(self): return self.DeleteItem
    def set_DeleteItem(self, DeleteItem): self.DeleteItem = DeleteItem
    def add_DeleteItem(self, value): self.DeleteItem.append(value)
    def insert_DeleteItem_at(self, index, value): self.DeleteItem.insert(index, value)
    def replace_DeleteItem_at(self, index, value): self.DeleteItem[index] = value
    def hasContent_(self):
        if (
            self.CreateItem or
            self.DeleteItem or
            super(RecomposeVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RecomposeVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RecomposeVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RecomposeVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RecomposeVAppParamsType'):
        super(RecomposeVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RecomposeVAppParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='RecomposeVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(RecomposeVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CreateItem_ in self.CreateItem:
            CreateItem_.export(outfile, level, namespace_, name_='CreateItem', pretty_print=pretty_print)
        for DeleteItem_ in self.DeleteItem:
            DeleteItem_.export(outfile, level, namespace_, name_='DeleteItem', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RecomposeVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RecomposeVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RecomposeVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('CreateItem=[\n')
        level += 1
        for CreateItem_ in self.CreateItem:
            showIndent(outfile, level)
            outfile.write('model_.VmType(\n')
            CreateItem_.exportLiteral(outfile, level, name_='VmType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DeleteItem=[\n')
        level += 1
        for DeleteItem_ in self.DeleteItem:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            DeleteItem_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RecomposeVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CreateItem':
            obj_ = VmType.factory()
            obj_.build(child_)
            self.CreateItem.append(obj_)
            obj_.original_tagname_ = 'CreateItem'
        elif nodeName_ == 'DeleteItem':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.DeleteItem.append(obj_)
            obj_.original_tagname_ = 'DeleteItem'
        super(RecomposeVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class RecomposeVAppParamsType


class RegisterVAppParamsType(ParamsType):
    """5.5 Represents vApp registration parameters."""
    subclass = None
    superclass = ParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, Ovf=None, VsToVmxMap=None, OvfToVdcNetworkMap=None, ExternalNatIpMap=None, NicIpMap=None):
        self.original_tagname_ = None
        super(RegisterVAppParamsType, self).__init__(VCloudExtension, name, Description, )
        self.Ovf = Ovf
        self.VsToVmxMap = VsToVmxMap
        self.OvfToVdcNetworkMap = OvfToVdcNetworkMap
        self.ExternalNatIpMap = ExternalNatIpMap
        self.NicIpMap = NicIpMap
    def factory(*args_, **kwargs_):
        if RegisterVAppParamsType.subclass:
            return RegisterVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return RegisterVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Ovf(self): return self.Ovf
    def set_Ovf(self, Ovf): self.Ovf = Ovf
    def get_VsToVmxMap(self): return self.VsToVmxMap
    def set_VsToVmxMap(self, VsToVmxMap): self.VsToVmxMap = VsToVmxMap
    def get_OvfToVdcNetworkMap(self): return self.OvfToVdcNetworkMap
    def set_OvfToVdcNetworkMap(self, OvfToVdcNetworkMap): self.OvfToVdcNetworkMap = OvfToVdcNetworkMap
    def get_ExternalNatIpMap(self): return self.ExternalNatIpMap
    def set_ExternalNatIpMap(self, ExternalNatIpMap): self.ExternalNatIpMap = ExternalNatIpMap
    def get_NicIpMap(self): return self.NicIpMap
    def set_NicIpMap(self, NicIpMap): self.NicIpMap = NicIpMap
    def hasContent_(self):
        if (
            self.Ovf is not None or
            self.VsToVmxMap is not None or
            self.OvfToVdcNetworkMap is not None or
            self.ExternalNatIpMap is not None or
            self.NicIpMap is not None or
            super(RegisterVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RegisterVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegisterVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RegisterVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegisterVAppParamsType'):
        super(RegisterVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RegisterVAppParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='RegisterVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(RegisterVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Ovf is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOvf>%s</%sOvf>%s' % (namespace_, self.gds_format_string(quote_xml(self.Ovf).encode(ExternalEncoding), input_name='Ovf'), namespace_, eol_))
        if self.VsToVmxMap is not None:
            self.VsToVmxMap.export(outfile, level, namespace_, name_='VsToVmxMap', pretty_print=pretty_print)
        if self.OvfToVdcNetworkMap is not None:
            self.OvfToVdcNetworkMap.export(outfile, level, namespace_, name_='OvfToVdcNetworkMap', pretty_print=pretty_print)
        if self.ExternalNatIpMap is not None:
            self.ExternalNatIpMap.export(outfile, level, namespace_, name_='ExternalNatIpMap', pretty_print=pretty_print)
        if self.NicIpMap is not None:
            self.NicIpMap.export(outfile, level, namespace_, name_='NicIpMap', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RegisterVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RegisterVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RegisterVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Ovf is not None:
            showIndent(outfile, level)
            outfile.write('Ovf=%s,\n' % quote_python(self.Ovf).encode(ExternalEncoding))
        if self.VsToVmxMap is not None:
            showIndent(outfile, level)
            outfile.write('VsToVmxMap=model_.VsToVmxMapType(\n')
            self.VsToVmxMap.exportLiteral(outfile, level, name_='VsToVmxMap')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OvfToVdcNetworkMap is not None:
            showIndent(outfile, level)
            outfile.write('OvfToVdcNetworkMap=model_.OvfToVdcNetworkMapType(\n')
            self.OvfToVdcNetworkMap.exportLiteral(outfile, level, name_='OvfToVdcNetworkMap')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ExternalNatIpMap is not None:
            showIndent(outfile, level)
            outfile.write('ExternalNatIpMap=model_.ExternalNatIpMapType(\n')
            self.ExternalNatIpMap.exportLiteral(outfile, level, name_='ExternalNatIpMap')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NicIpMap is not None:
            showIndent(outfile, level)
            outfile.write('NicIpMap=model_.NicIpMapType(\n')
            self.NicIpMap.exportLiteral(outfile, level, name_='NicIpMap')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RegisterVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Ovf':
            Ovf_ = child_.text
            Ovf_ = self.gds_validate_string(Ovf_, node, 'Ovf')
            self.Ovf = Ovf_
        elif nodeName_ == 'VsToVmxMap':
            obj_ = VsToVmxMapType.factory()
            obj_.build(child_)
            self.VsToVmxMap = obj_
            obj_.original_tagname_ = 'VsToVmxMap'
        elif nodeName_ == 'OvfToVdcNetworkMap':
            obj_ = OvfToVdcNetworkMapType.factory()
            obj_.build(child_)
            self.OvfToVdcNetworkMap = obj_
            obj_.original_tagname_ = 'OvfToVdcNetworkMap'
        elif nodeName_ == 'ExternalNatIpMap':
            obj_ = ExternalNatIpMapType.factory()
            obj_.build(child_)
            self.ExternalNatIpMap = obj_
            obj_.original_tagname_ = 'ExternalNatIpMap'
        elif nodeName_ == 'NicIpMap':
            obj_ = NicIpMapType.factory()
            obj_.build(child_)
            self.NicIpMap = obj_
            obj_.original_tagname_ = 'NicIpMap'
        super(RegisterVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class RegisterVAppParamsType


class VsToVmxMapType(GeneratedsSuper):
    """always Map from OVF Virtual Systems via the BIOS UUID to the
    datastore location of the replicated VM's files on the
    destination site."""
    subclass = None
    superclass = None
    def __init__(self, Entry=None):
        self.original_tagname_ = None
        if Entry is None:
            self.Entry = []
        else:
            self.Entry = Entry
    def factory(*args_, **kwargs_):
        if VsToVmxMapType.subclass:
            return VsToVmxMapType.subclass(*args_, **kwargs_)
        else:
            return VsToVmxMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Entry(self): return self.Entry
    def set_Entry(self, Entry): self.Entry = Entry
    def add_Entry(self, value): self.Entry.append(value)
    def insert_Entry_at(self, index, value): self.Entry.insert(index, value)
    def replace_Entry_at(self, index, value): self.Entry[index] = value
    def hasContent_(self):
        if (
            self.Entry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VsToVmxMapType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VsToVmxMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VsToVmxMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VsToVmxMapType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VsToVmxMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Entry_ in self.Entry:
            Entry_.export(outfile, level, namespace_, name_='Entry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VsToVmxMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Entry=[\n')
        level += 1
        for Entry_ in self.Entry:
            showIndent(outfile, level)
            outfile.write('model_.EntryType(\n')
            Entry_.exportLiteral(outfile, level, name_='EntryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Entry':
            obj_ = EntryType.factory()
            obj_.build(child_)
            self.Entry.append(obj_)
            obj_.original_tagname_ = 'Entry'
# end class VsToVmxMapType


class OvfToVdcNetworkMapType(GeneratedsSuper):
    """always Map from OVF to Org networks."""
    subclass = None
    superclass = None
    def __init__(self, Entry=None):
        self.original_tagname_ = None
        if Entry is None:
            self.Entry = []
        else:
            self.Entry = Entry
    def factory(*args_, **kwargs_):
        if OvfToVdcNetworkMapType.subclass:
            return OvfToVdcNetworkMapType.subclass(*args_, **kwargs_)
        else:
            return OvfToVdcNetworkMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Entry(self): return self.Entry
    def set_Entry(self, Entry): self.Entry = Entry
    def add_Entry(self, value): self.Entry.append(value)
    def insert_Entry_at(self, index, value): self.Entry.insert(index, value)
    def replace_Entry_at(self, index, value): self.Entry[index] = value
    def hasContent_(self):
        if (
            self.Entry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OvfToVdcNetworkMapType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OvfToVdcNetworkMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OvfToVdcNetworkMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OvfToVdcNetworkMapType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OvfToVdcNetworkMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Entry_ in self.Entry:
            Entry_.export(outfile, level, namespace_, name_='Entry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OvfToVdcNetworkMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Entry=[\n')
        level += 1
        for Entry_ in self.Entry:
            showIndent(outfile, level)
            outfile.write('model_.EntryType1(\n')
            Entry_.exportLiteral(outfile, level, name_='EntryType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Entry':
            obj_ = EntryType1.factory()
            obj_.build(child_)
            self.Entry.append(obj_)
            obj_.original_tagname_ = 'Entry'
# end class OvfToVdcNetworkMapType


class ExternalNatIpMapType(GeneratedsSuper):
    """always Maps source site external NAT IP addresses to destination
    site external NAT IP addresses."""
    subclass = None
    superclass = None
    def __init__(self, Entry=None):
        self.original_tagname_ = None
        if Entry is None:
            self.Entry = []
        else:
            self.Entry = Entry
    def factory(*args_, **kwargs_):
        if ExternalNatIpMapType.subclass:
            return ExternalNatIpMapType.subclass(*args_, **kwargs_)
        else:
            return ExternalNatIpMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Entry(self): return self.Entry
    def set_Entry(self, Entry): self.Entry = Entry
    def add_Entry(self, value): self.Entry.append(value)
    def insert_Entry_at(self, index, value): self.Entry.insert(index, value)
    def replace_Entry_at(self, index, value): self.Entry[index] = value
    def hasContent_(self):
        if (
            self.Entry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExternalNatIpMapType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExternalNatIpMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExternalNatIpMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExternalNatIpMapType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExternalNatIpMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Entry_ in self.Entry:
            Entry_.export(outfile, level, namespace_, name_='Entry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ExternalNatIpMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Entry=[\n')
        level += 1
        for Entry_ in self.Entry:
            showIndent(outfile, level)
            outfile.write('model_.EntryType2(\n')
            Entry_.exportLiteral(outfile, level, name_='EntryType2')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Entry':
            obj_ = EntryType2.factory()
            obj_.build(child_)
            self.Entry.append(obj_)
            obj_.original_tagname_ = 'Entry'
# end class ExternalNatIpMapType


class NicIpMapType(GeneratedsSuper):
    """always VM's with NICs that are connected directly to a VDC network
    and where the NICs have manually assigned IP addresses needs to
    be mapped to a valid IP address within the IP range of the
    destination site's VDC network. This type provides that mapping."""
    subclass = None
    superclass = None
    def __init__(self, Entry=None):
        self.original_tagname_ = None
        if Entry is None:
            self.Entry = []
        else:
            self.Entry = Entry
    def factory(*args_, **kwargs_):
        if NicIpMapType.subclass:
            return NicIpMapType.subclass(*args_, **kwargs_)
        else:
            return NicIpMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Entry(self): return self.Entry
    def set_Entry(self, Entry): self.Entry = Entry
    def add_Entry(self, value): self.Entry.append(value)
    def insert_Entry_at(self, index, value): self.Entry.insert(index, value)
    def replace_Entry_at(self, index, value): self.Entry[index] = value
    def hasContent_(self):
        if (
            self.Entry
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NicIpMapType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NicIpMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NicIpMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NicIpMapType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NicIpMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Entry_ in self.Entry:
            Entry_.export(outfile, level, namespace_, name_='Entry', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NicIpMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Entry=[\n')
        level += 1
        for Entry_ in self.Entry:
            showIndent(outfile, level)
            outfile.write('model_.EntryType3(\n')
            Entry_.exportLiteral(outfile, level, name_='EntryType3')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Entry':
            obj_ = EntryType3.factory()
            obj_.build(child_)
            self.Entry.append(obj_)
            obj_.original_tagname_ = 'Entry'
# end class NicIpMapType


class LocalityParamsType(VCloudExtensibleType):
    """5.1 Represents locality parameters. Locality parameters provide a
    hint that may help the placement engine optimize placement of a
    VM with respect to another VM or an independent disk."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, ResourceEntity=None):
        self.original_tagname_ = None
        super(LocalityParamsType, self).__init__(VCloudExtension, )
        if ResourceEntity is None:
            self.ResourceEntity = []
        else:
            self.ResourceEntity = ResourceEntity
    def factory(*args_, **kwargs_):
        if LocalityParamsType.subclass:
            return LocalityParamsType.subclass(*args_, **kwargs_)
        else:
            return LocalityParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ResourceEntity(self): return self.ResourceEntity
    def set_ResourceEntity(self, ResourceEntity): self.ResourceEntity = ResourceEntity
    def add_ResourceEntity(self, value): self.ResourceEntity.append(value)
    def insert_ResourceEntity_at(self, index, value): self.ResourceEntity.insert(index, value)
    def replace_ResourceEntity_at(self, index, value): self.ResourceEntity[index] = value
    def hasContent_(self):
        if (
            self.ResourceEntity or
            super(LocalityParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LocalityParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalityParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LocalityParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocalityParamsType'):
        super(LocalityParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LocalityParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='LocalityParamsType', fromsubclass_=False, pretty_print=True):
        super(LocalityParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResourceEntity_ in self.ResourceEntity:
            ResourceEntity_.export(outfile, level, namespace_, name_='ResourceEntity', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LocalityParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LocalityParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LocalityParamsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('ResourceEntity=[\n')
        level += 1
        for ResourceEntity_ in self.ResourceEntity:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            ResourceEntity_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LocalityParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResourceEntity':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ResourceEntity.append(obj_)
            obj_.original_tagname_ = 'ResourceEntity'
        super(LocalityParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class LocalityParamsType


class SourcedVmInstantiationParamsType(VCloudExtensibleType):
    """5.65.1 Represents instantiation parameters. Deprecated in favor of
    SourcedCompositionItemParamType"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Source=None, StorageProfile=None, LocalityParams=None, HardwareCustomization=None):
        self.original_tagname_ = None
        super(SourcedVmInstantiationParamsType, self).__init__(VCloudExtension, )
        self.Source = Source
        self.StorageProfile = StorageProfile
        self.LocalityParams = LocalityParams
        self.HardwareCustomization = HardwareCustomization
    def factory(*args_, **kwargs_):
        if SourcedVmInstantiationParamsType.subclass:
            return SourcedVmInstantiationParamsType.subclass(*args_, **kwargs_)
        else:
            return SourcedVmInstantiationParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_StorageProfile(self): return self.StorageProfile
    def set_StorageProfile(self, StorageProfile): self.StorageProfile = StorageProfile
    def get_LocalityParams(self): return self.LocalityParams
    def set_LocalityParams(self, LocalityParams): self.LocalityParams = LocalityParams
    def get_HardwareCustomization(self): return self.HardwareCustomization
    def set_HardwareCustomization(self, HardwareCustomization): self.HardwareCustomization = HardwareCustomization
    def hasContent_(self):
        if (
            self.Source is not None or
            self.StorageProfile is not None or
            self.LocalityParams is not None or
            self.HardwareCustomization is not None or
            super(SourcedVmInstantiationParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SourcedVmInstantiationParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourcedVmInstantiationParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SourcedVmInstantiationParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SourcedVmInstantiationParamsType'):
        super(SourcedVmInstantiationParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SourcedVmInstantiationParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='SourcedVmInstantiationParamsType', fromsubclass_=False, pretty_print=True):
        super(SourcedVmInstantiationParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Source is not None:
            self.Source.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
        if self.StorageProfile is not None:
            self.StorageProfile.export(outfile, level, namespace_, name_='StorageProfile', pretty_print=pretty_print)
        if self.LocalityParams is not None:
            self.LocalityParams.export(outfile, level, namespace_, name_='LocalityParams', pretty_print=pretty_print)
        if self.HardwareCustomization is not None:
            self.HardwareCustomization.export(outfile, level, namespace_, name_='HardwareCustomization', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SourcedVmInstantiationParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SourcedVmInstantiationParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SourcedVmInstantiationParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.ReferenceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('StorageProfile=model_.ReferenceType(\n')
            self.StorageProfile.exportLiteral(outfile, level, name_='StorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LocalityParams is not None:
            showIndent(outfile, level)
            outfile.write('LocalityParams=model_.LocalityParamsType(\n')
            self.LocalityParams.exportLiteral(outfile, level, name_='LocalityParams')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HardwareCustomization is not None:
            showIndent(outfile, level)
            outfile.write('HardwareCustomization=model_.InstantiateVmHardwareCustomizationParamsType(\n')
            self.HardwareCustomization.exportLiteral(outfile, level, name_='HardwareCustomization')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SourcedVmInstantiationParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Source = obj_
            obj_.original_tagname_ = 'Source'
        elif nodeName_ == 'StorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.StorageProfile = obj_
            obj_.original_tagname_ = 'StorageProfile'
        elif nodeName_ == 'LocalityParams':
            obj_ = LocalityParamsType.factory()
            obj_.build(child_)
            self.LocalityParams = obj_
            obj_.original_tagname_ = 'LocalityParams'
        elif nodeName_ == 'HardwareCustomization':
            obj_ = InstantiateVmHardwareCustomizationParamsType.factory()
            obj_.build(child_)
            self.HardwareCustomization = obj_
            obj_.original_tagname_ = 'HardwareCustomization'
        super(SourcedVmInstantiationParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class SourcedVmInstantiationParamsType


class InstantiateVAppParamsType(VAppCreationParamsType):
    """0.9 Represents vApp instantiation parameters. always Reserved.
    Unimplemented. false"""
    subclass = None
    superclass = VAppCreationParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, powerOn=None, deploy=None, VAppParent=None, InstantiationParams=None, linkedClone=None, Source=None, IsSourceDelete=None, SourcedVmInstantiationParams=None, SourcedItem=None, extensiontype_=None):
        self.original_tagname_ = None
        super(InstantiateVAppParamsType, self).__init__(VCloudExtension, name, Description, powerOn, deploy, VAppParent, InstantiationParams, extensiontype_, )
        self.linkedClone = _cast(bool, linkedClone)
        self.Source = Source
        self.IsSourceDelete = IsSourceDelete
        if SourcedVmInstantiationParams is None:
            self.SourcedVmInstantiationParams = []
        else:
            self.SourcedVmInstantiationParams = SourcedVmInstantiationParams
        if SourcedItem is None:
            self.SourcedItem = []
        else:
            self.SourcedItem = SourcedItem
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if InstantiateVAppParamsType.subclass:
            return InstantiateVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return InstantiateVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_IsSourceDelete(self): return self.IsSourceDelete
    def set_IsSourceDelete(self, IsSourceDelete): self.IsSourceDelete = IsSourceDelete
    def get_SourcedVmInstantiationParams(self): return self.SourcedVmInstantiationParams
    def set_SourcedVmInstantiationParams(self, SourcedVmInstantiationParams): self.SourcedVmInstantiationParams = SourcedVmInstantiationParams
    def add_SourcedVmInstantiationParams(self, value): self.SourcedVmInstantiationParams.append(value)
    def insert_SourcedVmInstantiationParams_at(self, index, value): self.SourcedVmInstantiationParams.insert(index, value)
    def replace_SourcedVmInstantiationParams_at(self, index, value): self.SourcedVmInstantiationParams[index] = value
    def get_SourcedItem(self): return self.SourcedItem
    def set_SourcedItem(self, SourcedItem): self.SourcedItem = SourcedItem
    def add_SourcedItem(self, value): self.SourcedItem.append(value)
    def insert_SourcedItem_at(self, index, value): self.SourcedItem.insert(index, value)
    def replace_SourcedItem_at(self, index, value): self.SourcedItem[index] = value
    def get_linkedClone(self): return self.linkedClone
    def set_linkedClone(self, linkedClone): self.linkedClone = linkedClone
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Source is not None or
            self.IsSourceDelete is not None or
            self.SourcedVmInstantiationParams or
            self.SourcedItem or
            super(InstantiateVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstantiateVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstantiateVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstantiateVAppParamsType'):
        super(InstantiateVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVAppParamsType')
        if self.linkedClone is not None and 'linkedClone' not in already_processed:
            already_processed.add('linkedClone')
            outfile.write(' linkedClone="%s"' % self.gds_format_boolean(self.linkedClone, input_name='linkedClone'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='InstantiateVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(InstantiateVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Source is not None:
            self.Source.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
        if self.IsSourceDelete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsSourceDelete>%s</%sIsSourceDelete>%s' % (namespace_, self.gds_format_boolean(self.IsSourceDelete, input_name='IsSourceDelete'), namespace_, eol_))
        for SourcedVmInstantiationParams_ in self.SourcedVmInstantiationParams:
            SourcedVmInstantiationParams_.export(outfile, level, namespace_, name_='SourcedVmInstantiationParams', pretty_print=pretty_print)
        for SourcedItem_ in self.SourcedItem:
            SourcedItem_.export(outfile, level, namespace_, name_='SourcedItem', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InstantiateVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.linkedClone is not None and 'linkedClone' not in already_processed:
            already_processed.add('linkedClone')
            showIndent(outfile, level)
            outfile.write('linkedClone=%s,\n' % (self.linkedClone,))
        super(InstantiateVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstantiateVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.ReferenceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IsSourceDelete is not None:
            showIndent(outfile, level)
            outfile.write('IsSourceDelete=%s,\n' % self.IsSourceDelete)
        showIndent(outfile, level)
        outfile.write('SourcedVmInstantiationParams=[\n')
        level += 1
        for SourcedVmInstantiationParams_ in self.SourcedVmInstantiationParams:
            showIndent(outfile, level)
            outfile.write('model_.SourcedVmInstantiationParamsType(\n')
            SourcedVmInstantiationParams_.exportLiteral(outfile, level, name_='SourcedVmInstantiationParamsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SourcedItem=[\n')
        level += 1
        for SourcedItem_ in self.SourcedItem:
            showIndent(outfile, level)
            outfile.write('model_.SourcedCompositionItemParamType(\n')
            SourcedItem_.exportLiteral(outfile, level, name_='SourcedCompositionItemParamType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('linkedClone', node)
        if value is not None and 'linkedClone' not in already_processed:
            already_processed.add('linkedClone')
            if value in ('true', '1'):
                self.linkedClone = True
            elif value in ('false', '0'):
                self.linkedClone = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(InstantiateVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Source = obj_
            obj_.original_tagname_ = 'Source'
        elif nodeName_ == 'IsSourceDelete':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsSourceDelete')
            self.IsSourceDelete = ival_
        elif nodeName_ == 'SourcedVmInstantiationParams':
            obj_ = SourcedVmInstantiationParamsType.factory()
            obj_.build(child_)
            self.SourcedVmInstantiationParams.append(obj_)
            obj_.original_tagname_ = 'SourcedVmInstantiationParams'
        elif nodeName_ == 'SourcedItem':
            obj_ = SourcedCompositionItemParamType.factory()
            obj_.build(child_)
            self.SourcedItem.append(obj_)
            obj_.original_tagname_ = 'SourcedItem'
        super(InstantiateVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class InstantiateVAppParamsType


class InstantiateVAppTemplateParamsType(InstantiateVAppParamsType):
    """0.9 Represents vApp template instantiation parameters."""
    subclass = None
    superclass = InstantiateVAppParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, powerOn=None, deploy=None, VAppParent=None, InstantiationParams=None, linkedClone=None, Source=None, IsSourceDelete=None, SourcedVmInstantiationParams=None, SourcedItem=None, AllEULAsAccepted=None):
        self.original_tagname_ = None
        super(InstantiateVAppTemplateParamsType, self).__init__(VCloudExtension, name, Description, powerOn, deploy, VAppParent, InstantiationParams, linkedClone, Source, IsSourceDelete, SourcedVmInstantiationParams, SourcedItem, )
        self.AllEULAsAccepted = AllEULAsAccepted
    def factory(*args_, **kwargs_):
        if InstantiateVAppTemplateParamsType.subclass:
            return InstantiateVAppTemplateParamsType.subclass(*args_, **kwargs_)
        else:
            return InstantiateVAppTemplateParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AllEULAsAccepted(self): return self.AllEULAsAccepted
    def set_AllEULAsAccepted(self, AllEULAsAccepted): self.AllEULAsAccepted = AllEULAsAccepted
    def hasContent_(self):
        if (
            self.AllEULAsAccepted is not None or
            super(InstantiateVAppTemplateParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstantiateVAppTemplateParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVAppTemplateParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstantiateVAppTemplateParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstantiateVAppTemplateParamsType'):
        super(InstantiateVAppTemplateParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVAppTemplateParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='InstantiateVAppTemplateParamsType', fromsubclass_=False, pretty_print=True):
        super(InstantiateVAppTemplateParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AllEULAsAccepted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllEULAsAccepted>%s</%sAllEULAsAccepted>%s' % (namespace_, self.gds_format_boolean(self.AllEULAsAccepted, input_name='AllEULAsAccepted'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='InstantiateVAppTemplateParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(InstantiateVAppTemplateParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstantiateVAppTemplateParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.AllEULAsAccepted is not None:
            showIndent(outfile, level)
            outfile.write('AllEULAsAccepted=%s,\n' % self.AllEULAsAccepted)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InstantiateVAppTemplateParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AllEULAsAccepted':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AllEULAsAccepted')
            self.AllEULAsAccepted = ival_
        super(InstantiateVAppTemplateParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class InstantiateVAppTemplateParamsType


class InstantiateOvfParamsType(VAppCreationParamsType):
    """Represents vApp instantiation from OVF parameters false"""
    subclass = None
    superclass = VAppCreationParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, powerOn=None, deploy=None, VAppParent=None, InstantiationParams=None, transferFormat=None, AllEULAsAccepted=None, NetworkMapping=None, InstantiateOvfProperty=None, InstantiateVmParams=None):
        self.original_tagname_ = None
        super(InstantiateOvfParamsType, self).__init__(VCloudExtension, name, Description, powerOn, deploy, VAppParent, InstantiationParams, )
        self.transferFormat = _cast(None, transferFormat)
        self.AllEULAsAccepted = AllEULAsAccepted
        if NetworkMapping is None:
            self.NetworkMapping = []
        else:
            self.NetworkMapping = NetworkMapping
        if InstantiateOvfProperty is None:
            self.InstantiateOvfProperty = []
        else:
            self.InstantiateOvfProperty = InstantiateOvfProperty
        if InstantiateVmParams is None:
            self.InstantiateVmParams = []
        else:
            self.InstantiateVmParams = InstantiateVmParams
    def factory(*args_, **kwargs_):
        if InstantiateOvfParamsType.subclass:
            return InstantiateOvfParamsType.subclass(*args_, **kwargs_)
        else:
            return InstantiateOvfParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AllEULAsAccepted(self): return self.AllEULAsAccepted
    def set_AllEULAsAccepted(self, AllEULAsAccepted): self.AllEULAsAccepted = AllEULAsAccepted
    def get_NetworkMapping(self): return self.NetworkMapping
    def set_NetworkMapping(self, NetworkMapping): self.NetworkMapping = NetworkMapping
    def add_NetworkMapping(self, value): self.NetworkMapping.append(value)
    def insert_NetworkMapping_at(self, index, value): self.NetworkMapping.insert(index, value)
    def replace_NetworkMapping_at(self, index, value): self.NetworkMapping[index] = value
    def get_InstantiateOvfProperty(self): return self.InstantiateOvfProperty
    def set_InstantiateOvfProperty(self, InstantiateOvfProperty): self.InstantiateOvfProperty = InstantiateOvfProperty
    def add_InstantiateOvfProperty(self, value): self.InstantiateOvfProperty.append(value)
    def insert_InstantiateOvfProperty_at(self, index, value): self.InstantiateOvfProperty.insert(index, value)
    def replace_InstantiateOvfProperty_at(self, index, value): self.InstantiateOvfProperty[index] = value
    def get_InstantiateVmParams(self): return self.InstantiateVmParams
    def set_InstantiateVmParams(self, InstantiateVmParams): self.InstantiateVmParams = InstantiateVmParams
    def add_InstantiateVmParams(self, value): self.InstantiateVmParams.append(value)
    def insert_InstantiateVmParams_at(self, index, value): self.InstantiateVmParams.insert(index, value)
    def replace_InstantiateVmParams_at(self, index, value): self.InstantiateVmParams[index] = value
    def get_transferFormat(self): return self.transferFormat
    def set_transferFormat(self, transferFormat): self.transferFormat = transferFormat
    def hasContent_(self):
        if (
            self.AllEULAsAccepted is not None or
            self.NetworkMapping or
            self.InstantiateOvfProperty or
            self.InstantiateVmParams or
            super(InstantiateOvfParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstantiateOvfParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateOvfParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstantiateOvfParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstantiateOvfParamsType'):
        super(InstantiateOvfParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateOvfParamsType')
        if self.transferFormat is not None and 'transferFormat' not in already_processed:
            already_processed.add('transferFormat')
            outfile.write(' transferFormat=%s' % (self.gds_format_string(quote_attrib(self.transferFormat).encode(ExternalEncoding), input_name='transferFormat'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InstantiateOvfParamsType', fromsubclass_=False, pretty_print=True):
        super(InstantiateOvfParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AllEULAsAccepted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllEULAsAccepted>%s</%sAllEULAsAccepted>%s' % (namespace_, self.gds_format_boolean(self.AllEULAsAccepted, input_name='AllEULAsAccepted'), namespace_, eol_))
        for NetworkMapping_ in self.NetworkMapping:
            NetworkMapping_.export(outfile, level, namespace_, name_='NetworkMapping', pretty_print=pretty_print)
        for InstantiateOvfProperty_ in self.InstantiateOvfProperty:
            InstantiateOvfProperty_.export(outfile, level, namespace_, name_='InstantiateOvfProperty', pretty_print=pretty_print)
        for InstantiateVmParams_ in self.InstantiateVmParams:
            InstantiateVmParams_.export(outfile, level, namespace_, name_='InstantiateVmParams', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InstantiateOvfParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.transferFormat is not None and 'transferFormat' not in already_processed:
            already_processed.add('transferFormat')
            showIndent(outfile, level)
            outfile.write('transferFormat="%s",\n' % (self.transferFormat,))
        super(InstantiateOvfParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstantiateOvfParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.AllEULAsAccepted is not None:
            showIndent(outfile, level)
            outfile.write('AllEULAsAccepted=%s,\n' % self.AllEULAsAccepted)
        showIndent(outfile, level)
        outfile.write('NetworkMapping=[\n')
        level += 1
        for NetworkMapping_ in self.NetworkMapping:
            showIndent(outfile, level)
            outfile.write('model_.NetworkMapping(\n')
            NetworkMapping_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InstantiateOvfProperty=[\n')
        level += 1
        for InstantiateOvfProperty_ in self.InstantiateOvfProperty:
            showIndent(outfile, level)
            outfile.write('model_.InstantiateOvfProperty(\n')
            InstantiateOvfProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('InstantiateVmParams=[\n')
        level += 1
        for InstantiateVmParams_ in self.InstantiateVmParams:
            showIndent(outfile, level)
            outfile.write('model_.InstantiateVmParams(\n')
            InstantiateVmParams_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('transferFormat', node)
        if value is not None and 'transferFormat' not in already_processed:
            already_processed.add('transferFormat')
            self.transferFormat = value
        super(InstantiateOvfParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AllEULAsAccepted':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AllEULAsAccepted')
            self.AllEULAsAccepted = ival_
        elif nodeName_ == 'NetworkMapping':
            obj_ = NetworkMappingType.factory()
            obj_.build(child_)
            self.NetworkMapping.append(obj_)
            obj_.original_tagname_ = 'NetworkMapping'
        elif nodeName_ == 'InstantiateOvfProperty':
            obj_ = InstantiateOvfPropertyType.factory()
            obj_.build(child_)
            self.InstantiateOvfProperty.append(obj_)
            obj_.original_tagname_ = 'InstantiateOvfProperty'
        elif nodeName_ == 'InstantiateVmParams':
            obj_ = InstantiateVmParamsType.factory()
            obj_.build(child_)
            self.InstantiateVmParams.append(obj_)
            obj_.original_tagname_ = 'InstantiateVmParams'
        super(InstantiateOvfParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class InstantiateOvfParamsType


class NetworkMappingType(GeneratedsSuper):
    """Represents a mapping from an OVF source network to a vCloud target
    network. Used to update network properties in the OVF. 5.5"""
    subclass = None
    superclass = None
    def __init__(self, Source=None, Target=None):
        self.original_tagname_ = None
        self.Source = Source
        self.Target = Target
    def factory(*args_, **kwargs_):
        if NetworkMappingType.subclass:
            return NetworkMappingType.subclass(*args_, **kwargs_)
        else:
            return NetworkMappingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_Target(self): return self.Target
    def set_Target(self, Target): self.Target = Target
    def hasContent_(self):
        if (
            self.Source is not None or
            self.Target is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkMappingType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkMappingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkMappingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkMappingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkMappingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSource>%s</%sSource>%s' % (namespace_, self.gds_format_string(quote_xml(self.Source).encode(ExternalEncoding), input_name='Source'), namespace_, eol_))
        if self.Target is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTarget>%s</%sTarget>%s' % (namespace_, self.gds_format_string(quote_xml(self.Target).encode(ExternalEncoding), input_name='Target'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NetworkMappingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=%s,\n' % quote_python(self.Source).encode(ExternalEncoding))
        if self.Target is not None:
            showIndent(outfile, level)
            outfile.write('Target=%s,\n' % quote_python(self.Target).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source = Source_
        elif nodeName_ == 'Target':
            Target_ = child_.text
            Target_ = self.gds_validate_string(Target_, node, 'Target')
            self.Target = Target_
# end class NetworkMappingType


class InstantiateOvfPropertyType(GeneratedsSuper):
    """Represents an OVF property value assignment. 5.5"""
    subclass = None
    superclass = None
    def __init__(self, ClassId=None, InstanceId=None, Key=None, Value=None):
        self.original_tagname_ = None
        self.ClassId = ClassId
        self.InstanceId = InstanceId
        self.Key = Key
        self.Value = Value
    def factory(*args_, **kwargs_):
        if InstantiateOvfPropertyType.subclass:
            return InstantiateOvfPropertyType.subclass(*args_, **kwargs_)
        else:
            return InstantiateOvfPropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ClassId(self): return self.ClassId
    def set_ClassId(self, ClassId): self.ClassId = ClassId
    def get_InstanceId(self): return self.InstanceId
    def set_InstanceId(self, InstanceId): self.InstanceId = InstanceId
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.ClassId is not None or
            self.InstanceId is not None or
            self.Key is not None or
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstantiateOvfPropertyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateOvfPropertyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstantiateOvfPropertyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstantiateOvfPropertyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InstantiateOvfPropertyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ClassId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sClassId>%s</%sClassId>%s' % (namespace_, self.gds_format_string(quote_xml(self.ClassId).encode(ExternalEncoding), input_name='ClassId'), namespace_, eol_))
        if self.InstanceId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInstanceId>%s</%sInstanceId>%s' % (namespace_, self.gds_format_string(quote_xml(self.InstanceId).encode(ExternalEncoding), input_name='InstanceId'), namespace_, eol_))
        if self.Key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKey>%s</%sKey>%s' % (namespace_, self.gds_format_string(quote_xml(self.Key).encode(ExternalEncoding), input_name='Key'), namespace_, eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='InstantiateOvfPropertyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ClassId is not None:
            showIndent(outfile, level)
            outfile.write('ClassId=%s,\n' % quote_python(self.ClassId).encode(ExternalEncoding))
        if self.InstanceId is not None:
            showIndent(outfile, level)
            outfile.write('InstanceId=%s,\n' % quote_python(self.InstanceId).encode(ExternalEncoding))
        if self.Key is not None:
            showIndent(outfile, level)
            outfile.write('Key=%s,\n' % quote_python(self.Key).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClassId':
            ClassId_ = child_.text
            ClassId_ = self.gds_validate_string(ClassId_, node, 'ClassId')
            self.ClassId = ClassId_
        elif nodeName_ == 'InstanceId':
            InstanceId_ = child_.text
            InstanceId_ = self.gds_validate_string(InstanceId_, node, 'InstanceId')
            self.InstanceId = InstanceId_
        elif nodeName_ == 'Key':
            Key_ = child_.text
            Key_ = self.gds_validate_string(Key_, node, 'Key')
            self.Key = Key_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class InstantiateOvfPropertyType


class InstantiateVmParamsType(VCloudExtensibleType):
    """Instantiation parameters for a VM in a vApp. 5.5 always The ovf:id
    of the VirtualSystem in the source OVF that the instantiation
    parameters apply to. 5.5true"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, id=None, NetworkConnectionSection=None, ComputerName=None, VdcStorageProfile=None, HardwareCustomization=None):
        self.original_tagname_ = None
        super(InstantiateVmParamsType, self).__init__(VCloudExtension, )
        self.id = _cast(None, id)
        self.NetworkConnectionSection = NetworkConnectionSection
        self.ComputerName = ComputerName
        self.VdcStorageProfile = VdcStorageProfile
        self.HardwareCustomization = HardwareCustomization
    def factory(*args_, **kwargs_):
        if InstantiateVmParamsType.subclass:
            return InstantiateVmParamsType.subclass(*args_, **kwargs_)
        else:
            return InstantiateVmParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NetworkConnectionSection(self): return self.NetworkConnectionSection
    def set_NetworkConnectionSection(self, NetworkConnectionSection): self.NetworkConnectionSection = NetworkConnectionSection
    def get_ComputerName(self): return self.ComputerName
    def set_ComputerName(self, ComputerName): self.ComputerName = ComputerName
    def get_VdcStorageProfile(self): return self.VdcStorageProfile
    def set_VdcStorageProfile(self, VdcStorageProfile): self.VdcStorageProfile = VdcStorageProfile
    def get_HardwareCustomization(self): return self.HardwareCustomization
    def set_HardwareCustomization(self, HardwareCustomization): self.HardwareCustomization = HardwareCustomization
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.NetworkConnectionSection is not None or
            self.ComputerName is not None or
            self.VdcStorageProfile is not None or
            self.HardwareCustomization is not None or
            super(InstantiateVmParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstantiateVmParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVmParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstantiateVmParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstantiateVmParamsType'):
        super(InstantiateVmParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVmParamsType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InstantiateVmParamsType', fromsubclass_=False, pretty_print=True):
        super(InstantiateVmParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NetworkConnectionSection is not None:
            self.NetworkConnectionSection.export(outfile, level, namespace_, name_='NetworkConnectionSection', pretty_print=pretty_print)
        if self.ComputerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComputerName>%s</%sComputerName>%s' % (namespace_, self.gds_format_string(quote_xml(self.ComputerName).encode(ExternalEncoding), input_name='ComputerName'), namespace_, eol_))
        if self.VdcStorageProfile is not None:
            self.VdcStorageProfile.export(outfile, level, namespace_, name_='VdcStorageProfile', pretty_print=pretty_print)
        if self.HardwareCustomization is not None:
            self.HardwareCustomization.export(outfile, level, namespace_, name_='HardwareCustomization', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InstantiateVmParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        super(InstantiateVmParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstantiateVmParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.NetworkConnectionSection is not None:
            showIndent(outfile, level)
            outfile.write('NetworkConnectionSection=model_.NetworkConnectionSectionType(\n')
            self.NetworkConnectionSection.exportLiteral(outfile, level, name_='NetworkConnectionSection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ComputerName is not None:
            showIndent(outfile, level)
            outfile.write('ComputerName=%s,\n' % quote_python(self.ComputerName).encode(ExternalEncoding))
        if self.VdcStorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('VdcStorageProfile=model_.ReferenceType(\n')
            self.VdcStorageProfile.exportLiteral(outfile, level, name_='VdcStorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HardwareCustomization is not None:
            showIndent(outfile, level)
            outfile.write('HardwareCustomization=model_.InstantiateVmHardwareCustomizationParamsType(\n')
            self.HardwareCustomization.exportLiteral(outfile, level, name_='HardwareCustomization')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(InstantiateVmParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.NetworkConnectionSection = obj_
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'ComputerName':
            ComputerName_ = child_.text
            ComputerName_ = self.gds_validate_string(ComputerName_, node, 'ComputerName')
            self.ComputerName = ComputerName_
        elif nodeName_ == 'VdcStorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VdcStorageProfile = obj_
            obj_.original_tagname_ = 'VdcStorageProfile'
        elif nodeName_ == 'HardwareCustomization':
            obj_ = InstantiateVmHardwareCustomizationParamsType.factory()
            obj_.build(child_)
            self.HardwareCustomization = obj_
            obj_.original_tagname_ = 'HardwareCustomization'
        super(InstantiateVmParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class InstantiateVmParamsType


class InstantiateVmHardwareCustomizationParamsType(VCloudExtensibleType):
    """Hardware parameter customization applied to a virtual machine in a
    vApp when instantiated. 5.5"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, NumberOfCpus=None, CoresPerSocket=None, MemorySize=None, Disk=None):
        self.original_tagname_ = None
        super(InstantiateVmHardwareCustomizationParamsType, self).__init__(VCloudExtension, )
        self.NumberOfCpus = NumberOfCpus
        self.CoresPerSocket = CoresPerSocket
        self.MemorySize = MemorySize
        if Disk is None:
            self.Disk = []
        else:
            self.Disk = Disk
    def factory(*args_, **kwargs_):
        if InstantiateVmHardwareCustomizationParamsType.subclass:
            return InstantiateVmHardwareCustomizationParamsType.subclass(*args_, **kwargs_)
        else:
            return InstantiateVmHardwareCustomizationParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NumberOfCpus(self): return self.NumberOfCpus
    def set_NumberOfCpus(self, NumberOfCpus): self.NumberOfCpus = NumberOfCpus
    def get_CoresPerSocket(self): return self.CoresPerSocket
    def set_CoresPerSocket(self, CoresPerSocket): self.CoresPerSocket = CoresPerSocket
    def get_MemorySize(self): return self.MemorySize
    def set_MemorySize(self, MemorySize): self.MemorySize = MemorySize
    def get_Disk(self): return self.Disk
    def set_Disk(self, Disk): self.Disk = Disk
    def add_Disk(self, value): self.Disk.append(value)
    def insert_Disk_at(self, index, value): self.Disk.insert(index, value)
    def replace_Disk_at(self, index, value): self.Disk[index] = value
    def hasContent_(self):
        if (
            self.NumberOfCpus is not None or
            self.CoresPerSocket is not None or
            self.MemorySize is not None or
            self.Disk or
            super(InstantiateVmHardwareCustomizationParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstantiateVmHardwareCustomizationParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVmHardwareCustomizationParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstantiateVmHardwareCustomizationParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstantiateVmHardwareCustomizationParamsType'):
        super(InstantiateVmHardwareCustomizationParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstantiateVmHardwareCustomizationParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='InstantiateVmHardwareCustomizationParamsType', fromsubclass_=False, pretty_print=True):
        super(InstantiateVmHardwareCustomizationParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NumberOfCpus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNumberOfCpus>%s</%sNumberOfCpus>%s' % (namespace_, self.gds_format_integer(self.NumberOfCpus, input_name='NumberOfCpus'), namespace_, eol_))
        if self.CoresPerSocket is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCoresPerSocket>%s</%sCoresPerSocket>%s' % (namespace_, self.gds_format_integer(self.CoresPerSocket, input_name='CoresPerSocket'), namespace_, eol_))
        if self.MemorySize is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMemorySize>%s</%sMemorySize>%s' % (namespace_, self.gds_format_integer(self.MemorySize, input_name='MemorySize'), namespace_, eol_))
        for Disk_ in self.Disk:
            Disk_.export(outfile, level, namespace_, name_='Disk', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InstantiateVmHardwareCustomizationParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(InstantiateVmHardwareCustomizationParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstantiateVmHardwareCustomizationParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.NumberOfCpus is not None:
            showIndent(outfile, level)
            outfile.write('NumberOfCpus=%d,\n' % self.NumberOfCpus)
        if self.CoresPerSocket is not None:
            showIndent(outfile, level)
            outfile.write('CoresPerSocket=%d,\n' % self.CoresPerSocket)
        if self.MemorySize is not None:
            showIndent(outfile, level)
            outfile.write('MemorySize=%d,\n' % self.MemorySize)
        showIndent(outfile, level)
        outfile.write('Disk=[\n')
        level += 1
        for Disk_ in self.Disk:
            showIndent(outfile, level)
            outfile.write('model_.DiskType4(\n')
            Disk_.exportLiteral(outfile, level, name_='DiskType4')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(InstantiateVmHardwareCustomizationParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NumberOfCpus':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NumberOfCpus')
            self.NumberOfCpus = ival_
        elif nodeName_ == 'CoresPerSocket':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CoresPerSocket')
            self.CoresPerSocket = ival_
        elif nodeName_ == 'MemorySize':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MemorySize')
            self.MemorySize = ival_
        elif nodeName_ == 'Disk':
            obj_ = DiskType4.factory()
            obj_.build(child_)
            self.Disk.append(obj_)
            obj_.original_tagname_ = 'Disk'
        super(InstantiateVmHardwareCustomizationParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class InstantiateVmHardwareCustomizationParamsType


class CloneVAppParamsType(InstantiateVAppParamsType):
    """0.9 Parameters for a clonevApp request."""
    subclass = None
    superclass = InstantiateVAppParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, powerOn=None, deploy=None, VAppParent=None, InstantiationParams=None, linkedClone=None, Source=None, IsSourceDelete=None, SourcedVmInstantiationParams=None, SourcedItem=None):
        self.original_tagname_ = None
        super(CloneVAppParamsType, self).__init__(VCloudExtension, name, Description, powerOn, deploy, VAppParent, InstantiationParams, linkedClone, Source, IsSourceDelete, SourcedVmInstantiationParams, SourcedItem, )
    def factory(*args_, **kwargs_):
        if CloneVAppParamsType.subclass:
            return CloneVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return CloneVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(CloneVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CloneVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CloneVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CloneVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CloneVAppParamsType'):
        super(CloneVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CloneVAppParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='CloneVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(CloneVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CloneVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CloneVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CloneVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CloneVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CloneVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CloneVAppParamsType


class DeployVAppParamsType(VCloudExtensibleType):
    """0.9 Parameters to a deploy vApp request. always Used to specify
    whether to power on vapp on deployment, if not set default value
    is true. falsealways Lease in seconds for deployment. A value of
    0 is replaced by the organization default deploymentLeaseSeconds
    value. false Used to specify whether to force customization on
    deployment, if not set default value is false. false"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, forceCustomization=None, powerOn=None, deploymentLeaseSeconds=None):
        self.original_tagname_ = None
        super(DeployVAppParamsType, self).__init__(VCloudExtension, )
        self.forceCustomization = _cast(bool, forceCustomization)
        self.powerOn = _cast(bool, powerOn)
        self.deploymentLeaseSeconds = _cast(int, deploymentLeaseSeconds)
    def factory(*args_, **kwargs_):
        if DeployVAppParamsType.subclass:
            return DeployVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return DeployVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_forceCustomization(self): return self.forceCustomization
    def set_forceCustomization(self, forceCustomization): self.forceCustomization = forceCustomization
    def get_powerOn(self): return self.powerOn
    def set_powerOn(self, powerOn): self.powerOn = powerOn
    def get_deploymentLeaseSeconds(self): return self.deploymentLeaseSeconds
    def set_deploymentLeaseSeconds(self, deploymentLeaseSeconds): self.deploymentLeaseSeconds = deploymentLeaseSeconds
    def hasContent_(self):
        if (
            super(DeployVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeployVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeployVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeployVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeployVAppParamsType'):
        super(DeployVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeployVAppParamsType')
        if self.forceCustomization is not None and 'forceCustomization' not in already_processed:
            already_processed.add('forceCustomization')
            outfile.write(' forceCustomization="%s"' % self.gds_format_boolean(self.forceCustomization, input_name='forceCustomization'))
        if self.powerOn is not None and 'powerOn' not in already_processed:
            already_processed.add('powerOn')
            outfile.write(' powerOn="%s"' % self.gds_format_boolean(self.powerOn, input_name='powerOn'))
        if self.deploymentLeaseSeconds is not None and 'deploymentLeaseSeconds' not in already_processed:
            already_processed.add('deploymentLeaseSeconds')
            outfile.write(' deploymentLeaseSeconds="%s"' % self.gds_format_integer(self.deploymentLeaseSeconds, input_name='deploymentLeaseSeconds'))
    def exportChildren(self, outfile, level, namespace_='', name_='DeployVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(DeployVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DeployVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.forceCustomization is not None and 'forceCustomization' not in already_processed:
            already_processed.add('forceCustomization')
            showIndent(outfile, level)
            outfile.write('forceCustomization=%s,\n' % (self.forceCustomization,))
        if self.powerOn is not None and 'powerOn' not in already_processed:
            already_processed.add('powerOn')
            showIndent(outfile, level)
            outfile.write('powerOn=%s,\n' % (self.powerOn,))
        if self.deploymentLeaseSeconds is not None and 'deploymentLeaseSeconds' not in already_processed:
            already_processed.add('deploymentLeaseSeconds')
            showIndent(outfile, level)
            outfile.write('deploymentLeaseSeconds=%d,\n' % (self.deploymentLeaseSeconds,))
        super(DeployVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DeployVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('forceCustomization', node)
        if value is not None and 'forceCustomization' not in already_processed:
            already_processed.add('forceCustomization')
            if value in ('true', '1'):
                self.forceCustomization = True
            elif value in ('false', '0'):
                self.forceCustomization = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('powerOn', node)
        if value is not None and 'powerOn' not in already_processed:
            already_processed.add('powerOn')
            if value in ('true', '1'):
                self.powerOn = True
            elif value in ('false', '0'):
                self.powerOn = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('deploymentLeaseSeconds', node)
        if value is not None and 'deploymentLeaseSeconds' not in already_processed:
            already_processed.add('deploymentLeaseSeconds')
            try:
                self.deploymentLeaseSeconds = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(DeployVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DeployVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DeployVAppParamsType


class UndeployVAppParamsType(VCloudExtensibleType):
    """0.9 Parameters to an undeploy vApp request."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, UndeployPowerAction=None):
        self.original_tagname_ = None
        super(UndeployVAppParamsType, self).__init__(VCloudExtension, )
        self.UndeployPowerAction = UndeployPowerAction
    def factory(*args_, **kwargs_):
        if UndeployVAppParamsType.subclass:
            return UndeployVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return UndeployVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UndeployPowerAction(self): return self.UndeployPowerAction
    def set_UndeployPowerAction(self, UndeployPowerAction): self.UndeployPowerAction = UndeployPowerAction
    def hasContent_(self):
        if (
            self.UndeployPowerAction is not None or
            super(UndeployVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UndeployVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UndeployVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UndeployVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UndeployVAppParamsType'):
        super(UndeployVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UndeployVAppParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='UndeployVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(UndeployVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UndeployPowerAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUndeployPowerAction>%s</%sUndeployPowerAction>%s' % (namespace_, self.gds_format_string(quote_xml(self.UndeployPowerAction).encode(ExternalEncoding), input_name='UndeployPowerAction'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='UndeployVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(UndeployVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UndeployVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.UndeployPowerAction is not None:
            showIndent(outfile, level)
            outfile.write('UndeployPowerAction=%s,\n' % quote_python(self.UndeployPowerAction).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UndeployVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UndeployPowerAction':
            UndeployPowerAction_ = child_.text
            UndeployPowerAction_ = self.gds_validate_string(UndeployPowerAction_, node, 'UndeployPowerAction')
            self.UndeployPowerAction = UndeployPowerAction_
        super(UndeployVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class UndeployVAppParamsType


class MediaInsertOrEjectParamsType(VCloudExtensibleType):
    """0.9 Parameters for an insertMedia or ejectMedia request."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Media=None):
        self.original_tagname_ = None
        super(MediaInsertOrEjectParamsType, self).__init__(VCloudExtension, )
        self.Media = Media
    def factory(*args_, **kwargs_):
        if MediaInsertOrEjectParamsType.subclass:
            return MediaInsertOrEjectParamsType.subclass(*args_, **kwargs_)
        else:
            return MediaInsertOrEjectParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Media(self): return self.Media
    def set_Media(self, Media): self.Media = Media
    def hasContent_(self):
        if (
            self.Media is not None or
            super(MediaInsertOrEjectParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MediaInsertOrEjectParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MediaInsertOrEjectParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MediaInsertOrEjectParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MediaInsertOrEjectParamsType'):
        super(MediaInsertOrEjectParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MediaInsertOrEjectParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='MediaInsertOrEjectParamsType', fromsubclass_=False, pretty_print=True):
        super(MediaInsertOrEjectParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Media is not None:
            self.Media.export(outfile, level, namespace_, name_='Media', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MediaInsertOrEjectParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MediaInsertOrEjectParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MediaInsertOrEjectParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Media is not None:
            showIndent(outfile, level)
            outfile.write('Media=model_.ReferenceType(\n')
            self.Media.exportLiteral(outfile, level, name_='Media')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MediaInsertOrEjectParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Media':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Media = obj_
            obj_.original_tagname_ = 'Media'
        super(MediaInsertOrEjectParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class MediaInsertOrEjectParamsType


class CaptureVAppParamsType(ParamsType):
    """0.9 Parameters for a captureVapp request."""
    subclass = None
    superclass = ParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, Source=None, Section=None, VdcStorageProfile=None, TargetCatalogItem=None):
        self.original_tagname_ = None
        super(CaptureVAppParamsType, self).__init__(VCloudExtension, name, Description, )
        self.Source = Source
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
        self.VdcStorageProfile = VdcStorageProfile
        self.TargetCatalogItem = TargetCatalogItem
    def factory(*args_, **kwargs_):
        if CaptureVAppParamsType.subclass:
            return CaptureVAppParamsType.subclass(*args_, **kwargs_)
        else:
            return CaptureVAppParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def get_VdcStorageProfile(self): return self.VdcStorageProfile
    def set_VdcStorageProfile(self, VdcStorageProfile): self.VdcStorageProfile = VdcStorageProfile
    def get_TargetCatalogItem(self): return self.TargetCatalogItem
    def set_TargetCatalogItem(self, TargetCatalogItem): self.TargetCatalogItem = TargetCatalogItem
    def hasContent_(self):
        if (
            self.Source is not None or
            self.Section or
            self.VdcStorageProfile is not None or
            self.TargetCatalogItem is not None or
            super(CaptureVAppParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CaptureVAppParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CaptureVAppParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CaptureVAppParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CaptureVAppParamsType'):
        super(CaptureVAppParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CaptureVAppParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='CaptureVAppParamsType', fromsubclass_=False, pretty_print=True):
        super(CaptureVAppParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Source is not None:
            self.Source.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovf:', name_='Section', pretty_print=pretty_print)
        if self.VdcStorageProfile is not None:
            self.VdcStorageProfile.export(outfile, level, namespace_, name_='VdcStorageProfile', pretty_print=pretty_print)
        if self.TargetCatalogItem is not None:
            self.TargetCatalogItem.export(outfile, level, namespace_, name_='TargetCatalogItem', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CaptureVAppParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CaptureVAppParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CaptureVAppParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.ReferenceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.VdcStorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('VdcStorageProfile=model_.ReferenceType(\n')
            self.VdcStorageProfile.exportLiteral(outfile, level, name_='VdcStorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TargetCatalogItem is not None:
            showIndent(outfile, level)
            outfile.write('TargetCatalogItem=model_.ReferenceType(\n')
            self.TargetCatalogItem.exportLiteral(outfile, level, name_='TargetCatalogItem')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CaptureVAppParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Source = obj_
            obj_.original_tagname_ = 'Source'
        elif nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
        elif nodeName_ == 'CustomizationSection':
            obj_ = CustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CustomizationSection'
        elif nodeName_ == 'VdcStorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VdcStorageProfile = obj_
            obj_.original_tagname_ = 'VdcStorageProfile'
        elif nodeName_ == 'TargetCatalogItem':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.TargetCatalogItem = obj_
            obj_.original_tagname_ = 'TargetCatalogItem'
        super(CaptureVAppParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class CaptureVAppParamsType


class VmPendingQuestionType(ResourceType):
    """0.9 Represents a question posted by a virtual machine that is
    WAITING_FOR_INPUT (status="5")."""
    subclass = None
    superclass = ResourceType
    def __init__(self, Question=None, QuestionId=None, Choices=None):
        self.original_tagname_ = None
        super(VmPendingQuestionType, self).__init__()
        self.Question = Question
        self.QuestionId = QuestionId
        if Choices is None:
            self.Choices = []
        else:
            self.Choices = Choices
    def factory(*args_, **kwargs_):
        if VmPendingQuestionType.subclass:
            return VmPendingQuestionType.subclass(*args_, **kwargs_)
        else:
            return VmPendingQuestionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Question(self): return self.Question
    def set_Question(self, Question): self.Question = Question
    def get_QuestionId(self): return self.QuestionId
    def set_QuestionId(self, QuestionId): self.QuestionId = QuestionId
    def get_Choices(self): return self.Choices
    def set_Choices(self, Choices): self.Choices = Choices
    def add_Choices(self, value): self.Choices.append(value)
    def insert_Choices_at(self, index, value): self.Choices.insert(index, value)
    def replace_Choices_at(self, index, value): self.Choices[index] = value
    def hasContent_(self):
        if (
            self.Question is not None or
            self.QuestionId is not None or
            self.Choices or
            super(VmPendingQuestionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmPendingQuestionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmPendingQuestionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmPendingQuestionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmPendingQuestionType'):
        super(VmPendingQuestionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmPendingQuestionType')
    def exportChildren(self, outfile, level, namespace_='', name_='VmPendingQuestionType', fromsubclass_=False, pretty_print=True):
        super(VmPendingQuestionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Question is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQuestion>%s</%sQuestion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Question).encode(ExternalEncoding), input_name='Question'), namespace_, eol_))
        if self.QuestionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQuestionId>%s</%sQuestionId>%s' % (namespace_, self.gds_format_string(quote_xml(self.QuestionId).encode(ExternalEncoding), input_name='QuestionId'), namespace_, eol_))
        for Choices_ in self.Choices:
            Choices_.export(outfile, level, namespace_, name_='Choices', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VmPendingQuestionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmPendingQuestionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmPendingQuestionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Question is not None:
            showIndent(outfile, level)
            outfile.write('Question=%s,\n' % quote_python(self.Question).encode(ExternalEncoding))
        if self.QuestionId is not None:
            showIndent(outfile, level)
            outfile.write('QuestionId=%s,\n' % quote_python(self.QuestionId).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Choices=[\n')
        level += 1
        for Choices_ in self.Choices:
            showIndent(outfile, level)
            outfile.write('model_.VmQuestionAnswerChoiceType(\n')
            Choices_.exportLiteral(outfile, level, name_='VmQuestionAnswerChoiceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VmPendingQuestionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Question':
            Question_ = child_.text
            Question_ = self.gds_validate_string(Question_, node, 'Question')
            self.Question = Question_
        elif nodeName_ == 'QuestionId':
            QuestionId_ = child_.text
            QuestionId_ = self.gds_validate_string(QuestionId_, node, 'QuestionId')
            self.QuestionId = QuestionId_
        elif nodeName_ == 'Choices':
            obj_ = VmQuestionAnswerChoiceType.factory()
            obj_.build(child_)
            self.Choices.append(obj_)
            obj_.original_tagname_ = 'Choices'
        super(VmPendingQuestionType, self).buildChildren(child_, node, nodeName_, True)
# end class VmPendingQuestionType


class VmQuestionAnswerType(GeneratedsSuper):
    """0.9 Represents the answer to a question posted by a virtual machine
    that is WAITING_FOR_INPUT (status="5")."""
    subclass = None
    superclass = None
    def __init__(self, ChoiceId=None, QuestionId=None):
        self.original_tagname_ = None
        self.ChoiceId = ChoiceId
        self.QuestionId = QuestionId
    def factory(*args_, **kwargs_):
        if VmQuestionAnswerType.subclass:
            return VmQuestionAnswerType.subclass(*args_, **kwargs_)
        else:
            return VmQuestionAnswerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ChoiceId(self): return self.ChoiceId
    def set_ChoiceId(self, ChoiceId): self.ChoiceId = ChoiceId
    def get_QuestionId(self): return self.QuestionId
    def set_QuestionId(self, QuestionId): self.QuestionId = QuestionId
    def hasContent_(self):
        if (
            self.ChoiceId is not None or
            self.QuestionId is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmQuestionAnswerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmQuestionAnswerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmQuestionAnswerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmQuestionAnswerType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VmQuestionAnswerType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ChoiceId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChoiceId>%s</%sChoiceId>%s' % (namespace_, self.gds_format_integer(self.ChoiceId, input_name='ChoiceId'), namespace_, eol_))
        if self.QuestionId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQuestionId>%s</%sQuestionId>%s' % (namespace_, self.gds_format_string(quote_xml(self.QuestionId).encode(ExternalEncoding), input_name='QuestionId'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VmQuestionAnswerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ChoiceId is not None:
            showIndent(outfile, level)
            outfile.write('ChoiceId=%d,\n' % self.ChoiceId)
        if self.QuestionId is not None:
            showIndent(outfile, level)
            outfile.write('QuestionId=%s,\n' % quote_python(self.QuestionId).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ChoiceId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ChoiceId')
            self.ChoiceId = ival_
        elif nodeName_ == 'QuestionId':
            QuestionId_ = child_.text
            QuestionId_ = self.gds_validate_string(QuestionId_, node, 'QuestionId')
            self.QuestionId = QuestionId_
# end class VmQuestionAnswerType


class VmQuestionAnswerChoiceType(GeneratedsSuper):
    """0.9 Represents the answer to a question posted by a virtual machine
    that is WAITING_FOR_INPUT (status="5")."""
    subclass = None
    superclass = None
    def __init__(self, Id=None, Text=None):
        self.original_tagname_ = None
        self.Id = Id
        self.Text = Text
    def factory(*args_, **kwargs_):
        if VmQuestionAnswerChoiceType.subclass:
            return VmQuestionAnswerChoiceType.subclass(*args_, **kwargs_)
        else:
            return VmQuestionAnswerChoiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Text is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmQuestionAnswerChoiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmQuestionAnswerChoiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmQuestionAnswerChoiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmQuestionAnswerChoiceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VmQuestionAnswerChoiceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_integer(self.Id, input_name='Id'), namespace_, eol_))
        if self.Text is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sText>%s</%sText>%s' % (namespace_, self.gds_format_string(quote_xml(self.Text).encode(ExternalEncoding), input_name='Text'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VmQuestionAnswerChoiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%d,\n' % self.Id)
        if self.Text is not None:
            showIndent(outfile, level)
            outfile.write('Text=%s,\n' % quote_python(self.Text).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Id')
            self.Id = ival_
        elif nodeName_ == 'Text':
            Text_ = child_.text
            Text_ = self.gds_validate_string(Text_, node, 'Text')
            self.Text = Text_
# end class VmQuestionAnswerChoiceType


class RelocateParamsType(GeneratedsSuper):
    """5.11.5 Parameters to be used for virtual machine relocation."""
    subclass = None
    superclass = None
    def __init__(self, Datastore=None):
        self.original_tagname_ = None
        self.Datastore = Datastore
    def factory(*args_, **kwargs_):
        if RelocateParamsType.subclass:
            return RelocateParamsType.subclass(*args_, **kwargs_)
        else:
            return RelocateParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Datastore(self): return self.Datastore
    def set_Datastore(self, Datastore): self.Datastore = Datastore
    def hasContent_(self):
        if (
            self.Datastore is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelocateParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelocateParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelocateParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelocateParamsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RelocateParamsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Datastore is not None:
            self.Datastore.export(outfile, level, namespace_, name_='Datastore', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RelocateParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Datastore is not None:
            showIndent(outfile, level)
            outfile.write('Datastore=model_.ReferenceType(\n')
            self.Datastore.exportLiteral(outfile, level, name_='Datastore')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Datastore':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Datastore = obj_
            obj_.original_tagname_ = 'Datastore'
# end class RelocateParamsType


class CreateSnapshotParamsType(ParamsType):
    """5.1 Parameters for a createSnapshot request. always True if the
    snapshot should include the virtual machine's memory.
    falsealways True if the file system of the virtual machine
    should be quiesced before the snapshot is created. false"""
    subclass = None
    superclass = ParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, quiesce=None, memory=None):
        self.original_tagname_ = None
        super(CreateSnapshotParamsType, self).__init__(VCloudExtension, name, Description, )
        self.quiesce = _cast(bool, quiesce)
        self.memory = _cast(bool, memory)
    def factory(*args_, **kwargs_):
        if CreateSnapshotParamsType.subclass:
            return CreateSnapshotParamsType.subclass(*args_, **kwargs_)
        else:
            return CreateSnapshotParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_quiesce(self): return self.quiesce
    def set_quiesce(self, quiesce): self.quiesce = quiesce
    def get_memory(self): return self.memory
    def set_memory(self, memory): self.memory = memory
    def hasContent_(self):
        if (
            super(CreateSnapshotParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreateSnapshotParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreateSnapshotParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreateSnapshotParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreateSnapshotParamsType'):
        super(CreateSnapshotParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CreateSnapshotParamsType')
        if self.quiesce is not None and 'quiesce' not in already_processed:
            already_processed.add('quiesce')
            outfile.write(' quiesce="%s"' % self.gds_format_boolean(self.quiesce, input_name='quiesce'))
        if self.memory is not None and 'memory' not in already_processed:
            already_processed.add('memory')
            outfile.write(' memory="%s"' % self.gds_format_boolean(self.memory, input_name='memory'))
    def exportChildren(self, outfile, level, namespace_='', name_='CreateSnapshotParamsType', fromsubclass_=False, pretty_print=True):
        super(CreateSnapshotParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CreateSnapshotParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.quiesce is not None and 'quiesce' not in already_processed:
            already_processed.add('quiesce')
            showIndent(outfile, level)
            outfile.write('quiesce=%s,\n' % (self.quiesce,))
        if self.memory is not None and 'memory' not in already_processed:
            already_processed.add('memory')
            showIndent(outfile, level)
            outfile.write('memory=%s,\n' % (self.memory,))
        super(CreateSnapshotParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CreateSnapshotParamsType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('quiesce', node)
        if value is not None and 'quiesce' not in already_processed:
            already_processed.add('quiesce')
            if value in ('true', '1'):
                self.quiesce = True
            elif value in ('false', '0'):
                self.quiesce = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('memory', node)
        if value is not None and 'memory' not in already_processed:
            already_processed.add('memory')
            if value in ('true', '1'):
                self.memory = True
            elif value in ('false', '0'):
                self.memory = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(CreateSnapshotParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CreateSnapshotParamsType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CreateSnapshotParamsType


class ComplianceResultType(VCloudExtensibleType):
    """5.1 Represents the results of a compliance check."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, ComplianceStatus=None, ComplianceStatusMessage=None, ComplianceCheckTime=None):
        self.original_tagname_ = None
        super(ComplianceResultType, self).__init__(VCloudExtension, )
        self.ComplianceStatus = ComplianceStatus
        self.ComplianceStatusMessage = ComplianceStatusMessage
        if isinstance(ComplianceCheckTime, basestring):
            initvalue_ = datetime_.datetime.strptime(ComplianceCheckTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = ComplianceCheckTime
        self.ComplianceCheckTime = initvalue_
    def factory(*args_, **kwargs_):
        if ComplianceResultType.subclass:
            return ComplianceResultType.subclass(*args_, **kwargs_)
        else:
            return ComplianceResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ComplianceStatus(self): return self.ComplianceStatus
    def set_ComplianceStatus(self, ComplianceStatus): self.ComplianceStatus = ComplianceStatus
    def get_ComplianceStatusMessage(self): return self.ComplianceStatusMessage
    def set_ComplianceStatusMessage(self, ComplianceStatusMessage): self.ComplianceStatusMessage = ComplianceStatusMessage
    def get_ComplianceCheckTime(self): return self.ComplianceCheckTime
    def set_ComplianceCheckTime(self, ComplianceCheckTime): self.ComplianceCheckTime = ComplianceCheckTime
    def hasContent_(self):
        if (
            self.ComplianceStatus is not None or
            self.ComplianceStatusMessage is not None or
            self.ComplianceCheckTime is not None or
            super(ComplianceResultType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ComplianceResultType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComplianceResultType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ComplianceResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ComplianceResultType'):
        super(ComplianceResultType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ComplianceResultType')
    def exportChildren(self, outfile, level, namespace_='', name_='ComplianceResultType', fromsubclass_=False, pretty_print=True):
        super(ComplianceResultType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ComplianceStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComplianceStatus>%s</%sComplianceStatus>%s' % (namespace_, self.gds_format_string(quote_xml(self.ComplianceStatus).encode(ExternalEncoding), input_name='ComplianceStatus'), namespace_, eol_))
        if self.ComplianceStatusMessage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComplianceStatusMessage>%s</%sComplianceStatusMessage>%s' % (namespace_, self.gds_format_string(quote_xml(self.ComplianceStatusMessage).encode(ExternalEncoding), input_name='ComplianceStatusMessage'), namespace_, eol_))
        if self.ComplianceCheckTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComplianceCheckTime>%s</%sComplianceCheckTime>%s' % (namespace_, self.gds_format_datetime(self.ComplianceCheckTime, input_name='ComplianceCheckTime'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ComplianceResultType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ComplianceResultType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ComplianceResultType, self).exportLiteralChildren(outfile, level, name_)
        if self.ComplianceStatus is not None:
            showIndent(outfile, level)
            outfile.write('ComplianceStatus=%s,\n' % quote_python(self.ComplianceStatus).encode(ExternalEncoding))
        if self.ComplianceStatusMessage is not None:
            showIndent(outfile, level)
            outfile.write('ComplianceStatusMessage=%s,\n' % quote_python(self.ComplianceStatusMessage).encode(ExternalEncoding))
        if self.ComplianceCheckTime is not None:
            showIndent(outfile, level)
            outfile.write('ComplianceCheckTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.ComplianceCheckTime, input_name='ComplianceCheckTime'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ComplianceResultType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ComplianceStatus':
            ComplianceStatus_ = child_.text
            ComplianceStatus_ = self.gds_validate_string(ComplianceStatus_, node, 'ComplianceStatus')
            self.ComplianceStatus = ComplianceStatus_
        elif nodeName_ == 'ComplianceStatusMessage':
            ComplianceStatusMessage_ = child_.text
            ComplianceStatusMessage_ = self.gds_validate_string(ComplianceStatusMessage_, node, 'ComplianceStatusMessage')
            self.ComplianceStatusMessage = ComplianceStatusMessage_
        elif nodeName_ == 'ComplianceCheckTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.ComplianceCheckTime = dval_
        super(ComplianceResultType, self).buildChildren(child_, node, nodeName_, True)
# end class ComplianceResultType


class ResourceEntitiesType(VCloudExtensibleType):
    """0.9 Container for references to ResourceEntity objects in this vDC."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, ResourceEntity=None):
        self.original_tagname_ = None
        super(ResourceEntitiesType, self).__init__(VCloudExtension, )
        if ResourceEntity is None:
            self.ResourceEntity = []
        else:
            self.ResourceEntity = ResourceEntity
    def factory(*args_, **kwargs_):
        if ResourceEntitiesType.subclass:
            return ResourceEntitiesType.subclass(*args_, **kwargs_)
        else:
            return ResourceEntitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ResourceEntity(self): return self.ResourceEntity
    def set_ResourceEntity(self, ResourceEntity): self.ResourceEntity = ResourceEntity
    def add_ResourceEntity(self, value): self.ResourceEntity.append(value)
    def insert_ResourceEntity_at(self, index, value): self.ResourceEntity.insert(index, value)
    def replace_ResourceEntity_at(self, index, value): self.ResourceEntity[index] = value
    def hasContent_(self):
        if (
            self.ResourceEntity or
            super(ResourceEntitiesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceEntitiesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceEntitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceEntitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceEntitiesType'):
        super(ResourceEntitiesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceEntitiesType')
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceEntitiesType', fromsubclass_=False, pretty_print=True):
        super(ResourceEntitiesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResourceEntity_ in self.ResourceEntity:
            ResourceEntity_.export(outfile, level, namespace_, name_='ResourceEntity', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResourceEntitiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ResourceEntitiesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResourceEntitiesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('ResourceEntity=[\n')
        level += 1
        for ResourceEntity_ in self.ResourceEntity:
            showIndent(outfile, level)
            outfile.write('model_.ResourceReferenceType(\n')
            ResourceEntity_.exportLiteral(outfile, level, name_='ResourceReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResourceEntitiesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResourceEntity':
            obj_ = ResourceReferenceType.factory()
            obj_.build(child_)
            self.ResourceEntity.append(obj_)
            obj_.original_tagname_ = 'ResourceEntity'
        super(ResourceEntitiesType, self).buildChildren(child_, node, nodeName_, True)
# end class ResourceEntitiesType


class AvailableNetworksType(VCloudExtensibleType):
    """0.9 Container for references to available organization vDC networks."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Network=None):
        self.original_tagname_ = None
        super(AvailableNetworksType, self).__init__(VCloudExtension, )
        if Network is None:
            self.Network = []
        else:
            self.Network = Network
    def factory(*args_, **kwargs_):
        if AvailableNetworksType.subclass:
            return AvailableNetworksType.subclass(*args_, **kwargs_)
        else:
            return AvailableNetworksType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Network(self): return self.Network
    def set_Network(self, Network): self.Network = Network
    def add_Network(self, value): self.Network.append(value)
    def insert_Network_at(self, index, value): self.Network.insert(index, value)
    def replace_Network_at(self, index, value): self.Network[index] = value
    def hasContent_(self):
        if (
            self.Network or
            super(AvailableNetworksType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AvailableNetworksType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AvailableNetworksType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AvailableNetworksType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AvailableNetworksType'):
        super(AvailableNetworksType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AvailableNetworksType')
    def exportChildren(self, outfile, level, namespace_='', name_='AvailableNetworksType', fromsubclass_=False, pretty_print=True):
        super(AvailableNetworksType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Network_ in self.Network:
            Network_.export(outfile, level, namespace_, name_='Network', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AvailableNetworksType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AvailableNetworksType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AvailableNetworksType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Network=[\n')
        level += 1
        for Network_ in self.Network:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            Network_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AvailableNetworksType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Network':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Network.append(obj_)
            obj_.original_tagname_ = 'Network'
        super(AvailableNetworksType, self).buildChildren(child_, node, nodeName_, True)
# end class AvailableNetworksType


class VdcsType(VCloudExtensibleType):
    """0.9 Represents a list of references to vDCs."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Vdc=None):
        self.original_tagname_ = None
        super(VdcsType, self).__init__(VCloudExtension, )
        if Vdc is None:
            self.Vdc = []
        else:
            self.Vdc = Vdc
    def factory(*args_, **kwargs_):
        if VdcsType.subclass:
            return VdcsType.subclass(*args_, **kwargs_)
        else:
            return VdcsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Vdc(self): return self.Vdc
    def set_Vdc(self, Vdc): self.Vdc = Vdc
    def add_Vdc(self, value): self.Vdc.append(value)
    def insert_Vdc_at(self, index, value): self.Vdc.insert(index, value)
    def replace_Vdc_at(self, index, value): self.Vdc[index] = value
    def hasContent_(self):
        if (
            self.Vdc or
            super(VdcsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VdcsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VdcsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VdcsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VdcsType'):
        super(VdcsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VdcsType')
    def exportChildren(self, outfile, level, namespace_='', name_='VdcsType', fromsubclass_=False, pretty_print=True):
        super(VdcsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Vdc_ in self.Vdc:
            Vdc_.export(outfile, level, namespace_, name_='Vdc', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VdcsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VdcsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VdcsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Vdc=[\n')
        level += 1
        for Vdc_ in self.Vdc:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            Vdc_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VdcsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Vdc':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Vdc.append(obj_)
            obj_.original_tagname_ = 'Vdc'
        super(VdcsType, self).buildChildren(child_, node, nodeName_, True)
# end class VdcsType


class VdcType(EntityType):
    """0.9 Represents the user view of an organization vDC. none Creation
    status of the vDC. One of:<br> 0 (The vDC is still being
    created)<br> 1 (The vDC is ready)<br> -1 (There was an error
    while creating the vDC). false"""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, AllocationModel=None, StorageCapacity=None, ComputeCapacity=None, ResourceEntities=None, AvailableNetworks=None, Capabilities=None, NicQuota=None, NetworkQuota=None, UsedNetworkCount=None, VmQuota=None, IsEnabled=None, VdcStorageProfiles=None):
        self.original_tagname_ = None
        super(VdcType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.status = _cast(int, status)
        self.AllocationModel = AllocationModel
        self.StorageCapacity = StorageCapacity
        self.ComputeCapacity = ComputeCapacity
        self.ResourceEntities = ResourceEntities
        self.AvailableNetworks = AvailableNetworks
        self.Capabilities = Capabilities
        self.NicQuota = NicQuota
        self.NetworkQuota = NetworkQuota
        self.UsedNetworkCount = UsedNetworkCount
        self.VmQuota = VmQuota
        self.IsEnabled = IsEnabled
        self.VdcStorageProfiles = VdcStorageProfiles
    def factory(*args_, **kwargs_):
        if VdcType.subclass:
            return VdcType.subclass(*args_, **kwargs_)
        else:
            return VdcType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AllocationModel(self): return self.AllocationModel
    def set_AllocationModel(self, AllocationModel): self.AllocationModel = AllocationModel
    def get_StorageCapacity(self): return self.StorageCapacity
    def set_StorageCapacity(self, StorageCapacity): self.StorageCapacity = StorageCapacity
    def get_ComputeCapacity(self): return self.ComputeCapacity
    def set_ComputeCapacity(self, ComputeCapacity): self.ComputeCapacity = ComputeCapacity
    def get_ResourceEntities(self): return self.ResourceEntities
    def set_ResourceEntities(self, ResourceEntities): self.ResourceEntities = ResourceEntities
    def get_AvailableNetworks(self): return self.AvailableNetworks
    def set_AvailableNetworks(self, AvailableNetworks): self.AvailableNetworks = AvailableNetworks
    def get_Capabilities(self): return self.Capabilities
    def set_Capabilities(self, Capabilities): self.Capabilities = Capabilities
    def get_NicQuota(self): return self.NicQuota
    def set_NicQuota(self, NicQuota): self.NicQuota = NicQuota
    def get_NetworkQuota(self): return self.NetworkQuota
    def set_NetworkQuota(self, NetworkQuota): self.NetworkQuota = NetworkQuota
    def get_UsedNetworkCount(self): return self.UsedNetworkCount
    def set_UsedNetworkCount(self, UsedNetworkCount): self.UsedNetworkCount = UsedNetworkCount
    def get_VmQuota(self): return self.VmQuota
    def set_VmQuota(self, VmQuota): self.VmQuota = VmQuota
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_VdcStorageProfiles(self): return self.VdcStorageProfiles
    def set_VdcStorageProfiles(self, VdcStorageProfiles): self.VdcStorageProfiles = VdcStorageProfiles
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def hasContent_(self):
        if (
            self.AllocationModel is not None or
            self.StorageCapacity is not None or
            self.ComputeCapacity is not None or
            self.ResourceEntities is not None or
            self.AvailableNetworks is not None or
            self.Capabilities is not None or
            self.NicQuota is not None or
            self.NetworkQuota is not None or
            self.UsedNetworkCount is not None or
            self.VmQuota is not None or
            self.IsEnabled is not None or
            self.VdcStorageProfiles is not None or
            super(VdcType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VdcType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VdcType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VdcType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VdcType'):
        super(VdcType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VdcType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status="%s"' % self.gds_format_integer(self.status, input_name='status'))
    def exportChildren(self, outfile, level, namespace_='', name_='VdcType', fromsubclass_=False, pretty_print=True):
        super(VdcType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AllocationModel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllocationModel>%s</%sAllocationModel>%s' % (namespace_, self.gds_format_string(quote_xml(self.AllocationModel).encode(ExternalEncoding), input_name='AllocationModel'), namespace_, eol_))
        if self.StorageCapacity is not None:
            self.StorageCapacity.export(outfile, level, namespace_, name_='StorageCapacity', pretty_print=pretty_print)
        if self.ComputeCapacity is not None:
            self.ComputeCapacity.export(outfile, level, namespace_, name_='ComputeCapacity', pretty_print=pretty_print)
        if self.ResourceEntities is not None:
            self.ResourceEntities.export(outfile, level, namespace_, name_='ResourceEntities', pretty_print=pretty_print)
        if self.AvailableNetworks is not None:
            self.AvailableNetworks.export(outfile, level, namespace_, name_='AvailableNetworks', pretty_print=pretty_print)
        if self.Capabilities is not None:
            self.Capabilities.export(outfile, level, namespace_, name_='Capabilities', pretty_print=pretty_print)
        if self.NicQuota is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNicQuota>%s</%sNicQuota>%s' % (namespace_, self.gds_format_integer(self.NicQuota, input_name='NicQuota'), namespace_, eol_))
        if self.NetworkQuota is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetworkQuota>%s</%sNetworkQuota>%s' % (namespace_, self.gds_format_integer(self.NetworkQuota, input_name='NetworkQuota'), namespace_, eol_))
        if self.UsedNetworkCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUsedNetworkCount>%s</%sUsedNetworkCount>%s' % (namespace_, self.gds_format_integer(self.UsedNetworkCount, input_name='UsedNetworkCount'), namespace_, eol_))
        if self.VmQuota is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVmQuota>%s</%sVmQuota>%s' % (namespace_, self.gds_format_integer(self.VmQuota, input_name='VmQuota'), namespace_, eol_))
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.VdcStorageProfiles is not None:
            self.VdcStorageProfiles.export(outfile, level, namespace_, name_='VdcStorageProfiles', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VdcType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % (self.status,))
        super(VdcType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VdcType, self).exportLiteralChildren(outfile, level, name_)
        if self.AllocationModel is not None:
            showIndent(outfile, level)
            outfile.write('AllocationModel=%s,\n' % quote_python(self.AllocationModel).encode(ExternalEncoding))
        if self.StorageCapacity is not None:
            showIndent(outfile, level)
            outfile.write('StorageCapacity=model_.CapacityWithUsageType(\n')
            self.StorageCapacity.exportLiteral(outfile, level, name_='StorageCapacity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ComputeCapacity is not None:
            showIndent(outfile, level)
            outfile.write('ComputeCapacity=model_.ComputeCapacityType(\n')
            self.ComputeCapacity.exportLiteral(outfile, level, name_='ComputeCapacity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ResourceEntities is not None:
            showIndent(outfile, level)
            outfile.write('ResourceEntities=model_.ResourceEntitiesType(\n')
            self.ResourceEntities.exportLiteral(outfile, level, name_='ResourceEntities')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AvailableNetworks is not None:
            showIndent(outfile, level)
            outfile.write('AvailableNetworks=model_.AvailableNetworksType(\n')
            self.AvailableNetworks.exportLiteral(outfile, level, name_='AvailableNetworks')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Capabilities is not None:
            showIndent(outfile, level)
            outfile.write('Capabilities=model_.CapabilitiesType(\n')
            self.Capabilities.exportLiteral(outfile, level, name_='Capabilities')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NicQuota is not None:
            showIndent(outfile, level)
            outfile.write('NicQuota=%d,\n' % self.NicQuota)
        if self.NetworkQuota is not None:
            showIndent(outfile, level)
            outfile.write('NetworkQuota=%d,\n' % self.NetworkQuota)
        if self.UsedNetworkCount is not None:
            showIndent(outfile, level)
            outfile.write('UsedNetworkCount=%d,\n' % self.UsedNetworkCount)
        if self.VmQuota is not None:
            showIndent(outfile, level)
            outfile.write('VmQuota=%d,\n' % self.VmQuota)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.VdcStorageProfiles is not None:
            showIndent(outfile, level)
            outfile.write('VdcStorageProfiles=model_.VdcStorageProfilesType(\n')
            self.VdcStorageProfiles.exportLiteral(outfile, level, name_='VdcStorageProfiles')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            try:
                self.status = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(VdcType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AllocationModel':
            AllocationModel_ = child_.text
            AllocationModel_ = self.gds_validate_string(AllocationModel_, node, 'AllocationModel')
            self.AllocationModel = AllocationModel_
        elif nodeName_ == 'StorageCapacity':
            obj_ = CapacityWithUsageType.factory()
            obj_.build(child_)
            self.StorageCapacity = obj_
            obj_.original_tagname_ = 'StorageCapacity'
        elif nodeName_ == 'ComputeCapacity':
            obj_ = ComputeCapacityType.factory()
            obj_.build(child_)
            self.ComputeCapacity = obj_
            obj_.original_tagname_ = 'ComputeCapacity'
        elif nodeName_ == 'ResourceEntities':
            obj_ = ResourceEntitiesType.factory()
            obj_.build(child_)
            self.ResourceEntities = obj_
            obj_.original_tagname_ = 'ResourceEntities'
        elif nodeName_ == 'AvailableNetworks':
            obj_ = AvailableNetworksType.factory()
            obj_.build(child_)
            self.AvailableNetworks = obj_
            obj_.original_tagname_ = 'AvailableNetworks'
        elif nodeName_ == 'Capabilities':
            obj_ = CapabilitiesType.factory()
            obj_.build(child_)
            self.Capabilities = obj_
            obj_.original_tagname_ = 'Capabilities'
        elif nodeName_ == 'NicQuota':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NicQuota')
            self.NicQuota = ival_
        elif nodeName_ == 'NetworkQuota':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'NetworkQuota')
            self.NetworkQuota = ival_
        elif nodeName_ == 'UsedNetworkCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'UsedNetworkCount')
            self.UsedNetworkCount = ival_
        elif nodeName_ == 'VmQuota':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VmQuota')
            self.VmQuota = ival_
        elif nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'VdcStorageProfiles':
            obj_ = VdcStorageProfilesType.factory()
            obj_.build(child_)
            self.VdcStorageProfiles = obj_
            obj_.original_tagname_ = 'VdcStorageProfiles'
        super(VdcType, self).buildChildren(child_, node, nodeName_, True)
# end class VdcType


class ComputeCapacityType(VCloudExtensibleType):
    """0.9 Represents vDC compute capacity."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Cpu=None, Memory=None):
        self.original_tagname_ = None
        super(ComputeCapacityType, self).__init__(VCloudExtension, )
        self.Cpu = Cpu
        self.Memory = Memory
    def factory(*args_, **kwargs_):
        if ComputeCapacityType.subclass:
            return ComputeCapacityType.subclass(*args_, **kwargs_)
        else:
            return ComputeCapacityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Cpu(self): return self.Cpu
    def set_Cpu(self, Cpu): self.Cpu = Cpu
    def get_Memory(self): return self.Memory
    def set_Memory(self, Memory): self.Memory = Memory
    def hasContent_(self):
        if (
            self.Cpu is not None or
            self.Memory is not None or
            super(ComputeCapacityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ComputeCapacityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComputeCapacityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ComputeCapacityType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ComputeCapacityType'):
        super(ComputeCapacityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ComputeCapacityType')
    def exportChildren(self, outfile, level, namespace_='', name_='ComputeCapacityType', fromsubclass_=False, pretty_print=True):
        super(ComputeCapacityType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Cpu is not None:
            self.Cpu.export(outfile, level, namespace_, name_='Cpu', pretty_print=pretty_print)
        if self.Memory is not None:
            self.Memory.export(outfile, level, namespace_, name_='Memory', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ComputeCapacityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ComputeCapacityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ComputeCapacityType, self).exportLiteralChildren(outfile, level, name_)
        if self.Cpu is not None:
            showIndent(outfile, level)
            outfile.write('Cpu=model_.CapacityWithUsageType(\n')
            self.Cpu.exportLiteral(outfile, level, name_='Cpu')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Memory is not None:
            showIndent(outfile, level)
            outfile.write('Memory=model_.CapacityWithUsageType(\n')
            self.Memory.exportLiteral(outfile, level, name_='Memory')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ComputeCapacityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Cpu':
            obj_ = CapacityWithUsageType.factory()
            obj_.build(child_)
            self.Cpu = obj_
            obj_.original_tagname_ = 'Cpu'
        elif nodeName_ == 'Memory':
            obj_ = CapacityWithUsageType.factory()
            obj_.build(child_)
            self.Memory = obj_
            obj_.original_tagname_ = 'Memory'
        super(ComputeCapacityType, self).buildChildren(child_, node, nodeName_, True)
# end class ComputeCapacityType


class CapabilitiesType(VCloudExtensibleType):
    """1.5 Collection of supported hardware capabilities."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, SupportedHardwareVersions=None):
        self.original_tagname_ = None
        super(CapabilitiesType, self).__init__(VCloudExtension, )
        self.SupportedHardwareVersions = SupportedHardwareVersions
    def factory(*args_, **kwargs_):
        if CapabilitiesType.subclass:
            return CapabilitiesType.subclass(*args_, **kwargs_)
        else:
            return CapabilitiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SupportedHardwareVersions(self): return self.SupportedHardwareVersions
    def set_SupportedHardwareVersions(self, SupportedHardwareVersions): self.SupportedHardwareVersions = SupportedHardwareVersions
    def hasContent_(self):
        if (
            self.SupportedHardwareVersions is not None or
            super(CapabilitiesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CapabilitiesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CapabilitiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CapabilitiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CapabilitiesType'):
        super(CapabilitiesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CapabilitiesType')
    def exportChildren(self, outfile, level, namespace_='', name_='CapabilitiesType', fromsubclass_=False, pretty_print=True):
        super(CapabilitiesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SupportedHardwareVersions is not None:
            self.SupportedHardwareVersions.export(outfile, level, namespace_, name_='SupportedHardwareVersions', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CapabilitiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CapabilitiesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CapabilitiesType, self).exportLiteralChildren(outfile, level, name_)
        if self.SupportedHardwareVersions is not None:
            showIndent(outfile, level)
            outfile.write('SupportedHardwareVersions=model_.SupportedHardwareVersionsType(\n')
            self.SupportedHardwareVersions.exportLiteral(outfile, level, name_='SupportedHardwareVersions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CapabilitiesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SupportedHardwareVersions':
            obj_ = SupportedHardwareVersionsType.factory()
            obj_.build(child_)
            self.SupportedHardwareVersions = obj_
            obj_.original_tagname_ = 'SupportedHardwareVersions'
        super(CapabilitiesType, self).buildChildren(child_, node, nodeName_, True)
# end class CapabilitiesType


class SupportedHardwareVersionsType(VCloudExtensibleType):
    """1.5 Contains a list of VMware virtual hardware versions supported in
    this vDC."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, SupportedHardwareVersion=None):
        self.original_tagname_ = None
        super(SupportedHardwareVersionsType, self).__init__(VCloudExtension, )
        if SupportedHardwareVersion is None:
            self.SupportedHardwareVersion = []
        else:
            self.SupportedHardwareVersion = SupportedHardwareVersion
    def factory(*args_, **kwargs_):
        if SupportedHardwareVersionsType.subclass:
            return SupportedHardwareVersionsType.subclass(*args_, **kwargs_)
        else:
            return SupportedHardwareVersionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SupportedHardwareVersion(self): return self.SupportedHardwareVersion
    def set_SupportedHardwareVersion(self, SupportedHardwareVersion): self.SupportedHardwareVersion = SupportedHardwareVersion
    def add_SupportedHardwareVersion(self, value): self.SupportedHardwareVersion.append(value)
    def insert_SupportedHardwareVersion_at(self, index, value): self.SupportedHardwareVersion.insert(index, value)
    def replace_SupportedHardwareVersion_at(self, index, value): self.SupportedHardwareVersion[index] = value
    def validate_SupportedHardwareVersionType(self, value):
        # Validate type SupportedHardwareVersionType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.SupportedHardwareVersion or
            super(SupportedHardwareVersionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupportedHardwareVersionsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupportedHardwareVersionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupportedHardwareVersionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupportedHardwareVersionsType'):
        super(SupportedHardwareVersionsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SupportedHardwareVersionsType')
    def exportChildren(self, outfile, level, namespace_='', name_='SupportedHardwareVersionsType', fromsubclass_=False, pretty_print=True):
        super(SupportedHardwareVersionsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SupportedHardwareVersion_ in self.SupportedHardwareVersion:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSupportedHardwareVersion>%s</%sSupportedHardwareVersion>%s' % (namespace_, self.gds_format_string(quote_xml(SupportedHardwareVersion_).encode(ExternalEncoding), input_name='SupportedHardwareVersion'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SupportedHardwareVersionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SupportedHardwareVersionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SupportedHardwareVersionsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('SupportedHardwareVersion=[\n')
        level += 1
        for SupportedHardwareVersion_ in self.SupportedHardwareVersion:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(SupportedHardwareVersion_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SupportedHardwareVersionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SupportedHardwareVersion':
            SupportedHardwareVersion_ = child_.text
            SupportedHardwareVersion_ = self.gds_validate_string(SupportedHardwareVersion_, node, 'SupportedHardwareVersion')
            self.SupportedHardwareVersion.append(SupportedHardwareVersion_)
            self.validate_SupportedHardwareVersionType(self.SupportedHardwareVersion)    # validate type SupportedHardwareVersionType
        super(SupportedHardwareVersionsType, self).buildChildren(child_, node, nodeName_, True)
# end class SupportedHardwareVersionsType


class NetworkType(EntityType):
    """0.9 Represents a Network in the vCloud model."""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, Configuration=None, extensiontype_=None):
        self.original_tagname_ = None
        super(NetworkType, self).__init__(operationKey, id, name, Description, Tasks, extensiontype_, )
        self.Configuration = Configuration
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if NetworkType.subclass:
            return NetworkType.subclass(*args_, **kwargs_)
        else:
            return NetworkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Configuration(self): return self.Configuration
    def set_Configuration(self, Configuration): self.Configuration = Configuration
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Configuration is not None or
            super(NetworkType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkType'):
        super(NetworkType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkType', fromsubclass_=False, pretty_print=True):
        super(NetworkType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Configuration is not None:
            self.Configuration.export(outfile, level, namespace_, name_='Configuration', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NetworkType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkType, self).exportLiteralChildren(outfile, level, name_)
        if self.Configuration is not None:
            showIndent(outfile, level)
            outfile.write('Configuration=model_.NetworkConfigurationType(\n')
            self.Configuration.exportLiteral(outfile, level, name_='Configuration')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NetworkType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Configuration':
            obj_ = NetworkConfigurationType.factory()
            obj_.build(child_)
            self.Configuration = obj_
            obj_.original_tagname_ = 'Configuration'
        super(NetworkType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkType


class OrgNetworkType(NetworkType):
    """0.95.1 Represents an organization network in the vCloud model."""
    subclass = None
    superclass = NetworkType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, Configuration=None, NetworkPool=None, AllowedExternalIpAddresses=None):
        self.original_tagname_ = None
        super(OrgNetworkType, self).__init__(operationKey, id, name, Description, Tasks, Configuration, )
        self.NetworkPool = NetworkPool
        self.AllowedExternalIpAddresses = AllowedExternalIpAddresses
    def factory(*args_, **kwargs_):
        if OrgNetworkType.subclass:
            return OrgNetworkType.subclass(*args_, **kwargs_)
        else:
            return OrgNetworkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NetworkPool(self): return self.NetworkPool
    def set_NetworkPool(self, NetworkPool): self.NetworkPool = NetworkPool
    def get_AllowedExternalIpAddresses(self): return self.AllowedExternalIpAddresses
    def set_AllowedExternalIpAddresses(self, AllowedExternalIpAddresses): self.AllowedExternalIpAddresses = AllowedExternalIpAddresses
    def hasContent_(self):
        if (
            self.NetworkPool is not None or
            self.AllowedExternalIpAddresses is not None or
            super(OrgNetworkType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrgNetworkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrgNetworkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrgNetworkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrgNetworkType'):
        super(OrgNetworkType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrgNetworkType')
    def exportChildren(self, outfile, level, namespace_='', name_='OrgNetworkType', fromsubclass_=False, pretty_print=True):
        super(OrgNetworkType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NetworkPool is not None:
            self.NetworkPool.export(outfile, level, namespace_, name_='NetworkPool', pretty_print=pretty_print)
        if self.AllowedExternalIpAddresses is not None:
            self.AllowedExternalIpAddresses.export(outfile, level, namespace_, name_='AllowedExternalIpAddresses', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OrgNetworkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OrgNetworkType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrgNetworkType, self).exportLiteralChildren(outfile, level, name_)
        if self.NetworkPool is not None:
            showIndent(outfile, level)
            outfile.write('NetworkPool=model_.ReferenceType(\n')
            self.NetworkPool.exportLiteral(outfile, level, name_='NetworkPool')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AllowedExternalIpAddresses is not None:
            showIndent(outfile, level)
            outfile.write('AllowedExternalIpAddresses=model_.IpAddressesType(\n')
            self.AllowedExternalIpAddresses.exportLiteral(outfile, level, name_='AllowedExternalIpAddresses')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OrgNetworkType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetworkPool':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.NetworkPool = obj_
            obj_.original_tagname_ = 'NetworkPool'
        elif nodeName_ == 'AllowedExternalIpAddresses':
            obj_ = IpAddressesType.factory()
            obj_.build(child_)
            self.AllowedExternalIpAddresses = obj_
            obj_.original_tagname_ = 'AllowedExternalIpAddresses'
        super(OrgNetworkType, self).buildChildren(child_, node, nodeName_, True)
# end class OrgNetworkType


class VAppNetworkType(NetworkType):
    """1.5 Represents a vApp network. 1.5none True if the network is
    deployed. false"""
    subclass = None
    superclass = NetworkType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, Configuration=None, deployed=None):
        self.original_tagname_ = None
        super(VAppNetworkType, self).__init__(operationKey, id, name, Description, Tasks, Configuration, )
        self.deployed = _cast(bool, deployed)
    def factory(*args_, **kwargs_):
        if VAppNetworkType.subclass:
            return VAppNetworkType.subclass(*args_, **kwargs_)
        else:
            return VAppNetworkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deployed(self): return self.deployed
    def set_deployed(self, deployed): self.deployed = deployed
    def hasContent_(self):
        if (
            super(VAppNetworkType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VAppNetworkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VAppNetworkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VAppNetworkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VAppNetworkType'):
        super(VAppNetworkType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VAppNetworkType')
        if self.deployed is not None and 'deployed' not in already_processed:
            already_processed.add('deployed')
            outfile.write(' deployed="%s"' % self.gds_format_boolean(self.deployed, input_name='deployed'))
    def exportChildren(self, outfile, level, namespace_='', name_='VAppNetworkType', fromsubclass_=False, pretty_print=True):
        super(VAppNetworkType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VAppNetworkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deployed is not None and 'deployed' not in already_processed:
            already_processed.add('deployed')
            showIndent(outfile, level)
            outfile.write('deployed=%s,\n' % (self.deployed,))
        super(VAppNetworkType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VAppNetworkType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deployed', node)
        if value is not None and 'deployed' not in already_processed:
            already_processed.add('deployed')
            if value in ('true', '1'):
                self.deployed = True
            elif value in ('false', '0'):
                self.deployed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(VAppNetworkType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VAppNetworkType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VAppNetworkType


class NetworkServiceType(VCloudExtensibleType):
    """This is the root of the substitution group for network services.
    Replace it with any of NatService, LoadBalancerService
    IpsecVpnService/GatewayIpsecVpnService,
    DhcpService/GatewayDhcpService, FirewallService, or
    StaticRoutingService."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsEnabled=None, extensiontype_=None):
        self.original_tagname_ = None
        super(NetworkServiceType, self).__init__(VCloudExtension, extensiontype_, )
        self.IsEnabled = IsEnabled
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if NetworkServiceType.subclass:
            return NetworkServiceType.subclass(*args_, **kwargs_)
        else:
            return NetworkServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.IsEnabled is not None or
            super(NetworkServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkServiceType'):
        super(NetworkServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkServiceType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkServiceType', fromsubclass_=False, pretty_print=True):
        super(NetworkServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NetworkServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NetworkServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkServiceType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(NetworkServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        super(NetworkServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkServiceType


class NetworkFeaturesType(GeneratedsSuper):
    """Represents features of a network."""
    subclass = None
    superclass = None
    def __init__(self, NetworkService=None):
        self.original_tagname_ = None
        if NetworkService is None:
            self.NetworkService = []
        else:
            self.NetworkService = NetworkService
    def factory(*args_, **kwargs_):
        if NetworkFeaturesType.subclass:
            return NetworkFeaturesType.subclass(*args_, **kwargs_)
        else:
            return NetworkFeaturesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NetworkService(self): return self.NetworkService
    def set_NetworkService(self, NetworkService): self.NetworkService = NetworkService
    def add_NetworkService(self, value): self.NetworkService.append(value)
    def insert_NetworkService_at(self, index, value): self.NetworkService.insert(index, value)
    def replace_NetworkService_at(self, index, value): self.NetworkService[index] = value
    def hasContent_(self):
        if (
            self.NetworkService
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkFeaturesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkFeaturesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkFeaturesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkFeaturesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkFeaturesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NetworkService_ in self.NetworkService:
            NetworkService_.export(outfile, level, namespace_, name_='NetworkService', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkFeaturesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NetworkService=[\n')
        level += 1
        for NetworkService_ in self.NetworkService:
            showIndent(outfile, level)
            outfile.write('model_.NetworkService(\n')
            NetworkService_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetworkService':
            class_obj_ = self.get_class_obj_(child_, NetworkServiceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'NetworkService'
        elif nodeName_ == 'DhcpService':
            obj_ = DhcpServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'DhcpService'
        elif nodeName_ == 'FirewallService':
            obj_ = FirewallServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'FirewallService'
        elif nodeName_ == 'NatService':
            obj_ = NatServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'NatService'
        elif nodeName_ == 'IpsecVpnService':
            obj_ = IpsecVpnServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'IpsecVpnService'
        elif nodeName_ == 'StaticRoutingService':
            obj_ = StaticRoutingServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'StaticRoutingService'
        elif nodeName_ == 'GatewayIpsecVpnService':
            obj_ = GatewayIpsecVpnServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'GatewayIpsecVpnService'
        elif nodeName_ == 'LoadBalancerService':
            obj_ = LoadBalancerServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'LoadBalancerService'
        elif nodeName_ == 'GatewayDhcpService':
            obj_ = GatewayDhcpServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'GatewayDhcpService'
# end class NetworkFeaturesType


class RouterInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ExternalIp=None):
        self.original_tagname_ = None
        self.ExternalIp = ExternalIp
    def factory(*args_, **kwargs_):
        if RouterInfoType.subclass:
            return RouterInfoType.subclass(*args_, **kwargs_)
        else:
            return RouterInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalIp(self): return self.ExternalIp
    def set_ExternalIp(self, ExternalIp): self.ExternalIp = ExternalIp
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ExternalIp is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RouterInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RouterInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RouterInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RouterInfoType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RouterInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExternalIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIp>%s</%sExternalIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIp).encode(ExternalEncoding), input_name='ExternalIp'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='RouterInfoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ExternalIp is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIp=%s,\n' % quote_python(self.ExternalIp).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalIp':
            ExternalIp_ = child_.text
            ExternalIp_ = self.gds_validate_string(ExternalIp_, node, 'ExternalIp')
            self.ExternalIp = ExternalIp_
            self.validate_IpAddressType(self.ExternalIp)    # validate type IpAddressType
# end class RouterInfoType


class DhcpServiceType(NetworkServiceType):
    """Represents a DHCP network service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, DefaultLeaseTime=None, MaxLeaseTime=None, IpRange=None, RouterIp=None, SubMask=None, PrimaryNameServer=None, SecondaryNameServer=None, DomainName=None):
        self.original_tagname_ = None
        super(DhcpServiceType, self).__init__(VCloudExtension, IsEnabled, )
        self.DefaultLeaseTime = DefaultLeaseTime
        self.MaxLeaseTime = MaxLeaseTime
        self.IpRange = IpRange
        self.RouterIp = RouterIp
        self.SubMask = SubMask
        self.PrimaryNameServer = PrimaryNameServer
        self.SecondaryNameServer = SecondaryNameServer
        self.DomainName = DomainName
    def factory(*args_, **kwargs_):
        if DhcpServiceType.subclass:
            return DhcpServiceType.subclass(*args_, **kwargs_)
        else:
            return DhcpServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DefaultLeaseTime(self): return self.DefaultLeaseTime
    def set_DefaultLeaseTime(self, DefaultLeaseTime): self.DefaultLeaseTime = DefaultLeaseTime
    def get_MaxLeaseTime(self): return self.MaxLeaseTime
    def set_MaxLeaseTime(self, MaxLeaseTime): self.MaxLeaseTime = MaxLeaseTime
    def get_IpRange(self): return self.IpRange
    def set_IpRange(self, IpRange): self.IpRange = IpRange
    def get_RouterIp(self): return self.RouterIp
    def set_RouterIp(self, RouterIp): self.RouterIp = RouterIp
    def get_SubMask(self): return self.SubMask
    def set_SubMask(self, SubMask): self.SubMask = SubMask
    def get_PrimaryNameServer(self): return self.PrimaryNameServer
    def set_PrimaryNameServer(self, PrimaryNameServer): self.PrimaryNameServer = PrimaryNameServer
    def get_SecondaryNameServer(self): return self.SecondaryNameServer
    def set_SecondaryNameServer(self, SecondaryNameServer): self.SecondaryNameServer = SecondaryNameServer
    def get_DomainName(self): return self.DomainName
    def set_DomainName(self, DomainName): self.DomainName = DomainName
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DefaultLeaseTime is not None or
            self.MaxLeaseTime is not None or
            self.IpRange is not None or
            self.RouterIp is not None or
            self.SubMask is not None or
            self.PrimaryNameServer is not None or
            self.SecondaryNameServer is not None or
            self.DomainName is not None or
            super(DhcpServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DhcpServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DhcpServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DhcpServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DhcpServiceType'):
        super(DhcpServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DhcpServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='DhcpServiceType', fromsubclass_=False, pretty_print=True):
        super(DhcpServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultLeaseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefaultLeaseTime>%s</%sDefaultLeaseTime>%s' % (namespace_, self.gds_format_integer(self.DefaultLeaseTime, input_name='DefaultLeaseTime'), namespace_, eol_))
        if self.MaxLeaseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxLeaseTime>%s</%sMaxLeaseTime>%s' % (namespace_, self.gds_format_integer(self.MaxLeaseTime, input_name='MaxLeaseTime'), namespace_, eol_))
        if self.IpRange is not None:
            self.IpRange.export(outfile, level, namespace_, name_='IpRange', pretty_print=pretty_print)
        if self.RouterIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRouterIp>%s</%sRouterIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.RouterIp).encode(ExternalEncoding), input_name='RouterIp'), namespace_, eol_))
        if self.SubMask is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubMask>%s</%sSubMask>%s' % (namespace_, self.gds_format_string(quote_xml(self.SubMask).encode(ExternalEncoding), input_name='SubMask'), namespace_, eol_))
        if self.PrimaryNameServer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryNameServer>%s</%sPrimaryNameServer>%s' % (namespace_, self.gds_format_string(quote_xml(self.PrimaryNameServer).encode(ExternalEncoding), input_name='PrimaryNameServer'), namespace_, eol_))
        if self.SecondaryNameServer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSecondaryNameServer>%s</%sSecondaryNameServer>%s' % (namespace_, self.gds_format_string(quote_xml(self.SecondaryNameServer).encode(ExternalEncoding), input_name='SecondaryNameServer'), namespace_, eol_))
        if self.DomainName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDomainName>%s</%sDomainName>%s' % (namespace_, self.gds_format_string(quote_xml(self.DomainName).encode(ExternalEncoding), input_name='DomainName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DhcpServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DhcpServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DhcpServiceType, self).exportLiteralChildren(outfile, level, name_)
        if self.DefaultLeaseTime is not None:
            showIndent(outfile, level)
            outfile.write('DefaultLeaseTime=%d,\n' % self.DefaultLeaseTime)
        if self.MaxLeaseTime is not None:
            showIndent(outfile, level)
            outfile.write('MaxLeaseTime=%d,\n' % self.MaxLeaseTime)
        if self.IpRange is not None:
            showIndent(outfile, level)
            outfile.write('IpRange=model_.IpRangeType(\n')
            self.IpRange.exportLiteral(outfile, level, name_='IpRange')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RouterIp is not None:
            showIndent(outfile, level)
            outfile.write('RouterIp=%s,\n' % quote_python(self.RouterIp).encode(ExternalEncoding))
        if self.SubMask is not None:
            showIndent(outfile, level)
            outfile.write('SubMask=%s,\n' % quote_python(self.SubMask).encode(ExternalEncoding))
        if self.PrimaryNameServer is not None:
            showIndent(outfile, level)
            outfile.write('PrimaryNameServer=%s,\n' % quote_python(self.PrimaryNameServer).encode(ExternalEncoding))
        if self.SecondaryNameServer is not None:
            showIndent(outfile, level)
            outfile.write('SecondaryNameServer=%s,\n' % quote_python(self.SecondaryNameServer).encode(ExternalEncoding))
        if self.DomainName is not None:
            showIndent(outfile, level)
            outfile.write('DomainName=%s,\n' % quote_python(self.DomainName).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DhcpServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DefaultLeaseTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DefaultLeaseTime')
            self.DefaultLeaseTime = ival_
        elif nodeName_ == 'MaxLeaseTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaxLeaseTime')
            self.MaxLeaseTime = ival_
        elif nodeName_ == 'IpRange':
            obj_ = IpRangeType.factory()
            obj_.build(child_)
            self.IpRange = obj_
            obj_.original_tagname_ = 'IpRange'
        elif nodeName_ == 'RouterIp':
            RouterIp_ = child_.text
            RouterIp_ = self.gds_validate_string(RouterIp_, node, 'RouterIp')
            self.RouterIp = RouterIp_
            self.validate_IpAddressType(self.RouterIp)    # validate type IpAddressType
        elif nodeName_ == 'SubMask':
            SubMask_ = child_.text
            SubMask_ = self.gds_validate_string(SubMask_, node, 'SubMask')
            self.SubMask = SubMask_
            self.validate_IpAddressType(self.SubMask)    # validate type IpAddressType
        elif nodeName_ == 'PrimaryNameServer':
            PrimaryNameServer_ = child_.text
            PrimaryNameServer_ = self.gds_validate_string(PrimaryNameServer_, node, 'PrimaryNameServer')
            self.PrimaryNameServer = PrimaryNameServer_
        elif nodeName_ == 'SecondaryNameServer':
            SecondaryNameServer_ = child_.text
            SecondaryNameServer_ = self.gds_validate_string(SecondaryNameServer_, node, 'SecondaryNameServer')
            self.SecondaryNameServer = SecondaryNameServer_
        elif nodeName_ == 'DomainName':
            DomainName_ = child_.text
            DomainName_ = self.gds_validate_string(DomainName_, node, 'DomainName')
            self.DomainName = DomainName_
        super(DhcpServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class DhcpServiceType


class NatServiceType(NetworkServiceType):
    """Represents a NAT network service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, NatType=None, Policy=None, NatRule=None, ExternalIp=None):
        self.original_tagname_ = None
        super(NatServiceType, self).__init__(VCloudExtension, IsEnabled, )
        self.NatType = NatType
        self.Policy = Policy
        if NatRule is None:
            self.NatRule = []
        else:
            self.NatRule = NatRule
        self.ExternalIp = ExternalIp
    def factory(*args_, **kwargs_):
        if NatServiceType.subclass:
            return NatServiceType.subclass(*args_, **kwargs_)
        else:
            return NatServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NatType(self): return self.NatType
    def set_NatType(self, NatType): self.NatType = NatType
    def get_Policy(self): return self.Policy
    def set_Policy(self, Policy): self.Policy = Policy
    def get_NatRule(self): return self.NatRule
    def set_NatRule(self, NatRule): self.NatRule = NatRule
    def add_NatRule(self, value): self.NatRule.append(value)
    def insert_NatRule_at(self, index, value): self.NatRule.insert(index, value)
    def replace_NatRule_at(self, index, value): self.NatRule[index] = value
    def get_ExternalIp(self): return self.ExternalIp
    def set_ExternalIp(self, ExternalIp): self.ExternalIp = ExternalIp
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.NatType is not None or
            self.Policy is not None or
            self.NatRule or
            self.ExternalIp is not None or
            super(NatServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NatServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NatServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NatServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NatServiceType'):
        super(NatServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NatServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='NatServiceType', fromsubclass_=False, pretty_print=True):
        super(NatServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NatType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNatType>%s</%sNatType>%s' % (namespace_, self.gds_format_string(quote_xml(self.NatType).encode(ExternalEncoding), input_name='NatType'), namespace_, eol_))
        if self.Policy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPolicy>%s</%sPolicy>%s' % (namespace_, self.gds_format_string(quote_xml(self.Policy).encode(ExternalEncoding), input_name='Policy'), namespace_, eol_))
        for NatRule_ in self.NatRule:
            NatRule_.export(outfile, level, namespace_, name_='NatRule', pretty_print=pretty_print)
        if self.ExternalIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIp>%s</%sExternalIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIp).encode(ExternalEncoding), input_name='ExternalIp'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NatServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NatServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NatServiceType, self).exportLiteralChildren(outfile, level, name_)
        if self.NatType is not None:
            showIndent(outfile, level)
            outfile.write('NatType=%s,\n' % quote_python(self.NatType).encode(ExternalEncoding))
        if self.Policy is not None:
            showIndent(outfile, level)
            outfile.write('Policy=%s,\n' % quote_python(self.Policy).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('NatRule=[\n')
        level += 1
        for NatRule_ in self.NatRule:
            showIndent(outfile, level)
            outfile.write('model_.NatRuleType(\n')
            NatRule_.exportLiteral(outfile, level, name_='NatRuleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ExternalIp is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIp=%s,\n' % quote_python(self.ExternalIp).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NatServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NatType':
            NatType_ = child_.text
            NatType_ = self.gds_validate_string(NatType_, node, 'NatType')
            self.NatType = NatType_
        elif nodeName_ == 'Policy':
            Policy_ = child_.text
            Policy_ = self.gds_validate_string(Policy_, node, 'Policy')
            self.Policy = Policy_
        elif nodeName_ == 'NatRule':
            obj_ = NatRuleType.factory()
            obj_.build(child_)
            self.NatRule.append(obj_)
            obj_.original_tagname_ = 'NatRule'
        elif nodeName_ == 'ExternalIp':
            ExternalIp_ = child_.text
            ExternalIp_ = self.gds_validate_string(ExternalIp_, node, 'ExternalIp')
            self.ExternalIp = ExternalIp_
            self.validate_IpAddressType(self.ExternalIp)    # validate type IpAddressType
        super(NatServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class NatServiceType


class NatRuleType(VCloudExtensibleType):
    """0.9 Represents a NAT rule."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Description=None, RuleType=None, IsEnabled=None, Id=None, GatewayNatRule=None, OneToOneBasicRule=None, OneToOneVmRule=None, PortForwardingRule=None, VmRule=None):
        self.original_tagname_ = None
        super(NatRuleType, self).__init__(VCloudExtension, )
        self.Description = Description
        self.RuleType = RuleType
        self.IsEnabled = IsEnabled
        self.Id = Id
        self.GatewayNatRule = GatewayNatRule
        self.OneToOneBasicRule = OneToOneBasicRule
        self.OneToOneVmRule = OneToOneVmRule
        self.PortForwardingRule = PortForwardingRule
        self.VmRule = VmRule
    def factory(*args_, **kwargs_):
        if NatRuleType.subclass:
            return NatRuleType.subclass(*args_, **kwargs_)
        else:
            return NatRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_RuleType(self): return self.RuleType
    def set_RuleType(self, RuleType): self.RuleType = RuleType
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_GatewayNatRule(self): return self.GatewayNatRule
    def set_GatewayNatRule(self, GatewayNatRule): self.GatewayNatRule = GatewayNatRule
    def get_OneToOneBasicRule(self): return self.OneToOneBasicRule
    def set_OneToOneBasicRule(self, OneToOneBasicRule): self.OneToOneBasicRule = OneToOneBasicRule
    def get_OneToOneVmRule(self): return self.OneToOneVmRule
    def set_OneToOneVmRule(self, OneToOneVmRule): self.OneToOneVmRule = OneToOneVmRule
    def get_PortForwardingRule(self): return self.PortForwardingRule
    def set_PortForwardingRule(self, PortForwardingRule): self.PortForwardingRule = PortForwardingRule
    def get_VmRule(self): return self.VmRule
    def set_VmRule(self, VmRule): self.VmRule = VmRule
    def hasContent_(self):
        if (
            self.Description is not None or
            self.RuleType is not None or
            self.IsEnabled is not None or
            self.Id is not None or
            self.GatewayNatRule is not None or
            self.OneToOneBasicRule is not None or
            self.OneToOneVmRule is not None or
            self.PortForwardingRule is not None or
            self.VmRule is not None or
            super(NatRuleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NatRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NatRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NatRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NatRuleType'):
        super(NatRuleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NatRuleType')
    def exportChildren(self, outfile, level, namespace_='', name_='NatRuleType', fromsubclass_=False, pretty_print=True):
        super(NatRuleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.RuleType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRuleType>%s</%sRuleType>%s' % (namespace_, self.gds_format_string(quote_xml(self.RuleType).encode(ExternalEncoding), input_name='RuleType'), namespace_, eol_))
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_integer(self.Id, input_name='Id'), namespace_, eol_))
        if self.GatewayNatRule is not None:
            self.GatewayNatRule.export(outfile, level, namespace_, name_='GatewayNatRule', pretty_print=pretty_print)
        if self.OneToOneBasicRule is not None:
            self.OneToOneBasicRule.export(outfile, level, namespace_, name_='OneToOneBasicRule', pretty_print=pretty_print)
        if self.OneToOneVmRule is not None:
            self.OneToOneVmRule.export(outfile, level, namespace_, name_='OneToOneVmRule', pretty_print=pretty_print)
        if self.PortForwardingRule is not None:
            self.PortForwardingRule.export(outfile, level, namespace_, name_='PortForwardingRule', pretty_print=pretty_print)
        if self.VmRule is not None:
            self.VmRule.export(outfile, level, namespace_, name_='VmRule', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NatRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NatRuleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NatRuleType, self).exportLiteralChildren(outfile, level, name_)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.RuleType is not None:
            showIndent(outfile, level)
            outfile.write('RuleType=%s,\n' % quote_python(self.RuleType).encode(ExternalEncoding))
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%d,\n' % self.Id)
        if self.GatewayNatRule is not None:
            showIndent(outfile, level)
            outfile.write('GatewayNatRule=model_.GatewayNatRuleType(\n')
            self.GatewayNatRule.exportLiteral(outfile, level, name_='GatewayNatRule')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OneToOneBasicRule is not None:
            showIndent(outfile, level)
            outfile.write('OneToOneBasicRule=model_.NatOneToOneBasicRuleType(\n')
            self.OneToOneBasicRule.exportLiteral(outfile, level, name_='OneToOneBasicRule')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OneToOneVmRule is not None:
            showIndent(outfile, level)
            outfile.write('OneToOneVmRule=model_.NatOneToOneVmRuleType(\n')
            self.OneToOneVmRule.exportLiteral(outfile, level, name_='OneToOneVmRule')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PortForwardingRule is not None:
            showIndent(outfile, level)
            outfile.write('PortForwardingRule=model_.NatPortForwardingRuleType(\n')
            self.PortForwardingRule.exportLiteral(outfile, level, name_='PortForwardingRule')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VmRule is not None:
            showIndent(outfile, level)
            outfile.write('VmRule=model_.NatVmRuleType(\n')
            self.VmRule.exportLiteral(outfile, level, name_='VmRule')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NatRuleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'RuleType':
            RuleType_ = child_.text
            RuleType_ = self.gds_validate_string(RuleType_, node, 'RuleType')
            self.RuleType = RuleType_
        elif nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'Id':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Id')
            self.Id = ival_
        elif nodeName_ == 'GatewayNatRule':
            obj_ = GatewayNatRuleType.factory()
            obj_.build(child_)
            self.GatewayNatRule = obj_
            obj_.original_tagname_ = 'GatewayNatRule'
        elif nodeName_ == 'OneToOneBasicRule':
            obj_ = NatOneToOneBasicRuleType.factory()
            obj_.build(child_)
            self.OneToOneBasicRule = obj_
            obj_.original_tagname_ = 'OneToOneBasicRule'
        elif nodeName_ == 'OneToOneVmRule':
            obj_ = NatOneToOneVmRuleType.factory()
            obj_.build(child_)
            self.OneToOneVmRule = obj_
            obj_.original_tagname_ = 'OneToOneVmRule'
        elif nodeName_ == 'PortForwardingRule':
            obj_ = NatPortForwardingRuleType.factory()
            obj_.build(child_)
            self.PortForwardingRule = obj_
            obj_.original_tagname_ = 'PortForwardingRule'
        elif nodeName_ == 'VmRule':
            obj_ = NatVmRuleType.factory()
            obj_.build(child_)
            self.VmRule = obj_
            obj_.original_tagname_ = 'VmRule'
        super(NatRuleType, self).buildChildren(child_, node, nodeName_, True)
# end class NatRuleType


class GatewayNatRuleType(VCloudExtensibleType):
    """5.1 Represents the SNAT and DNAT rules."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Interface=None, OriginalIp=None, OriginalPort=None, TranslatedIp=None, TranslatedPort=None, Protocol=None, IcmpSubType=None):
        self.original_tagname_ = None
        super(GatewayNatRuleType, self).__init__(VCloudExtension, )
        self.Interface = Interface
        self.OriginalIp = OriginalIp
        self.OriginalPort = OriginalPort
        self.TranslatedIp = TranslatedIp
        self.TranslatedPort = TranslatedPort
        self.Protocol = Protocol
        self.IcmpSubType = IcmpSubType
    def factory(*args_, **kwargs_):
        if GatewayNatRuleType.subclass:
            return GatewayNatRuleType.subclass(*args_, **kwargs_)
        else:
            return GatewayNatRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Interface(self): return self.Interface
    def set_Interface(self, Interface): self.Interface = Interface
    def get_OriginalIp(self): return self.OriginalIp
    def set_OriginalIp(self, OriginalIp): self.OriginalIp = OriginalIp
    def get_OriginalPort(self): return self.OriginalPort
    def set_OriginalPort(self, OriginalPort): self.OriginalPort = OriginalPort
    def get_TranslatedIp(self): return self.TranslatedIp
    def set_TranslatedIp(self, TranslatedIp): self.TranslatedIp = TranslatedIp
    def get_TranslatedPort(self): return self.TranslatedPort
    def set_TranslatedPort(self, TranslatedPort): self.TranslatedPort = TranslatedPort
    def get_Protocol(self): return self.Protocol
    def set_Protocol(self, Protocol): self.Protocol = Protocol
    def get_IcmpSubType(self): return self.IcmpSubType
    def set_IcmpSubType(self, IcmpSubType): self.IcmpSubType = IcmpSubType
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Interface is not None or
            self.OriginalIp is not None or
            self.OriginalPort is not None or
            self.TranslatedIp is not None or
            self.TranslatedPort is not None or
            self.Protocol is not None or
            self.IcmpSubType is not None or
            super(GatewayNatRuleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayNatRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayNatRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayNatRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayNatRuleType'):
        super(GatewayNatRuleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayNatRuleType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayNatRuleType', fromsubclass_=False, pretty_print=True):
        super(GatewayNatRuleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Interface is not None:
            self.Interface.export(outfile, level, namespace_, name_='Interface', pretty_print=pretty_print)
        if self.OriginalIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOriginalIp>%s</%sOriginalIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.OriginalIp).encode(ExternalEncoding), input_name='OriginalIp'), namespace_, eol_))
        if self.OriginalPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOriginalPort>%s</%sOriginalPort>%s' % (namespace_, self.gds_format_string(quote_xml(self.OriginalPort).encode(ExternalEncoding), input_name='OriginalPort'), namespace_, eol_))
        if self.TranslatedIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTranslatedIp>%s</%sTranslatedIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.TranslatedIp).encode(ExternalEncoding), input_name='TranslatedIp'), namespace_, eol_))
        if self.TranslatedPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTranslatedPort>%s</%sTranslatedPort>%s' % (namespace_, self.gds_format_string(quote_xml(self.TranslatedPort).encode(ExternalEncoding), input_name='TranslatedPort'), namespace_, eol_))
        if self.Protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol>%s</%sProtocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.Protocol).encode(ExternalEncoding), input_name='Protocol'), namespace_, eol_))
        if self.IcmpSubType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIcmpSubType>%s</%sIcmpSubType>%s' % (namespace_, self.gds_format_string(quote_xml(self.IcmpSubType).encode(ExternalEncoding), input_name='IcmpSubType'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GatewayNatRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayNatRuleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayNatRuleType, self).exportLiteralChildren(outfile, level, name_)
        if self.Interface is not None:
            showIndent(outfile, level)
            outfile.write('Interface=model_.ReferenceType(\n')
            self.Interface.exportLiteral(outfile, level, name_='Interface')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OriginalIp is not None:
            showIndent(outfile, level)
            outfile.write('OriginalIp=%s,\n' % quote_python(self.OriginalIp).encode(ExternalEncoding))
        if self.OriginalPort is not None:
            showIndent(outfile, level)
            outfile.write('OriginalPort=%s,\n' % quote_python(self.OriginalPort).encode(ExternalEncoding))
        if self.TranslatedIp is not None:
            showIndent(outfile, level)
            outfile.write('TranslatedIp=%s,\n' % quote_python(self.TranslatedIp).encode(ExternalEncoding))
        if self.TranslatedPort is not None:
            showIndent(outfile, level)
            outfile.write('TranslatedPort=%s,\n' % quote_python(self.TranslatedPort).encode(ExternalEncoding))
        if self.Protocol is not None:
            showIndent(outfile, level)
            outfile.write('Protocol=%s,\n' % quote_python(self.Protocol).encode(ExternalEncoding))
        if self.IcmpSubType is not None:
            showIndent(outfile, level)
            outfile.write('IcmpSubType=%s,\n' % quote_python(self.IcmpSubType).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayNatRuleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Interface':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Interface = obj_
            obj_.original_tagname_ = 'Interface'
        elif nodeName_ == 'OriginalIp':
            OriginalIp_ = child_.text
            OriginalIp_ = self.gds_validate_string(OriginalIp_, node, 'OriginalIp')
            self.OriginalIp = OriginalIp_
            self.validate_IpAddressType(self.OriginalIp)    # validate type IpAddressType
        elif nodeName_ == 'OriginalPort':
            OriginalPort_ = child_.text
            OriginalPort_ = self.gds_validate_string(OriginalPort_, node, 'OriginalPort')
            self.OriginalPort = OriginalPort_
        elif nodeName_ == 'TranslatedIp':
            TranslatedIp_ = child_.text
            TranslatedIp_ = self.gds_validate_string(TranslatedIp_, node, 'TranslatedIp')
            self.TranslatedIp = TranslatedIp_
            self.validate_IpAddressType(self.TranslatedIp)    # validate type IpAddressType
        elif nodeName_ == 'TranslatedPort':
            TranslatedPort_ = child_.text
            TranslatedPort_ = self.gds_validate_string(TranslatedPort_, node, 'TranslatedPort')
            self.TranslatedPort = TranslatedPort_
        elif nodeName_ == 'Protocol':
            Protocol_ = child_.text
            Protocol_ = self.gds_validate_string(Protocol_, node, 'Protocol')
            self.Protocol = Protocol_
        elif nodeName_ == 'IcmpSubType':
            IcmpSubType_ = child_.text
            IcmpSubType_ = self.gds_validate_string(IcmpSubType_, node, 'IcmpSubType')
            self.IcmpSubType = IcmpSubType_
        super(GatewayNatRuleType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayNatRuleType


class NatOneToOneBasicRuleType(VCloudExtensibleType):
    """0.9 Represents the NAT basic rule for one to one mapping of internal
    and external IP addresses from a network."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, MappingMode=None, ExternalIpAddress=None, InternalIpAddress=None):
        self.original_tagname_ = None
        super(NatOneToOneBasicRuleType, self).__init__(VCloudExtension, )
        self.MappingMode = MappingMode
        self.ExternalIpAddress = ExternalIpAddress
        self.InternalIpAddress = InternalIpAddress
    def factory(*args_, **kwargs_):
        if NatOneToOneBasicRuleType.subclass:
            return NatOneToOneBasicRuleType.subclass(*args_, **kwargs_)
        else:
            return NatOneToOneBasicRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MappingMode(self): return self.MappingMode
    def set_MappingMode(self, MappingMode): self.MappingMode = MappingMode
    def get_ExternalIpAddress(self): return self.ExternalIpAddress
    def set_ExternalIpAddress(self, ExternalIpAddress): self.ExternalIpAddress = ExternalIpAddress
    def get_InternalIpAddress(self): return self.InternalIpAddress
    def set_InternalIpAddress(self, InternalIpAddress): self.InternalIpAddress = InternalIpAddress
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MappingMode is not None or
            self.ExternalIpAddress is not None or
            self.InternalIpAddress is not None or
            super(NatOneToOneBasicRuleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NatOneToOneBasicRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NatOneToOneBasicRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NatOneToOneBasicRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NatOneToOneBasicRuleType'):
        super(NatOneToOneBasicRuleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NatOneToOneBasicRuleType')
    def exportChildren(self, outfile, level, namespace_='', name_='NatOneToOneBasicRuleType', fromsubclass_=False, pretty_print=True):
        super(NatOneToOneBasicRuleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MappingMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMappingMode>%s</%sMappingMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.MappingMode).encode(ExternalEncoding), input_name='MappingMode'), namespace_, eol_))
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIpAddress>%s</%sExternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIpAddress).encode(ExternalEncoding), input_name='ExternalIpAddress'), namespace_, eol_))
        if self.InternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInternalIpAddress>%s</%sInternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.InternalIpAddress).encode(ExternalEncoding), input_name='InternalIpAddress'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NatOneToOneBasicRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NatOneToOneBasicRuleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NatOneToOneBasicRuleType, self).exportLiteralChildren(outfile, level, name_)
        if self.MappingMode is not None:
            showIndent(outfile, level)
            outfile.write('MappingMode=%s,\n' % quote_python(self.MappingMode).encode(ExternalEncoding))
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIpAddress=%s,\n' % quote_python(self.ExternalIpAddress).encode(ExternalEncoding))
        if self.InternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('InternalIpAddress=%s,\n' % quote_python(self.InternalIpAddress).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NatOneToOneBasicRuleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MappingMode':
            MappingMode_ = child_.text
            MappingMode_ = self.gds_validate_string(MappingMode_, node, 'MappingMode')
            self.MappingMode = MappingMode_
        elif nodeName_ == 'ExternalIpAddress':
            ExternalIpAddress_ = child_.text
            ExternalIpAddress_ = self.gds_validate_string(ExternalIpAddress_, node, 'ExternalIpAddress')
            self.ExternalIpAddress = ExternalIpAddress_
            self.validate_IpAddressType(self.ExternalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'InternalIpAddress':
            InternalIpAddress_ = child_.text
            InternalIpAddress_ = self.gds_validate_string(InternalIpAddress_, node, 'InternalIpAddress')
            self.InternalIpAddress = InternalIpAddress_
            self.validate_IpAddressType(self.InternalIpAddress)    # validate type IpAddressType
        super(NatOneToOneBasicRuleType, self).buildChildren(child_, node, nodeName_, True)
# end class NatOneToOneBasicRuleType


class NatOneToOneVmRuleType(VCloudExtensibleType):
    """0.9 Represents the NAT rule for one to one mapping of VM NIC and
    external IP addresses from a network."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, MappingMode=None, ExternalIpAddress=None, VAppScopedVmId=None, VmNicId=None):
        self.original_tagname_ = None
        super(NatOneToOneVmRuleType, self).__init__(VCloudExtension, )
        self.MappingMode = MappingMode
        self.ExternalIpAddress = ExternalIpAddress
        self.VAppScopedVmId = VAppScopedVmId
        self.VmNicId = VmNicId
    def factory(*args_, **kwargs_):
        if NatOneToOneVmRuleType.subclass:
            return NatOneToOneVmRuleType.subclass(*args_, **kwargs_)
        else:
            return NatOneToOneVmRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MappingMode(self): return self.MappingMode
    def set_MappingMode(self, MappingMode): self.MappingMode = MappingMode
    def get_ExternalIpAddress(self): return self.ExternalIpAddress
    def set_ExternalIpAddress(self, ExternalIpAddress): self.ExternalIpAddress = ExternalIpAddress
    def get_VAppScopedVmId(self): return self.VAppScopedVmId
    def set_VAppScopedVmId(self, VAppScopedVmId): self.VAppScopedVmId = VAppScopedVmId
    def get_VmNicId(self): return self.VmNicId
    def set_VmNicId(self, VmNicId): self.VmNicId = VmNicId
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MappingMode is not None or
            self.ExternalIpAddress is not None or
            self.VAppScopedVmId is not None or
            self.VmNicId is not None or
            super(NatOneToOneVmRuleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NatOneToOneVmRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NatOneToOneVmRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NatOneToOneVmRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NatOneToOneVmRuleType'):
        super(NatOneToOneVmRuleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NatOneToOneVmRuleType')
    def exportChildren(self, outfile, level, namespace_='', name_='NatOneToOneVmRuleType', fromsubclass_=False, pretty_print=True):
        super(NatOneToOneVmRuleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MappingMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMappingMode>%s</%sMappingMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.MappingMode).encode(ExternalEncoding), input_name='MappingMode'), namespace_, eol_))
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIpAddress>%s</%sExternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIpAddress).encode(ExternalEncoding), input_name='ExternalIpAddress'), namespace_, eol_))
        if self.VAppScopedVmId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVAppScopedVmId>%s</%sVAppScopedVmId>%s' % (namespace_, self.gds_format_string(quote_xml(self.VAppScopedVmId).encode(ExternalEncoding), input_name='VAppScopedVmId'), namespace_, eol_))
        if self.VmNicId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVmNicId>%s</%sVmNicId>%s' % (namespace_, self.gds_format_integer(self.VmNicId, input_name='VmNicId'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NatOneToOneVmRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NatOneToOneVmRuleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NatOneToOneVmRuleType, self).exportLiteralChildren(outfile, level, name_)
        if self.MappingMode is not None:
            showIndent(outfile, level)
            outfile.write('MappingMode=%s,\n' % quote_python(self.MappingMode).encode(ExternalEncoding))
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIpAddress=%s,\n' % quote_python(self.ExternalIpAddress).encode(ExternalEncoding))
        if self.VAppScopedVmId is not None:
            showIndent(outfile, level)
            outfile.write('VAppScopedVmId=%s,\n' % quote_python(self.VAppScopedVmId).encode(ExternalEncoding))
        if self.VmNicId is not None:
            showIndent(outfile, level)
            outfile.write('VmNicId=%d,\n' % self.VmNicId)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NatOneToOneVmRuleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MappingMode':
            MappingMode_ = child_.text
            MappingMode_ = self.gds_validate_string(MappingMode_, node, 'MappingMode')
            self.MappingMode = MappingMode_
        elif nodeName_ == 'ExternalIpAddress':
            ExternalIpAddress_ = child_.text
            ExternalIpAddress_ = self.gds_validate_string(ExternalIpAddress_, node, 'ExternalIpAddress')
            self.ExternalIpAddress = ExternalIpAddress_
            self.validate_IpAddressType(self.ExternalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'VAppScopedVmId':
            VAppScopedVmId_ = child_.text
            VAppScopedVmId_ = self.gds_validate_string(VAppScopedVmId_, node, 'VAppScopedVmId')
            self.VAppScopedVmId = VAppScopedVmId_
        elif nodeName_ == 'VmNicId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VmNicId')
            self.VmNicId = ival_
        super(NatOneToOneVmRuleType, self).buildChildren(child_, node, nodeName_, True)
# end class NatOneToOneVmRuleType


class NatPortForwardingRuleType(VCloudExtensibleType):
    """0.9 Represents the NAT rule for port forwarding between internal
    IP/port and external IP/port."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, ExternalIpAddress=None, ExternalPort=None, InternalIpAddress=None, InternalPort=None, Protocol=None):
        self.original_tagname_ = None
        super(NatPortForwardingRuleType, self).__init__(VCloudExtension, )
        self.ExternalIpAddress = ExternalIpAddress
        self.ExternalPort = ExternalPort
        self.InternalIpAddress = InternalIpAddress
        self.InternalPort = InternalPort
        self.Protocol = Protocol
    def factory(*args_, **kwargs_):
        if NatPortForwardingRuleType.subclass:
            return NatPortForwardingRuleType.subclass(*args_, **kwargs_)
        else:
            return NatPortForwardingRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalIpAddress(self): return self.ExternalIpAddress
    def set_ExternalIpAddress(self, ExternalIpAddress): self.ExternalIpAddress = ExternalIpAddress
    def get_ExternalPort(self): return self.ExternalPort
    def set_ExternalPort(self, ExternalPort): self.ExternalPort = ExternalPort
    def get_InternalIpAddress(self): return self.InternalIpAddress
    def set_InternalIpAddress(self, InternalIpAddress): self.InternalIpAddress = InternalIpAddress
    def get_InternalPort(self): return self.InternalPort
    def set_InternalPort(self, InternalPort): self.InternalPort = InternalPort
    def get_Protocol(self): return self.Protocol
    def set_Protocol(self, Protocol): self.Protocol = Protocol
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ExternalIpAddress is not None or
            self.ExternalPort is not None or
            self.InternalIpAddress is not None or
            self.InternalPort is not None or
            self.Protocol is not None or
            super(NatPortForwardingRuleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NatPortForwardingRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NatPortForwardingRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NatPortForwardingRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NatPortForwardingRuleType'):
        super(NatPortForwardingRuleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NatPortForwardingRuleType')
    def exportChildren(self, outfile, level, namespace_='', name_='NatPortForwardingRuleType', fromsubclass_=False, pretty_print=True):
        super(NatPortForwardingRuleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIpAddress>%s</%sExternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIpAddress).encode(ExternalEncoding), input_name='ExternalIpAddress'), namespace_, eol_))
        if self.ExternalPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalPort>%s</%sExternalPort>%s' % (namespace_, self.gds_format_integer(self.ExternalPort, input_name='ExternalPort'), namespace_, eol_))
        if self.InternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInternalIpAddress>%s</%sInternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.InternalIpAddress).encode(ExternalEncoding), input_name='InternalIpAddress'), namespace_, eol_))
        if self.InternalPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInternalPort>%s</%sInternalPort>%s' % (namespace_, self.gds_format_integer(self.InternalPort, input_name='InternalPort'), namespace_, eol_))
        if self.Protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol>%s</%sProtocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.Protocol).encode(ExternalEncoding), input_name='Protocol'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NatPortForwardingRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NatPortForwardingRuleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NatPortForwardingRuleType, self).exportLiteralChildren(outfile, level, name_)
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIpAddress=%s,\n' % quote_python(self.ExternalIpAddress).encode(ExternalEncoding))
        if self.ExternalPort is not None:
            showIndent(outfile, level)
            outfile.write('ExternalPort=%d,\n' % self.ExternalPort)
        if self.InternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('InternalIpAddress=%s,\n' % quote_python(self.InternalIpAddress).encode(ExternalEncoding))
        if self.InternalPort is not None:
            showIndent(outfile, level)
            outfile.write('InternalPort=%d,\n' % self.InternalPort)
        if self.Protocol is not None:
            showIndent(outfile, level)
            outfile.write('Protocol=%s,\n' % quote_python(self.Protocol).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NatPortForwardingRuleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalIpAddress':
            ExternalIpAddress_ = child_.text
            ExternalIpAddress_ = self.gds_validate_string(ExternalIpAddress_, node, 'ExternalIpAddress')
            self.ExternalIpAddress = ExternalIpAddress_
            self.validate_IpAddressType(self.ExternalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'ExternalPort':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ExternalPort')
            self.ExternalPort = ival_
        elif nodeName_ == 'InternalIpAddress':
            InternalIpAddress_ = child_.text
            InternalIpAddress_ = self.gds_validate_string(InternalIpAddress_, node, 'InternalIpAddress')
            self.InternalIpAddress = InternalIpAddress_
            self.validate_IpAddressType(self.InternalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'InternalPort':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InternalPort')
            self.InternalPort = ival_
        elif nodeName_ == 'Protocol':
            Protocol_ = child_.text
            Protocol_ = self.gds_validate_string(Protocol_, node, 'Protocol')
            self.Protocol = Protocol_
        super(NatPortForwardingRuleType, self).buildChildren(child_, node, nodeName_, True)
# end class NatPortForwardingRuleType


class NatVmRuleType(VCloudExtensibleType):
    """0.9 Represents the NAT rule for port forwarding between VM NIC/port
    and external IP/port."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, ExternalIpAddress=None, ExternalPort=None, VAppScopedVmId=None, VmNicId=None, InternalPort=None, Protocol=None):
        self.original_tagname_ = None
        super(NatVmRuleType, self).__init__(VCloudExtension, )
        self.ExternalIpAddress = ExternalIpAddress
        self.ExternalPort = ExternalPort
        self.VAppScopedVmId = VAppScopedVmId
        self.VmNicId = VmNicId
        self.InternalPort = InternalPort
        self.Protocol = Protocol
    def factory(*args_, **kwargs_):
        if NatVmRuleType.subclass:
            return NatVmRuleType.subclass(*args_, **kwargs_)
        else:
            return NatVmRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalIpAddress(self): return self.ExternalIpAddress
    def set_ExternalIpAddress(self, ExternalIpAddress): self.ExternalIpAddress = ExternalIpAddress
    def get_ExternalPort(self): return self.ExternalPort
    def set_ExternalPort(self, ExternalPort): self.ExternalPort = ExternalPort
    def get_VAppScopedVmId(self): return self.VAppScopedVmId
    def set_VAppScopedVmId(self, VAppScopedVmId): self.VAppScopedVmId = VAppScopedVmId
    def get_VmNicId(self): return self.VmNicId
    def set_VmNicId(self, VmNicId): self.VmNicId = VmNicId
    def get_InternalPort(self): return self.InternalPort
    def set_InternalPort(self, InternalPort): self.InternalPort = InternalPort
    def get_Protocol(self): return self.Protocol
    def set_Protocol(self, Protocol): self.Protocol = Protocol
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ExternalIpAddress is not None or
            self.ExternalPort is not None or
            self.VAppScopedVmId is not None or
            self.VmNicId is not None or
            self.InternalPort is not None or
            self.Protocol is not None or
            super(NatVmRuleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NatVmRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NatVmRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NatVmRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NatVmRuleType'):
        super(NatVmRuleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NatVmRuleType')
    def exportChildren(self, outfile, level, namespace_='', name_='NatVmRuleType', fromsubclass_=False, pretty_print=True):
        super(NatVmRuleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIpAddress>%s</%sExternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIpAddress).encode(ExternalEncoding), input_name='ExternalIpAddress'), namespace_, eol_))
        if self.ExternalPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalPort>%s</%sExternalPort>%s' % (namespace_, self.gds_format_integer(self.ExternalPort, input_name='ExternalPort'), namespace_, eol_))
        if self.VAppScopedVmId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVAppScopedVmId>%s</%sVAppScopedVmId>%s' % (namespace_, self.gds_format_string(quote_xml(self.VAppScopedVmId).encode(ExternalEncoding), input_name='VAppScopedVmId'), namespace_, eol_))
        if self.VmNicId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVmNicId>%s</%sVmNicId>%s' % (namespace_, self.gds_format_integer(self.VmNicId, input_name='VmNicId'), namespace_, eol_))
        if self.InternalPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInternalPort>%s</%sInternalPort>%s' % (namespace_, self.gds_format_integer(self.InternalPort, input_name='InternalPort'), namespace_, eol_))
        if self.Protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol>%s</%sProtocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.Protocol).encode(ExternalEncoding), input_name='Protocol'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='NatVmRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NatVmRuleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NatVmRuleType, self).exportLiteralChildren(outfile, level, name_)
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIpAddress=%s,\n' % quote_python(self.ExternalIpAddress).encode(ExternalEncoding))
        if self.ExternalPort is not None:
            showIndent(outfile, level)
            outfile.write('ExternalPort=%d,\n' % self.ExternalPort)
        if self.VAppScopedVmId is not None:
            showIndent(outfile, level)
            outfile.write('VAppScopedVmId=%s,\n' % quote_python(self.VAppScopedVmId).encode(ExternalEncoding))
        if self.VmNicId is not None:
            showIndent(outfile, level)
            outfile.write('VmNicId=%d,\n' % self.VmNicId)
        if self.InternalPort is not None:
            showIndent(outfile, level)
            outfile.write('InternalPort=%d,\n' % self.InternalPort)
        if self.Protocol is not None:
            showIndent(outfile, level)
            outfile.write('Protocol=%s,\n' % quote_python(self.Protocol).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NatVmRuleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalIpAddress':
            ExternalIpAddress_ = child_.text
            ExternalIpAddress_ = self.gds_validate_string(ExternalIpAddress_, node, 'ExternalIpAddress')
            self.ExternalIpAddress = ExternalIpAddress_
            self.validate_IpAddressType(self.ExternalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'ExternalPort':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ExternalPort')
            self.ExternalPort = ival_
        elif nodeName_ == 'VAppScopedVmId':
            VAppScopedVmId_ = child_.text
            VAppScopedVmId_ = self.gds_validate_string(VAppScopedVmId_, node, 'VAppScopedVmId')
            self.VAppScopedVmId = VAppScopedVmId_
        elif nodeName_ == 'VmNicId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VmNicId')
            self.VmNicId = ival_
        elif nodeName_ == 'InternalPort':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'InternalPort')
            self.InternalPort = ival_
        elif nodeName_ == 'Protocol':
            Protocol_ = child_.text
            Protocol_ = self.gds_validate_string(Protocol_, node, 'Protocol')
            self.Protocol = Protocol_
        super(NatVmRuleType, self).buildChildren(child_, node, nodeName_, True)
# end class NatVmRuleType


class FirewallServiceType(NetworkServiceType):
    """Represents a network firewall service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, DefaultAction=None, LogDefaultAction=None, FirewallRule=None):
        self.original_tagname_ = None
        super(FirewallServiceType, self).__init__(VCloudExtension, IsEnabled, )
        self.DefaultAction = DefaultAction
        self.LogDefaultAction = LogDefaultAction
        if FirewallRule is None:
            self.FirewallRule = []
        else:
            self.FirewallRule = FirewallRule
    def factory(*args_, **kwargs_):
        if FirewallServiceType.subclass:
            return FirewallServiceType.subclass(*args_, **kwargs_)
        else:
            return FirewallServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DefaultAction(self): return self.DefaultAction
    def set_DefaultAction(self, DefaultAction): self.DefaultAction = DefaultAction
    def get_LogDefaultAction(self): return self.LogDefaultAction
    def set_LogDefaultAction(self, LogDefaultAction): self.LogDefaultAction = LogDefaultAction
    def get_FirewallRule(self): return self.FirewallRule
    def set_FirewallRule(self, FirewallRule): self.FirewallRule = FirewallRule
    def add_FirewallRule(self, value): self.FirewallRule.append(value)
    def insert_FirewallRule_at(self, index, value): self.FirewallRule.insert(index, value)
    def replace_FirewallRule_at(self, index, value): self.FirewallRule[index] = value
    def hasContent_(self):
        if (
            self.DefaultAction is not None or
            self.LogDefaultAction is not None or
            self.FirewallRule or
            super(FirewallServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FirewallServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FirewallServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirewallServiceType'):
        super(FirewallServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='FirewallServiceType', fromsubclass_=False, pretty_print=True):
        super(FirewallServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DefaultAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefaultAction>%s</%sDefaultAction>%s' % (namespace_, self.gds_format_string(quote_xml(self.DefaultAction).encode(ExternalEncoding), input_name='DefaultAction'), namespace_, eol_))
        if self.LogDefaultAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLogDefaultAction>%s</%sLogDefaultAction>%s' % (namespace_, self.gds_format_boolean(self.LogDefaultAction, input_name='LogDefaultAction'), namespace_, eol_))
        for FirewallRule_ in self.FirewallRule:
            FirewallRule_.export(outfile, level, namespace_, name_='FirewallRule', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FirewallServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FirewallServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FirewallServiceType, self).exportLiteralChildren(outfile, level, name_)
        if self.DefaultAction is not None:
            showIndent(outfile, level)
            outfile.write('DefaultAction=%s,\n' % quote_python(self.DefaultAction).encode(ExternalEncoding))
        if self.LogDefaultAction is not None:
            showIndent(outfile, level)
            outfile.write('LogDefaultAction=%s,\n' % self.LogDefaultAction)
        showIndent(outfile, level)
        outfile.write('FirewallRule=[\n')
        level += 1
        for FirewallRule_ in self.FirewallRule:
            showIndent(outfile, level)
            outfile.write('model_.FirewallRuleType(\n')
            FirewallRule_.exportLiteral(outfile, level, name_='FirewallRuleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FirewallServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DefaultAction':
            DefaultAction_ = child_.text
            DefaultAction_ = self.gds_validate_string(DefaultAction_, node, 'DefaultAction')
            self.DefaultAction = DefaultAction_
        elif nodeName_ == 'LogDefaultAction':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'LogDefaultAction')
            self.LogDefaultAction = ival_
        elif nodeName_ == 'FirewallRule':
            obj_ = FirewallRuleType.factory()
            obj_.build(child_)
            self.FirewallRule.append(obj_)
            obj_.original_tagname_ = 'FirewallRule'
        super(FirewallServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class FirewallServiceType


class VmSelectionType(VCloudExtensibleType):
    """5.1 Represents details of an vm+nic+iptype selection."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, VAppScopedVmId=None, VmNicId=None, IpType=None):
        self.original_tagname_ = None
        super(VmSelectionType, self).__init__(VCloudExtension, )
        self.VAppScopedVmId = VAppScopedVmId
        self.VmNicId = VmNicId
        self.IpType = IpType
    def factory(*args_, **kwargs_):
        if VmSelectionType.subclass:
            return VmSelectionType.subclass(*args_, **kwargs_)
        else:
            return VmSelectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VAppScopedVmId(self): return self.VAppScopedVmId
    def set_VAppScopedVmId(self, VAppScopedVmId): self.VAppScopedVmId = VAppScopedVmId
    def get_VmNicId(self): return self.VmNicId
    def set_VmNicId(self, VmNicId): self.VmNicId = VmNicId
    def get_IpType(self): return self.IpType
    def set_IpType(self, IpType): self.IpType = IpType
    def hasContent_(self):
        if (
            self.VAppScopedVmId is not None or
            self.VmNicId is not None or
            self.IpType is not None or
            super(VmSelectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmSelectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmSelectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmSelectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmSelectionType'):
        super(VmSelectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmSelectionType')
    def exportChildren(self, outfile, level, namespace_='', name_='VmSelectionType', fromsubclass_=False, pretty_print=True):
        super(VmSelectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VAppScopedVmId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVAppScopedVmId>%s</%sVAppScopedVmId>%s' % (namespace_, self.gds_format_string(quote_xml(self.VAppScopedVmId).encode(ExternalEncoding), input_name='VAppScopedVmId'), namespace_, eol_))
        if self.VmNicId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVmNicId>%s</%sVmNicId>%s' % (namespace_, self.gds_format_integer(self.VmNicId, input_name='VmNicId'), namespace_, eol_))
        if self.IpType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpType>%s</%sIpType>%s' % (namespace_, self.gds_format_string(quote_xml(self.IpType).encode(ExternalEncoding), input_name='IpType'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VmSelectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmSelectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmSelectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.VAppScopedVmId is not None:
            showIndent(outfile, level)
            outfile.write('VAppScopedVmId=%s,\n' % quote_python(self.VAppScopedVmId).encode(ExternalEncoding))
        if self.VmNicId is not None:
            showIndent(outfile, level)
            outfile.write('VmNicId=%d,\n' % self.VmNicId)
        if self.IpType is not None:
            showIndent(outfile, level)
            outfile.write('IpType=%s,\n' % quote_python(self.IpType).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VmSelectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VAppScopedVmId':
            VAppScopedVmId_ = child_.text
            VAppScopedVmId_ = self.gds_validate_string(VAppScopedVmId_, node, 'VAppScopedVmId')
            self.VAppScopedVmId = VAppScopedVmId_
        elif nodeName_ == 'VmNicId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VmNicId')
            self.VmNicId = ival_
        elif nodeName_ == 'IpType':
            IpType_ = child_.text
            IpType_ = self.gds_validate_string(IpType_, node, 'IpType')
            self.IpType = IpType_
        super(VmSelectionType, self).buildChildren(child_, node, nodeName_, True)
# end class VmSelectionType


class FirewallRuleType(VCloudExtensibleType):
    """0.9 Represents a firewall rule."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Id=None, IsEnabled=None, MatchOnTranslate=None, Description=None, Policy=None, Protocols=None, IcmpSubType=None, Port=None, DestinationPortRange=None, DestinationIp=None, DestinationVm=None, SourcePort=None, SourcePortRange=None, SourceIp=None, SourceVm=None, Direction=None, EnableLogging=None):
        self.original_tagname_ = None
        super(FirewallRuleType, self).__init__(VCloudExtension, )
        self.Id = Id
        self.IsEnabled = IsEnabled
        self.MatchOnTranslate = MatchOnTranslate
        self.Description = Description
        self.Policy = Policy
        self.Protocols = Protocols
        self.IcmpSubType = IcmpSubType
        self.Port = Port
        self.DestinationPortRange = DestinationPortRange
        self.DestinationIp = DestinationIp
        self.DestinationVm = DestinationVm
        self.SourcePort = SourcePort
        self.SourcePortRange = SourcePortRange
        self.SourceIp = SourceIp
        self.SourceVm = SourceVm
        self.Direction = Direction
        self.EnableLogging = EnableLogging
    def factory(*args_, **kwargs_):
        if FirewallRuleType.subclass:
            return FirewallRuleType.subclass(*args_, **kwargs_)
        else:
            return FirewallRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_MatchOnTranslate(self): return self.MatchOnTranslate
    def set_MatchOnTranslate(self, MatchOnTranslate): self.MatchOnTranslate = MatchOnTranslate
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Policy(self): return self.Policy
    def set_Policy(self, Policy): self.Policy = Policy
    def get_Protocols(self): return self.Protocols
    def set_Protocols(self, Protocols): self.Protocols = Protocols
    def get_IcmpSubType(self): return self.IcmpSubType
    def set_IcmpSubType(self, IcmpSubType): self.IcmpSubType = IcmpSubType
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def get_DestinationPortRange(self): return self.DestinationPortRange
    def set_DestinationPortRange(self, DestinationPortRange): self.DestinationPortRange = DestinationPortRange
    def get_DestinationIp(self): return self.DestinationIp
    def set_DestinationIp(self, DestinationIp): self.DestinationIp = DestinationIp
    def get_DestinationVm(self): return self.DestinationVm
    def set_DestinationVm(self, DestinationVm): self.DestinationVm = DestinationVm
    def get_SourcePort(self): return self.SourcePort
    def set_SourcePort(self, SourcePort): self.SourcePort = SourcePort
    def get_SourcePortRange(self): return self.SourcePortRange
    def set_SourcePortRange(self, SourcePortRange): self.SourcePortRange = SourcePortRange
    def get_SourceIp(self): return self.SourceIp
    def set_SourceIp(self, SourceIp): self.SourceIp = SourceIp
    def get_SourceVm(self): return self.SourceVm
    def set_SourceVm(self, SourceVm): self.SourceVm = SourceVm
    def get_Direction(self): return self.Direction
    def set_Direction(self, Direction): self.Direction = Direction
    def get_EnableLogging(self): return self.EnableLogging
    def set_EnableLogging(self, EnableLogging): self.EnableLogging = EnableLogging
    def validate_FirewallIpAddressType(self, value):
        # Validate type FirewallIpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Id is not None or
            self.IsEnabled is not None or
            self.MatchOnTranslate is not None or
            self.Description is not None or
            self.Policy is not None or
            self.Protocols is not None or
            self.IcmpSubType is not None or
            self.Port is not None or
            self.DestinationPortRange is not None or
            self.DestinationIp is not None or
            self.DestinationVm is not None or
            self.SourcePort is not None or
            self.SourcePortRange is not None or
            self.SourceIp is not None or
            self.SourceVm is not None or
            self.Direction is not None or
            self.EnableLogging is not None or
            super(FirewallRuleType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FirewallRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallRuleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FirewallRuleType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FirewallRuleType'):
        super(FirewallRuleType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FirewallRuleType')
    def exportChildren(self, outfile, level, namespace_='', name_='FirewallRuleType', fromsubclass_=False, pretty_print=True):
        super(FirewallRuleType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_, eol_))
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.MatchOnTranslate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMatchOnTranslate>%s</%sMatchOnTranslate>%s' % (namespace_, self.gds_format_boolean(self.MatchOnTranslate, input_name='MatchOnTranslate'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.Policy is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPolicy>%s</%sPolicy>%s' % (namespace_, self.gds_format_string(quote_xml(self.Policy).encode(ExternalEncoding), input_name='Policy'), namespace_, eol_))
        if self.Protocols is not None:
            self.Protocols.export(outfile, level, namespace_, name_='Protocols', pretty_print=pretty_print)
        if self.IcmpSubType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIcmpSubType>%s</%sIcmpSubType>%s' % (namespace_, self.gds_format_string(quote_xml(self.IcmpSubType).encode(ExternalEncoding), input_name='IcmpSubType'), namespace_, eol_))
        if self.Port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPort>%s</%sPort>%s' % (namespace_, self.gds_format_integer(self.Port, input_name='Port'), namespace_, eol_))
        if self.DestinationPortRange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDestinationPortRange>%s</%sDestinationPortRange>%s' % (namespace_, self.gds_format_string(quote_xml(self.DestinationPortRange).encode(ExternalEncoding), input_name='DestinationPortRange'), namespace_, eol_))
        if self.DestinationIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDestinationIp>%s</%sDestinationIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.DestinationIp).encode(ExternalEncoding), input_name='DestinationIp'), namespace_, eol_))
        if self.DestinationVm is not None:
            self.DestinationVm.export(outfile, level, namespace_, name_='DestinationVm', pretty_print=pretty_print)
        if self.SourcePort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourcePort>%s</%sSourcePort>%s' % (namespace_, self.gds_format_integer(self.SourcePort, input_name='SourcePort'), namespace_, eol_))
        if self.SourcePortRange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourcePortRange>%s</%sSourcePortRange>%s' % (namespace_, self.gds_format_string(quote_xml(self.SourcePortRange).encode(ExternalEncoding), input_name='SourcePortRange'), namespace_, eol_))
        if self.SourceIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourceIp>%s</%sSourceIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.SourceIp).encode(ExternalEncoding), input_name='SourceIp'), namespace_, eol_))
        if self.SourceVm is not None:
            self.SourceVm.export(outfile, level, namespace_, name_='SourceVm', pretty_print=pretty_print)
        if self.Direction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDirection>%s</%sDirection>%s' % (namespace_, self.gds_format_string(quote_xml(self.Direction).encode(ExternalEncoding), input_name='Direction'), namespace_, eol_))
        if self.EnableLogging is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnableLogging>%s</%sEnableLogging>%s' % (namespace_, self.gds_format_boolean(self.EnableLogging, input_name='EnableLogging'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='FirewallRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FirewallRuleType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FirewallRuleType, self).exportLiteralChildren(outfile, level, name_)
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.MatchOnTranslate is not None:
            showIndent(outfile, level)
            outfile.write('MatchOnTranslate=%s,\n' % self.MatchOnTranslate)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Policy is not None:
            showIndent(outfile, level)
            outfile.write('Policy=%s,\n' % quote_python(self.Policy).encode(ExternalEncoding))
        if self.Protocols is not None:
            showIndent(outfile, level)
            outfile.write('Protocols=model_.ProtocolsType(\n')
            self.Protocols.exportLiteral(outfile, level, name_='Protocols')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IcmpSubType is not None:
            showIndent(outfile, level)
            outfile.write('IcmpSubType=%s,\n' % quote_python(self.IcmpSubType).encode(ExternalEncoding))
        if self.Port is not None:
            showIndent(outfile, level)
            outfile.write('Port=%d,\n' % self.Port)
        if self.DestinationPortRange is not None:
            showIndent(outfile, level)
            outfile.write('DestinationPortRange=%s,\n' % quote_python(self.DestinationPortRange).encode(ExternalEncoding))
        if self.DestinationIp is not None:
            showIndent(outfile, level)
            outfile.write('DestinationIp=%s,\n' % quote_python(self.DestinationIp).encode(ExternalEncoding))
        if self.DestinationVm is not None:
            showIndent(outfile, level)
            outfile.write('DestinationVm=model_.VmSelectionType(\n')
            self.DestinationVm.exportLiteral(outfile, level, name_='DestinationVm')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SourcePort is not None:
            showIndent(outfile, level)
            outfile.write('SourcePort=%d,\n' % self.SourcePort)
        if self.SourcePortRange is not None:
            showIndent(outfile, level)
            outfile.write('SourcePortRange=%s,\n' % quote_python(self.SourcePortRange).encode(ExternalEncoding))
        if self.SourceIp is not None:
            showIndent(outfile, level)
            outfile.write('SourceIp=%s,\n' % quote_python(self.SourceIp).encode(ExternalEncoding))
        if self.SourceVm is not None:
            showIndent(outfile, level)
            outfile.write('SourceVm=model_.VmSelectionType(\n')
            self.SourceVm.exportLiteral(outfile, level, name_='SourceVm')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Direction is not None:
            showIndent(outfile, level)
            outfile.write('Direction=%s,\n' % quote_python(self.Direction).encode(ExternalEncoding))
        if self.EnableLogging is not None:
            showIndent(outfile, level)
            outfile.write('EnableLogging=%s,\n' % self.EnableLogging)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FirewallRuleType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'MatchOnTranslate':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'MatchOnTranslate')
            self.MatchOnTranslate = ival_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Policy':
            Policy_ = child_.text
            Policy_ = self.gds_validate_string(Policy_, node, 'Policy')
            self.Policy = Policy_
        elif nodeName_ == 'Protocols':
            obj_ = ProtocolsType.factory()
            obj_.build(child_)
            self.Protocols = obj_
            obj_.original_tagname_ = 'Protocols'
        elif nodeName_ == 'IcmpSubType':
            IcmpSubType_ = child_.text
            IcmpSubType_ = self.gds_validate_string(IcmpSubType_, node, 'IcmpSubType')
            self.IcmpSubType = IcmpSubType_
        elif nodeName_ == 'Port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Port')
            self.Port = ival_
        elif nodeName_ == 'DestinationPortRange':
            DestinationPortRange_ = child_.text
            DestinationPortRange_ = self.gds_validate_string(DestinationPortRange_, node, 'DestinationPortRange')
            self.DestinationPortRange = DestinationPortRange_
        elif nodeName_ == 'DestinationIp':
            DestinationIp_ = child_.text
            DestinationIp_ = self.gds_validate_string(DestinationIp_, node, 'DestinationIp')
            self.DestinationIp = DestinationIp_
            self.validate_FirewallIpAddressType(self.DestinationIp)    # validate type FirewallIpAddressType
        elif nodeName_ == 'DestinationVm':
            obj_ = VmSelectionType.factory()
            obj_.build(child_)
            self.DestinationVm = obj_
            obj_.original_tagname_ = 'DestinationVm'
        elif nodeName_ == 'SourcePort':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'SourcePort')
            self.SourcePort = ival_
        elif nodeName_ == 'SourcePortRange':
            SourcePortRange_ = child_.text
            SourcePortRange_ = self.gds_validate_string(SourcePortRange_, node, 'SourcePortRange')
            self.SourcePortRange = SourcePortRange_
        elif nodeName_ == 'SourceIp':
            SourceIp_ = child_.text
            SourceIp_ = self.gds_validate_string(SourceIp_, node, 'SourceIp')
            self.SourceIp = SourceIp_
            self.validate_FirewallIpAddressType(self.SourceIp)    # validate type FirewallIpAddressType
        elif nodeName_ == 'SourceVm':
            obj_ = VmSelectionType.factory()
            obj_.build(child_)
            self.SourceVm = obj_
            obj_.original_tagname_ = 'SourceVm'
        elif nodeName_ == 'Direction':
            Direction_ = child_.text
            Direction_ = self.gds_validate_string(Direction_, node, 'Direction')
            self.Direction = Direction_
        elif nodeName_ == 'EnableLogging':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'EnableLogging')
            self.EnableLogging = ival_
        super(FirewallRuleType, self).buildChildren(child_, node, nodeName_, True)
# end class FirewallRuleType


class IpsecVpnServiceType(NetworkServiceType):
    """1.5 Represents an IPSec-VPN network service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, ExternalIpAddress=None, PublicIpAddress=None, IpsecVpnTunnel=None):
        self.original_tagname_ = None
        super(IpsecVpnServiceType, self).__init__(VCloudExtension, IsEnabled, )
        self.ExternalIpAddress = ExternalIpAddress
        self.PublicIpAddress = PublicIpAddress
        if IpsecVpnTunnel is None:
            self.IpsecVpnTunnel = []
        else:
            self.IpsecVpnTunnel = IpsecVpnTunnel
    def factory(*args_, **kwargs_):
        if IpsecVpnServiceType.subclass:
            return IpsecVpnServiceType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExternalIpAddress(self): return self.ExternalIpAddress
    def set_ExternalIpAddress(self, ExternalIpAddress): self.ExternalIpAddress = ExternalIpAddress
    def get_PublicIpAddress(self): return self.PublicIpAddress
    def set_PublicIpAddress(self, PublicIpAddress): self.PublicIpAddress = PublicIpAddress
    def get_IpsecVpnTunnel(self): return self.IpsecVpnTunnel
    def set_IpsecVpnTunnel(self, IpsecVpnTunnel): self.IpsecVpnTunnel = IpsecVpnTunnel
    def add_IpsecVpnTunnel(self, value): self.IpsecVpnTunnel.append(value)
    def insert_IpsecVpnTunnel_at(self, index, value): self.IpsecVpnTunnel.insert(index, value)
    def replace_IpsecVpnTunnel_at(self, index, value): self.IpsecVpnTunnel[index] = value
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ExternalIpAddress is not None or
            self.PublicIpAddress is not None or
            self.IpsecVpnTunnel or
            super(IpsecVpnServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnServiceType'):
        super(IpsecVpnServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnServiceType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExternalIpAddress>%s</%sExternalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.ExternalIpAddress).encode(ExternalEncoding), input_name='ExternalIpAddress'), namespace_, eol_))
        if self.PublicIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPublicIpAddress>%s</%sPublicIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.PublicIpAddress).encode(ExternalEncoding), input_name='PublicIpAddress'), namespace_, eol_))
        for IpsecVpnTunnel_ in self.IpsecVpnTunnel:
            IpsecVpnTunnel_.export(outfile, level, namespace_, name_='IpsecVpnTunnel', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IpsecVpnServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnServiceType, self).exportLiteralChildren(outfile, level, name_)
        if self.ExternalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('ExternalIpAddress=%s,\n' % quote_python(self.ExternalIpAddress).encode(ExternalEncoding))
        if self.PublicIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('PublicIpAddress=%s,\n' % quote_python(self.PublicIpAddress).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('IpsecVpnTunnel=[\n')
        level += 1
        for IpsecVpnTunnel_ in self.IpsecVpnTunnel:
            showIndent(outfile, level)
            outfile.write('model_.IpsecVpnTunnelType(\n')
            IpsecVpnTunnel_.exportLiteral(outfile, level, name_='IpsecVpnTunnelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpsecVpnServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExternalIpAddress':
            ExternalIpAddress_ = child_.text
            ExternalIpAddress_ = self.gds_validate_string(ExternalIpAddress_, node, 'ExternalIpAddress')
            self.ExternalIpAddress = ExternalIpAddress_
            self.validate_IpAddressType(self.ExternalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'PublicIpAddress':
            PublicIpAddress_ = child_.text
            PublicIpAddress_ = self.gds_validate_string(PublicIpAddress_, node, 'PublicIpAddress')
            self.PublicIpAddress = PublicIpAddress_
            self.validate_IpAddressType(self.PublicIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'IpsecVpnTunnel':
            obj_ = IpsecVpnTunnelType.factory()
            obj_.build(child_)
            self.IpsecVpnTunnel.append(obj_)
            obj_.original_tagname_ = 'IpsecVpnTunnel'
        super(IpsecVpnServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class IpsecVpnServiceType


class IpsecVpnTunnelType(VCloudExtensibleType):
    """1.5 Represents details of an IPSec-VPN tunnel."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Description=None, IpsecVpnPeer=None, PeerIpAddress=None, PeerNetworkAddress=None, PeerNetworkMask=None, SharedSecret=None, EncryptionProtocol=None, Mtu=None, IsEnabled=None, IsOperational=None, ErrorDetails=None):
        self.original_tagname_ = None
        super(IpsecVpnTunnelType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Description = Description
        self.IpsecVpnPeer = IpsecVpnPeer
        self.PeerIpAddress = PeerIpAddress
        self.PeerNetworkAddress = PeerNetworkAddress
        self.PeerNetworkMask = PeerNetworkMask
        self.SharedSecret = SharedSecret
        self.EncryptionProtocol = EncryptionProtocol
        self.Mtu = Mtu
        self.IsEnabled = IsEnabled
        self.IsOperational = IsOperational
        self.ErrorDetails = ErrorDetails
    def factory(*args_, **kwargs_):
        if IpsecVpnTunnelType.subclass:
            return IpsecVpnTunnelType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnTunnelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_IpsecVpnPeer(self): return self.IpsecVpnPeer
    def set_IpsecVpnPeer(self, IpsecVpnPeer): self.IpsecVpnPeer = IpsecVpnPeer
    def get_PeerIpAddress(self): return self.PeerIpAddress
    def set_PeerIpAddress(self, PeerIpAddress): self.PeerIpAddress = PeerIpAddress
    def get_PeerNetworkAddress(self): return self.PeerNetworkAddress
    def set_PeerNetworkAddress(self, PeerNetworkAddress): self.PeerNetworkAddress = PeerNetworkAddress
    def get_PeerNetworkMask(self): return self.PeerNetworkMask
    def set_PeerNetworkMask(self, PeerNetworkMask): self.PeerNetworkMask = PeerNetworkMask
    def get_SharedSecret(self): return self.SharedSecret
    def set_SharedSecret(self, SharedSecret): self.SharedSecret = SharedSecret
    def get_EncryptionProtocol(self): return self.EncryptionProtocol
    def set_EncryptionProtocol(self, EncryptionProtocol): self.EncryptionProtocol = EncryptionProtocol
    def get_Mtu(self): return self.Mtu
    def set_Mtu(self, Mtu): self.Mtu = Mtu
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_IsOperational(self): return self.IsOperational
    def set_IsOperational(self, IsOperational): self.IsOperational = IsOperational
    def get_ErrorDetails(self): return self.ErrorDetails
    def set_ErrorDetails(self, ErrorDetails): self.ErrorDetails = ErrorDetails
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Description is not None or
            self.IpsecVpnPeer is not None or
            self.PeerIpAddress is not None or
            self.PeerNetworkAddress is not None or
            self.PeerNetworkMask is not None or
            self.SharedSecret is not None or
            self.EncryptionProtocol is not None or
            self.Mtu is not None or
            self.IsEnabled is not None or
            self.IsOperational is not None or
            self.ErrorDetails is not None or
            super(IpsecVpnTunnelType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnTunnelType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnTunnelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnTunnelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnTunnelType'):
        super(IpsecVpnTunnelType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnTunnelType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnTunnelType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnTunnelType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.IpsecVpnPeer is not None:
            self.IpsecVpnPeer.export(outfile, level, namespace_, name_='IpsecVpnPeer', pretty_print=pretty_print)
        if self.PeerIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeerIpAddress>%s</%sPeerIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.PeerIpAddress).encode(ExternalEncoding), input_name='PeerIpAddress'), namespace_, eol_))
        if self.PeerNetworkAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeerNetworkAddress>%s</%sPeerNetworkAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.PeerNetworkAddress).encode(ExternalEncoding), input_name='PeerNetworkAddress'), namespace_, eol_))
        if self.PeerNetworkMask is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeerNetworkMask>%s</%sPeerNetworkMask>%s' % (namespace_, self.gds_format_string(quote_xml(self.PeerNetworkMask).encode(ExternalEncoding), input_name='PeerNetworkMask'), namespace_, eol_))
        if self.SharedSecret is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSharedSecret>%s</%sSharedSecret>%s' % (namespace_, self.gds_format_string(quote_xml(self.SharedSecret).encode(ExternalEncoding), input_name='SharedSecret'), namespace_, eol_))
        if self.EncryptionProtocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEncryptionProtocol>%s</%sEncryptionProtocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.EncryptionProtocol).encode(ExternalEncoding), input_name='EncryptionProtocol'), namespace_, eol_))
        if self.Mtu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMtu>%s</%sMtu>%s' % (namespace_, self.gds_format_integer(self.Mtu, input_name='Mtu'), namespace_, eol_))
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.IsOperational is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsOperational>%s</%sIsOperational>%s' % (namespace_, self.gds_format_boolean(self.IsOperational, input_name='IsOperational'), namespace_, eol_))
        if self.ErrorDetails is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sErrorDetails>%s</%sErrorDetails>%s' % (namespace_, self.gds_format_string(quote_xml(self.ErrorDetails).encode(ExternalEncoding), input_name='ErrorDetails'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IpsecVpnTunnelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnTunnelType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnTunnelType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.IpsecVpnPeer is not None:
            showIndent(outfile, level)
            outfile.write('IpsecVpnPeer=model_.IpsecVpnPeer(\n')
            self.IpsecVpnPeer.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PeerIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('PeerIpAddress=%s,\n' % quote_python(self.PeerIpAddress).encode(ExternalEncoding))
        if self.PeerNetworkAddress is not None:
            showIndent(outfile, level)
            outfile.write('PeerNetworkAddress=%s,\n' % quote_python(self.PeerNetworkAddress).encode(ExternalEncoding))
        if self.PeerNetworkMask is not None:
            showIndent(outfile, level)
            outfile.write('PeerNetworkMask=%s,\n' % quote_python(self.PeerNetworkMask).encode(ExternalEncoding))
        if self.SharedSecret is not None:
            showIndent(outfile, level)
            outfile.write('SharedSecret=%s,\n' % quote_python(self.SharedSecret).encode(ExternalEncoding))
        if self.EncryptionProtocol is not None:
            showIndent(outfile, level)
            outfile.write('EncryptionProtocol=%s,\n' % quote_python(self.EncryptionProtocol).encode(ExternalEncoding))
        if self.Mtu is not None:
            showIndent(outfile, level)
            outfile.write('Mtu=%d,\n' % self.Mtu)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.IsOperational is not None:
            showIndent(outfile, level)
            outfile.write('IsOperational=%s,\n' % self.IsOperational)
        if self.ErrorDetails is not None:
            showIndent(outfile, level)
            outfile.write('ErrorDetails=%s,\n' % quote_python(self.ErrorDetails).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpsecVpnTunnelType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'IpsecVpnPeer':
            class_obj_ = self.get_class_obj_(child_, IpsecVpnPeerType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnPeer'
        elif nodeName_ == 'IpsecVpnLocalPeer':
            obj_ = IpsecVpnLocalPeerType.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnLocalPeer'
        elif nodeName_ == 'IpsecVpnRemotePeer':
            obj_ = IpsecVpnRemotePeerType.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnRemotePeer'
        elif nodeName_ == 'IpsecVpnThirdPartyPeer':
            obj_ = IpsecVpnThirdPartyPeerType.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnThirdPartyPeer'
        elif nodeName_ == 'PeerIpAddress':
            PeerIpAddress_ = child_.text
            PeerIpAddress_ = self.gds_validate_string(PeerIpAddress_, node, 'PeerIpAddress')
            self.PeerIpAddress = PeerIpAddress_
            self.validate_IpAddressType(self.PeerIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'PeerNetworkAddress':
            PeerNetworkAddress_ = child_.text
            PeerNetworkAddress_ = self.gds_validate_string(PeerNetworkAddress_, node, 'PeerNetworkAddress')
            self.PeerNetworkAddress = PeerNetworkAddress_
            self.validate_IpAddressType(self.PeerNetworkAddress)    # validate type IpAddressType
        elif nodeName_ == 'PeerNetworkMask':
            PeerNetworkMask_ = child_.text
            PeerNetworkMask_ = self.gds_validate_string(PeerNetworkMask_, node, 'PeerNetworkMask')
            self.PeerNetworkMask = PeerNetworkMask_
            self.validate_IpAddressType(self.PeerNetworkMask)    # validate type IpAddressType
        elif nodeName_ == 'SharedSecret':
            SharedSecret_ = child_.text
            SharedSecret_ = self.gds_validate_string(SharedSecret_, node, 'SharedSecret')
            self.SharedSecret = SharedSecret_
        elif nodeName_ == 'EncryptionProtocol':
            EncryptionProtocol_ = child_.text
            EncryptionProtocol_ = self.gds_validate_string(EncryptionProtocol_, node, 'EncryptionProtocol')
            self.EncryptionProtocol = EncryptionProtocol_
        elif nodeName_ == 'Mtu':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Mtu')
            self.Mtu = ival_
        elif nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'IsOperational':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsOperational')
            self.IsOperational = ival_
        elif nodeName_ == 'ErrorDetails':
            ErrorDetails_ = child_.text
            ErrorDetails_ = self.gds_validate_string(ErrorDetails_, node, 'ErrorDetails')
            self.ErrorDetails = ErrorDetails_
        super(IpsecVpnTunnelType, self).buildChildren(child_, node, nodeName_, True)
# end class IpsecVpnTunnelType


class IpsecVpnPeerType(VCloudExtensibleType):
    """1.5 Gives more details of peer end point."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, extensiontype_=None):
        self.original_tagname_ = None
        super(IpsecVpnPeerType, self).__init__(VCloudExtension, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if IpsecVpnPeerType.subclass:
            return IpsecVpnPeerType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnPeerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(IpsecVpnPeerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnPeerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnPeerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnPeerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnPeerType'):
        super(IpsecVpnPeerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnPeerType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnPeerType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnPeerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IpsecVpnPeerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnPeerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnPeerType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IpsecVpnPeerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IpsecVpnPeerType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IpsecVpnPeerType


class IpsecVpnManagedPeerType(IpsecVpnPeerType):
    """1.5 Gives more details of peer end point."""
    subclass = None
    superclass = IpsecVpnPeerType
    def __init__(self, VCloudExtension=None, Id=None, Name=None, extensiontype_=None):
        self.original_tagname_ = None
        super(IpsecVpnManagedPeerType, self).__init__(VCloudExtension, extensiontype_, )
        self.Id = Id
        self.Name = Name
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if IpsecVpnManagedPeerType.subclass:
            return IpsecVpnManagedPeerType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnManagedPeerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Name is not None or
            super(IpsecVpnManagedPeerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnManagedPeerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnManagedPeerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnManagedPeerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnManagedPeerType'):
        super(IpsecVpnManagedPeerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnManagedPeerType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnManagedPeerType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnManagedPeerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IpsecVpnManagedPeerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnManagedPeerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnManagedPeerType, self).exportLiteralChildren(outfile, level, name_)
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IpsecVpnManagedPeerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        super(IpsecVpnManagedPeerType, self).buildChildren(child_, node, nodeName_, True)
# end class IpsecVpnManagedPeerType


class IpsecVpnLocalPeerType(IpsecVpnManagedPeerType):
    """1.5 Gives more details of local peer end point."""
    subclass = None
    superclass = IpsecVpnManagedPeerType
    def __init__(self, VCloudExtension=None, Id=None, Name=None):
        self.original_tagname_ = None
        super(IpsecVpnLocalPeerType, self).__init__(VCloudExtension, Id, Name, )
    def factory(*args_, **kwargs_):
        if IpsecVpnLocalPeerType.subclass:
            return IpsecVpnLocalPeerType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnLocalPeerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(IpsecVpnLocalPeerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnLocalPeerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnLocalPeerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnLocalPeerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnLocalPeerType'):
        super(IpsecVpnLocalPeerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnLocalPeerType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnLocalPeerType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnLocalPeerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IpsecVpnLocalPeerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnLocalPeerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnLocalPeerType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpsecVpnLocalPeerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IpsecVpnLocalPeerType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IpsecVpnLocalPeerType


class IpsecVpnRemotePeerType(IpsecVpnManagedPeerType):
    """1.5 Gives more details of remote peer end point."""
    subclass = None
    superclass = IpsecVpnManagedPeerType
    def __init__(self, VCloudExtension=None, Id=None, Name=None, VcdUrl=None, VcdOrganization=None, VcdUsername=None):
        self.original_tagname_ = None
        super(IpsecVpnRemotePeerType, self).__init__(VCloudExtension, Id, Name, )
        self.VcdUrl = VcdUrl
        self.VcdOrganization = VcdOrganization
        self.VcdUsername = VcdUsername
    def factory(*args_, **kwargs_):
        if IpsecVpnRemotePeerType.subclass:
            return IpsecVpnRemotePeerType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnRemotePeerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VcdUrl(self): return self.VcdUrl
    def set_VcdUrl(self, VcdUrl): self.VcdUrl = VcdUrl
    def get_VcdOrganization(self): return self.VcdOrganization
    def set_VcdOrganization(self, VcdOrganization): self.VcdOrganization = VcdOrganization
    def get_VcdUsername(self): return self.VcdUsername
    def set_VcdUsername(self, VcdUsername): self.VcdUsername = VcdUsername
    def hasContent_(self):
        if (
            self.VcdUrl is not None or
            self.VcdOrganization is not None or
            self.VcdUsername is not None or
            super(IpsecVpnRemotePeerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnRemotePeerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnRemotePeerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnRemotePeerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnRemotePeerType'):
        super(IpsecVpnRemotePeerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnRemotePeerType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnRemotePeerType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnRemotePeerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VcdUrl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVcdUrl>%s</%sVcdUrl>%s' % (namespace_, self.gds_format_string(quote_xml(self.VcdUrl).encode(ExternalEncoding), input_name='VcdUrl'), namespace_, eol_))
        if self.VcdOrganization is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVcdOrganization>%s</%sVcdOrganization>%s' % (namespace_, self.gds_format_string(quote_xml(self.VcdOrganization).encode(ExternalEncoding), input_name='VcdOrganization'), namespace_, eol_))
        if self.VcdUsername is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVcdUsername>%s</%sVcdUsername>%s' % (namespace_, self.gds_format_string(quote_xml(self.VcdUsername).encode(ExternalEncoding), input_name='VcdUsername'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IpsecVpnRemotePeerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnRemotePeerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnRemotePeerType, self).exportLiteralChildren(outfile, level, name_)
        if self.VcdUrl is not None:
            showIndent(outfile, level)
            outfile.write('VcdUrl=%s,\n' % quote_python(self.VcdUrl).encode(ExternalEncoding))
        if self.VcdOrganization is not None:
            showIndent(outfile, level)
            outfile.write('VcdOrganization=%s,\n' % quote_python(self.VcdOrganization).encode(ExternalEncoding))
        if self.VcdUsername is not None:
            showIndent(outfile, level)
            outfile.write('VcdUsername=%s,\n' % quote_python(self.VcdUsername).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpsecVpnRemotePeerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VcdUrl':
            VcdUrl_ = child_.text
            VcdUrl_ = self.gds_validate_string(VcdUrl_, node, 'VcdUrl')
            self.VcdUrl = VcdUrl_
        elif nodeName_ == 'VcdOrganization':
            VcdOrganization_ = child_.text
            VcdOrganization_ = self.gds_validate_string(VcdOrganization_, node, 'VcdOrganization')
            self.VcdOrganization = VcdOrganization_
        elif nodeName_ == 'VcdUsername':
            VcdUsername_ = child_.text
            VcdUsername_ = self.gds_validate_string(VcdUsername_, node, 'VcdUsername')
            self.VcdUsername = VcdUsername_
        super(IpsecVpnRemotePeerType, self).buildChildren(child_, node, nodeName_, True)
# end class IpsecVpnRemotePeerType


class IpsecVpnUnmanagedPeerType(IpsecVpnPeerType):
    """1.5 Gives more details of peer end point not managed by vCloud
    Director."""
    subclass = None
    superclass = IpsecVpnPeerType
    def __init__(self, VCloudExtension=None, extensiontype_=None):
        self.original_tagname_ = None
        super(IpsecVpnUnmanagedPeerType, self).__init__(VCloudExtension, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if IpsecVpnUnmanagedPeerType.subclass:
            return IpsecVpnUnmanagedPeerType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnUnmanagedPeerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(IpsecVpnUnmanagedPeerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnUnmanagedPeerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnUnmanagedPeerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnUnmanagedPeerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnUnmanagedPeerType'):
        super(IpsecVpnUnmanagedPeerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnUnmanagedPeerType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnUnmanagedPeerType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnUnmanagedPeerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IpsecVpnUnmanagedPeerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnUnmanagedPeerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnUnmanagedPeerType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(IpsecVpnUnmanagedPeerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IpsecVpnUnmanagedPeerType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IpsecVpnUnmanagedPeerType


class IpsecVpnThirdPartyPeerType(IpsecVpnUnmanagedPeerType):
    """1.5 Gives more details of third party peer end point."""
    subclass = None
    superclass = IpsecVpnUnmanagedPeerType
    def __init__(self, VCloudExtension=None, PeerId=None):
        self.original_tagname_ = None
        super(IpsecVpnThirdPartyPeerType, self).__init__(VCloudExtension, )
        self.PeerId = PeerId
    def factory(*args_, **kwargs_):
        if IpsecVpnThirdPartyPeerType.subclass:
            return IpsecVpnThirdPartyPeerType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnThirdPartyPeerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PeerId(self): return self.PeerId
    def set_PeerId(self, PeerId): self.PeerId = PeerId
    def hasContent_(self):
        if (
            self.PeerId is not None or
            super(IpsecVpnThirdPartyPeerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnThirdPartyPeerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnThirdPartyPeerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnThirdPartyPeerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnThirdPartyPeerType'):
        super(IpsecVpnThirdPartyPeerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnThirdPartyPeerType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnThirdPartyPeerType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnThirdPartyPeerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PeerId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeerId>%s</%sPeerId>%s' % (namespace_, self.gds_format_string(quote_xml(self.PeerId).encode(ExternalEncoding), input_name='PeerId'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IpsecVpnThirdPartyPeerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnThirdPartyPeerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnThirdPartyPeerType, self).exportLiteralChildren(outfile, level, name_)
        if self.PeerId is not None:
            showIndent(outfile, level)
            outfile.write('PeerId=%s,\n' % quote_python(self.PeerId).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpsecVpnThirdPartyPeerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PeerId':
            PeerId_ = child_.text
            PeerId_ = self.gds_validate_string(PeerId_, node, 'PeerId')
            self.PeerId = PeerId_
        super(IpsecVpnThirdPartyPeerType, self).buildChildren(child_, node, nodeName_, True)
# end class IpsecVpnThirdPartyPeerType


class StaticRoutingServiceType(NetworkServiceType):
    """1.5 Represents Static Routing network service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, StaticRoute=None):
        self.original_tagname_ = None
        super(StaticRoutingServiceType, self).__init__(VCloudExtension, IsEnabled, )
        if StaticRoute is None:
            self.StaticRoute = []
        else:
            self.StaticRoute = StaticRoute
    def factory(*args_, **kwargs_):
        if StaticRoutingServiceType.subclass:
            return StaticRoutingServiceType.subclass(*args_, **kwargs_)
        else:
            return StaticRoutingServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StaticRoute(self): return self.StaticRoute
    def set_StaticRoute(self, StaticRoute): self.StaticRoute = StaticRoute
    def add_StaticRoute(self, value): self.StaticRoute.append(value)
    def insert_StaticRoute_at(self, index, value): self.StaticRoute.insert(index, value)
    def replace_StaticRoute_at(self, index, value): self.StaticRoute[index] = value
    def hasContent_(self):
        if (
            self.StaticRoute or
            super(StaticRoutingServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StaticRoutingServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaticRoutingServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StaticRoutingServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StaticRoutingServiceType'):
        super(StaticRoutingServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StaticRoutingServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='StaticRoutingServiceType', fromsubclass_=False, pretty_print=True):
        super(StaticRoutingServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for StaticRoute_ in self.StaticRoute:
            StaticRoute_.export(outfile, level, namespace_, name_='StaticRoute', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StaticRoutingServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StaticRoutingServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StaticRoutingServiceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('StaticRoute=[\n')
        level += 1
        for StaticRoute_ in self.StaticRoute:
            showIndent(outfile, level)
            outfile.write('model_.StaticRouteType(\n')
            StaticRoute_.exportLiteral(outfile, level, name_='StaticRouteType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StaticRoutingServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StaticRoute':
            obj_ = StaticRouteType.factory()
            obj_.build(child_)
            self.StaticRoute.append(obj_)
            obj_.original_tagname_ = 'StaticRoute'
        super(StaticRoutingServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class StaticRoutingServiceType


class StaticRouteType(VCloudExtensibleType):
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Network=None, NextHopIp=None, Interface=None, GatewayInterface=None):
        self.original_tagname_ = None
        super(StaticRouteType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Network = Network
        self.NextHopIp = NextHopIp
        self.Interface = Interface
        self.GatewayInterface = GatewayInterface
    def factory(*args_, **kwargs_):
        if StaticRouteType.subclass:
            return StaticRouteType.subclass(*args_, **kwargs_)
        else:
            return StaticRouteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Network(self): return self.Network
    def set_Network(self, Network): self.Network = Network
    def get_NextHopIp(self): return self.NextHopIp
    def set_NextHopIp(self, NextHopIp): self.NextHopIp = NextHopIp
    def get_Interface(self): return self.Interface
    def set_Interface(self, Interface): self.Interface = Interface
    def get_GatewayInterface(self): return self.GatewayInterface
    def set_GatewayInterface(self, GatewayInterface): self.GatewayInterface = GatewayInterface
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Network is not None or
            self.NextHopIp is not None or
            self.Interface is not None or
            self.GatewayInterface is not None or
            super(StaticRouteType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StaticRouteType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StaticRouteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StaticRouteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StaticRouteType'):
        super(StaticRouteType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StaticRouteType')
    def exportChildren(self, outfile, level, namespace_='', name_='StaticRouteType', fromsubclass_=False, pretty_print=True):
        super(StaticRouteType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Network is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetwork>%s</%sNetwork>%s' % (namespace_, self.gds_format_string(quote_xml(self.Network).encode(ExternalEncoding), input_name='Network'), namespace_, eol_))
        if self.NextHopIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNextHopIp>%s</%sNextHopIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.NextHopIp).encode(ExternalEncoding), input_name='NextHopIp'), namespace_, eol_))
        if self.Interface is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInterface>%s</%sInterface>%s' % (namespace_, self.gds_format_string(quote_xml(self.Interface).encode(ExternalEncoding), input_name='Interface'), namespace_, eol_))
        if self.GatewayInterface is not None:
            self.GatewayInterface.export(outfile, level, namespace_, name_='GatewayInterface', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StaticRouteType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StaticRouteType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StaticRouteType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Network is not None:
            showIndent(outfile, level)
            outfile.write('Network=%s,\n' % quote_python(self.Network).encode(ExternalEncoding))
        if self.NextHopIp is not None:
            showIndent(outfile, level)
            outfile.write('NextHopIp=%s,\n' % quote_python(self.NextHopIp).encode(ExternalEncoding))
        if self.Interface is not None:
            showIndent(outfile, level)
            outfile.write('Interface=%s,\n' % quote_python(self.Interface).encode(ExternalEncoding))
        if self.GatewayInterface is not None:
            showIndent(outfile, level)
            outfile.write('GatewayInterface=model_.ReferenceType(\n')
            self.GatewayInterface.exportLiteral(outfile, level, name_='GatewayInterface')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StaticRouteType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Network':
            Network_ = child_.text
            Network_ = self.gds_validate_string(Network_, node, 'Network')
            self.Network = Network_
        elif nodeName_ == 'NextHopIp':
            NextHopIp_ = child_.text
            NextHopIp_ = self.gds_validate_string(NextHopIp_, node, 'NextHopIp')
            self.NextHopIp = NextHopIp_
            self.validate_IpAddressType(self.NextHopIp)    # validate type IpAddressType
        elif nodeName_ == 'Interface':
            Interface_ = child_.text
            Interface_ = self.gds_validate_string(Interface_, node, 'Interface')
            self.Interface = Interface_
        elif nodeName_ == 'GatewayInterface':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.GatewayInterface = obj_
            obj_.original_tagname_ = 'GatewayInterface'
        super(StaticRouteType, self).buildChildren(child_, node, nodeName_, True)
# end class StaticRouteType


class GatewayDhcpServiceType(NetworkServiceType):
    """5.1 Represents Gateway DHCP service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, Pool=None):
        self.original_tagname_ = None
        super(GatewayDhcpServiceType, self).__init__(VCloudExtension, IsEnabled, )
        if Pool is None:
            self.Pool = []
        else:
            self.Pool = Pool
    def factory(*args_, **kwargs_):
        if GatewayDhcpServiceType.subclass:
            return GatewayDhcpServiceType.subclass(*args_, **kwargs_)
        else:
            return GatewayDhcpServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Pool(self): return self.Pool
    def set_Pool(self, Pool): self.Pool = Pool
    def add_Pool(self, value): self.Pool.append(value)
    def insert_Pool_at(self, index, value): self.Pool.insert(index, value)
    def replace_Pool_at(self, index, value): self.Pool[index] = value
    def hasContent_(self):
        if (
            self.Pool or
            super(GatewayDhcpServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayDhcpServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayDhcpServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayDhcpServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayDhcpServiceType'):
        super(GatewayDhcpServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayDhcpServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayDhcpServiceType', fromsubclass_=False, pretty_print=True):
        super(GatewayDhcpServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Pool_ in self.Pool:
            Pool_.export(outfile, level, namespace_, name_='Pool', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GatewayDhcpServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayDhcpServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayDhcpServiceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Pool=[\n')
        level += 1
        for Pool_ in self.Pool:
            showIndent(outfile, level)
            outfile.write('model_.DhcpPoolServiceType(\n')
            Pool_.exportLiteral(outfile, level, name_='DhcpPoolServiceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayDhcpServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Pool':
            obj_ = DhcpPoolServiceType.factory()
            obj_.build(child_)
            self.Pool.append(obj_)
            obj_.original_tagname_ = 'Pool'
        super(GatewayDhcpServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayDhcpServiceType


class DhcpPoolServiceType(VCloudExtensibleType):
    """5.1 Represents DHCP pool service."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsEnabled=None, Network=None, DefaultLeaseTime=None, MaxLeaseTime=None, LowIpAddress=None, HighIpAddress=None):
        self.original_tagname_ = None
        super(DhcpPoolServiceType, self).__init__(VCloudExtension, )
        self.IsEnabled = IsEnabled
        self.Network = Network
        self.DefaultLeaseTime = DefaultLeaseTime
        self.MaxLeaseTime = MaxLeaseTime
        self.LowIpAddress = LowIpAddress
        self.HighIpAddress = HighIpAddress
    def factory(*args_, **kwargs_):
        if DhcpPoolServiceType.subclass:
            return DhcpPoolServiceType.subclass(*args_, **kwargs_)
        else:
            return DhcpPoolServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_Network(self): return self.Network
    def set_Network(self, Network): self.Network = Network
    def get_DefaultLeaseTime(self): return self.DefaultLeaseTime
    def set_DefaultLeaseTime(self, DefaultLeaseTime): self.DefaultLeaseTime = DefaultLeaseTime
    def get_MaxLeaseTime(self): return self.MaxLeaseTime
    def set_MaxLeaseTime(self, MaxLeaseTime): self.MaxLeaseTime = MaxLeaseTime
    def get_LowIpAddress(self): return self.LowIpAddress
    def set_LowIpAddress(self, LowIpAddress): self.LowIpAddress = LowIpAddress
    def get_HighIpAddress(self): return self.HighIpAddress
    def set_HighIpAddress(self, HighIpAddress): self.HighIpAddress = HighIpAddress
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.IsEnabled is not None or
            self.Network is not None or
            self.DefaultLeaseTime is not None or
            self.MaxLeaseTime is not None or
            self.LowIpAddress is not None or
            self.HighIpAddress is not None or
            super(DhcpPoolServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DhcpPoolServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DhcpPoolServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DhcpPoolServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DhcpPoolServiceType'):
        super(DhcpPoolServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DhcpPoolServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='DhcpPoolServiceType', fromsubclass_=False, pretty_print=True):
        super(DhcpPoolServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.Network is not None:
            self.Network.export(outfile, level, namespace_, name_='Network', pretty_print=pretty_print)
        if self.DefaultLeaseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefaultLeaseTime>%s</%sDefaultLeaseTime>%s' % (namespace_, self.gds_format_integer(self.DefaultLeaseTime, input_name='DefaultLeaseTime'), namespace_, eol_))
        if self.MaxLeaseTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaxLeaseTime>%s</%sMaxLeaseTime>%s' % (namespace_, self.gds_format_integer(self.MaxLeaseTime, input_name='MaxLeaseTime'), namespace_, eol_))
        if self.LowIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLowIpAddress>%s</%sLowIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.LowIpAddress).encode(ExternalEncoding), input_name='LowIpAddress'), namespace_, eol_))
        if self.HighIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHighIpAddress>%s</%sHighIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.HighIpAddress).encode(ExternalEncoding), input_name='HighIpAddress'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DhcpPoolServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DhcpPoolServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DhcpPoolServiceType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.Network is not None:
            showIndent(outfile, level)
            outfile.write('Network=model_.ReferenceType(\n')
            self.Network.exportLiteral(outfile, level, name_='Network')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DefaultLeaseTime is not None:
            showIndent(outfile, level)
            outfile.write('DefaultLeaseTime=%d,\n' % self.DefaultLeaseTime)
        if self.MaxLeaseTime is not None:
            showIndent(outfile, level)
            outfile.write('MaxLeaseTime=%d,\n' % self.MaxLeaseTime)
        if self.LowIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('LowIpAddress=%s,\n' % quote_python(self.LowIpAddress).encode(ExternalEncoding))
        if self.HighIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('HighIpAddress=%s,\n' % quote_python(self.HighIpAddress).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DhcpPoolServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'Network':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Network = obj_
            obj_.original_tagname_ = 'Network'
        elif nodeName_ == 'DefaultLeaseTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DefaultLeaseTime')
            self.DefaultLeaseTime = ival_
        elif nodeName_ == 'MaxLeaseTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaxLeaseTime')
            self.MaxLeaseTime = ival_
        elif nodeName_ == 'LowIpAddress':
            LowIpAddress_ = child_.text
            LowIpAddress_ = self.gds_validate_string(LowIpAddress_, node, 'LowIpAddress')
            self.LowIpAddress = LowIpAddress_
            self.validate_IpAddressType(self.LowIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'HighIpAddress':
            HighIpAddress_ = child_.text
            HighIpAddress_ = self.gds_validate_string(HighIpAddress_, node, 'HighIpAddress')
            self.HighIpAddress = HighIpAddress_
            self.validate_IpAddressType(self.HighIpAddress)    # validate type IpAddressType
        super(DhcpPoolServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class DhcpPoolServiceType


class LoadBalancerServiceType(NetworkServiceType):
    """5.1 Represents gateway load balancer service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, Pool=None, VirtualServer=None):
        self.original_tagname_ = None
        super(LoadBalancerServiceType, self).__init__(VCloudExtension, IsEnabled, )
        if Pool is None:
            self.Pool = []
        else:
            self.Pool = Pool
        if VirtualServer is None:
            self.VirtualServer = []
        else:
            self.VirtualServer = VirtualServer
    def factory(*args_, **kwargs_):
        if LoadBalancerServiceType.subclass:
            return LoadBalancerServiceType.subclass(*args_, **kwargs_)
        else:
            return LoadBalancerServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Pool(self): return self.Pool
    def set_Pool(self, Pool): self.Pool = Pool
    def add_Pool(self, value): self.Pool.append(value)
    def insert_Pool_at(self, index, value): self.Pool.insert(index, value)
    def replace_Pool_at(self, index, value): self.Pool[index] = value
    def get_VirtualServer(self): return self.VirtualServer
    def set_VirtualServer(self, VirtualServer): self.VirtualServer = VirtualServer
    def add_VirtualServer(self, value): self.VirtualServer.append(value)
    def insert_VirtualServer_at(self, index, value): self.VirtualServer.insert(index, value)
    def replace_VirtualServer_at(self, index, value): self.VirtualServer[index] = value
    def hasContent_(self):
        if (
            self.Pool or
            self.VirtualServer or
            super(LoadBalancerServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LoadBalancerServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadBalancerServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LoadBalancerServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LoadBalancerServiceType'):
        super(LoadBalancerServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LoadBalancerServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='LoadBalancerServiceType', fromsubclass_=False, pretty_print=True):
        super(LoadBalancerServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Pool_ in self.Pool:
            Pool_.export(outfile, level, namespace_, name_='Pool', pretty_print=pretty_print)
        for VirtualServer_ in self.VirtualServer:
            VirtualServer_.export(outfile, level, namespace_, name_='VirtualServer', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LoadBalancerServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LoadBalancerServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LoadBalancerServiceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Pool=[\n')
        level += 1
        for Pool_ in self.Pool:
            showIndent(outfile, level)
            outfile.write('model_.LoadBalancerPoolType(\n')
            Pool_.exportLiteral(outfile, level, name_='LoadBalancerPoolType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('VirtualServer=[\n')
        level += 1
        for VirtualServer_ in self.VirtualServer:
            showIndent(outfile, level)
            outfile.write('model_.LoadBalancerVirtualServerType(\n')
            VirtualServer_.exportLiteral(outfile, level, name_='LoadBalancerVirtualServerType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LoadBalancerServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Pool':
            obj_ = LoadBalancerPoolType.factory()
            obj_.build(child_)
            self.Pool.append(obj_)
            obj_.original_tagname_ = 'Pool'
        elif nodeName_ == 'VirtualServer':
            obj_ = LoadBalancerVirtualServerType.factory()
            obj_.build(child_)
            self.VirtualServer.append(obj_)
            obj_.original_tagname_ = 'VirtualServer'
        super(LoadBalancerServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class LoadBalancerServiceType


class LoadBalancerPoolType(VCloudExtensibleType):
    """5.1 Represents a load balancer pool."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Id=None, Name=None, Description=None, ServicePort=None, Member=None, Operational=None, ErrorDetails=None):
        self.original_tagname_ = None
        super(LoadBalancerPoolType, self).__init__(VCloudExtension, )
        self.Id = Id
        self.Name = Name
        self.Description = Description
        if ServicePort is None:
            self.ServicePort = []
        else:
            self.ServicePort = ServicePort
        if Member is None:
            self.Member = []
        else:
            self.Member = Member
        self.Operational = Operational
        self.ErrorDetails = ErrorDetails
    def factory(*args_, **kwargs_):
        if LoadBalancerPoolType.subclass:
            return LoadBalancerPoolType.subclass(*args_, **kwargs_)
        else:
            return LoadBalancerPoolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ServicePort(self): return self.ServicePort
    def set_ServicePort(self, ServicePort): self.ServicePort = ServicePort
    def add_ServicePort(self, value): self.ServicePort.append(value)
    def insert_ServicePort_at(self, index, value): self.ServicePort.insert(index, value)
    def replace_ServicePort_at(self, index, value): self.ServicePort[index] = value
    def get_Member(self): return self.Member
    def set_Member(self, Member): self.Member = Member
    def add_Member(self, value): self.Member.append(value)
    def insert_Member_at(self, index, value): self.Member.insert(index, value)
    def replace_Member_at(self, index, value): self.Member[index] = value
    def get_Operational(self): return self.Operational
    def set_Operational(self, Operational): self.Operational = Operational
    def get_ErrorDetails(self): return self.ErrorDetails
    def set_ErrorDetails(self, ErrorDetails): self.ErrorDetails = ErrorDetails
    def hasContent_(self):
        if (
            self.Id is not None or
            self.Name is not None or
            self.Description is not None or
            self.ServicePort or
            self.Member or
            self.Operational is not None or
            self.ErrorDetails is not None or
            super(LoadBalancerPoolType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LoadBalancerPoolType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadBalancerPoolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LoadBalancerPoolType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LoadBalancerPoolType'):
        super(LoadBalancerPoolType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LoadBalancerPoolType')
    def exportChildren(self, outfile, level, namespace_='', name_='LoadBalancerPoolType', fromsubclass_=False, pretty_print=True):
        super(LoadBalancerPoolType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        for ServicePort_ in self.ServicePort:
            ServicePort_.export(outfile, level, namespace_, name_='ServicePort', pretty_print=pretty_print)
        for Member_ in self.Member:
            Member_.export(outfile, level, namespace_, name_='Member', pretty_print=pretty_print)
        if self.Operational is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOperational>%s</%sOperational>%s' % (namespace_, self.gds_format_boolean(self.Operational, input_name='Operational'), namespace_, eol_))
        if self.ErrorDetails is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sErrorDetails>%s</%sErrorDetails>%s' % (namespace_, self.gds_format_string(quote_xml(self.ErrorDetails).encode(ExternalEncoding), input_name='ErrorDetails'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LoadBalancerPoolType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LoadBalancerPoolType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LoadBalancerPoolType, self).exportLiteralChildren(outfile, level, name_)
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ServicePort=[\n')
        level += 1
        for ServicePort_ in self.ServicePort:
            showIndent(outfile, level)
            outfile.write('model_.LBPoolServicePortType(\n')
            ServicePort_.exportLiteral(outfile, level, name_='LBPoolServicePortType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Member=[\n')
        level += 1
        for Member_ in self.Member:
            showIndent(outfile, level)
            outfile.write('model_.LBPoolMemberType(\n')
            Member_.exportLiteral(outfile, level, name_='LBPoolMemberType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Operational is not None:
            showIndent(outfile, level)
            outfile.write('Operational=%s,\n' % self.Operational)
        if self.ErrorDetails is not None:
            showIndent(outfile, level)
            outfile.write('ErrorDetails=%s,\n' % quote_python(self.ErrorDetails).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LoadBalancerPoolType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'ServicePort':
            obj_ = LBPoolServicePortType.factory()
            obj_.build(child_)
            self.ServicePort.append(obj_)
            obj_.original_tagname_ = 'ServicePort'
        elif nodeName_ == 'Member':
            obj_ = LBPoolMemberType.factory()
            obj_.build(child_)
            self.Member.append(obj_)
            obj_.original_tagname_ = 'Member'
        elif nodeName_ == 'Operational':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Operational')
            self.Operational = ival_
        elif nodeName_ == 'ErrorDetails':
            ErrorDetails_ = child_.text
            ErrorDetails_ = self.gds_validate_string(ErrorDetails_, node, 'ErrorDetails')
            self.ErrorDetails = ErrorDetails_
        super(LoadBalancerPoolType, self).buildChildren(child_, node, nodeName_, True)
# end class LoadBalancerPoolType


class LoadBalancerVirtualServerType(VCloudExtensibleType):
    """5.1 Represents a load balancer virtual server."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsEnabled=None, Name=None, Description=None, Interface=None, IpAddress=None, ServiceProfile=None, Logging=None, Pool=None, LoadBalancerTemplates=None):
        self.original_tagname_ = None
        super(LoadBalancerVirtualServerType, self).__init__(VCloudExtension, )
        self.IsEnabled = IsEnabled
        self.Name = Name
        self.Description = Description
        self.Interface = Interface
        self.IpAddress = IpAddress
        if ServiceProfile is None:
            self.ServiceProfile = []
        else:
            self.ServiceProfile = ServiceProfile
        self.Logging = Logging
        self.Pool = Pool
        if LoadBalancerTemplates is None:
            self.LoadBalancerTemplates = []
        else:
            self.LoadBalancerTemplates = LoadBalancerTemplates
    def factory(*args_, **kwargs_):
        if LoadBalancerVirtualServerType.subclass:
            return LoadBalancerVirtualServerType.subclass(*args_, **kwargs_)
        else:
            return LoadBalancerVirtualServerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Interface(self): return self.Interface
    def set_Interface(self, Interface): self.Interface = Interface
    def get_IpAddress(self): return self.IpAddress
    def set_IpAddress(self, IpAddress): self.IpAddress = IpAddress
    def get_ServiceProfile(self): return self.ServiceProfile
    def set_ServiceProfile(self, ServiceProfile): self.ServiceProfile = ServiceProfile
    def add_ServiceProfile(self, value): self.ServiceProfile.append(value)
    def insert_ServiceProfile_at(self, index, value): self.ServiceProfile.insert(index, value)
    def replace_ServiceProfile_at(self, index, value): self.ServiceProfile[index] = value
    def get_Logging(self): return self.Logging
    def set_Logging(self, Logging): self.Logging = Logging
    def get_Pool(self): return self.Pool
    def set_Pool(self, Pool): self.Pool = Pool
    def get_LoadBalancerTemplates(self): return self.LoadBalancerTemplates
    def set_LoadBalancerTemplates(self, LoadBalancerTemplates): self.LoadBalancerTemplates = LoadBalancerTemplates
    def add_LoadBalancerTemplates(self, value): self.LoadBalancerTemplates.append(value)
    def insert_LoadBalancerTemplates_at(self, index, value): self.LoadBalancerTemplates.insert(index, value)
    def replace_LoadBalancerTemplates_at(self, index, value): self.LoadBalancerTemplates[index] = value
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.IsEnabled is not None or
            self.Name is not None or
            self.Description is not None or
            self.Interface is not None or
            self.IpAddress is not None or
            self.ServiceProfile or
            self.Logging is not None or
            self.Pool is not None or
            self.LoadBalancerTemplates or
            super(LoadBalancerVirtualServerType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LoadBalancerVirtualServerType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadBalancerVirtualServerType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LoadBalancerVirtualServerType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LoadBalancerVirtualServerType'):
        super(LoadBalancerVirtualServerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LoadBalancerVirtualServerType')
    def exportChildren(self, outfile, level, namespace_='', name_='LoadBalancerVirtualServerType', fromsubclass_=False, pretty_print=True):
        super(LoadBalancerVirtualServerType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.Interface is not None:
            self.Interface.export(outfile, level, namespace_, name_='Interface', pretty_print=pretty_print)
        if self.IpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpAddress>%s</%sIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IpAddress).encode(ExternalEncoding), input_name='IpAddress'), namespace_, eol_))
        for ServiceProfile_ in self.ServiceProfile:
            ServiceProfile_.export(outfile, level, namespace_, name_='ServiceProfile', pretty_print=pretty_print)
        if self.Logging is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLogging>%s</%sLogging>%s' % (namespace_, self.gds_format_boolean(self.Logging, input_name='Logging'), namespace_, eol_))
        if self.Pool is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPool>%s</%sPool>%s' % (namespace_, self.gds_format_string(quote_xml(self.Pool).encode(ExternalEncoding), input_name='Pool'), namespace_, eol_))
        for LoadBalancerTemplates_ in self.LoadBalancerTemplates:
            LoadBalancerTemplates_.export(outfile, level, namespace_, name_='LoadBalancerTemplates', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LoadBalancerVirtualServerType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LoadBalancerVirtualServerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LoadBalancerVirtualServerType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.Interface is not None:
            showIndent(outfile, level)
            outfile.write('Interface=model_.ReferenceType(\n')
            self.Interface.exportLiteral(outfile, level, name_='Interface')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IpAddress is not None:
            showIndent(outfile, level)
            outfile.write('IpAddress=%s,\n' % quote_python(self.IpAddress).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ServiceProfile=[\n')
        level += 1
        for ServiceProfile_ in self.ServiceProfile:
            showIndent(outfile, level)
            outfile.write('model_.LBVirtualServerServiceProfileType(\n')
            ServiceProfile_.exportLiteral(outfile, level, name_='LBVirtualServerServiceProfileType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Logging is not None:
            showIndent(outfile, level)
            outfile.write('Logging=%s,\n' % self.Logging)
        if self.Pool is not None:
            showIndent(outfile, level)
            outfile.write('Pool=%s,\n' % quote_python(self.Pool).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('LoadBalancerTemplates=[\n')
        level += 1
        for LoadBalancerTemplates_ in self.LoadBalancerTemplates:
            showIndent(outfile, level)
            outfile.write('model_.VendorTemplateType(\n')
            LoadBalancerTemplates_.exportLiteral(outfile, level, name_='VendorTemplateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LoadBalancerVirtualServerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'Interface':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Interface = obj_
            obj_.original_tagname_ = 'Interface'
        elif nodeName_ == 'IpAddress':
            IpAddress_ = child_.text
            IpAddress_ = self.gds_validate_string(IpAddress_, node, 'IpAddress')
            self.IpAddress = IpAddress_
            self.validate_IpAddressType(self.IpAddress)    # validate type IpAddressType
        elif nodeName_ == 'ServiceProfile':
            obj_ = LBVirtualServerServiceProfileType.factory()
            obj_.build(child_)
            self.ServiceProfile.append(obj_)
            obj_.original_tagname_ = 'ServiceProfile'
        elif nodeName_ == 'Logging':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Logging')
            self.Logging = ival_
        elif nodeName_ == 'Pool':
            Pool_ = child_.text
            Pool_ = self.gds_validate_string(Pool_, node, 'Pool')
            self.Pool = Pool_
        elif nodeName_ == 'LoadBalancerTemplates':
            obj_ = VendorTemplateType.factory()
            obj_.build(child_)
            self.LoadBalancerTemplates.append(obj_)
            obj_.original_tagname_ = 'LoadBalancerTemplates'
        super(LoadBalancerVirtualServerType, self).buildChildren(child_, node, nodeName_, True)
# end class LoadBalancerVirtualServerType


class LBPoolServicePortType(VCloudExtensibleType):
    """5.1 Represents a service port in a load balancer pool."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsEnabled=None, Protocol=None, Algorithm=None, Port=None, HealthCheckPort=None, HealthCheck=None):
        self.original_tagname_ = None
        super(LBPoolServicePortType, self).__init__(VCloudExtension, )
        self.IsEnabled = IsEnabled
        self.Protocol = Protocol
        self.Algorithm = Algorithm
        self.Port = Port
        self.HealthCheckPort = HealthCheckPort
        if HealthCheck is None:
            self.HealthCheck = []
        else:
            self.HealthCheck = HealthCheck
    def factory(*args_, **kwargs_):
        if LBPoolServicePortType.subclass:
            return LBPoolServicePortType.subclass(*args_, **kwargs_)
        else:
            return LBPoolServicePortType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_Protocol(self): return self.Protocol
    def set_Protocol(self, Protocol): self.Protocol = Protocol
    def get_Algorithm(self): return self.Algorithm
    def set_Algorithm(self, Algorithm): self.Algorithm = Algorithm
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def get_HealthCheckPort(self): return self.HealthCheckPort
    def set_HealthCheckPort(self, HealthCheckPort): self.HealthCheckPort = HealthCheckPort
    def get_HealthCheck(self): return self.HealthCheck
    def set_HealthCheck(self, HealthCheck): self.HealthCheck = HealthCheck
    def add_HealthCheck(self, value): self.HealthCheck.append(value)
    def insert_HealthCheck_at(self, index, value): self.HealthCheck.insert(index, value)
    def replace_HealthCheck_at(self, index, value): self.HealthCheck[index] = value
    def hasContent_(self):
        if (
            self.IsEnabled is not None or
            self.Protocol is not None or
            self.Algorithm is not None or
            self.Port is not None or
            self.HealthCheckPort is not None or
            self.HealthCheck or
            super(LBPoolServicePortType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LBPoolServicePortType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LBPoolServicePortType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LBPoolServicePortType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LBPoolServicePortType'):
        super(LBPoolServicePortType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LBPoolServicePortType')
    def exportChildren(self, outfile, level, namespace_='', name_='LBPoolServicePortType', fromsubclass_=False, pretty_print=True):
        super(LBPoolServicePortType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.Protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol>%s</%sProtocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.Protocol).encode(ExternalEncoding), input_name='Protocol'), namespace_, eol_))
        if self.Algorithm is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAlgorithm>%s</%sAlgorithm>%s' % (namespace_, self.gds_format_string(quote_xml(self.Algorithm).encode(ExternalEncoding), input_name='Algorithm'), namespace_, eol_))
        if self.Port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPort>%s</%sPort>%s' % (namespace_, self.gds_format_string(quote_xml(self.Port).encode(ExternalEncoding), input_name='Port'), namespace_, eol_))
        if self.HealthCheckPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHealthCheckPort>%s</%sHealthCheckPort>%s' % (namespace_, self.gds_format_string(quote_xml(self.HealthCheckPort).encode(ExternalEncoding), input_name='HealthCheckPort'), namespace_, eol_))
        for HealthCheck_ in self.HealthCheck:
            HealthCheck_.export(outfile, level, namespace_, name_='HealthCheck', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LBPoolServicePortType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LBPoolServicePortType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LBPoolServicePortType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.Protocol is not None:
            showIndent(outfile, level)
            outfile.write('Protocol=%s,\n' % quote_python(self.Protocol).encode(ExternalEncoding))
        if self.Algorithm is not None:
            showIndent(outfile, level)
            outfile.write('Algorithm=%s,\n' % quote_python(self.Algorithm).encode(ExternalEncoding))
        if self.Port is not None:
            showIndent(outfile, level)
            outfile.write('Port=%s,\n' % quote_python(self.Port).encode(ExternalEncoding))
        if self.HealthCheckPort is not None:
            showIndent(outfile, level)
            outfile.write('HealthCheckPort=%s,\n' % quote_python(self.HealthCheckPort).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('HealthCheck=[\n')
        level += 1
        for HealthCheck_ in self.HealthCheck:
            showIndent(outfile, level)
            outfile.write('model_.LBPoolHealthCheckType(\n')
            HealthCheck_.exportLiteral(outfile, level, name_='LBPoolHealthCheckType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LBPoolServicePortType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'Protocol':
            Protocol_ = child_.text
            Protocol_ = self.gds_validate_string(Protocol_, node, 'Protocol')
            self.Protocol = Protocol_
        elif nodeName_ == 'Algorithm':
            Algorithm_ = child_.text
            Algorithm_ = self.gds_validate_string(Algorithm_, node, 'Algorithm')
            self.Algorithm = Algorithm_
        elif nodeName_ == 'Port':
            Port_ = child_.text
            Port_ = self.gds_validate_string(Port_, node, 'Port')
            self.Port = Port_
        elif nodeName_ == 'HealthCheckPort':
            HealthCheckPort_ = child_.text
            HealthCheckPort_ = self.gds_validate_string(HealthCheckPort_, node, 'HealthCheckPort')
            self.HealthCheckPort = HealthCheckPort_
        elif nodeName_ == 'HealthCheck':
            obj_ = LBPoolHealthCheckType.factory()
            obj_.build(child_)
            self.HealthCheck.append(obj_)
            obj_.original_tagname_ = 'HealthCheck'
        super(LBPoolServicePortType, self).buildChildren(child_, node, nodeName_, True)
# end class LBPoolServicePortType


class LBVirtualServerServiceProfileType(VCloudExtensibleType):
    """5.1 Represents service profile for a load balancing virtual server."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsEnabled=None, Protocol=None, Port=None, Persistence=None):
        self.original_tagname_ = None
        super(LBVirtualServerServiceProfileType, self).__init__(VCloudExtension, )
        self.IsEnabled = IsEnabled
        self.Protocol = Protocol
        self.Port = Port
        self.Persistence = Persistence
    def factory(*args_, **kwargs_):
        if LBVirtualServerServiceProfileType.subclass:
            return LBVirtualServerServiceProfileType.subclass(*args_, **kwargs_)
        else:
            return LBVirtualServerServiceProfileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_Protocol(self): return self.Protocol
    def set_Protocol(self, Protocol): self.Protocol = Protocol
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def get_Persistence(self): return self.Persistence
    def set_Persistence(self, Persistence): self.Persistence = Persistence
    def hasContent_(self):
        if (
            self.IsEnabled is not None or
            self.Protocol is not None or
            self.Port is not None or
            self.Persistence is not None or
            super(LBVirtualServerServiceProfileType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LBVirtualServerServiceProfileType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LBVirtualServerServiceProfileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LBVirtualServerServiceProfileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LBVirtualServerServiceProfileType'):
        super(LBVirtualServerServiceProfileType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LBVirtualServerServiceProfileType')
    def exportChildren(self, outfile, level, namespace_='', name_='LBVirtualServerServiceProfileType', fromsubclass_=False, pretty_print=True):
        super(LBVirtualServerServiceProfileType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.Protocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProtocol>%s</%sProtocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.Protocol).encode(ExternalEncoding), input_name='Protocol'), namespace_, eol_))
        if self.Port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPort>%s</%sPort>%s' % (namespace_, self.gds_format_string(quote_xml(self.Port).encode(ExternalEncoding), input_name='Port'), namespace_, eol_))
        if self.Persistence is not None:
            self.Persistence.export(outfile, level, namespace_, name_='Persistence', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LBVirtualServerServiceProfileType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LBVirtualServerServiceProfileType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LBVirtualServerServiceProfileType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.Protocol is not None:
            showIndent(outfile, level)
            outfile.write('Protocol=%s,\n' % quote_python(self.Protocol).encode(ExternalEncoding))
        if self.Port is not None:
            showIndent(outfile, level)
            outfile.write('Port=%s,\n' % quote_python(self.Port).encode(ExternalEncoding))
        if self.Persistence is not None:
            showIndent(outfile, level)
            outfile.write('Persistence=model_.LBPersistenceType(\n')
            self.Persistence.exportLiteral(outfile, level, name_='Persistence')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LBVirtualServerServiceProfileType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'Protocol':
            Protocol_ = child_.text
            Protocol_ = self.gds_validate_string(Protocol_, node, 'Protocol')
            self.Protocol = Protocol_
        elif nodeName_ == 'Port':
            Port_ = child_.text
            Port_ = self.gds_validate_string(Port_, node, 'Port')
            self.Port = Port_
        elif nodeName_ == 'Persistence':
            obj_ = LBPersistenceType.factory()
            obj_.build(child_)
            self.Persistence = obj_
            obj_.original_tagname_ = 'Persistence'
        super(LBVirtualServerServiceProfileType, self).buildChildren(child_, node, nodeName_, True)
# end class LBVirtualServerServiceProfileType


class LBPersistenceType(VCloudExtensibleType):
    """5.1 Represents persistence type for a load balancer service profile."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Method=None, CookieName=None, CookieMode=None):
        self.original_tagname_ = None
        super(LBPersistenceType, self).__init__(VCloudExtension, )
        self.Method = Method
        self.CookieName = CookieName
        self.CookieMode = CookieMode
    def factory(*args_, **kwargs_):
        if LBPersistenceType.subclass:
            return LBPersistenceType.subclass(*args_, **kwargs_)
        else:
            return LBPersistenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Method(self): return self.Method
    def set_Method(self, Method): self.Method = Method
    def get_CookieName(self): return self.CookieName
    def set_CookieName(self, CookieName): self.CookieName = CookieName
    def get_CookieMode(self): return self.CookieMode
    def set_CookieMode(self, CookieMode): self.CookieMode = CookieMode
    def hasContent_(self):
        if (
            self.Method is not None or
            self.CookieName is not None or
            self.CookieMode is not None or
            super(LBPersistenceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LBPersistenceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LBPersistenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LBPersistenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LBPersistenceType'):
        super(LBPersistenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LBPersistenceType')
    def exportChildren(self, outfile, level, namespace_='', name_='LBPersistenceType', fromsubclass_=False, pretty_print=True):
        super(LBPersistenceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Method is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMethod>%s</%sMethod>%s' % (namespace_, self.gds_format_string(quote_xml(self.Method).encode(ExternalEncoding), input_name='Method'), namespace_, eol_))
        if self.CookieName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCookieName>%s</%sCookieName>%s' % (namespace_, self.gds_format_string(quote_xml(self.CookieName).encode(ExternalEncoding), input_name='CookieName'), namespace_, eol_))
        if self.CookieMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCookieMode>%s</%sCookieMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.CookieMode).encode(ExternalEncoding), input_name='CookieMode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LBPersistenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LBPersistenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LBPersistenceType, self).exportLiteralChildren(outfile, level, name_)
        if self.Method is not None:
            showIndent(outfile, level)
            outfile.write('Method=%s,\n' % quote_python(self.Method).encode(ExternalEncoding))
        if self.CookieName is not None:
            showIndent(outfile, level)
            outfile.write('CookieName=%s,\n' % quote_python(self.CookieName).encode(ExternalEncoding))
        if self.CookieMode is not None:
            showIndent(outfile, level)
            outfile.write('CookieMode=%s,\n' % quote_python(self.CookieMode).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LBPersistenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Method':
            Method_ = child_.text
            Method_ = self.gds_validate_string(Method_, node, 'Method')
            self.Method = Method_
        elif nodeName_ == 'CookieName':
            CookieName_ = child_.text
            CookieName_ = self.gds_validate_string(CookieName_, node, 'CookieName')
            self.CookieName = CookieName_
        elif nodeName_ == 'CookieMode':
            CookieMode_ = child_.text
            CookieMode_ = self.gds_validate_string(CookieMode_, node, 'CookieMode')
            self.CookieMode = CookieMode_
        super(LBPersistenceType, self).buildChildren(child_, node, nodeName_, True)
# end class LBPersistenceType


class LBPoolMemberType(VCloudExtensibleType):
    """5.1 Represents a member in a load balancer pool."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IpAddress=None, Weight=None, ServicePort=None):
        self.original_tagname_ = None
        super(LBPoolMemberType, self).__init__(VCloudExtension, )
        self.IpAddress = IpAddress
        self.Weight = Weight
        if ServicePort is None:
            self.ServicePort = []
        else:
            self.ServicePort = ServicePort
    def factory(*args_, **kwargs_):
        if LBPoolMemberType.subclass:
            return LBPoolMemberType.subclass(*args_, **kwargs_)
        else:
            return LBPoolMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IpAddress(self): return self.IpAddress
    def set_IpAddress(self, IpAddress): self.IpAddress = IpAddress
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_ServicePort(self): return self.ServicePort
    def set_ServicePort(self, ServicePort): self.ServicePort = ServicePort
    def add_ServicePort(self, value): self.ServicePort.append(value)
    def insert_ServicePort_at(self, index, value): self.ServicePort.insert(index, value)
    def replace_ServicePort_at(self, index, value): self.ServicePort[index] = value
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.IpAddress is not None or
            self.Weight is not None or
            self.ServicePort or
            super(LBPoolMemberType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LBPoolMemberType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LBPoolMemberType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LBPoolMemberType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LBPoolMemberType'):
        super(LBPoolMemberType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LBPoolMemberType')
    def exportChildren(self, outfile, level, namespace_='', name_='LBPoolMemberType', fromsubclass_=False, pretty_print=True):
        super(LBPoolMemberType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpAddress>%s</%sIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IpAddress).encode(ExternalEncoding), input_name='IpAddress'), namespace_, eol_))
        if self.Weight is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWeight>%s</%sWeight>%s' % (namespace_, self.gds_format_string(quote_xml(self.Weight).encode(ExternalEncoding), input_name='Weight'), namespace_, eol_))
        for ServicePort_ in self.ServicePort:
            ServicePort_.export(outfile, level, namespace_, name_='ServicePort', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LBPoolMemberType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LBPoolMemberType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LBPoolMemberType, self).exportLiteralChildren(outfile, level, name_)
        if self.IpAddress is not None:
            showIndent(outfile, level)
            outfile.write('IpAddress=%s,\n' % quote_python(self.IpAddress).encode(ExternalEncoding))
        if self.Weight is not None:
            showIndent(outfile, level)
            outfile.write('Weight=%s,\n' % quote_python(self.Weight).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('ServicePort=[\n')
        level += 1
        for ServicePort_ in self.ServicePort:
            showIndent(outfile, level)
            outfile.write('model_.LBPoolServicePortType(\n')
            ServicePort_.exportLiteral(outfile, level, name_='LBPoolServicePortType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LBPoolMemberType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IpAddress':
            IpAddress_ = child_.text
            IpAddress_ = self.gds_validate_string(IpAddress_, node, 'IpAddress')
            self.IpAddress = IpAddress_
            self.validate_IpAddressType(self.IpAddress)    # validate type IpAddressType
        elif nodeName_ == 'Weight':
            Weight_ = child_.text
            Weight_ = self.gds_validate_string(Weight_, node, 'Weight')
            self.Weight = Weight_
        elif nodeName_ == 'ServicePort':
            obj_ = LBPoolServicePortType.factory()
            obj_.build(child_)
            self.ServicePort.append(obj_)
            obj_.original_tagname_ = 'ServicePort'
        super(LBPoolMemberType, self).buildChildren(child_, node, nodeName_, True)
# end class LBPoolMemberType


class LBPoolHealthCheckType(VCloudExtensibleType):
    """5.1 Represents a service port health check list."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Mode=None, Uri=None, HealthThreshold=None, UnhealthThreshold=None, Interval=None, Timeout=None):
        self.original_tagname_ = None
        super(LBPoolHealthCheckType, self).__init__(VCloudExtension, )
        self.Mode = Mode
        self.Uri = Uri
        self.HealthThreshold = HealthThreshold
        self.UnhealthThreshold = UnhealthThreshold
        self.Interval = Interval
        self.Timeout = Timeout
    def factory(*args_, **kwargs_):
        if LBPoolHealthCheckType.subclass:
            return LBPoolHealthCheckType.subclass(*args_, **kwargs_)
        else:
            return LBPoolHealthCheckType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Mode(self): return self.Mode
    def set_Mode(self, Mode): self.Mode = Mode
    def get_Uri(self): return self.Uri
    def set_Uri(self, Uri): self.Uri = Uri
    def get_HealthThreshold(self): return self.HealthThreshold
    def set_HealthThreshold(self, HealthThreshold): self.HealthThreshold = HealthThreshold
    def get_UnhealthThreshold(self): return self.UnhealthThreshold
    def set_UnhealthThreshold(self, UnhealthThreshold): self.UnhealthThreshold = UnhealthThreshold
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def get_Timeout(self): return self.Timeout
    def set_Timeout(self, Timeout): self.Timeout = Timeout
    def hasContent_(self):
        if (
            self.Mode is not None or
            self.Uri is not None or
            self.HealthThreshold is not None or
            self.UnhealthThreshold is not None or
            self.Interval is not None or
            self.Timeout is not None or
            super(LBPoolHealthCheckType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LBPoolHealthCheckType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LBPoolHealthCheckType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LBPoolHealthCheckType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LBPoolHealthCheckType'):
        super(LBPoolHealthCheckType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LBPoolHealthCheckType')
    def exportChildren(self, outfile, level, namespace_='', name_='LBPoolHealthCheckType', fromsubclass_=False, pretty_print=True):
        super(LBPoolHealthCheckType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMode>%s</%sMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.Mode).encode(ExternalEncoding), input_name='Mode'), namespace_, eol_))
        if self.Uri is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUri>%s</%sUri>%s' % (namespace_, self.gds_format_string(quote_xml(self.Uri).encode(ExternalEncoding), input_name='Uri'), namespace_, eol_))
        if self.HealthThreshold is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHealthThreshold>%s</%sHealthThreshold>%s' % (namespace_, self.gds_format_string(quote_xml(self.HealthThreshold).encode(ExternalEncoding), input_name='HealthThreshold'), namespace_, eol_))
        if self.UnhealthThreshold is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnhealthThreshold>%s</%sUnhealthThreshold>%s' % (namespace_, self.gds_format_string(quote_xml(self.UnhealthThreshold).encode(ExternalEncoding), input_name='UnhealthThreshold'), namespace_, eol_))
        if self.Interval is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInterval>%s</%sInterval>%s' % (namespace_, self.gds_format_string(quote_xml(self.Interval).encode(ExternalEncoding), input_name='Interval'), namespace_, eol_))
        if self.Timeout is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimeout>%s</%sTimeout>%s' % (namespace_, self.gds_format_string(quote_xml(self.Timeout).encode(ExternalEncoding), input_name='Timeout'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LBPoolHealthCheckType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LBPoolHealthCheckType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LBPoolHealthCheckType, self).exportLiteralChildren(outfile, level, name_)
        if self.Mode is not None:
            showIndent(outfile, level)
            outfile.write('Mode=%s,\n' % quote_python(self.Mode).encode(ExternalEncoding))
        if self.Uri is not None:
            showIndent(outfile, level)
            outfile.write('Uri=%s,\n' % quote_python(self.Uri).encode(ExternalEncoding))
        if self.HealthThreshold is not None:
            showIndent(outfile, level)
            outfile.write('HealthThreshold=%s,\n' % quote_python(self.HealthThreshold).encode(ExternalEncoding))
        if self.UnhealthThreshold is not None:
            showIndent(outfile, level)
            outfile.write('UnhealthThreshold=%s,\n' % quote_python(self.UnhealthThreshold).encode(ExternalEncoding))
        if self.Interval is not None:
            showIndent(outfile, level)
            outfile.write('Interval=%s,\n' % quote_python(self.Interval).encode(ExternalEncoding))
        if self.Timeout is not None:
            showIndent(outfile, level)
            outfile.write('Timeout=%s,\n' % quote_python(self.Timeout).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LBPoolHealthCheckType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Mode':
            Mode_ = child_.text
            Mode_ = self.gds_validate_string(Mode_, node, 'Mode')
            self.Mode = Mode_
        elif nodeName_ == 'Uri':
            Uri_ = child_.text
            Uri_ = self.gds_validate_string(Uri_, node, 'Uri')
            self.Uri = Uri_
        elif nodeName_ == 'HealthThreshold':
            HealthThreshold_ = child_.text
            HealthThreshold_ = self.gds_validate_string(HealthThreshold_, node, 'HealthThreshold')
            self.HealthThreshold = HealthThreshold_
        elif nodeName_ == 'UnhealthThreshold':
            UnhealthThreshold_ = child_.text
            UnhealthThreshold_ = self.gds_validate_string(UnhealthThreshold_, node, 'UnhealthThreshold')
            self.UnhealthThreshold = UnhealthThreshold_
        elif nodeName_ == 'Interval':
            Interval_ = child_.text
            Interval_ = self.gds_validate_string(Interval_, node, 'Interval')
            self.Interval = Interval_
        elif nodeName_ == 'Timeout':
            Timeout_ = child_.text
            Timeout_ = self.gds_validate_string(Timeout_, node, 'Timeout')
            self.Timeout = Timeout_
        super(LBPoolHealthCheckType, self).buildChildren(child_, node, nodeName_, True)
# end class LBPoolHealthCheckType


class GatewayIpsecVpnServiceType(NetworkServiceType):
    """5.1 Represents gateway IPsec VPN service."""
    subclass = None
    superclass = NetworkServiceType
    def __init__(self, VCloudExtension=None, IsEnabled=None, Endpoint=None, Tunnel=None):
        self.original_tagname_ = None
        super(GatewayIpsecVpnServiceType, self).__init__(VCloudExtension, IsEnabled, )
        if Endpoint is None:
            self.Endpoint = []
        else:
            self.Endpoint = Endpoint
        if Tunnel is None:
            self.Tunnel = []
        else:
            self.Tunnel = Tunnel
    def factory(*args_, **kwargs_):
        if GatewayIpsecVpnServiceType.subclass:
            return GatewayIpsecVpnServiceType.subclass(*args_, **kwargs_)
        else:
            return GatewayIpsecVpnServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Endpoint(self): return self.Endpoint
    def set_Endpoint(self, Endpoint): self.Endpoint = Endpoint
    def add_Endpoint(self, value): self.Endpoint.append(value)
    def insert_Endpoint_at(self, index, value): self.Endpoint.insert(index, value)
    def replace_Endpoint_at(self, index, value): self.Endpoint[index] = value
    def get_Tunnel(self): return self.Tunnel
    def set_Tunnel(self, Tunnel): self.Tunnel = Tunnel
    def add_Tunnel(self, value): self.Tunnel.append(value)
    def insert_Tunnel_at(self, index, value): self.Tunnel.insert(index, value)
    def replace_Tunnel_at(self, index, value): self.Tunnel[index] = value
    def hasContent_(self):
        if (
            self.Endpoint or
            self.Tunnel or
            super(GatewayIpsecVpnServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayIpsecVpnServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayIpsecVpnServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayIpsecVpnServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayIpsecVpnServiceType'):
        super(GatewayIpsecVpnServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayIpsecVpnServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayIpsecVpnServiceType', fromsubclass_=False, pretty_print=True):
        super(GatewayIpsecVpnServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Endpoint_ in self.Endpoint:
            Endpoint_.export(outfile, level, namespace_, name_='Endpoint', pretty_print=pretty_print)
        for Tunnel_ in self.Tunnel:
            Tunnel_.export(outfile, level, namespace_, name_='Tunnel', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GatewayIpsecVpnServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayIpsecVpnServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayIpsecVpnServiceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Endpoint=[\n')
        level += 1
        for Endpoint_ in self.Endpoint:
            showIndent(outfile, level)
            outfile.write('model_.GatewayIpsecVpnEndpointType(\n')
            Endpoint_.exportLiteral(outfile, level, name_='GatewayIpsecVpnEndpointType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Tunnel=[\n')
        level += 1
        for Tunnel_ in self.Tunnel:
            showIndent(outfile, level)
            outfile.write('model_.GatewayIpsecVpnTunnelType(\n')
            Tunnel_.exportLiteral(outfile, level, name_='GatewayIpsecVpnTunnelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayIpsecVpnServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Endpoint':
            obj_ = GatewayIpsecVpnEndpointType.factory()
            obj_.build(child_)
            self.Endpoint.append(obj_)
            obj_.original_tagname_ = 'Endpoint'
        elif nodeName_ == 'Tunnel':
            obj_ = GatewayIpsecVpnTunnelType.factory()
            obj_.build(child_)
            self.Tunnel.append(obj_)
            obj_.original_tagname_ = 'Tunnel'
        super(GatewayIpsecVpnServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayIpsecVpnServiceType


class GatewayIpsecVpnEndpointType(VCloudExtensibleType):
    """5.1 Represents an IPSec VPN endpoint."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Network=None, PublicIp=None):
        self.original_tagname_ = None
        super(GatewayIpsecVpnEndpointType, self).__init__(VCloudExtension, )
        self.Network = Network
        self.PublicIp = PublicIp
    def factory(*args_, **kwargs_):
        if GatewayIpsecVpnEndpointType.subclass:
            return GatewayIpsecVpnEndpointType.subclass(*args_, **kwargs_)
        else:
            return GatewayIpsecVpnEndpointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Network(self): return self.Network
    def set_Network(self, Network): self.Network = Network
    def get_PublicIp(self): return self.PublicIp
    def set_PublicIp(self, PublicIp): self.PublicIp = PublicIp
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Network is not None or
            self.PublicIp is not None or
            super(GatewayIpsecVpnEndpointType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayIpsecVpnEndpointType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayIpsecVpnEndpointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayIpsecVpnEndpointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayIpsecVpnEndpointType'):
        super(GatewayIpsecVpnEndpointType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayIpsecVpnEndpointType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayIpsecVpnEndpointType', fromsubclass_=False, pretty_print=True):
        super(GatewayIpsecVpnEndpointType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Network is not None:
            self.Network.export(outfile, level, namespace_, name_='Network', pretty_print=pretty_print)
        if self.PublicIp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPublicIp>%s</%sPublicIp>%s' % (namespace_, self.gds_format_string(quote_xml(self.PublicIp).encode(ExternalEncoding), input_name='PublicIp'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GatewayIpsecVpnEndpointType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayIpsecVpnEndpointType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayIpsecVpnEndpointType, self).exportLiteralChildren(outfile, level, name_)
        if self.Network is not None:
            showIndent(outfile, level)
            outfile.write('Network=model_.ReferenceType(\n')
            self.Network.exportLiteral(outfile, level, name_='Network')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PublicIp is not None:
            showIndent(outfile, level)
            outfile.write('PublicIp=%s,\n' % quote_python(self.PublicIp).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayIpsecVpnEndpointType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Network':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Network = obj_
            obj_.original_tagname_ = 'Network'
        elif nodeName_ == 'PublicIp':
            PublicIp_ = child_.text
            PublicIp_ = self.gds_validate_string(PublicIp_, node, 'PublicIp')
            self.PublicIp = PublicIp_
            self.validate_IpAddressType(self.PublicIp)    # validate type IpAddressType
        super(GatewayIpsecVpnEndpointType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayIpsecVpnEndpointType


class GatewayIpsecVpnTunnelType(VCloudExtensibleType):
    """5.1 Represents an IPSec VPN tunnel."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Description=None, IpsecVpnPeer=None, PeerIpAddress=None, PeerId=None, LocalIpAddress=None, LocalId=None, LocalSubnet=None, PeerSubnet=None, SharedSecret=None, SharedSecretEncrypted=None, EncryptionProtocol=None, Mtu=None, IsEnabled=None, IsOperational=None, ErrorDetails=None):
        self.original_tagname_ = None
        super(GatewayIpsecVpnTunnelType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Description = Description
        self.IpsecVpnPeer = IpsecVpnPeer
        self.PeerIpAddress = PeerIpAddress
        self.PeerId = PeerId
        self.LocalIpAddress = LocalIpAddress
        self.LocalId = LocalId
        if LocalSubnet is None:
            self.LocalSubnet = []
        else:
            self.LocalSubnet = LocalSubnet
        if PeerSubnet is None:
            self.PeerSubnet = []
        else:
            self.PeerSubnet = PeerSubnet
        self.SharedSecret = SharedSecret
        self.SharedSecretEncrypted = SharedSecretEncrypted
        self.EncryptionProtocol = EncryptionProtocol
        self.Mtu = Mtu
        self.IsEnabled = IsEnabled
        self.IsOperational = IsOperational
        self.ErrorDetails = ErrorDetails
    def factory(*args_, **kwargs_):
        if GatewayIpsecVpnTunnelType.subclass:
            return GatewayIpsecVpnTunnelType.subclass(*args_, **kwargs_)
        else:
            return GatewayIpsecVpnTunnelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_IpsecVpnPeer(self): return self.IpsecVpnPeer
    def set_IpsecVpnPeer(self, IpsecVpnPeer): self.IpsecVpnPeer = IpsecVpnPeer
    def get_PeerIpAddress(self): return self.PeerIpAddress
    def set_PeerIpAddress(self, PeerIpAddress): self.PeerIpAddress = PeerIpAddress
    def get_PeerId(self): return self.PeerId
    def set_PeerId(self, PeerId): self.PeerId = PeerId
    def get_LocalIpAddress(self): return self.LocalIpAddress
    def set_LocalIpAddress(self, LocalIpAddress): self.LocalIpAddress = LocalIpAddress
    def get_LocalId(self): return self.LocalId
    def set_LocalId(self, LocalId): self.LocalId = LocalId
    def get_LocalSubnet(self): return self.LocalSubnet
    def set_LocalSubnet(self, LocalSubnet): self.LocalSubnet = LocalSubnet
    def add_LocalSubnet(self, value): self.LocalSubnet.append(value)
    def insert_LocalSubnet_at(self, index, value): self.LocalSubnet.insert(index, value)
    def replace_LocalSubnet_at(self, index, value): self.LocalSubnet[index] = value
    def get_PeerSubnet(self): return self.PeerSubnet
    def set_PeerSubnet(self, PeerSubnet): self.PeerSubnet = PeerSubnet
    def add_PeerSubnet(self, value): self.PeerSubnet.append(value)
    def insert_PeerSubnet_at(self, index, value): self.PeerSubnet.insert(index, value)
    def replace_PeerSubnet_at(self, index, value): self.PeerSubnet[index] = value
    def get_SharedSecret(self): return self.SharedSecret
    def set_SharedSecret(self, SharedSecret): self.SharedSecret = SharedSecret
    def get_SharedSecretEncrypted(self): return self.SharedSecretEncrypted
    def set_SharedSecretEncrypted(self, SharedSecretEncrypted): self.SharedSecretEncrypted = SharedSecretEncrypted
    def get_EncryptionProtocol(self): return self.EncryptionProtocol
    def set_EncryptionProtocol(self, EncryptionProtocol): self.EncryptionProtocol = EncryptionProtocol
    def get_Mtu(self): return self.Mtu
    def set_Mtu(self, Mtu): self.Mtu = Mtu
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_IsOperational(self): return self.IsOperational
    def set_IsOperational(self, IsOperational): self.IsOperational = IsOperational
    def get_ErrorDetails(self): return self.ErrorDetails
    def set_ErrorDetails(self, ErrorDetails): self.ErrorDetails = ErrorDetails
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Description is not None or
            self.IpsecVpnPeer is not None or
            self.PeerIpAddress is not None or
            self.PeerId is not None or
            self.LocalIpAddress is not None or
            self.LocalId is not None or
            self.LocalSubnet or
            self.PeerSubnet or
            self.SharedSecret is not None or
            self.SharedSecretEncrypted is not None or
            self.EncryptionProtocol is not None or
            self.Mtu is not None or
            self.IsEnabled is not None or
            self.IsOperational is not None or
            self.ErrorDetails is not None or
            super(GatewayIpsecVpnTunnelType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayIpsecVpnTunnelType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayIpsecVpnTunnelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayIpsecVpnTunnelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayIpsecVpnTunnelType'):
        super(GatewayIpsecVpnTunnelType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayIpsecVpnTunnelType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayIpsecVpnTunnelType', fromsubclass_=False, pretty_print=True):
        super(GatewayIpsecVpnTunnelType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.IpsecVpnPeer is not None:
            self.IpsecVpnPeer.export(outfile, level, namespace_, name_='IpsecVpnPeer', pretty_print=pretty_print)
        if self.PeerIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeerIpAddress>%s</%sPeerIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.PeerIpAddress).encode(ExternalEncoding), input_name='PeerIpAddress'), namespace_, eol_))
        if self.PeerId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeerId>%s</%sPeerId>%s' % (namespace_, self.gds_format_string(quote_xml(self.PeerId).encode(ExternalEncoding), input_name='PeerId'), namespace_, eol_))
        if self.LocalIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocalIpAddress>%s</%sLocalIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.LocalIpAddress).encode(ExternalEncoding), input_name='LocalIpAddress'), namespace_, eol_))
        if self.LocalId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLocalId>%s</%sLocalId>%s' % (namespace_, self.gds_format_string(quote_xml(self.LocalId).encode(ExternalEncoding), input_name='LocalId'), namespace_, eol_))
        for LocalSubnet_ in self.LocalSubnet:
            LocalSubnet_.export(outfile, level, namespace_, name_='LocalSubnet', pretty_print=pretty_print)
        for PeerSubnet_ in self.PeerSubnet:
            PeerSubnet_.export(outfile, level, namespace_, name_='PeerSubnet', pretty_print=pretty_print)
        if self.SharedSecret is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSharedSecret>%s</%sSharedSecret>%s' % (namespace_, self.gds_format_string(quote_xml(self.SharedSecret).encode(ExternalEncoding), input_name='SharedSecret'), namespace_, eol_))
        if self.SharedSecretEncrypted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSharedSecretEncrypted>%s</%sSharedSecretEncrypted>%s' % (namespace_, self.gds_format_boolean(self.SharedSecretEncrypted, input_name='SharedSecretEncrypted'), namespace_, eol_))
        if self.EncryptionProtocol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEncryptionProtocol>%s</%sEncryptionProtocol>%s' % (namespace_, self.gds_format_string(quote_xml(self.EncryptionProtocol).encode(ExternalEncoding), input_name='EncryptionProtocol'), namespace_, eol_))
        if self.Mtu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMtu>%s</%sMtu>%s' % (namespace_, self.gds_format_integer(self.Mtu, input_name='Mtu'), namespace_, eol_))
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.IsOperational is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsOperational>%s</%sIsOperational>%s' % (namespace_, self.gds_format_boolean(self.IsOperational, input_name='IsOperational'), namespace_, eol_))
        if self.ErrorDetails is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sErrorDetails>%s</%sErrorDetails>%s' % (namespace_, self.gds_format_string(quote_xml(self.ErrorDetails).encode(ExternalEncoding), input_name='ErrorDetails'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GatewayIpsecVpnTunnelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayIpsecVpnTunnelType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayIpsecVpnTunnelType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.IpsecVpnPeer is not None:
            showIndent(outfile, level)
            outfile.write('IpsecVpnPeer=model_.IpsecVpnPeer(\n')
            self.IpsecVpnPeer.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PeerIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('PeerIpAddress=%s,\n' % quote_python(self.PeerIpAddress).encode(ExternalEncoding))
        if self.PeerId is not None:
            showIndent(outfile, level)
            outfile.write('PeerId=%s,\n' % quote_python(self.PeerId).encode(ExternalEncoding))
        if self.LocalIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('LocalIpAddress=%s,\n' % quote_python(self.LocalIpAddress).encode(ExternalEncoding))
        if self.LocalId is not None:
            showIndent(outfile, level)
            outfile.write('LocalId=%s,\n' % quote_python(self.LocalId).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('LocalSubnet=[\n')
        level += 1
        for LocalSubnet_ in self.LocalSubnet:
            showIndent(outfile, level)
            outfile.write('model_.IpsecVpnSubnetType(\n')
            LocalSubnet_.exportLiteral(outfile, level, name_='IpsecVpnSubnetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('PeerSubnet=[\n')
        level += 1
        for PeerSubnet_ in self.PeerSubnet:
            showIndent(outfile, level)
            outfile.write('model_.IpsecVpnSubnetType(\n')
            PeerSubnet_.exportLiteral(outfile, level, name_='IpsecVpnSubnetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SharedSecret is not None:
            showIndent(outfile, level)
            outfile.write('SharedSecret=%s,\n' % quote_python(self.SharedSecret).encode(ExternalEncoding))
        if self.SharedSecretEncrypted is not None:
            showIndent(outfile, level)
            outfile.write('SharedSecretEncrypted=%s,\n' % self.SharedSecretEncrypted)
        if self.EncryptionProtocol is not None:
            showIndent(outfile, level)
            outfile.write('EncryptionProtocol=%s,\n' % quote_python(self.EncryptionProtocol).encode(ExternalEncoding))
        if self.Mtu is not None:
            showIndent(outfile, level)
            outfile.write('Mtu=%d,\n' % self.Mtu)
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.IsOperational is not None:
            showIndent(outfile, level)
            outfile.write('IsOperational=%s,\n' % self.IsOperational)
        if self.ErrorDetails is not None:
            showIndent(outfile, level)
            outfile.write('ErrorDetails=%s,\n' % quote_python(self.ErrorDetails).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayIpsecVpnTunnelType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'IpsecVpnPeer':
            class_obj_ = self.get_class_obj_(child_, IpsecVpnPeerType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnPeer'
        elif nodeName_ == 'IpsecVpnLocalPeer':
            obj_ = IpsecVpnLocalPeerType.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnLocalPeer'
        elif nodeName_ == 'IpsecVpnRemotePeer':
            obj_ = IpsecVpnRemotePeerType.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnRemotePeer'
        elif nodeName_ == 'IpsecVpnThirdPartyPeer':
            obj_ = IpsecVpnThirdPartyPeerType.factory()
            obj_.build(child_)
            self.IpsecVpnPeer = obj_
            obj_.original_tagname_ = 'IpsecVpnThirdPartyPeer'
        elif nodeName_ == 'PeerIpAddress':
            PeerIpAddress_ = child_.text
            PeerIpAddress_ = self.gds_validate_string(PeerIpAddress_, node, 'PeerIpAddress')
            self.PeerIpAddress = PeerIpAddress_
            self.validate_IpAddressType(self.PeerIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'PeerId':
            PeerId_ = child_.text
            PeerId_ = self.gds_validate_string(PeerId_, node, 'PeerId')
            self.PeerId = PeerId_
        elif nodeName_ == 'LocalIpAddress':
            LocalIpAddress_ = child_.text
            LocalIpAddress_ = self.gds_validate_string(LocalIpAddress_, node, 'LocalIpAddress')
            self.LocalIpAddress = LocalIpAddress_
            self.validate_IpAddressType(self.LocalIpAddress)    # validate type IpAddressType
        elif nodeName_ == 'LocalId':
            LocalId_ = child_.text
            LocalId_ = self.gds_validate_string(LocalId_, node, 'LocalId')
            self.LocalId = LocalId_
        elif nodeName_ == 'LocalSubnet':
            obj_ = IpsecVpnSubnetType.factory()
            obj_.build(child_)
            self.LocalSubnet.append(obj_)
            obj_.original_tagname_ = 'LocalSubnet'
        elif nodeName_ == 'PeerSubnet':
            obj_ = IpsecVpnSubnetType.factory()
            obj_.build(child_)
            self.PeerSubnet.append(obj_)
            obj_.original_tagname_ = 'PeerSubnet'
        elif nodeName_ == 'SharedSecret':
            SharedSecret_ = child_.text
            SharedSecret_ = self.gds_validate_string(SharedSecret_, node, 'SharedSecret')
            self.SharedSecret = SharedSecret_
        elif nodeName_ == 'SharedSecretEncrypted':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SharedSecretEncrypted')
            self.SharedSecretEncrypted = ival_
        elif nodeName_ == 'EncryptionProtocol':
            EncryptionProtocol_ = child_.text
            EncryptionProtocol_ = self.gds_validate_string(EncryptionProtocol_, node, 'EncryptionProtocol')
            self.EncryptionProtocol = EncryptionProtocol_
        elif nodeName_ == 'Mtu':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Mtu')
            self.Mtu = ival_
        elif nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'IsOperational':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsOperational')
            self.IsOperational = ival_
        elif nodeName_ == 'ErrorDetails':
            ErrorDetails_ = child_.text
            ErrorDetails_ = self.gds_validate_string(ErrorDetails_, node, 'ErrorDetails')
            self.ErrorDetails = ErrorDetails_
        super(GatewayIpsecVpnTunnelType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayIpsecVpnTunnelType


class IpsecVpnSubnetType(VCloudExtensibleType):
    """5.1 Represents subnet details."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Gateway=None, Netmask=None):
        self.original_tagname_ = None
        super(IpsecVpnSubnetType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Gateway = Gateway
        self.Netmask = Netmask
    def factory(*args_, **kwargs_):
        if IpsecVpnSubnetType.subclass:
            return IpsecVpnSubnetType.subclass(*args_, **kwargs_)
        else:
            return IpsecVpnSubnetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Gateway(self): return self.Gateway
    def set_Gateway(self, Gateway): self.Gateway = Gateway
    def get_Netmask(self): return self.Netmask
    def set_Netmask(self, Netmask): self.Netmask = Netmask
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Gateway is not None or
            self.Netmask is not None or
            super(IpsecVpnSubnetType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpsecVpnSubnetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnSubnetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpsecVpnSubnetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpsecVpnSubnetType'):
        super(IpsecVpnSubnetType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpsecVpnSubnetType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpsecVpnSubnetType', fromsubclass_=False, pretty_print=True):
        super(IpsecVpnSubnetType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Gateway is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGateway>%s</%sGateway>%s' % (namespace_, self.gds_format_string(quote_xml(self.Gateway).encode(ExternalEncoding), input_name='Gateway'), namespace_, eol_))
        if self.Netmask is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetmask>%s</%sNetmask>%s' % (namespace_, self.gds_format_string(quote_xml(self.Netmask).encode(ExternalEncoding), input_name='Netmask'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IpsecVpnSubnetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpsecVpnSubnetType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpsecVpnSubnetType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Gateway is not None:
            showIndent(outfile, level)
            outfile.write('Gateway=%s,\n' % quote_python(self.Gateway).encode(ExternalEncoding))
        if self.Netmask is not None:
            showIndent(outfile, level)
            outfile.write('Netmask=%s,\n' % quote_python(self.Netmask).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpsecVpnSubnetType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Gateway':
            Gateway_ = child_.text
            Gateway_ = self.gds_validate_string(Gateway_, node, 'Gateway')
            self.Gateway = Gateway_
            self.validate_IpAddressType(self.Gateway)    # validate type IpAddressType
        elif nodeName_ == 'Netmask':
            Netmask_ = child_.text
            Netmask_ = self.gds_validate_string(Netmask_, node, 'Netmask')
            self.Netmask = Netmask_
            self.validate_IpAddressType(self.Netmask)    # validate type IpAddressType
        super(IpsecVpnSubnetType, self).buildChildren(child_, node, nodeName_, True)
# end class IpsecVpnSubnetType


class NetworkConfigurationType(VCloudExtensibleType):
    """0.9 The configurations applied to a network. This is an abstract
    base type. The concrete types include those for vApp and
    Organization wide networks."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, BackwardCompatibilityMode=None, IpScope=None, IpScopes=None, ParentNetwork=None, FenceMode=None, RetainNetInfoAcrossDeployments=None, Features=None, SyslogServerSettings=None, RouterInfo=None):
        self.original_tagname_ = None
        super(NetworkConfigurationType, self).__init__(VCloudExtension, )
        self.BackwardCompatibilityMode = BackwardCompatibilityMode
        self.IpScope = IpScope
        self.IpScopes = IpScopes
        self.ParentNetwork = ParentNetwork
        self.FenceMode = FenceMode
        self.RetainNetInfoAcrossDeployments = RetainNetInfoAcrossDeployments
        self.Features = Features
        self.SyslogServerSettings = SyslogServerSettings
        self.RouterInfo = RouterInfo
    def factory(*args_, **kwargs_):
        if NetworkConfigurationType.subclass:
            return NetworkConfigurationType.subclass(*args_, **kwargs_)
        else:
            return NetworkConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BackwardCompatibilityMode(self): return self.BackwardCompatibilityMode
    def set_BackwardCompatibilityMode(self, BackwardCompatibilityMode): self.BackwardCompatibilityMode = BackwardCompatibilityMode
    def get_IpScope(self): return self.IpScope
    def set_IpScope(self, IpScope): self.IpScope = IpScope
    def get_IpScopes(self): return self.IpScopes
    def set_IpScopes(self, IpScopes): self.IpScopes = IpScopes
    def get_ParentNetwork(self): return self.ParentNetwork
    def set_ParentNetwork(self, ParentNetwork): self.ParentNetwork = ParentNetwork
    def get_FenceMode(self): return self.FenceMode
    def set_FenceMode(self, FenceMode): self.FenceMode = FenceMode
    def get_RetainNetInfoAcrossDeployments(self): return self.RetainNetInfoAcrossDeployments
    def set_RetainNetInfoAcrossDeployments(self, RetainNetInfoAcrossDeployments): self.RetainNetInfoAcrossDeployments = RetainNetInfoAcrossDeployments
    def get_Features(self): return self.Features
    def set_Features(self, Features): self.Features = Features
    def get_SyslogServerSettings(self): return self.SyslogServerSettings
    def set_SyslogServerSettings(self, SyslogServerSettings): self.SyslogServerSettings = SyslogServerSettings
    def get_RouterInfo(self): return self.RouterInfo
    def set_RouterInfo(self, RouterInfo): self.RouterInfo = RouterInfo
    def hasContent_(self):
        if (
            self.BackwardCompatibilityMode is not None or
            self.IpScope is not None or
            self.IpScopes is not None or
            self.ParentNetwork is not None or
            self.FenceMode is not None or
            self.RetainNetInfoAcrossDeployments is not None or
            self.Features is not None or
            self.SyslogServerSettings is not None or
            self.RouterInfo is not None or
            super(NetworkConfigurationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkConfigurationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConfigurationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkConfigurationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkConfigurationType'):
        super(NetworkConfigurationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConfigurationType')
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkConfigurationType', fromsubclass_=False, pretty_print=True):
        super(NetworkConfigurationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BackwardCompatibilityMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBackwardCompatibilityMode>%s</%sBackwardCompatibilityMode>%s' % (namespace_, self.gds_format_boolean(self.BackwardCompatibilityMode, input_name='BackwardCompatibilityMode'), namespace_, eol_))
        if self.IpScope is not None:
            self.IpScope.export(outfile, level, namespace_, name_='IpScope', pretty_print=pretty_print)
        if self.IpScopes is not None:
            self.IpScopes.export(outfile, level, namespace_, name_='IpScopes', pretty_print=pretty_print)
        if self.ParentNetwork is not None:
            self.ParentNetwork.export(outfile, level, namespace_, name_='ParentNetwork', pretty_print=pretty_print)
        if self.FenceMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFenceMode>%s</%sFenceMode>%s' % (namespace_, self.gds_format_string(quote_xml(self.FenceMode).encode(ExternalEncoding), input_name='FenceMode'), namespace_, eol_))
        if self.RetainNetInfoAcrossDeployments is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRetainNetInfoAcrossDeployments>%s</%sRetainNetInfoAcrossDeployments>%s' % (namespace_, self.gds_format_boolean(self.RetainNetInfoAcrossDeployments, input_name='RetainNetInfoAcrossDeployments'), namespace_, eol_))
        if self.Features is not None:
            self.Features.export(outfile, level, namespace_, name_='Features', pretty_print=pretty_print)
        if self.SyslogServerSettings is not None:
            self.SyslogServerSettings.export(outfile, level, namespace_, name_='SyslogServerSettings', pretty_print=pretty_print)
        if self.RouterInfo is not None:
            self.RouterInfo.export(outfile, level, namespace_, name_='RouterInfo', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkConfigurationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NetworkConfigurationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkConfigurationType, self).exportLiteralChildren(outfile, level, name_)
        if self.BackwardCompatibilityMode is not None:
            showIndent(outfile, level)
            outfile.write('BackwardCompatibilityMode=%s,\n' % self.BackwardCompatibilityMode)
        if self.IpScope is not None:
            showIndent(outfile, level)
            outfile.write('IpScope=model_.IpScopeType(\n')
            self.IpScope.exportLiteral(outfile, level, name_='IpScope')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IpScopes is not None:
            showIndent(outfile, level)
            outfile.write('IpScopes=model_.IpScopesType(\n')
            self.IpScopes.exportLiteral(outfile, level, name_='IpScopes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ParentNetwork is not None:
            showIndent(outfile, level)
            outfile.write('ParentNetwork=model_.ReferenceType(\n')
            self.ParentNetwork.exportLiteral(outfile, level, name_='ParentNetwork')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FenceMode is not None:
            showIndent(outfile, level)
            outfile.write('FenceMode=%s,\n' % quote_python(self.FenceMode).encode(ExternalEncoding))
        if self.RetainNetInfoAcrossDeployments is not None:
            showIndent(outfile, level)
            outfile.write('RetainNetInfoAcrossDeployments=%s,\n' % self.RetainNetInfoAcrossDeployments)
        if self.Features is not None:
            showIndent(outfile, level)
            outfile.write('Features=model_.NetworkFeaturesType(\n')
            self.Features.exportLiteral(outfile, level, name_='Features')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SyslogServerSettings is not None:
            showIndent(outfile, level)
            outfile.write('SyslogServerSettings=model_.SyslogServerSettingsType(\n')
            self.SyslogServerSettings.exportLiteral(outfile, level, name_='SyslogServerSettings')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RouterInfo is not None:
            showIndent(outfile, level)
            outfile.write('RouterInfo=model_.RouterInfoType(\n')
            self.RouterInfo.exportLiteral(outfile, level, name_='RouterInfo')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NetworkConfigurationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BackwardCompatibilityMode':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'BackwardCompatibilityMode')
            self.BackwardCompatibilityMode = ival_
        elif nodeName_ == 'IpScope':
            obj_ = IpScopeType.factory()
            obj_.build(child_)
            self.IpScope = obj_
            obj_.original_tagname_ = 'IpScope'
        elif nodeName_ == 'IpScopes':
            obj_ = IpScopesType.factory()
            obj_.build(child_)
            self.IpScopes = obj_
            obj_.original_tagname_ = 'IpScopes'
        elif nodeName_ == 'ParentNetwork':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ParentNetwork = obj_
            obj_.original_tagname_ = 'ParentNetwork'
        elif nodeName_ == 'FenceMode':
            FenceMode_ = child_.text
            FenceMode_ = self.gds_validate_string(FenceMode_, node, 'FenceMode')
            self.FenceMode = FenceMode_
        elif nodeName_ == 'RetainNetInfoAcrossDeployments':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'RetainNetInfoAcrossDeployments')
            self.RetainNetInfoAcrossDeployments = ival_
        elif nodeName_ == 'Features':
            obj_ = NetworkFeaturesType.factory()
            obj_.build(child_)
            self.Features = obj_
            obj_.original_tagname_ = 'Features'
        elif nodeName_ == 'SyslogServerSettings':
            obj_ = SyslogServerSettingsType.factory()
            obj_.build(child_)
            self.SyslogServerSettings = obj_
            obj_.original_tagname_ = 'SyslogServerSettings'
        elif nodeName_ == 'RouterInfo':
            obj_ = RouterInfoType.factory()
            obj_.build(child_)
            self.RouterInfo = obj_
            obj_.original_tagname_ = 'RouterInfo'
        super(NetworkConfigurationType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkConfigurationType


class IpAddressesType(VCloudExtensibleType):
    """0.9 A list of IP addresses."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IpAddress=None):
        self.original_tagname_ = None
        super(IpAddressesType, self).__init__(VCloudExtension, )
        if IpAddress is None:
            self.IpAddress = []
        else:
            self.IpAddress = IpAddress
    def factory(*args_, **kwargs_):
        if IpAddressesType.subclass:
            return IpAddressesType.subclass(*args_, **kwargs_)
        else:
            return IpAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IpAddress(self): return self.IpAddress
    def set_IpAddress(self, IpAddress): self.IpAddress = IpAddress
    def add_IpAddress(self, value): self.IpAddress.append(value)
    def insert_IpAddress_at(self, index, value): self.IpAddress.insert(index, value)
    def replace_IpAddress_at(self, index, value): self.IpAddress[index] = value
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.IpAddress or
            super(IpAddressesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpAddressesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpAddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpAddressesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpAddressesType'):
        super(IpAddressesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpAddressesType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpAddressesType', fromsubclass_=False, pretty_print=True):
        super(IpAddressesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IpAddress_ in self.IpAddress:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpAddress>%s</%sIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(IpAddress_).encode(ExternalEncoding), input_name='IpAddress'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IpAddressesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpAddressesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpAddressesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('IpAddress=[\n')
        level += 1
        for IpAddress_ in self.IpAddress:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IpAddress_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpAddressesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IpAddress':
            IpAddress_ = child_.text
            IpAddress_ = self.gds_validate_string(IpAddress_, node, 'IpAddress')
            self.IpAddress.append(IpAddress_)
            self.validate_IpAddressType(self.IpAddress)    # validate type IpAddressType
        super(IpAddressesType, self).buildChildren(child_, node, nodeName_, True)
# end class IpAddressesType


class AllocatedIpAddressType(ResourceType):
    """5.1 Represents an information for allocated IP address 5.1 True if
    vApp is deployed. falsealways One of: vmAllocated (IP is
    allocated by VM), natRouted (IP is NAT routed) vsmAllocated (IP
    is allocated for vShieldManager) false"""
    subclass = None
    superclass = ResourceType
    def __init__(self, allocationType=None, isDeployed=None, IpAddress=None):
        self.original_tagname_ = None
        super(AllocatedIpAddressType, self).__init__()
        self.allocationType = _cast(None, allocationType)
        self.isDeployed = _cast(bool, isDeployed)
        self.IpAddress = IpAddress
    def factory(*args_, **kwargs_):
        if AllocatedIpAddressType.subclass:
            return AllocatedIpAddressType.subclass(*args_, **kwargs_)
        else:
            return AllocatedIpAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IpAddress(self): return self.IpAddress
    def set_IpAddress(self, IpAddress): self.IpAddress = IpAddress
    def get_allocationType(self): return self.allocationType
    def set_allocationType(self, allocationType): self.allocationType = allocationType
    def get_isDeployed(self): return self.isDeployed
    def set_isDeployed(self, isDeployed): self.isDeployed = isDeployed
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.IpAddress is not None or
            super(AllocatedIpAddressType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AllocatedIpAddressType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllocatedIpAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AllocatedIpAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AllocatedIpAddressType'):
        super(AllocatedIpAddressType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AllocatedIpAddressType')
        if self.allocationType is not None and 'allocationType' not in already_processed:
            already_processed.add('allocationType')
            outfile.write(' allocationType=%s' % (self.gds_format_string(quote_attrib(self.allocationType).encode(ExternalEncoding), input_name='allocationType'), ))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            outfile.write(' isDeployed="%s"' % self.gds_format_boolean(self.isDeployed, input_name='isDeployed'))
    def exportChildren(self, outfile, level, namespace_='', name_='AllocatedIpAddressType', fromsubclass_=False, pretty_print=True):
        super(AllocatedIpAddressType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpAddress>%s</%sIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IpAddress).encode(ExternalEncoding), input_name='IpAddress'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AllocatedIpAddressType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.allocationType is not None and 'allocationType' not in already_processed:
            already_processed.add('allocationType')
            showIndent(outfile, level)
            outfile.write('allocationType="%s",\n' % (self.allocationType,))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            showIndent(outfile, level)
            outfile.write('isDeployed=%s,\n' % (self.isDeployed,))
        super(AllocatedIpAddressType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AllocatedIpAddressType, self).exportLiteralChildren(outfile, level, name_)
        if self.IpAddress is not None:
            showIndent(outfile, level)
            outfile.write('IpAddress=%s,\n' % quote_python(self.IpAddress).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('allocationType', node)
        if value is not None and 'allocationType' not in already_processed:
            already_processed.add('allocationType')
            self.allocationType = value
        value = find_attr_value_('isDeployed', node)
        if value is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            if value in ('true', '1'):
                self.isDeployed = True
            elif value in ('false', '0'):
                self.isDeployed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(AllocatedIpAddressType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IpAddress':
            IpAddress_ = child_.text
            IpAddress_ = self.gds_validate_string(IpAddress_, node, 'IpAddress')
            self.IpAddress = IpAddress_
            self.validate_IpAddressType(self.IpAddress)    # validate type IpAddressType
        super(AllocatedIpAddressType, self).buildChildren(child_, node, nodeName_, True)
# end class AllocatedIpAddressType


class AllocatedIpAddressesType(ResourceType):
    """5.1A list of information for allocated IP addresses."""
    subclass = None
    superclass = ResourceType
    def __init__(self, IpAddress=None):
        self.original_tagname_ = None
        super(AllocatedIpAddressesType, self).__init__()
        if IpAddress is None:
            self.IpAddress = []
        else:
            self.IpAddress = IpAddress
    def factory(*args_, **kwargs_):
        if AllocatedIpAddressesType.subclass:
            return AllocatedIpAddressesType.subclass(*args_, **kwargs_)
        else:
            return AllocatedIpAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IpAddress(self): return self.IpAddress
    def set_IpAddress(self, IpAddress): self.IpAddress = IpAddress
    def add_IpAddress(self, value): self.IpAddress.append(value)
    def insert_IpAddress_at(self, index, value): self.IpAddress.insert(index, value)
    def replace_IpAddress_at(self, index, value): self.IpAddress[index] = value
    def hasContent_(self):
        if (
            self.IpAddress or
            super(AllocatedIpAddressesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AllocatedIpAddressesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AllocatedIpAddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AllocatedIpAddressesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AllocatedIpAddressesType'):
        super(AllocatedIpAddressesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AllocatedIpAddressesType')
    def exportChildren(self, outfile, level, namespace_='', name_='AllocatedIpAddressesType', fromsubclass_=False, pretty_print=True):
        super(AllocatedIpAddressesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IpAddress_ in self.IpAddress:
            IpAddress_.export(outfile, level, namespace_, name_='IpAddress', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AllocatedIpAddressesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AllocatedIpAddressesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AllocatedIpAddressesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('IpAddress=[\n')
        level += 1
        for IpAddress_ in self.IpAddress:
            showIndent(outfile, level)
            outfile.write('model_.AllocatedIpAddressType(\n')
            IpAddress_.exportLiteral(outfile, level, name_='AllocatedIpAddressType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AllocatedIpAddressesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IpAddress':
            obj_ = AllocatedIpAddressType.factory()
            obj_.build(child_)
            self.IpAddress.append(obj_)
            obj_.original_tagname_ = 'IpAddress'
        super(AllocatedIpAddressesType, self).buildChildren(child_, node, nodeName_, True)
# end class AllocatedIpAddressesType


class SubAllocationsType(ResourceType):
    """5.1A list of IP addresses that are sub allocated to edge gateways."""
    subclass = None
    superclass = ResourceType
    def __init__(self, SubAllocation=None):
        self.original_tagname_ = None
        super(SubAllocationsType, self).__init__()
        if SubAllocation is None:
            self.SubAllocation = []
        else:
            self.SubAllocation = SubAllocation
    def factory(*args_, **kwargs_):
        if SubAllocationsType.subclass:
            return SubAllocationsType.subclass(*args_, **kwargs_)
        else:
            return SubAllocationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubAllocation(self): return self.SubAllocation
    def set_SubAllocation(self, SubAllocation): self.SubAllocation = SubAllocation
    def add_SubAllocation(self, value): self.SubAllocation.append(value)
    def insert_SubAllocation_at(self, index, value): self.SubAllocation.insert(index, value)
    def replace_SubAllocation_at(self, index, value): self.SubAllocation[index] = value
    def hasContent_(self):
        if (
            self.SubAllocation or
            super(SubAllocationsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubAllocationsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubAllocationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubAllocationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubAllocationsType'):
        super(SubAllocationsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubAllocationsType')
    def exportChildren(self, outfile, level, namespace_='', name_='SubAllocationsType', fromsubclass_=False, pretty_print=True):
        super(SubAllocationsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SubAllocation_ in self.SubAllocation:
            SubAllocation_.export(outfile, level, namespace_, name_='SubAllocation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubAllocationsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SubAllocationsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubAllocationsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('SubAllocation=[\n')
        level += 1
        for SubAllocation_ in self.SubAllocation:
            showIndent(outfile, level)
            outfile.write('model_.SubAllocationType(\n')
            SubAllocation_.exportLiteral(outfile, level, name_='SubAllocationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SubAllocationsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubAllocation':
            obj_ = SubAllocationType.factory()
            obj_.build(child_)
            self.SubAllocation.append(obj_)
            obj_.original_tagname_ = 'SubAllocation'
        super(SubAllocationsType, self).buildChildren(child_, node, nodeName_, True)
# end class SubAllocationsType


class SubAllocationType(VCloudExtensibleType):
    """IP range sub allocated to an edge gateway."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, EdgeGateway=None, IpRanges=None):
        self.original_tagname_ = None
        super(SubAllocationType, self).__init__(VCloudExtension, )
        self.EdgeGateway = EdgeGateway
        self.IpRanges = IpRanges
    def factory(*args_, **kwargs_):
        if SubAllocationType.subclass:
            return SubAllocationType.subclass(*args_, **kwargs_)
        else:
            return SubAllocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EdgeGateway(self): return self.EdgeGateway
    def set_EdgeGateway(self, EdgeGateway): self.EdgeGateway = EdgeGateway
    def get_IpRanges(self): return self.IpRanges
    def set_IpRanges(self, IpRanges): self.IpRanges = IpRanges
    def hasContent_(self):
        if (
            self.EdgeGateway is not None or
            self.IpRanges is not None or
            super(SubAllocationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubAllocationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubAllocationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubAllocationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubAllocationType'):
        super(SubAllocationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubAllocationType')
    def exportChildren(self, outfile, level, namespace_='', name_='SubAllocationType', fromsubclass_=False, pretty_print=True):
        super(SubAllocationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EdgeGateway is not None:
            self.EdgeGateway.export(outfile, level, namespace_, name_='EdgeGateway', pretty_print=pretty_print)
        if self.IpRanges is not None:
            self.IpRanges.export(outfile, level, namespace_, name_='IpRanges', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubAllocationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SubAllocationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubAllocationType, self).exportLiteralChildren(outfile, level, name_)
        if self.EdgeGateway is not None:
            showIndent(outfile, level)
            outfile.write('EdgeGateway=model_.ReferenceType(\n')
            self.EdgeGateway.exportLiteral(outfile, level, name_='EdgeGateway')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IpRanges is not None:
            showIndent(outfile, level)
            outfile.write('IpRanges=model_.IpRangesType(\n')
            self.IpRanges.exportLiteral(outfile, level, name_='IpRanges')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SubAllocationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EdgeGateway':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.EdgeGateway = obj_
            obj_.original_tagname_ = 'EdgeGateway'
        elif nodeName_ == 'IpRanges':
            obj_ = IpRangesType.factory()
            obj_.build(child_)
            self.IpRanges = obj_
            obj_.original_tagname_ = 'IpRanges'
        super(SubAllocationType, self).buildChildren(child_, node, nodeName_, True)
# end class SubAllocationType


class IpRangeType(VCloudExtensibleType):
    """0.9 Represents a range of IP addresses, start and end inclusive."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, StartAddress=None, EndAddress=None):
        self.original_tagname_ = None
        super(IpRangeType, self).__init__(VCloudExtension, )
        self.StartAddress = StartAddress
        self.EndAddress = EndAddress
    def factory(*args_, **kwargs_):
        if IpRangeType.subclass:
            return IpRangeType.subclass(*args_, **kwargs_)
        else:
            return IpRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartAddress(self): return self.StartAddress
    def set_StartAddress(self, StartAddress): self.StartAddress = StartAddress
    def get_EndAddress(self): return self.EndAddress
    def set_EndAddress(self, EndAddress): self.EndAddress = EndAddress
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.StartAddress is not None or
            self.EndAddress is not None or
            super(IpRangeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpRangeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpRangeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpRangeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpRangeType'):
        super(IpRangeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpRangeType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpRangeType', fromsubclass_=False, pretty_print=True):
        super(IpRangeType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StartAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartAddress>%s</%sStartAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.StartAddress).encode(ExternalEncoding), input_name='StartAddress'), namespace_, eol_))
        if self.EndAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndAddress>%s</%sEndAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.EndAddress).encode(ExternalEncoding), input_name='EndAddress'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IpRangeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpRangeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpRangeType, self).exportLiteralChildren(outfile, level, name_)
        if self.StartAddress is not None:
            showIndent(outfile, level)
            outfile.write('StartAddress=%s,\n' % quote_python(self.StartAddress).encode(ExternalEncoding))
        if self.EndAddress is not None:
            showIndent(outfile, level)
            outfile.write('EndAddress=%s,\n' % quote_python(self.EndAddress).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpRangeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartAddress':
            StartAddress_ = child_.text
            StartAddress_ = self.gds_validate_string(StartAddress_, node, 'StartAddress')
            self.StartAddress = StartAddress_
            self.validate_IpAddressType(self.StartAddress)    # validate type IpAddressType
        elif nodeName_ == 'EndAddress':
            EndAddress_ = child_.text
            EndAddress_ = self.gds_validate_string(EndAddress_, node, 'EndAddress')
            self.EndAddress = EndAddress_
            self.validate_IpAddressType(self.EndAddress)    # validate type IpAddressType
        super(IpRangeType, self).buildChildren(child_, node, nodeName_, True)
# end class IpRangeType


class IpRangesType(VCloudExtensibleType):
    """0.9 Represents a list of IP ranges."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IpRange=None):
        self.original_tagname_ = None
        super(IpRangesType, self).__init__(VCloudExtension, )
        if IpRange is None:
            self.IpRange = []
        else:
            self.IpRange = IpRange
    def factory(*args_, **kwargs_):
        if IpRangesType.subclass:
            return IpRangesType.subclass(*args_, **kwargs_)
        else:
            return IpRangesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IpRange(self): return self.IpRange
    def set_IpRange(self, IpRange): self.IpRange = IpRange
    def add_IpRange(self, value): self.IpRange.append(value)
    def insert_IpRange_at(self, index, value): self.IpRange.insert(index, value)
    def replace_IpRange_at(self, index, value): self.IpRange[index] = value
    def hasContent_(self):
        if (
            self.IpRange or
            super(IpRangesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpRangesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpRangesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpRangesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpRangesType'):
        super(IpRangesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpRangesType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpRangesType', fromsubclass_=False, pretty_print=True):
        super(IpRangesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IpRange_ in self.IpRange:
            IpRange_.export(outfile, level, namespace_, name_='IpRange', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IpRangesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpRangesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpRangesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('IpRange=[\n')
        level += 1
        for IpRange_ in self.IpRange:
            showIndent(outfile, level)
            outfile.write('model_.IpRangeType(\n')
            IpRange_.exportLiteral(outfile, level, name_='IpRangeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpRangesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IpRange':
            obj_ = IpRangeType.factory()
            obj_.build(child_)
            self.IpRange.append(obj_)
            obj_.original_tagname_ = 'IpRange'
        super(IpRangesType, self).buildChildren(child_, node, nodeName_, True)
# end class IpRangesType


class IpScopeType(VCloudExtensibleType):
    """0.9 Specify network settings like gateway, network mask, DNS
    servers, IP ranges, etc."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsInherited=None, Gateway=None, Netmask=None, Dns1=None, Dns2=None, DnsSuffix=None, IsEnabled=None, IpRanges=None, AllocatedIpAddresses=None, SubAllocations=None):
        self.original_tagname_ = None
        super(IpScopeType, self).__init__(VCloudExtension, )
        self.IsInherited = IsInherited
        self.Gateway = Gateway
        self.Netmask = Netmask
        self.Dns1 = Dns1
        self.Dns2 = Dns2
        self.DnsSuffix = DnsSuffix
        self.IsEnabled = IsEnabled
        self.IpRanges = IpRanges
        self.AllocatedIpAddresses = AllocatedIpAddresses
        self.SubAllocations = SubAllocations
    def factory(*args_, **kwargs_):
        if IpScopeType.subclass:
            return IpScopeType.subclass(*args_, **kwargs_)
        else:
            return IpScopeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsInherited(self): return self.IsInherited
    def set_IsInherited(self, IsInherited): self.IsInherited = IsInherited
    def get_Gateway(self): return self.Gateway
    def set_Gateway(self, Gateway): self.Gateway = Gateway
    def get_Netmask(self): return self.Netmask
    def set_Netmask(self, Netmask): self.Netmask = Netmask
    def get_Dns1(self): return self.Dns1
    def set_Dns1(self, Dns1): self.Dns1 = Dns1
    def get_Dns2(self): return self.Dns2
    def set_Dns2(self, Dns2): self.Dns2 = Dns2
    def get_DnsSuffix(self): return self.DnsSuffix
    def set_DnsSuffix(self, DnsSuffix): self.DnsSuffix = DnsSuffix
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def get_IpRanges(self): return self.IpRanges
    def set_IpRanges(self, IpRanges): self.IpRanges = IpRanges
    def get_AllocatedIpAddresses(self): return self.AllocatedIpAddresses
    def set_AllocatedIpAddresses(self, AllocatedIpAddresses): self.AllocatedIpAddresses = AllocatedIpAddresses
    def get_SubAllocations(self): return self.SubAllocations
    def set_SubAllocations(self, SubAllocations): self.SubAllocations = SubAllocations
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.IsInherited is not None or
            self.Gateway is not None or
            self.Netmask is not None or
            self.Dns1 is not None or
            self.Dns2 is not None or
            self.DnsSuffix is not None or
            self.IsEnabled is not None or
            self.IpRanges is not None or
            self.AllocatedIpAddresses is not None or
            self.SubAllocations is not None or
            super(IpScopeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpScopeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpScopeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpScopeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpScopeType'):
        super(IpScopeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpScopeType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpScopeType', fromsubclass_=False, pretty_print=True):
        super(IpScopeType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsInherited is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsInherited>%s</%sIsInherited>%s' % (namespace_, self.gds_format_boolean(self.IsInherited, input_name='IsInherited'), namespace_, eol_))
        if self.Gateway is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGateway>%s</%sGateway>%s' % (namespace_, self.gds_format_string(quote_xml(self.Gateway).encode(ExternalEncoding), input_name='Gateway'), namespace_, eol_))
        if self.Netmask is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetmask>%s</%sNetmask>%s' % (namespace_, self.gds_format_string(quote_xml(self.Netmask).encode(ExternalEncoding), input_name='Netmask'), namespace_, eol_))
        if self.Dns1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDns1>%s</%sDns1>%s' % (namespace_, self.gds_format_string(quote_xml(self.Dns1).encode(ExternalEncoding), input_name='Dns1'), namespace_, eol_))
        if self.Dns2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDns2>%s</%sDns2>%s' % (namespace_, self.gds_format_string(quote_xml(self.Dns2).encode(ExternalEncoding), input_name='Dns2'), namespace_, eol_))
        if self.DnsSuffix is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDnsSuffix>%s</%sDnsSuffix>%s' % (namespace_, self.gds_format_string(quote_xml(self.DnsSuffix).encode(ExternalEncoding), input_name='DnsSuffix'), namespace_, eol_))
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
        if self.IpRanges is not None:
            self.IpRanges.export(outfile, level, namespace_, name_='IpRanges', pretty_print=pretty_print)
        if self.AllocatedIpAddresses is not None:
            self.AllocatedIpAddresses.export(outfile, level, namespace_, name_='AllocatedIpAddresses', pretty_print=pretty_print)
        if self.SubAllocations is not None:
            self.SubAllocations.export(outfile, level, namespace_, name_='SubAllocations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IpScopeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpScopeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpScopeType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsInherited is not None:
            showIndent(outfile, level)
            outfile.write('IsInherited=%s,\n' % self.IsInherited)
        if self.Gateway is not None:
            showIndent(outfile, level)
            outfile.write('Gateway=%s,\n' % quote_python(self.Gateway).encode(ExternalEncoding))
        if self.Netmask is not None:
            showIndent(outfile, level)
            outfile.write('Netmask=%s,\n' % quote_python(self.Netmask).encode(ExternalEncoding))
        if self.Dns1 is not None:
            showIndent(outfile, level)
            outfile.write('Dns1=%s,\n' % quote_python(self.Dns1).encode(ExternalEncoding))
        if self.Dns2 is not None:
            showIndent(outfile, level)
            outfile.write('Dns2=%s,\n' % quote_python(self.Dns2).encode(ExternalEncoding))
        if self.DnsSuffix is not None:
            showIndent(outfile, level)
            outfile.write('DnsSuffix=%s,\n' % quote_python(self.DnsSuffix).encode(ExternalEncoding))
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
        if self.IpRanges is not None:
            showIndent(outfile, level)
            outfile.write('IpRanges=model_.IpRangesType(\n')
            self.IpRanges.exportLiteral(outfile, level, name_='IpRanges')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AllocatedIpAddresses is not None:
            showIndent(outfile, level)
            outfile.write('AllocatedIpAddresses=model_.IpAddressesType(\n')
            self.AllocatedIpAddresses.exportLiteral(outfile, level, name_='AllocatedIpAddresses')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubAllocations is not None:
            showIndent(outfile, level)
            outfile.write('SubAllocations=model_.SubAllocationsType(\n')
            self.SubAllocations.exportLiteral(outfile, level, name_='SubAllocations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpScopeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsInherited':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsInherited')
            self.IsInherited = ival_
        elif nodeName_ == 'Gateway':
            Gateway_ = child_.text
            Gateway_ = self.gds_validate_string(Gateway_, node, 'Gateway')
            self.Gateway = Gateway_
            self.validate_IpAddressType(self.Gateway)    # validate type IpAddressType
        elif nodeName_ == 'Netmask':
            Netmask_ = child_.text
            Netmask_ = self.gds_validate_string(Netmask_, node, 'Netmask')
            self.Netmask = Netmask_
            self.validate_IpAddressType(self.Netmask)    # validate type IpAddressType
        elif nodeName_ == 'Dns1':
            Dns1_ = child_.text
            Dns1_ = self.gds_validate_string(Dns1_, node, 'Dns1')
            self.Dns1 = Dns1_
            self.validate_IpAddressType(self.Dns1)    # validate type IpAddressType
        elif nodeName_ == 'Dns2':
            Dns2_ = child_.text
            Dns2_ = self.gds_validate_string(Dns2_, node, 'Dns2')
            self.Dns2 = Dns2_
            self.validate_IpAddressType(self.Dns2)    # validate type IpAddressType
        elif nodeName_ == 'DnsSuffix':
            DnsSuffix_ = child_.text
            DnsSuffix_ = self.gds_validate_string(DnsSuffix_, node, 'DnsSuffix')
            self.DnsSuffix = DnsSuffix_
        elif nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        elif nodeName_ == 'IpRanges':
            obj_ = IpRangesType.factory()
            obj_.build(child_)
            self.IpRanges = obj_
            obj_.original_tagname_ = 'IpRanges'
        elif nodeName_ == 'AllocatedIpAddresses':
            obj_ = IpAddressesType.factory()
            obj_.build(child_)
            self.AllocatedIpAddresses = obj_
            obj_.original_tagname_ = 'AllocatedIpAddresses'
        elif nodeName_ == 'SubAllocations':
            obj_ = SubAllocationsType.factory()
            obj_.build(child_)
            self.SubAllocations = obj_
            obj_.original_tagname_ = 'SubAllocations'
        super(IpScopeType, self).buildChildren(child_, node, nodeName_, True)
# end class IpScopeType


class IpScopesType(VCloudExtensibleType):
    """5.1 Represents a list of IP scopes."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IpScope=None):
        self.original_tagname_ = None
        super(IpScopesType, self).__init__(VCloudExtension, )
        if IpScope is None:
            self.IpScope = []
        else:
            self.IpScope = IpScope
    def factory(*args_, **kwargs_):
        if IpScopesType.subclass:
            return IpScopesType.subclass(*args_, **kwargs_)
        else:
            return IpScopesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IpScope(self): return self.IpScope
    def set_IpScope(self, IpScope): self.IpScope = IpScope
    def add_IpScope(self, value): self.IpScope.append(value)
    def insert_IpScope_at(self, index, value): self.IpScope.insert(index, value)
    def replace_IpScope_at(self, index, value): self.IpScope[index] = value
    def hasContent_(self):
        if (
            self.IpScope or
            super(IpScopesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpScopesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpScopesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpScopesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpScopesType'):
        super(IpScopesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpScopesType')
    def exportChildren(self, outfile, level, namespace_='', name_='IpScopesType', fromsubclass_=False, pretty_print=True):
        super(IpScopesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IpScope_ in self.IpScope:
            IpScope_.export(outfile, level, namespace_, name_='IpScope', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IpScopesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IpScopesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpScopesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('IpScope=[\n')
        level += 1
        for IpScope_ in self.IpScope:
            showIndent(outfile, level)
            outfile.write('model_.IpScopeType(\n')
            IpScope_.exportLiteral(outfile, level, name_='IpScopeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IpScopesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IpScope':
            obj_ = IpScopeType.factory()
            obj_.build(child_)
            self.IpScope.append(obj_)
            obj_.original_tagname_ = 'IpScope'
        super(IpScopesType, self).buildChildren(child_, node, nodeName_, True)
# end class IpScopesType


class SyslogServerSettingsType(GeneratedsSuper):
    """1.5 Syslog server settings. If logging is configured for firewall
    rules, the logs will be directed to these syslog servers."""
    subclass = None
    superclass = None
    def __init__(self, SyslogServerIp1=None, SyslogServerIp2=None):
        self.original_tagname_ = None
        self.SyslogServerIp1 = SyslogServerIp1
        self.SyslogServerIp2 = SyslogServerIp2
    def factory(*args_, **kwargs_):
        if SyslogServerSettingsType.subclass:
            return SyslogServerSettingsType.subclass(*args_, **kwargs_)
        else:
            return SyslogServerSettingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SyslogServerIp1(self): return self.SyslogServerIp1
    def set_SyslogServerIp1(self, SyslogServerIp1): self.SyslogServerIp1 = SyslogServerIp1
    def get_SyslogServerIp2(self): return self.SyslogServerIp2
    def set_SyslogServerIp2(self, SyslogServerIp2): self.SyslogServerIp2 = SyslogServerIp2
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.SyslogServerIp1 is not None or
            self.SyslogServerIp2 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SyslogServerSettingsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SyslogServerSettingsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SyslogServerSettingsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SyslogServerSettingsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SyslogServerSettingsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SyslogServerIp1 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSyslogServerIp1>%s</%sSyslogServerIp1>%s' % (namespace_, self.gds_format_string(quote_xml(self.SyslogServerIp1).encode(ExternalEncoding), input_name='SyslogServerIp1'), namespace_, eol_))
        if self.SyslogServerIp2 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSyslogServerIp2>%s</%sSyslogServerIp2>%s' % (namespace_, self.gds_format_string(quote_xml(self.SyslogServerIp2).encode(ExternalEncoding), input_name='SyslogServerIp2'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SyslogServerSettingsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SyslogServerIp1 is not None:
            showIndent(outfile, level)
            outfile.write('SyslogServerIp1=%s,\n' % quote_python(self.SyslogServerIp1).encode(ExternalEncoding))
        if self.SyslogServerIp2 is not None:
            showIndent(outfile, level)
            outfile.write('SyslogServerIp2=%s,\n' % quote_python(self.SyslogServerIp2).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SyslogServerIp1':
            SyslogServerIp1_ = child_.text
            SyslogServerIp1_ = self.gds_validate_string(SyslogServerIp1_, node, 'SyslogServerIp1')
            self.SyslogServerIp1 = SyslogServerIp1_
            self.validate_IpAddressType(self.SyslogServerIp1)    # validate type IpAddressType
        elif nodeName_ == 'SyslogServerIp2':
            SyslogServerIp2_ = child_.text
            SyslogServerIp2_ = self.gds_validate_string(SyslogServerIp2_, node, 'SyslogServerIp2')
            self.SyslogServerIp2 = SyslogServerIp2_
            self.validate_IpAddressType(self.SyslogServerIp2)    # validate type IpAddressType
# end class SyslogServerSettingsType


class OrgVdcNetworkType(NetworkType):
    """5.1 Represents an Org vDC network in the vCloud model. none Creation
    status of the org vDC network. One of:<br> 0 (The org vDC
    network is not completely created)<br> 1 (The org vDC network is
    ready) false"""
    subclass = None
    superclass = NetworkType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, Configuration=None, status=None, EdgeGateway=None, ServiceConfig=None, IsShared=None):
        self.original_tagname_ = None
        super(OrgVdcNetworkType, self).__init__(operationKey, id, name, Description, Tasks, Configuration, )
        self.status = _cast(int, status)
        self.EdgeGateway = EdgeGateway
        self.ServiceConfig = ServiceConfig
        self.IsShared = IsShared
    def factory(*args_, **kwargs_):
        if OrgVdcNetworkType.subclass:
            return OrgVdcNetworkType.subclass(*args_, **kwargs_)
        else:
            return OrgVdcNetworkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EdgeGateway(self): return self.EdgeGateway
    def set_EdgeGateway(self, EdgeGateway): self.EdgeGateway = EdgeGateway
    def get_ServiceConfig(self): return self.ServiceConfig
    def set_ServiceConfig(self, ServiceConfig): self.ServiceConfig = ServiceConfig
    def get_IsShared(self): return self.IsShared
    def set_IsShared(self, IsShared): self.IsShared = IsShared
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def hasContent_(self):
        if (
            self.EdgeGateway is not None or
            self.ServiceConfig is not None or
            self.IsShared is not None or
            super(OrgVdcNetworkType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrgVdcNetworkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrgVdcNetworkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrgVdcNetworkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrgVdcNetworkType'):
        super(OrgVdcNetworkType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrgVdcNetworkType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status="%s"' % self.gds_format_integer(self.status, input_name='status'))
    def exportChildren(self, outfile, level, namespace_='', name_='OrgVdcNetworkType', fromsubclass_=False, pretty_print=True):
        super(OrgVdcNetworkType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EdgeGateway is not None:
            self.EdgeGateway.export(outfile, level, namespace_, name_='EdgeGateway', pretty_print=pretty_print)
        if self.ServiceConfig is not None:
            self.ServiceConfig.export(outfile, level, namespace_, name_='ServiceConfig', pretty_print=pretty_print)
        if self.IsShared is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsShared>%s</%sIsShared>%s' % (namespace_, self.gds_format_boolean(self.IsShared, input_name='IsShared'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OrgVdcNetworkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % (self.status,))
        super(OrgVdcNetworkType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrgVdcNetworkType, self).exportLiteralChildren(outfile, level, name_)
        if self.EdgeGateway is not None:
            showIndent(outfile, level)
            outfile.write('EdgeGateway=model_.ReferenceType(\n')
            self.EdgeGateway.exportLiteral(outfile, level, name_='EdgeGateway')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ServiceConfig is not None:
            showIndent(outfile, level)
            outfile.write('ServiceConfig=model_.GatewayFeaturesType(\n')
            self.ServiceConfig.exportLiteral(outfile, level, name_='ServiceConfig')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IsShared is not None:
            showIndent(outfile, level)
            outfile.write('IsShared=%s,\n' % self.IsShared)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            try:
                self.status = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(OrgVdcNetworkType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EdgeGateway':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.EdgeGateway = obj_
            obj_.original_tagname_ = 'EdgeGateway'
        elif nodeName_ == 'ServiceConfig':
            obj_ = GatewayFeaturesType.factory()
            obj_.build(child_)
            self.ServiceConfig = obj_
            obj_.original_tagname_ = 'ServiceConfig'
        elif nodeName_ == 'IsShared':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsShared')
            self.IsShared = ival_
        super(OrgVdcNetworkType, self).buildChildren(child_, node, nodeName_, True)
# end class OrgVdcNetworkType


class GatewayType(EntityType):
    """5.1 Represents a gateway. none Creation status of the gateway. One
    of:<br> 0 (The gateway is still being created)<br> 1 (The
    gateway is ready)<br> -1 (There was an error while creating the
    gateway). false"""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, Configuration=None):
        self.original_tagname_ = None
        super(GatewayType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.status = _cast(int, status)
        self.Configuration = Configuration
    def factory(*args_, **kwargs_):
        if GatewayType.subclass:
            return GatewayType.subclass(*args_, **kwargs_)
        else:
            return GatewayType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Configuration(self): return self.Configuration
    def set_Configuration(self, Configuration): self.Configuration = Configuration
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def hasContent_(self):
        if (
            self.Configuration is not None or
            super(GatewayType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayType'):
        super(GatewayType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status="%s"' % self.gds_format_integer(self.status, input_name='status'))
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayType', fromsubclass_=False, pretty_print=True):
        super(GatewayType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Configuration is not None:
            self.Configuration.export(outfile, level, namespace_, name_='Configuration', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GatewayType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % (self.status,))
        super(GatewayType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayType, self).exportLiteralChildren(outfile, level, name_)
        if self.Configuration is not None:
            showIndent(outfile, level)
            outfile.write('Configuration=model_.GatewayConfigurationType(\n')
            self.Configuration.exportLiteral(outfile, level, name_='Configuration')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            try:
                self.status = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(GatewayType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Configuration':
            obj_ = GatewayConfigurationType.factory()
            obj_.build(child_)
            self.Configuration = obj_
            obj_.original_tagname_ = 'Configuration'
        super(GatewayType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayType


class GatewayConfigurationType(VCloudExtensibleType):
    """5.1 Gateway Configuration."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, BackwardCompatibilityMode=None, GatewayBackingConfig=None, GatewayInterfaces=None, EdgeGatewayServiceConfiguration=None, HaEnabled=None, UseDefaultRouteForDnsRelay=None):
        self.original_tagname_ = None
        super(GatewayConfigurationType, self).__init__(VCloudExtension, )
        self.BackwardCompatibilityMode = BackwardCompatibilityMode
        self.GatewayBackingConfig = GatewayBackingConfig
        self.GatewayInterfaces = GatewayInterfaces
        self.EdgeGatewayServiceConfiguration = EdgeGatewayServiceConfiguration
        self.HaEnabled = HaEnabled
        self.UseDefaultRouteForDnsRelay = UseDefaultRouteForDnsRelay
    def factory(*args_, **kwargs_):
        if GatewayConfigurationType.subclass:
            return GatewayConfigurationType.subclass(*args_, **kwargs_)
        else:
            return GatewayConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BackwardCompatibilityMode(self): return self.BackwardCompatibilityMode
    def set_BackwardCompatibilityMode(self, BackwardCompatibilityMode): self.BackwardCompatibilityMode = BackwardCompatibilityMode
    def get_GatewayBackingConfig(self): return self.GatewayBackingConfig
    def set_GatewayBackingConfig(self, GatewayBackingConfig): self.GatewayBackingConfig = GatewayBackingConfig
    def get_GatewayInterfaces(self): return self.GatewayInterfaces
    def set_GatewayInterfaces(self, GatewayInterfaces): self.GatewayInterfaces = GatewayInterfaces
    def get_EdgeGatewayServiceConfiguration(self): return self.EdgeGatewayServiceConfiguration
    def set_EdgeGatewayServiceConfiguration(self, EdgeGatewayServiceConfiguration): self.EdgeGatewayServiceConfiguration = EdgeGatewayServiceConfiguration
    def get_HaEnabled(self): return self.HaEnabled
    def set_HaEnabled(self, HaEnabled): self.HaEnabled = HaEnabled
    def get_UseDefaultRouteForDnsRelay(self): return self.UseDefaultRouteForDnsRelay
    def set_UseDefaultRouteForDnsRelay(self, UseDefaultRouteForDnsRelay): self.UseDefaultRouteForDnsRelay = UseDefaultRouteForDnsRelay
    def hasContent_(self):
        if (
            self.BackwardCompatibilityMode is not None or
            self.GatewayBackingConfig is not None or
            self.GatewayInterfaces is not None or
            self.EdgeGatewayServiceConfiguration is not None or
            self.HaEnabled is not None or
            self.UseDefaultRouteForDnsRelay is not None or
            super(GatewayConfigurationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayConfigurationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayConfigurationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayConfigurationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayConfigurationType'):
        super(GatewayConfigurationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayConfigurationType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayConfigurationType', fromsubclass_=False, pretty_print=True):
        super(GatewayConfigurationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BackwardCompatibilityMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBackwardCompatibilityMode>%s</%sBackwardCompatibilityMode>%s' % (namespace_, self.gds_format_boolean(self.BackwardCompatibilityMode, input_name='BackwardCompatibilityMode'), namespace_, eol_))
        if self.GatewayBackingConfig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGatewayBackingConfig>%s</%sGatewayBackingConfig>%s' % (namespace_, self.gds_format_string(quote_xml(self.GatewayBackingConfig).encode(ExternalEncoding), input_name='GatewayBackingConfig'), namespace_, eol_))
        if self.GatewayInterfaces is not None:
            self.GatewayInterfaces.export(outfile, level, namespace_, name_='GatewayInterfaces', pretty_print=pretty_print)
        if self.EdgeGatewayServiceConfiguration is not None:
            self.EdgeGatewayServiceConfiguration.export(outfile, level, namespace_, name_='EdgeGatewayServiceConfiguration', pretty_print=pretty_print)
        if self.HaEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHaEnabled>%s</%sHaEnabled>%s' % (namespace_, self.gds_format_boolean(self.HaEnabled, input_name='HaEnabled'), namespace_, eol_))
        if self.UseDefaultRouteForDnsRelay is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUseDefaultRouteForDnsRelay>%s</%sUseDefaultRouteForDnsRelay>%s' % (namespace_, self.gds_format_boolean(self.UseDefaultRouteForDnsRelay, input_name='UseDefaultRouteForDnsRelay'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GatewayConfigurationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayConfigurationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayConfigurationType, self).exportLiteralChildren(outfile, level, name_)
        if self.BackwardCompatibilityMode is not None:
            showIndent(outfile, level)
            outfile.write('BackwardCompatibilityMode=%s,\n' % self.BackwardCompatibilityMode)
        if self.GatewayBackingConfig is not None:
            showIndent(outfile, level)
            outfile.write('GatewayBackingConfig=%s,\n' % quote_python(self.GatewayBackingConfig).encode(ExternalEncoding))
        if self.GatewayInterfaces is not None:
            showIndent(outfile, level)
            outfile.write('GatewayInterfaces=model_.GatewayInterfacesType(\n')
            self.GatewayInterfaces.exportLiteral(outfile, level, name_='GatewayInterfaces')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EdgeGatewayServiceConfiguration is not None:
            showIndent(outfile, level)
            outfile.write('EdgeGatewayServiceConfiguration=model_.GatewayFeaturesType(\n')
            self.EdgeGatewayServiceConfiguration.exportLiteral(outfile, level, name_='EdgeGatewayServiceConfiguration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HaEnabled is not None:
            showIndent(outfile, level)
            outfile.write('HaEnabled=%s,\n' % self.HaEnabled)
        if self.UseDefaultRouteForDnsRelay is not None:
            showIndent(outfile, level)
            outfile.write('UseDefaultRouteForDnsRelay=%s,\n' % self.UseDefaultRouteForDnsRelay)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayConfigurationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BackwardCompatibilityMode':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'BackwardCompatibilityMode')
            self.BackwardCompatibilityMode = ival_
        elif nodeName_ == 'GatewayBackingConfig':
            GatewayBackingConfig_ = child_.text
            GatewayBackingConfig_ = self.gds_validate_string(GatewayBackingConfig_, node, 'GatewayBackingConfig')
            self.GatewayBackingConfig = GatewayBackingConfig_
        elif nodeName_ == 'GatewayInterfaces':
            obj_ = GatewayInterfacesType.factory()
            obj_.build(child_)
            self.GatewayInterfaces = obj_
            obj_.original_tagname_ = 'GatewayInterfaces'
        elif nodeName_ == 'EdgeGatewayServiceConfiguration':
            obj_ = GatewayFeaturesType.factory()
            obj_.build(child_)
            self.EdgeGatewayServiceConfiguration = obj_
            obj_.original_tagname_ = 'EdgeGatewayServiceConfiguration'
        elif nodeName_ == 'HaEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'HaEnabled')
            self.HaEnabled = ival_
        elif nodeName_ == 'UseDefaultRouteForDnsRelay':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'UseDefaultRouteForDnsRelay')
            self.UseDefaultRouteForDnsRelay = ival_
        super(GatewayConfigurationType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayConfigurationType


class GatewayInterfacesType(VCloudExtensibleType):
    """5.1 A list of Gateway Interfaces."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, GatewayInterface=None):
        self.original_tagname_ = None
        super(GatewayInterfacesType, self).__init__(VCloudExtension, )
        if GatewayInterface is None:
            self.GatewayInterface = []
        else:
            self.GatewayInterface = GatewayInterface
    def factory(*args_, **kwargs_):
        if GatewayInterfacesType.subclass:
            return GatewayInterfacesType.subclass(*args_, **kwargs_)
        else:
            return GatewayInterfacesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GatewayInterface(self): return self.GatewayInterface
    def set_GatewayInterface(self, GatewayInterface): self.GatewayInterface = GatewayInterface
    def add_GatewayInterface(self, value): self.GatewayInterface.append(value)
    def insert_GatewayInterface_at(self, index, value): self.GatewayInterface.insert(index, value)
    def replace_GatewayInterface_at(self, index, value): self.GatewayInterface[index] = value
    def hasContent_(self):
        if (
            self.GatewayInterface or
            super(GatewayInterfacesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayInterfacesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayInterfacesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayInterfacesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayInterfacesType'):
        super(GatewayInterfacesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayInterfacesType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayInterfacesType', fromsubclass_=False, pretty_print=True):
        super(GatewayInterfacesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for GatewayInterface_ in self.GatewayInterface:
            GatewayInterface_.export(outfile, level, namespace_, name_='GatewayInterface', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GatewayInterfacesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayInterfacesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayInterfacesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('GatewayInterface=[\n')
        level += 1
        for GatewayInterface_ in self.GatewayInterface:
            showIndent(outfile, level)
            outfile.write('model_.GatewayInterfaceType(\n')
            GatewayInterface_.exportLiteral(outfile, level, name_='GatewayInterfaceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayInterfacesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GatewayInterface':
            obj_ = GatewayInterfaceType.factory()
            obj_.build(child_)
            self.GatewayInterface.append(obj_)
            obj_.original_tagname_ = 'GatewayInterface'
        super(GatewayInterfacesType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayInterfacesType


class GatewayInterfaceType(VCloudExtensibleType):
    """5.1 Gateway Interface configuration."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, DisplayName=None, Network=None, InterfaceType=None, SubnetParticipation=None, ApplyRateLimit=None, InRateLimit=None, OutRateLimit=None, UseForDefaultRoute=None):
        self.original_tagname_ = None
        super(GatewayInterfaceType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.DisplayName = DisplayName
        self.Network = Network
        self.InterfaceType = InterfaceType
        if SubnetParticipation is None:
            self.SubnetParticipation = []
        else:
            self.SubnetParticipation = SubnetParticipation
        self.ApplyRateLimit = ApplyRateLimit
        self.InRateLimit = InRateLimit
        self.OutRateLimit = OutRateLimit
        self.UseForDefaultRoute = UseForDefaultRoute
    def factory(*args_, **kwargs_):
        if GatewayInterfaceType.subclass:
            return GatewayInterfaceType.subclass(*args_, **kwargs_)
        else:
            return GatewayInterfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_DisplayName(self): return self.DisplayName
    def set_DisplayName(self, DisplayName): self.DisplayName = DisplayName
    def get_Network(self): return self.Network
    def set_Network(self, Network): self.Network = Network
    def get_InterfaceType(self): return self.InterfaceType
    def set_InterfaceType(self, InterfaceType): self.InterfaceType = InterfaceType
    def get_SubnetParticipation(self): return self.SubnetParticipation
    def set_SubnetParticipation(self, SubnetParticipation): self.SubnetParticipation = SubnetParticipation
    def add_SubnetParticipation(self, value): self.SubnetParticipation.append(value)
    def insert_SubnetParticipation_at(self, index, value): self.SubnetParticipation.insert(index, value)
    def replace_SubnetParticipation_at(self, index, value): self.SubnetParticipation[index] = value
    def get_ApplyRateLimit(self): return self.ApplyRateLimit
    def set_ApplyRateLimit(self, ApplyRateLimit): self.ApplyRateLimit = ApplyRateLimit
    def get_InRateLimit(self): return self.InRateLimit
    def set_InRateLimit(self, InRateLimit): self.InRateLimit = InRateLimit
    def get_OutRateLimit(self): return self.OutRateLimit
    def set_OutRateLimit(self, OutRateLimit): self.OutRateLimit = OutRateLimit
    def get_UseForDefaultRoute(self): return self.UseForDefaultRoute
    def set_UseForDefaultRoute(self, UseForDefaultRoute): self.UseForDefaultRoute = UseForDefaultRoute
    def hasContent_(self):
        if (
            self.Name is not None or
            self.DisplayName is not None or
            self.Network is not None or
            self.InterfaceType is not None or
            self.SubnetParticipation or
            self.ApplyRateLimit is not None or
            self.InRateLimit is not None or
            self.OutRateLimit is not None or
            self.UseForDefaultRoute is not None or
            super(GatewayInterfaceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayInterfaceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayInterfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayInterfaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayInterfaceType'):
        super(GatewayInterfaceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayInterfaceType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayInterfaceType', fromsubclass_=False, pretty_print=True):
        super(GatewayInterfaceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.DisplayName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDisplayName>%s</%sDisplayName>%s' % (namespace_, self.gds_format_string(quote_xml(self.DisplayName).encode(ExternalEncoding), input_name='DisplayName'), namespace_, eol_))
        if self.Network is not None:
            self.Network.export(outfile, level, namespace_, name_='Network', pretty_print=pretty_print)
        if self.InterfaceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInterfaceType>%s</%sInterfaceType>%s' % (namespace_, self.gds_format_string(quote_xml(self.InterfaceType).encode(ExternalEncoding), input_name='InterfaceType'), namespace_, eol_))
        for SubnetParticipation_ in self.SubnetParticipation:
            SubnetParticipation_.export(outfile, level, namespace_, name_='SubnetParticipation', pretty_print=pretty_print)
        if self.ApplyRateLimit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApplyRateLimit>%s</%sApplyRateLimit>%s' % (namespace_, self.gds_format_boolean(self.ApplyRateLimit, input_name='ApplyRateLimit'), namespace_, eol_))
        if self.InRateLimit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInRateLimit>%s</%sInRateLimit>%s' % (namespace_, self.gds_format_double(self.InRateLimit, input_name='InRateLimit'), namespace_, eol_))
        if self.OutRateLimit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOutRateLimit>%s</%sOutRateLimit>%s' % (namespace_, self.gds_format_double(self.OutRateLimit, input_name='OutRateLimit'), namespace_, eol_))
        if self.UseForDefaultRoute is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUseForDefaultRoute>%s</%sUseForDefaultRoute>%s' % (namespace_, self.gds_format_boolean(self.UseForDefaultRoute, input_name='UseForDefaultRoute'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='GatewayInterfaceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayInterfaceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayInterfaceType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.DisplayName is not None:
            showIndent(outfile, level)
            outfile.write('DisplayName=%s,\n' % quote_python(self.DisplayName).encode(ExternalEncoding))
        if self.Network is not None:
            showIndent(outfile, level)
            outfile.write('Network=model_.ReferenceType(\n')
            self.Network.exportLiteral(outfile, level, name_='Network')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InterfaceType is not None:
            showIndent(outfile, level)
            outfile.write('InterfaceType=%s,\n' % quote_python(self.InterfaceType).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('SubnetParticipation=[\n')
        level += 1
        for SubnetParticipation_ in self.SubnetParticipation:
            showIndent(outfile, level)
            outfile.write('model_.SubnetParticipationType(\n')
            SubnetParticipation_.exportLiteral(outfile, level, name_='SubnetParticipationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ApplyRateLimit is not None:
            showIndent(outfile, level)
            outfile.write('ApplyRateLimit=%s,\n' % self.ApplyRateLimit)
        if self.InRateLimit is not None:
            showIndent(outfile, level)
            outfile.write('InRateLimit=%e,\n' % self.InRateLimit)
        if self.OutRateLimit is not None:
            showIndent(outfile, level)
            outfile.write('OutRateLimit=%e,\n' % self.OutRateLimit)
        if self.UseForDefaultRoute is not None:
            showIndent(outfile, level)
            outfile.write('UseForDefaultRoute=%s,\n' % self.UseForDefaultRoute)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayInterfaceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'DisplayName':
            DisplayName_ = child_.text
            DisplayName_ = self.gds_validate_string(DisplayName_, node, 'DisplayName')
            self.DisplayName = DisplayName_
        elif nodeName_ == 'Network':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Network = obj_
            obj_.original_tagname_ = 'Network'
        elif nodeName_ == 'InterfaceType':
            InterfaceType_ = child_.text
            InterfaceType_ = self.gds_validate_string(InterfaceType_, node, 'InterfaceType')
            self.InterfaceType = InterfaceType_
        elif nodeName_ == 'SubnetParticipation':
            obj_ = SubnetParticipationType.factory()
            obj_.build(child_)
            self.SubnetParticipation.append(obj_)
            obj_.original_tagname_ = 'SubnetParticipation'
        elif nodeName_ == 'ApplyRateLimit':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ApplyRateLimit')
            self.ApplyRateLimit = ival_
        elif nodeName_ == 'InRateLimit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'InRateLimit')
            self.InRateLimit = fval_
        elif nodeName_ == 'OutRateLimit':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'OutRateLimit')
            self.OutRateLimit = fval_
        elif nodeName_ == 'UseForDefaultRoute':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'UseForDefaultRoute')
            self.UseForDefaultRoute = ival_
        super(GatewayInterfaceType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayInterfaceType


class GatewayFeaturesType(VCloudExtensibleType):
    """5.1 Represents edge gateway services."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, NetworkService=None):
        self.original_tagname_ = None
        super(GatewayFeaturesType, self).__init__(VCloudExtension, )
        if NetworkService is None:
            self.NetworkService = []
        else:
            self.NetworkService = NetworkService
    def factory(*args_, **kwargs_):
        if GatewayFeaturesType.subclass:
            return GatewayFeaturesType.subclass(*args_, **kwargs_)
        else:
            return GatewayFeaturesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NetworkService(self): return self.NetworkService
    def set_NetworkService(self, NetworkService): self.NetworkService = NetworkService
    def add_NetworkService(self, value): self.NetworkService.append(value)
    def insert_NetworkService_at(self, index, value): self.NetworkService.insert(index, value)
    def replace_NetworkService_at(self, index, value): self.NetworkService[index] = value
    def hasContent_(self):
        if (
            self.NetworkService or
            super(GatewayFeaturesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GatewayFeaturesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayFeaturesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GatewayFeaturesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GatewayFeaturesType'):
        super(GatewayFeaturesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GatewayFeaturesType')
    def exportChildren(self, outfile, level, namespace_='', name_='GatewayFeaturesType', fromsubclass_=False, pretty_print=True):
        super(GatewayFeaturesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NetworkService_ in self.NetworkService:
            NetworkService_.export(outfile, level, namespace_, name_='NetworkService', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GatewayFeaturesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GatewayFeaturesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GatewayFeaturesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('NetworkService=[\n')
        level += 1
        for NetworkService_ in self.NetworkService:
            showIndent(outfile, level)
            outfile.write('model_.NetworkService(\n')
            NetworkService_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GatewayFeaturesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetworkService':
            class_obj_ = self.get_class_obj_(child_, NetworkServiceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'NetworkService'
        elif nodeName_ == 'DhcpService':
            obj_ = DhcpServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'DhcpService'
        elif nodeName_ == 'FirewallService':
            obj_ = FirewallServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'FirewallService'
        elif nodeName_ == 'NatService':
            obj_ = NatServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'NatService'
        elif nodeName_ == 'IpsecVpnService':
            obj_ = IpsecVpnServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'IpsecVpnService'
        elif nodeName_ == 'StaticRoutingService':
            obj_ = StaticRoutingServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'StaticRoutingService'
        elif nodeName_ == 'GatewayIpsecVpnService':
            obj_ = GatewayIpsecVpnServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'GatewayIpsecVpnService'
        elif nodeName_ == 'LoadBalancerService':
            obj_ = LoadBalancerServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'LoadBalancerService'
        elif nodeName_ == 'GatewayDhcpService':
            obj_ = GatewayDhcpServiceType.factory()
            obj_.build(child_)
            self.NetworkService.append(obj_)
            obj_.original_tagname_ = 'GatewayDhcpService'
        super(GatewayFeaturesType, self).buildChildren(child_, node, nodeName_, True)
# end class GatewayFeaturesType


class SubnetParticipationType(VCloudExtensibleType):
    """5.1 Allows to chose which subnets a gateway can be part of"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Gateway=None, Netmask=None, IpAddress=None, IpRanges=None):
        self.original_tagname_ = None
        super(SubnetParticipationType, self).__init__(VCloudExtension, )
        self.Gateway = Gateway
        self.Netmask = Netmask
        self.IpAddress = IpAddress
        self.IpRanges = IpRanges
    def factory(*args_, **kwargs_):
        if SubnetParticipationType.subclass:
            return SubnetParticipationType.subclass(*args_, **kwargs_)
        else:
            return SubnetParticipationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Gateway(self): return self.Gateway
    def set_Gateway(self, Gateway): self.Gateway = Gateway
    def get_Netmask(self): return self.Netmask
    def set_Netmask(self, Netmask): self.Netmask = Netmask
    def get_IpAddress(self): return self.IpAddress
    def set_IpAddress(self, IpAddress): self.IpAddress = IpAddress
    def get_IpRanges(self): return self.IpRanges
    def set_IpRanges(self, IpRanges): self.IpRanges = IpRanges
    def validate_IpAddressType(self, value):
        # Validate type IpAddressType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Gateway is not None or
            self.Netmask is not None or
            self.IpAddress is not None or
            self.IpRanges is not None or
            super(SubnetParticipationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubnetParticipationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubnetParticipationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubnetParticipationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubnetParticipationType'):
        super(SubnetParticipationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubnetParticipationType')
    def exportChildren(self, outfile, level, namespace_='', name_='SubnetParticipationType', fromsubclass_=False, pretty_print=True):
        super(SubnetParticipationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Gateway is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGateway>%s</%sGateway>%s' % (namespace_, self.gds_format_string(quote_xml(self.Gateway).encode(ExternalEncoding), input_name='Gateway'), namespace_, eol_))
        if self.Netmask is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNetmask>%s</%sNetmask>%s' % (namespace_, self.gds_format_string(quote_xml(self.Netmask).encode(ExternalEncoding), input_name='Netmask'), namespace_, eol_))
        if self.IpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIpAddress>%s</%sIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.IpAddress).encode(ExternalEncoding), input_name='IpAddress'), namespace_, eol_))
        if self.IpRanges is not None:
            self.IpRanges.export(outfile, level, namespace_, name_='IpRanges', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubnetParticipationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SubnetParticipationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubnetParticipationType, self).exportLiteralChildren(outfile, level, name_)
        if self.Gateway is not None:
            showIndent(outfile, level)
            outfile.write('Gateway=%s,\n' % quote_python(self.Gateway).encode(ExternalEncoding))
        if self.Netmask is not None:
            showIndent(outfile, level)
            outfile.write('Netmask=%s,\n' % quote_python(self.Netmask).encode(ExternalEncoding))
        if self.IpAddress is not None:
            showIndent(outfile, level)
            outfile.write('IpAddress=%s,\n' % quote_python(self.IpAddress).encode(ExternalEncoding))
        if self.IpRanges is not None:
            showIndent(outfile, level)
            outfile.write('IpRanges=model_.IpRangesType(\n')
            self.IpRanges.exportLiteral(outfile, level, name_='IpRanges')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SubnetParticipationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Gateway':
            Gateway_ = child_.text
            Gateway_ = self.gds_validate_string(Gateway_, node, 'Gateway')
            self.Gateway = Gateway_
            self.validate_IpAddressType(self.Gateway)    # validate type IpAddressType
        elif nodeName_ == 'Netmask':
            Netmask_ = child_.text
            Netmask_ = self.gds_validate_string(Netmask_, node, 'Netmask')
            self.Netmask = Netmask_
            self.validate_IpAddressType(self.Netmask)    # validate type IpAddressType
        elif nodeName_ == 'IpAddress':
            IpAddress_ = child_.text
            IpAddress_ = self.gds_validate_string(IpAddress_, node, 'IpAddress')
            self.IpAddress = IpAddress_
            self.validate_IpAddressType(self.IpAddress)    # validate type IpAddressType
        elif nodeName_ == 'IpRanges':
            obj_ = IpRangesType.factory()
            obj_.build(child_)
            self.IpRanges = obj_
            obj_.original_tagname_ = 'IpRanges'
        super(SubnetParticipationType, self).buildChildren(child_, node, nodeName_, True)
# end class SubnetParticipationType


class VendorServicesType(GeneratedsSuper):
    """5.1 Vendor services available for service insertion on networks or
    edge gateways."""
    subclass = None
    superclass = None
    def __init__(self, NetworkServices=None, EdgeGatewayServices=None):
        self.original_tagname_ = None
        if NetworkServices is None:
            self.NetworkServices = []
        else:
            self.NetworkServices = NetworkServices
        if EdgeGatewayServices is None:
            self.EdgeGatewayServices = []
        else:
            self.EdgeGatewayServices = EdgeGatewayServices
    def factory(*args_, **kwargs_):
        if VendorServicesType.subclass:
            return VendorServicesType.subclass(*args_, **kwargs_)
        else:
            return VendorServicesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NetworkServices(self): return self.NetworkServices
    def set_NetworkServices(self, NetworkServices): self.NetworkServices = NetworkServices
    def add_NetworkServices(self, value): self.NetworkServices.append(value)
    def insert_NetworkServices_at(self, index, value): self.NetworkServices.insert(index, value)
    def replace_NetworkServices_at(self, index, value): self.NetworkServices[index] = value
    def get_EdgeGatewayServices(self): return self.EdgeGatewayServices
    def set_EdgeGatewayServices(self, EdgeGatewayServices): self.EdgeGatewayServices = EdgeGatewayServices
    def add_EdgeGatewayServices(self, value): self.EdgeGatewayServices.append(value)
    def insert_EdgeGatewayServices_at(self, index, value): self.EdgeGatewayServices.insert(index, value)
    def replace_EdgeGatewayServices_at(self, index, value): self.EdgeGatewayServices[index] = value
    def hasContent_(self):
        if (
            self.NetworkServices or
            self.EdgeGatewayServices
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VendorServicesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VendorServicesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VendorServicesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VendorServicesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VendorServicesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for NetworkServices_ in self.NetworkServices:
            NetworkServices_.export(outfile, level, namespace_, name_='NetworkServices', pretty_print=pretty_print)
        for EdgeGatewayServices_ in self.EdgeGatewayServices:
            EdgeGatewayServices_.export(outfile, level, namespace_, name_='EdgeGatewayServices', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VendorServicesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('NetworkServices=[\n')
        level += 1
        for NetworkServices_ in self.NetworkServices:
            showIndent(outfile, level)
            outfile.write('model_.NetworkServiceInsertionType(\n')
            NetworkServices_.exportLiteral(outfile, level, name_='NetworkServiceInsertionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EdgeGatewayServices=[\n')
        level += 1
        for EdgeGatewayServices_ in self.EdgeGatewayServices:
            showIndent(outfile, level)
            outfile.write('model_.NetworkServiceInsertionType(\n')
            EdgeGatewayServices_.exportLiteral(outfile, level, name_='NetworkServiceInsertionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NetworkServices':
            obj_ = NetworkServiceInsertionType.factory()
            obj_.build(child_)
            self.NetworkServices.append(obj_)
            obj_.original_tagname_ = 'NetworkServices'
        elif nodeName_ == 'EdgeGatewayServices':
            obj_ = NetworkServiceInsertionType.factory()
            obj_.build(child_)
            self.EdgeGatewayServices.append(obj_)
            obj_.original_tagname_ = 'EdgeGatewayServices'
# end class VendorServicesType


class NetworkServiceInsertionType(VCloudExtensibleType):
    """5.1 always Information about a network service that has been
    inserted"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Id=None, Category=None, CategoryType=None, VendorTemplates=None):
        self.original_tagname_ = None
        super(NetworkServiceInsertionType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Id = Id
        self.Category = Category
        self.CategoryType = CategoryType
        if VendorTemplates is None:
            self.VendorTemplates = []
        else:
            self.VendorTemplates = VendorTemplates
    def factory(*args_, **kwargs_):
        if NetworkServiceInsertionType.subclass:
            return NetworkServiceInsertionType.subclass(*args_, **kwargs_)
        else:
            return NetworkServiceInsertionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def get_CategoryType(self): return self.CategoryType
    def set_CategoryType(self, CategoryType): self.CategoryType = CategoryType
    def get_VendorTemplates(self): return self.VendorTemplates
    def set_VendorTemplates(self, VendorTemplates): self.VendorTemplates = VendorTemplates
    def add_VendorTemplates(self, value): self.VendorTemplates.append(value)
    def insert_VendorTemplates_at(self, index, value): self.VendorTemplates.insert(index, value)
    def replace_VendorTemplates_at(self, index, value): self.VendorTemplates[index] = value
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Id is not None or
            self.Category is not None or
            self.CategoryType is not None or
            self.VendorTemplates or
            super(NetworkServiceInsertionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkServiceInsertionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkServiceInsertionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkServiceInsertionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkServiceInsertionType'):
        super(NetworkServiceInsertionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkServiceInsertionType')
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkServiceInsertionType', fromsubclass_=False, pretty_print=True):
        super(NetworkServiceInsertionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_, eol_))
        if self.Category is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategory>%s</%sCategory>%s' % (namespace_, self.gds_format_string(quote_xml(self.Category).encode(ExternalEncoding), input_name='Category'), namespace_, eol_))
        if self.CategoryType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategoryType>%s</%sCategoryType>%s' % (namespace_, self.gds_format_string(quote_xml(self.CategoryType).encode(ExternalEncoding), input_name='CategoryType'), namespace_, eol_))
        for VendorTemplates_ in self.VendorTemplates:
            VendorTemplates_.export(outfile, level, namespace_, name_='VendorTemplates', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkServiceInsertionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NetworkServiceInsertionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkServiceInsertionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
        if self.Category is not None:
            showIndent(outfile, level)
            outfile.write('Category=%s,\n' % quote_python(self.Category).encode(ExternalEncoding))
        if self.CategoryType is not None:
            showIndent(outfile, level)
            outfile.write('CategoryType=%s,\n' % quote_python(self.CategoryType).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('VendorTemplates=[\n')
        level += 1
        for VendorTemplates_ in self.VendorTemplates:
            showIndent(outfile, level)
            outfile.write('model_.VendorTemplateType(\n')
            VendorTemplates_.exportLiteral(outfile, level, name_='VendorTemplateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NetworkServiceInsertionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'Category':
            Category_ = child_.text
            Category_ = self.gds_validate_string(Category_, node, 'Category')
            self.Category = Category_
        elif nodeName_ == 'CategoryType':
            CategoryType_ = child_.text
            CategoryType_ = self.gds_validate_string(CategoryType_, node, 'CategoryType')
            self.CategoryType = CategoryType_
        elif nodeName_ == 'VendorTemplates':
            obj_ = VendorTemplateType.factory()
            obj_.build(child_)
            self.VendorTemplates.append(obj_)
            obj_.original_tagname_ = 'VendorTemplates'
        super(NetworkServiceInsertionType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkServiceInsertionType


class VendorTemplateType(VCloudExtensibleType):
    """5.1 always Information about a vendor service template. This is
    optional."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Id=None, VendorTemplateAttributes=None):
        self.original_tagname_ = None
        super(VendorTemplateType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Id = Id
        if VendorTemplateAttributes is None:
            self.VendorTemplateAttributes = []
        else:
            self.VendorTemplateAttributes = VendorTemplateAttributes
    def factory(*args_, **kwargs_):
        if VendorTemplateType.subclass:
            return VendorTemplateType.subclass(*args_, **kwargs_)
        else:
            return VendorTemplateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Id(self): return self.Id
    def set_Id(self, Id): self.Id = Id
    def get_VendorTemplateAttributes(self): return self.VendorTemplateAttributes
    def set_VendorTemplateAttributes(self, VendorTemplateAttributes): self.VendorTemplateAttributes = VendorTemplateAttributes
    def add_VendorTemplateAttributes(self, value): self.VendorTemplateAttributes.append(value)
    def insert_VendorTemplateAttributes_at(self, index, value): self.VendorTemplateAttributes.insert(index, value)
    def replace_VendorTemplateAttributes_at(self, index, value): self.VendorTemplateAttributes[index] = value
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Id is not None or
            self.VendorTemplateAttributes or
            super(VendorTemplateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VendorTemplateType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VendorTemplateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VendorTemplateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VendorTemplateType'):
        super(VendorTemplateType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VendorTemplateType')
    def exportChildren(self, outfile, level, namespace_='', name_='VendorTemplateType', fromsubclass_=False, pretty_print=True):
        super(VendorTemplateType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Id is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sId>%s</%sId>%s' % (namespace_, self.gds_format_string(quote_xml(self.Id).encode(ExternalEncoding), input_name='Id'), namespace_, eol_))
        for VendorTemplateAttributes_ in self.VendorTemplateAttributes:
            VendorTemplateAttributes_.export(outfile, level, namespace_, name_='VendorTemplateAttributes', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VendorTemplateType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VendorTemplateType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VendorTemplateType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Id is not None:
            showIndent(outfile, level)
            outfile.write('Id=%s,\n' % quote_python(self.Id).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('VendorTemplateAttributes=[\n')
        level += 1
        for VendorTemplateAttributes_ in self.VendorTemplateAttributes:
            showIndent(outfile, level)
            outfile.write('model_.VendorTemplateAttributesType(\n')
            VendorTemplateAttributes_.exportLiteral(outfile, level, name_='VendorTemplateAttributesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VendorTemplateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Id':
            Id_ = child_.text
            Id_ = self.gds_validate_string(Id_, node, 'Id')
            self.Id = Id_
        elif nodeName_ == 'VendorTemplateAttributes':
            obj_ = VendorTemplateAttributesType.factory()
            obj_.build(child_)
            self.VendorTemplateAttributes.append(obj_)
            obj_.original_tagname_ = 'VendorTemplateAttributes'
        super(VendorTemplateType, self).buildChildren(child_, node, nodeName_, True)
# end class VendorTemplateType


class VendorTemplateAttributesType(VCloudExtensibleType):
    """5.1 always Information about vendor template attributes"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, Key=None, Value=None):
        self.original_tagname_ = None
        super(VendorTemplateAttributesType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.Key = Key
        self.Value = Value
    def factory(*args_, **kwargs_):
        if VendorTemplateAttributesType.subclass:
            return VendorTemplateAttributesType.subclass(*args_, **kwargs_)
        else:
            return VendorTemplateAttributesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Name is not None or
            self.Key is not None or
            self.Value is not None or
            super(VendorTemplateAttributesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VendorTemplateAttributesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VendorTemplateAttributesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VendorTemplateAttributesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VendorTemplateAttributesType'):
        super(VendorTemplateAttributesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VendorTemplateAttributesType')
    def exportChildren(self, outfile, level, namespace_='', name_='VendorTemplateAttributesType', fromsubclass_=False, pretty_print=True):
        super(VendorTemplateAttributesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.Key is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKey>%s</%sKey>%s' % (namespace_, self.gds_format_string(quote_xml(self.Key).encode(ExternalEncoding), input_name='Key'), namespace_, eol_))
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VendorTemplateAttributesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VendorTemplateAttributesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VendorTemplateAttributesType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.Key is not None:
            showIndent(outfile, level)
            outfile.write('Key=%s,\n' % quote_python(self.Key).encode(ExternalEncoding))
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VendorTemplateAttributesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'Key':
            Key_ = child_.text
            Key_ = self.gds_validate_string(Key_, node, 'Key')
            self.Key = Key_
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
        super(VendorTemplateAttributesType, self).buildChildren(child_, node, nodeName_, True)
# end class VendorTemplateAttributesType


class VdcStorageProfilesType(VCloudExtensibleType):
    """5.1 Container for references to storage profiles associated with a
    vDC."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, VdcStorageProfile=None):
        self.original_tagname_ = None
        super(VdcStorageProfilesType, self).__init__(VCloudExtension, )
        if VdcStorageProfile is None:
            self.VdcStorageProfile = []
        else:
            self.VdcStorageProfile = VdcStorageProfile
    def factory(*args_, **kwargs_):
        if VdcStorageProfilesType.subclass:
            return VdcStorageProfilesType.subclass(*args_, **kwargs_)
        else:
            return VdcStorageProfilesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VdcStorageProfile(self): return self.VdcStorageProfile
    def set_VdcStorageProfile(self, VdcStorageProfile): self.VdcStorageProfile = VdcStorageProfile
    def add_VdcStorageProfile(self, value): self.VdcStorageProfile.append(value)
    def insert_VdcStorageProfile_at(self, index, value): self.VdcStorageProfile.insert(index, value)
    def replace_VdcStorageProfile_at(self, index, value): self.VdcStorageProfile[index] = value
    def hasContent_(self):
        if (
            self.VdcStorageProfile or
            super(VdcStorageProfilesType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VdcStorageProfilesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VdcStorageProfilesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VdcStorageProfilesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VdcStorageProfilesType'):
        super(VdcStorageProfilesType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VdcStorageProfilesType')
    def exportChildren(self, outfile, level, namespace_='', name_='VdcStorageProfilesType', fromsubclass_=False, pretty_print=True):
        super(VdcStorageProfilesType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VdcStorageProfile_ in self.VdcStorageProfile:
            VdcStorageProfile_.export(outfile, level, namespace_, name_='VdcStorageProfile', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VdcStorageProfilesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VdcStorageProfilesType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VdcStorageProfilesType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('VdcStorageProfile=[\n')
        level += 1
        for VdcStorageProfile_ in self.VdcStorageProfile:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            VdcStorageProfile_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VdcStorageProfilesType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VdcStorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VdcStorageProfile.append(obj_)
            obj_.original_tagname_ = 'VdcStorageProfile'
        super(VdcStorageProfilesType, self).buildChildren(child_, node, nodeName_, True)
# end class VdcStorageProfilesType


class VdcStorageProfileType(EntityType):
    """5.1 Represents a storage profile in an organization vDC."""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, Enabled=None, Units=None, Limit=None, Default=None):
        self.original_tagname_ = None
        super(VdcStorageProfileType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.Enabled = Enabled
        self.Units = Units
        self.Limit = Limit
        self.Default = Default
    def factory(*args_, **kwargs_):
        if VdcStorageProfileType.subclass:
            return VdcStorageProfileType.subclass(*args_, **kwargs_)
        else:
            return VdcStorageProfileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Enabled(self): return self.Enabled
    def set_Enabled(self, Enabled): self.Enabled = Enabled
    def get_Units(self): return self.Units
    def set_Units(self, Units): self.Units = Units
    def get_Limit(self): return self.Limit
    def set_Limit(self, Limit): self.Limit = Limit
    def get_Default(self): return self.Default
    def set_Default(self, Default): self.Default = Default
    def hasContent_(self):
        if (
            self.Enabled is not None or
            self.Units is not None or
            self.Limit is not None or
            self.Default is not None or
            super(VdcStorageProfileType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VdcStorageProfileType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VdcStorageProfileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VdcStorageProfileType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VdcStorageProfileType'):
        super(VdcStorageProfileType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VdcStorageProfileType')
    def exportChildren(self, outfile, level, namespace_='', name_='VdcStorageProfileType', fromsubclass_=False, pretty_print=True):
        super(VdcStorageProfileType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnabled>%s</%sEnabled>%s' % (namespace_, self.gds_format_boolean(self.Enabled, input_name='Enabled'), namespace_, eol_))
        if self.Units is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUnits>%s</%sUnits>%s' % (namespace_, self.gds_format_string(quote_xml(self.Units).encode(ExternalEncoding), input_name='Units'), namespace_, eol_))
        if self.Limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLimit>%s</%sLimit>%s' % (namespace_, self.gds_format_integer(self.Limit, input_name='Limit'), namespace_, eol_))
        if self.Default is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefault>%s</%sDefault>%s' % (namespace_, self.gds_format_boolean(self.Default, input_name='Default'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VdcStorageProfileType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VdcStorageProfileType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VdcStorageProfileType, self).exportLiteralChildren(outfile, level, name_)
        if self.Enabled is not None:
            showIndent(outfile, level)
            outfile.write('Enabled=%s,\n' % self.Enabled)
        if self.Units is not None:
            showIndent(outfile, level)
            outfile.write('Units=%s,\n' % quote_python(self.Units).encode(ExternalEncoding))
        if self.Limit is not None:
            showIndent(outfile, level)
            outfile.write('Limit=%d,\n' % self.Limit)
        if self.Default is not None:
            showIndent(outfile, level)
            outfile.write('Default=%s,\n' % self.Default)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VdcStorageProfileType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Enabled')
            self.Enabled = ival_
        elif nodeName_ == 'Units':
            Units_ = child_.text
            Units_ = self.gds_validate_string(Units_, node, 'Units')
            self.Units = Units_
        elif nodeName_ == 'Limit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Limit')
            self.Limit = ival_
        elif nodeName_ == 'Default':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Default')
            self.Default = ival_
        super(VdcStorageProfileType, self).buildChildren(child_, node, nodeName_, True)
# end class VdcStorageProfileType


class EnvelopeType(GeneratedsSuper):
    """Root OVF descriptor type"""
    subclass = None
    superclass = None
    def __init__(self, lang='en-US', References=None, Section=None, Content=None, Strings=None):
        self.original_tagname_ = None
        self.lang = _cast(None, lang)
        self.References = References
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
        self.Content = Content
        if Strings is None:
            self.Strings = []
        else:
            self.Strings = Strings
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if EnvelopeType.subclass:
            return EnvelopeType.subclass(*args_, **kwargs_)
        else:
            return EnvelopeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_References(self): return self.References
    def set_References(self, References): self.References = References
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def get_Content(self): return self.Content
    def set_Content(self, Content): self.Content = Content
    def get_Strings(self): return self.Strings
    def set_Strings(self, Strings): self.Strings = Strings
    def add_Strings(self, value): self.Strings.append(value)
    def insert_Strings_at(self, index, value): self.Strings.insert(index, value)
    def replace_Strings_at(self, index, value): self.Strings[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.References is not None or
            self.Section or
            self.Content is not None or
            self.Strings
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EnvelopeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnvelopeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EnvelopeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EnvelopeType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EnvelopeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.References is not None:
            self.References.export(outfile, level, namespace_, name_='References', pretty_print=pretty_print)
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovf:', name_='Section', pretty_print=pretty_print)
        if self.Content is not None:
            self.Content.export(outfile, level, namespace_='ovf:', name_='Content', pretty_print=pretty_print)
        for Strings_ in self.Strings:
            Strings_.export(outfile, level, namespace_, name_='Strings', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EnvelopeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.References is not None:
            showIndent(outfile, level)
            outfile.write('References=model_.References_Type(\n')
            self.References.exportLiteral(outfile, level, name_='References')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Content is not None:
            showIndent(outfile, level)
            outfile.write('Content=model_.Content(\n')
            self.Content.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Strings=[\n')
        level += 1
        for Strings_ in self.Strings:
            showIndent(outfile, level)
            outfile.write('model_.Strings_Type(\n')
            Strings_.exportLiteral(outfile, level, name_='Strings_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'References':
            obj_ = References_Type.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'References'
        elif nodeName_ == 'ShadowVMReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'ShadowVMReferences'
        elif nodeName_ == 'OrgReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'OrgReferences'
        elif nodeName_ == 'OrgVdcReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'OrgVdcReferences'
        elif nodeName_ == 'MediaReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'MediaReferences'
        elif nodeName_ == 'VAppTemplateReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'VAppTemplateReferences'
        elif nodeName_ == 'VAppReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'VAppReferences'
        elif nodeName_ == 'VMReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'VMReferences'
        elif nodeName_ == 'OrgNetworkReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'OrgNetworkReferences'
        elif nodeName_ == 'VAppNetworkReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'VAppNetworkReferences'
        elif nodeName_ == 'CatalogReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'CatalogReferences'
        elif nodeName_ == 'AdminVdcReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'AdminVdcReferences'
        elif nodeName_ == 'VMWProviderVdcReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'VMWProviderVdcReferences'
        elif nodeName_ == 'NetworkReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'NetworkReferences'
        elif nodeName_ == 'GroupReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'GroupReferences'
        elif nodeName_ == 'UserReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'UserReferences'
        elif nodeName_ == 'RoleReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'RoleReferences'
        elif nodeName_ == 'DatastoreReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'DatastoreReferences'
        elif nodeName_ == 'NetworkPoolReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'NetworkPoolReferences'
        elif nodeName_ == 'VirtualCenterReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'VirtualCenterReferences'
        elif nodeName_ == 'HostReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'HostReferences'
        elif nodeName_ == 'RightReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'RightReferences'
        elif nodeName_ == 'VAppOrgNetworkRelationReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'VAppOrgNetworkRelationReferences'
        elif nodeName_ == 'CatalogItemReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'CatalogItemReferences'
        elif nodeName_ == 'TaskReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'TaskReferences'
        elif nodeName_ == 'BlockingTaskReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'BlockingTaskReferences'
        elif nodeName_ == 'DiskReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'DiskReferences'
        elif nodeName_ == 'AdminDiskReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'AdminDiskReferences'
        elif nodeName_ == 'AdminEventReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'AdminEventReferences'
        elif nodeName_ == 'StrandedItemReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'StrandedItemReferences'
        elif nodeName_ == 'AdminServiceReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'AdminServiceReferences'
        elif nodeName_ == 'ServiceReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'ServiceReferences'
        elif nodeName_ == 'ServiceLinkReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'ServiceLinkReferences'
        elif nodeName_ == 'OrgVdcStorageProfileReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'OrgVdcStorageProfileReferences'
        elif nodeName_ == 'AdminOrgVdcStorageProfileReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'AdminOrgVdcStorageProfileReferences'
        elif nodeName_ == 'ProviderVdcStorageProfileReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'ProviderVdcStorageProfileReferences'
        elif nodeName_ == 'ApiFilterReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'ApiFilterReferences'
        elif nodeName_ == 'AdminApiDefinitionReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'AdminApiDefinitionReferences'
        elif nodeName_ == 'ApiDefinitionReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'ApiDefinitionReferences'
        elif nodeName_ == 'AdminFileDescriptorReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'AdminFileDescriptorReferences'
        elif nodeName_ == 'ResourceClassActionReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'ResourceClassActionReferences'
        elif nodeName_ == 'AclRuleReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'AclRuleReferences'
        elif nodeName_ == 'ResourceClassReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'ResourceClassReferences'
        elif nodeName_ == 'ServiceResourceResourceReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'ServiceResourceResourceReferences'
        elif nodeName_ == 'EdgeGatewayReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'EdgeGatewayReferences'
        elif nodeName_ == 'OrgVdcNetworkReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'OrgVdcNetworkReferences'
        elif nodeName_ == 'VAppOrgVdcNetworkRelationReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'VAppOrgVdcNetworkRelationReferences'
        elif nodeName_ == 'ToCloudTunnelReferences':
            obj_ = ReferencesType.factory()
            obj_.build(child_)
            self.References = obj_
            obj_.original_tagname_ = 'ToCloudTunnelReferences'
        elif nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
        elif nodeName_ == 'CustomizationSection':
            obj_ = CustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CustomizationSection'
        elif nodeName_ == 'Content':
            class_obj_ = self.get_class_obj_(child_, Content_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Content = obj_
            obj_.original_tagname_ = 'Content'
        elif nodeName_ == 'VirtualSystem':
            obj_ = VirtualSystem_Type.factory()
            obj_.build(child_)
            self.ovf.Content = obj_
            obj_.original_tagname_ = 'VirtualSystem'
        elif nodeName_ == 'VirtualSystemCollection':
            obj_ = VirtualSystemCollection_Type.factory()
            obj_.build(child_)
            self.ovf.Content = obj_
            obj_.original_tagname_ = 'VirtualSystemCollection'
        elif nodeName_ == 'Strings':
            obj_ = Strings_Type.factory()
            obj_.build(child_)
            self.Strings.append(obj_)
            obj_.original_tagname_ = 'Strings'
# end class EnvelopeType


class References_Type(GeneratedsSuper):
    """Type for list of external resources"""
    subclass = None
    superclass = None
    def __init__(self, File=None, anytypeobjs_=None):
        self.original_tagname_ = None
        if File is None:
            self.File = []
        else:
            self.File = File
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if References_Type.subclass:
            return References_Type.subclass(*args_, **kwargs_)
        else:
            return References_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_File(self): return self.File
    def set_File(self, File): self.File = File
    def add_File(self, value): self.File.append(value)
    def insert_File_at(self, index, value): self.File.insert(index, value)
    def replace_File_at(self, index, value): self.File[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.File or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='References_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='References_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='References_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='References_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='References_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for File_ in self.File:
            File_.export(outfile, level, namespace_, name_='File', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='References_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('File=[\n')
        level += 1
        for File_ in self.File:
            showIndent(outfile, level)
            outfile.write('model_.File_Type(\n')
            File_.exportLiteral(outfile, level, name_='File_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'File':
            obj_ = File_Type.factory()
            obj_.build(child_)
            self.File.append(obj_)
            obj_.original_tagname_ = 'File'
        else:
            obj_ = self.gds_build_any(child_, 'References_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class References_Type


class File_Type(GeneratedsSuper):
    """Type for an external reference to a resourceReference key used in
    other parts of the packageLocation of external resourceSize in
    bytes of the files (if known)Compression type (gzip, bzip2, or
    none if empty or not specified)Chunk size (except for last
    chunk)"""
    subclass = None
    superclass = None
    def __init__(self, compression='', href=None, chunkSize=None, id=None, size=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.compression = _cast(None, compression)
        self.href = _cast(None, href)
        self.chunkSize = _cast(int, chunkSize)
        self.id = _cast(None, id)
        self.size = _cast(int, size)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if File_Type.subclass:
            return File_Type.subclass(*args_, **kwargs_)
        else:
            return File_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_compression(self): return self.compression
    def set_compression(self, compression): self.compression = compression
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_chunkSize(self): return self.chunkSize
    def set_chunkSize(self, chunkSize): self.chunkSize = chunkSize
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='File_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='File_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='File_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='File_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            outfile.write(' compression=%s' % (self.gds_format_string(quote_attrib(self.compression).encode(ExternalEncoding), input_name='compression'), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.chunkSize is not None and 'chunkSize' not in already_processed:
            already_processed.add('chunkSize')
            outfile.write(' chunkSize="%s"' % self.gds_format_integer(self.chunkSize, input_name='chunkSize'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespace_='', name_='File_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='File_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.compression is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            showIndent(outfile, level)
            outfile.write('compression="%s",\n' % (self.compression,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.chunkSize is not None and 'chunkSize' not in already_processed:
            already_processed.add('chunkSize')
            showIndent(outfile, level)
            outfile.write('chunkSize=%d,\n' % (self.chunkSize,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % (self.size,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('compression', node)
        if value is not None and 'compression' not in already_processed:
            already_processed.add('compression')
            self.compression = value
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('chunkSize', node)
        if value is not None and 'chunkSize' not in already_processed:
            already_processed.add('chunkSize')
            try:
                self.chunkSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'File_Type')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class File_Type


class Content_Type(GeneratedsSuper):
    """Base class for content"""
    subclass = None
    superclass = None
    def __init__(self, id=None, Info=None, Name=None, Section=None, extensiontype_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.Info = Info
        self.Name = Name
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if Content_Type.subclass:
            return Content_Type.subclass(*args_, **kwargs_)
        else:
            return Content_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Info(self): return self.Info
    def set_Info(self, Info): self.Info = Info
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Info is not None or
            self.Name is not None or
            self.Section
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Content_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Content_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Content_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Content_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='Content_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Info is not None:
            self.Info.export(outfile, level, namespace_, name_='Info', pretty_print=pretty_print)
        if self.Name is not None:
            self.Name.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovf:', name_='Section', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Content_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Info is not None:
            showIndent(outfile, level)
            outfile.write('Info=model_.Msg_Type(\n')
            self.Info.exportLiteral(outfile, level, name_='Info')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=model_.Msg_Type(\n')
            self.Name.exportLiteral(outfile, level, name_='Name')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Info':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Info = obj_
            obj_.original_tagname_ = 'Info'
        elif nodeName_ == 'Name':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
        elif nodeName_ == 'CustomizationSection':
            obj_ = CustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CustomizationSection'
# end class Content_Type


class VirtualSystem_Type(Content_Type):
    """Content describing a virtual system"""
    subclass = None
    superclass = Content_Type
    def __init__(self, id=None, Info=None, Name=None, Section=None):
        self.original_tagname_ = None
        super(VirtualSystem_Type, self).__init__(id, Info, Name, Section, )
    def factory(*args_, **kwargs_):
        if VirtualSystem_Type.subclass:
            return VirtualSystem_Type.subclass(*args_, **kwargs_)
        else:
            return VirtualSystem_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(VirtualSystem_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VirtualSystem_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualSystem_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VirtualSystem_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualSystem_Type'):
        super(VirtualSystem_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualSystem_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualSystem_Type', fromsubclass_=False, pretty_print=True):
        super(VirtualSystem_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VirtualSystem_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VirtualSystem_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VirtualSystem_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VirtualSystem_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VirtualSystem_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VirtualSystem_Type


class VirtualSystemCollection_Type(Content_Type):
    """A collection of Content."""
    subclass = None
    superclass = Content_Type
    def __init__(self, id=None, Info=None, Name=None, Section=None, Content=None):
        self.original_tagname_ = None
        super(VirtualSystemCollection_Type, self).__init__(id, Info, Name, Section, )
        if Content is None:
            self.Content = []
        else:
            self.Content = Content
    def factory(*args_, **kwargs_):
        if VirtualSystemCollection_Type.subclass:
            return VirtualSystemCollection_Type.subclass(*args_, **kwargs_)
        else:
            return VirtualSystemCollection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Content(self): return self.Content
    def set_Content(self, Content): self.Content = Content
    def add_Content(self, value): self.Content.append(value)
    def insert_Content_at(self, index, value): self.Content.insert(index, value)
    def replace_Content_at(self, index, value): self.Content[index] = value
    def hasContent_(self):
        if (
            self.Content or
            super(VirtualSystemCollection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VirtualSystemCollection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualSystemCollection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VirtualSystemCollection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualSystemCollection_Type'):
        super(VirtualSystemCollection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualSystemCollection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualSystemCollection_Type', fromsubclass_=False, pretty_print=True):
        super(VirtualSystemCollection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Content_ in self.Content:
            Content_.export(outfile, level, namespace_='ovf:', name_='Content', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VirtualSystemCollection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VirtualSystemCollection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VirtualSystemCollection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Content=[\n')
        level += 1
        for Content_ in self.Content:
            showIndent(outfile, level)
            outfile.write('model_.Content(\n')
            Content_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VirtualSystemCollection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Content':
            class_obj_ = self.get_class_obj_(child_, Content_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Content.append(obj_)
            obj_.original_tagname_ = 'Content'
        elif nodeName_ == 'VirtualSystem':
            obj_ = VirtualSystem_Type.factory()
            obj_.build(child_)
            self.Content.append(obj_)
            obj_.original_tagname_ = 'VirtualSystem'
        elif nodeName_ == 'VirtualSystemCollection':
            obj_ = VirtualSystemCollection_Type.factory()
            obj_.build(child_)
            self.Content.append(obj_)
            obj_.original_tagname_ = 'VirtualSystemCollection'
        super(VirtualSystemCollection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class VirtualSystemCollection_Type


class Strings_Type(GeneratedsSuper):
    """Type for string resource bundleLocale for this string resource
    bundleReference to external resource bundle"""
    subclass = None
    superclass = None
    def __init__(self, lang=None, fileRef=None, Msg=None):
        self.original_tagname_ = None
        self.lang = _cast(None, lang)
        self.fileRef = _cast(None, fileRef)
        if Msg is None:
            self.Msg = []
        else:
            self.Msg = Msg
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Strings_Type.subclass:
            return Strings_Type.subclass(*args_, **kwargs_)
        else:
            return Strings_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Msg(self): return self.Msg
    def set_Msg(self, Msg): self.Msg = Msg
    def add_Msg(self, value): self.Msg.append(value)
    def insert_Msg_at(self, index, value): self.Msg.insert(index, value)
    def replace_Msg_at(self, index, value): self.Msg[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_fileRef(self): return self.fileRef
    def set_fileRef(self, fileRef): self.fileRef = fileRef
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Msg
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Strings_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Strings_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Strings_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Strings_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.fileRef is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            outfile.write(' fileRef=%s' % (self.gds_format_string(quote_attrib(self.fileRef).encode(ExternalEncoding), input_name='fileRef'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Strings_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Msg_ in self.Msg:
            Msg_.export(outfile, level, namespace_, name_='Msg', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Strings_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
        if self.fileRef is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            showIndent(outfile, level)
            outfile.write('fileRef="%s",\n' % (self.fileRef,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Msg=[\n')
        level += 1
        for Msg_ in self.Msg:
            showIndent(outfile, level)
            outfile.write('model_.MsgType(\n')
            Msg_.exportLiteral(outfile, level, name_='MsgType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
        value = find_attr_value_('fileRef', node)
        if value is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            self.fileRef = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Msg':
            obj_ = MsgType.factory()
            obj_.build(child_)
            self.Msg.append(obj_)
            obj_.original_tagname_ = 'Msg'
# end class Strings_Type


class Section_Type(GeneratedsSuper):
    """Base type for Sections, subclassing this is the most common form of
    extensibility. Subtypes define more specific elements."""
    subclass = None
    superclass = None
    def __init__(self, required=None, Info=None):
        self.original_tagname_ = None
        self.required = _cast(None, required)
        self.Info = Info
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Section_Type.subclass:
            return Section_Type.subclass(*args_, **kwargs_)
        else:
            return Section_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Info(self): return self.Info
    def set_Info(self, Info): self.Info = Info
    def get_required(self): return self.required
    def set_required(self, required): self.required = required
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Info is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Section_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Section_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Section_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Section_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required=%s' % (self.gds_format_string(quote_attrib(self.required).encode(ExternalEncoding), input_name='required'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Section_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Info is not None:
            self.Info.export(outfile, level, namespace_, name_='Info', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Section_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            showIndent(outfile, level)
            outfile.write('required="%s",\n' % (self.required,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Info is not None:
            showIndent(outfile, level)
            outfile.write('Info=model_.Msg_Type(\n')
            self.Info.exportLiteral(outfile, level, name_='Info')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            self.required = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Info':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Info = obj_
            obj_.original_tagname_ = 'Info'
# end class Section_Type


class Msg_Type(GeneratedsSuper):
    """Type for localizable stringDefault string valueIdentifier for lookup
    in string resource bundle for alternate locale"""
    subclass = None
    superclass = None
    def __init__(self, msgid='', valueOf_=None):
        self.original_tagname_ = None
        self.msgid = _cast(None, msgid)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Msg_Type.subclass:
            return Msg_Type.subclass(*args_, **kwargs_)
        else:
            return Msg_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_msgid(self): return self.msgid
    def set_msgid(self, msgid): self.msgid = msgid
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Msg_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Msg_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Msg_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Msg_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.msgid is not None and 'msgid' not in already_processed:
            already_processed.add('msgid')
            outfile.write(' msgid=%s' % (self.gds_format_string(quote_attrib(self.msgid).encode(ExternalEncoding), input_name='msgid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Msg_Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Msg_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.msgid is not None and 'msgid' not in already_processed:
            already_processed.add('msgid')
            showIndent(outfile, level)
            outfile.write('msgid="%s",\n' % (self.msgid,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('msgid', node)
        if value is not None and 'msgid' not in already_processed:
            already_processed.add('msgid')
            self.msgid = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Msg_Type


class AnnotationSection_Type(Section_Type):
    """User defined annotation"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Annotation=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(AnnotationSection_Type, self).__init__()
        self.Annotation = Annotation
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if AnnotationSection_Type.subclass:
            return AnnotationSection_Type.subclass(*args_, **kwargs_)
        else:
            return AnnotationSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Annotation(self): return self.Annotation
    def set_Annotation(self, Annotation): self.Annotation = Annotation
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Annotation is not None or
            self.anytypeobjs_ or
            super(AnnotationSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AnnotationSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnotationSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AnnotationSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AnnotationSection_Type'):
        super(AnnotationSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AnnotationSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='AnnotationSection_Type', fromsubclass_=False, pretty_print=True):
        super(AnnotationSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Annotation is not None:
            self.Annotation.export(outfile, level, namespace_, name_='Annotation', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AnnotationSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AnnotationSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AnnotationSection_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.Annotation is not None:
            showIndent(outfile, level)
            outfile.write('Annotation=model_.Msg_Type(\n')
            self.Annotation.exportLiteral(outfile, level, name_='Annotation')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AnnotationSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Annotation':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Annotation = obj_
            obj_.original_tagname_ = 'Annotation'
        else:
            obj_ = self.gds_build_any(child_, 'AnnotationSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(AnnotationSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class AnnotationSection_Type


class ProductSection_Type(Section_Type):
    """Product information for a virtual applianceProperties for
    application-level customizationProperty identifier
    prefixProperty identifier suffix"""
    subclass = None
    superclass = Section_Type
    def __init__(self, instance='', class_='', Product=None, Vendor=None, Version=None, FullVersion=None, ProductUrl=None, VendorUrl=None, AppUrl=None, Icon=None, Category=None, Property=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(ProductSection_Type, self).__init__()
        self.instance = _cast(None, instance)
        self.class_ = _cast(None, class_)
        self.Product = Product
        self.Vendor = Vendor
        self.Version = Version
        self.FullVersion = FullVersion
        self.ProductUrl = ProductUrl
        self.VendorUrl = VendorUrl
        self.AppUrl = AppUrl
        if Icon is None:
            self.Icon = []
        else:
            self.Icon = Icon
        if Category is None:
            self.Category = []
        else:
            self.Category = Category
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if ProductSection_Type.subclass:
            return ProductSection_Type.subclass(*args_, **kwargs_)
        else:
            return ProductSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Product(self): return self.Product
    def set_Product(self, Product): self.Product = Product
    def get_Vendor(self): return self.Vendor
    def set_Vendor(self, Vendor): self.Vendor = Vendor
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_FullVersion(self): return self.FullVersion
    def set_FullVersion(self, FullVersion): self.FullVersion = FullVersion
    def get_ProductUrl(self): return self.ProductUrl
    def set_ProductUrl(self, ProductUrl): self.ProductUrl = ProductUrl
    def get_VendorUrl(self): return self.VendorUrl
    def set_VendorUrl(self, VendorUrl): self.VendorUrl = VendorUrl
    def get_AppUrl(self): return self.AppUrl
    def set_AppUrl(self, AppUrl): self.AppUrl = AppUrl
    def get_Icon(self): return self.Icon
    def set_Icon(self, Icon): self.Icon = Icon
    def add_Icon(self, value): self.Icon.append(value)
    def insert_Icon_at(self, index, value): self.Icon.insert(index, value)
    def replace_Icon_at(self, index, value): self.Icon[index] = value
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def add_Category(self, value): self.Category.append(value)
    def insert_Category_at(self, index, value): self.Category.insert(index, value)
    def replace_Category_at(self, index, value): self.Category[index] = value
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property_at(self, index, value): self.Property.insert(index, value)
    def replace_Property_at(self, index, value): self.Property[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_instance(self): return self.instance
    def set_instance(self, instance): self.instance = instance
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def hasContent_(self):
        if (
            self.Product is not None or
            self.Vendor is not None or
            self.Version is not None or
            self.FullVersion is not None or
            self.ProductUrl is not None or
            self.VendorUrl is not None or
            self.AppUrl is not None or
            self.Icon or
            self.Category or
            self.Property or
            self.anytypeobjs_ or
            super(ProductSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProductSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProductSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProductSection_Type'):
        super(ProductSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProductSection_Type')
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.add('instance')
            outfile.write(' instance=%s' % (self.gds_format_string(quote_attrib(self.instance).encode(ExternalEncoding), input_name='instance'), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.class_).encode(ExternalEncoding), input_name='class'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ProductSection_Type', fromsubclass_=False, pretty_print=True):
        super(ProductSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Product is not None:
            self.Product.export(outfile, level, namespace_, name_='Product', pretty_print=pretty_print)
        if self.Vendor is not None:
            self.Vendor.export(outfile, level, namespace_, name_='Vendor', pretty_print=pretty_print)
        if self.Version is not None:
            self.Version.export(outfile, level, namespace_, name_='Version', pretty_print=pretty_print)
        if self.FullVersion is not None:
            self.FullVersion.export(outfile, level, namespace_, name_='FullVersion', pretty_print=pretty_print)
        if self.ProductUrl is not None:
            self.ProductUrl.export(outfile, level, namespace_, name_='ProductUrl', pretty_print=pretty_print)
        if self.VendorUrl is not None:
            self.VendorUrl.export(outfile, level, namespace_, name_='VendorUrl', pretty_print=pretty_print)
        if self.AppUrl is not None:
            self.AppUrl.export(outfile, level, namespace_, name_='AppUrl', pretty_print=pretty_print)
        for Icon_ in self.Icon:
            Icon_.export(outfile, level, namespace_, name_='Icon', pretty_print=pretty_print)
        for Category_ in self.Category:
            Category_.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProductSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instance is not None and 'instance' not in already_processed:
            already_processed.add('instance')
            showIndent(outfile, level)
            outfile.write('instance="%s",\n' % (self.instance,))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            showIndent(outfile, level)
            outfile.write('class_="%s",\n' % (self.class_,))
        super(ProductSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ProductSection_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.Product is not None:
            showIndent(outfile, level)
            outfile.write('Product=model_.Msg_Type(\n')
            self.Product.exportLiteral(outfile, level, name_='Product')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Vendor is not None:
            showIndent(outfile, level)
            outfile.write('Vendor=model_.Msg_Type(\n')
            self.Vendor.exportLiteral(outfile, level, name_='Vendor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=model_.cimString(\n')
            self.Version.exportLiteral(outfile, level, name_='Version')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FullVersion is not None:
            showIndent(outfile, level)
            outfile.write('FullVersion=model_.cimString(\n')
            self.FullVersion.exportLiteral(outfile, level, name_='FullVersion')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProductUrl is not None:
            showIndent(outfile, level)
            outfile.write('ProductUrl=model_.cimString(\n')
            self.ProductUrl.exportLiteral(outfile, level, name_='ProductUrl')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VendorUrl is not None:
            showIndent(outfile, level)
            outfile.write('VendorUrl=model_.cimString(\n')
            self.VendorUrl.exportLiteral(outfile, level, name_='VendorUrl')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AppUrl is not None:
            showIndent(outfile, level)
            outfile.write('AppUrl=model_.cimString(\n')
            self.AppUrl.exportLiteral(outfile, level, name_='AppUrl')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Icon=[\n')
        level += 1
        for Icon_ in self.Icon:
            showIndent(outfile, level)
            outfile.write('model_.IconType(\n')
            Icon_.exportLiteral(outfile, level, name_='IconType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Category=[\n')
        level += 1
        for Category_ in self.Category:
            showIndent(outfile, level)
            outfile.write('model_.Msg_Type(\n')
            Category_.exportLiteral(outfile, level, name_='Msg_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.PropertyType5(\n')
            Property_.exportLiteral(outfile, level, name_='PropertyType5')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instance', node)
        if value is not None and 'instance' not in already_processed:
            already_processed.add('instance')
            self.instance = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
        super(ProductSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Product':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Product = obj_
            obj_.original_tagname_ = 'Product'
        elif nodeName_ == 'Vendor':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Vendor = obj_
            obj_.original_tagname_ = 'Vendor'
        elif nodeName_ == 'Version':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Version = obj_
            obj_.original_tagname_ = 'Version'
        elif nodeName_ == 'FullVersion':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.FullVersion = obj_
            obj_.original_tagname_ = 'FullVersion'
        elif nodeName_ == 'ProductUrl':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ProductUrl = obj_
            obj_.original_tagname_ = 'ProductUrl'
        elif nodeName_ == 'VendorUrl':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VendorUrl = obj_
            obj_.original_tagname_ = 'VendorUrl'
        elif nodeName_ == 'AppUrl':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AppUrl = obj_
            obj_.original_tagname_ = 'AppUrl'
        elif nodeName_ == 'Icon':
            obj_ = IconType.factory()
            obj_.build(child_)
            self.Icon.append(obj_)
            obj_.original_tagname_ = 'Icon'
        elif nodeName_ == 'Category':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Category.append(obj_)
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'Property':
            obj_ = PropertyType5.factory()
            obj_.build(child_)
            self.Property.append(obj_)
            obj_.original_tagname_ = 'Property'
        else:
            obj_ = self.gds_build_any(child_, 'ProductSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(ProductSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class ProductSection_Type


class PropertyConfigurationValue_Type(GeneratedsSuper):
    """Type for alternative default values for properties when
    DeploymentOptionSection is usedAlternative default property
    valueConfiguration from DeploymentOptionSection in which this
    value is default"""
    subclass = None
    superclass = None
    def __init__(self, configuration=None, value=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.configuration = _cast(None, configuration)
        self.value = _cast(None, value)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PropertyConfigurationValue_Type.subclass:
            return PropertyConfigurationValue_Type.subclass(*args_, **kwargs_)
        else:
            return PropertyConfigurationValue_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_configuration(self): return self.configuration
    def set_configuration(self, configuration): self.configuration = configuration
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertyConfigurationValue_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyConfigurationValue_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PropertyConfigurationValue_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyConfigurationValue_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.configuration is not None and 'configuration' not in already_processed:
            already_processed.add('configuration')
            outfile.write(' configuration=%s' % (self.gds_format_string(quote_attrib(self.configuration).encode(ExternalEncoding), input_name='configuration'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyConfigurationValue_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PropertyConfigurationValue_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.configuration is not None and 'configuration' not in already_processed:
            already_processed.add('configuration')
            showIndent(outfile, level)
            outfile.write('configuration="%s",\n' % (self.configuration,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('configuration', node)
        if value is not None and 'configuration' not in already_processed:
            already_processed.add('configuration')
            self.configuration = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'PropertyConfigurationValue_Type')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class PropertyConfigurationValue_Type


class NetworkSection_Type(Section_Type):
    """Descriptions of logical networks used within the package"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Network=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(NetworkSection_Type, self).__init__()
        if Network is None:
            self.Network = []
        else:
            self.Network = Network
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if NetworkSection_Type.subclass:
            return NetworkSection_Type.subclass(*args_, **kwargs_)
        else:
            return NetworkSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Network(self): return self.Network
    def set_Network(self, Network): self.Network = Network
    def add_Network(self, value): self.Network.append(value)
    def insert_Network_at(self, index, value): self.Network.insert(index, value)
    def replace_Network_at(self, index, value): self.Network[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Network or
            self.anytypeobjs_ or
            super(NetworkSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkSection_Type'):
        super(NetworkSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkSection_Type', fromsubclass_=False, pretty_print=True):
        super(NetworkSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Network_ in self.Network:
            Network_.export(outfile, level, namespace_, name_='Network', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NetworkSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkSection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Network=[\n')
        level += 1
        for Network_ in self.Network:
            showIndent(outfile, level)
            outfile.write('model_.NetworkType6(\n')
            Network_.exportLiteral(outfile, level, name_='NetworkType6')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NetworkSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Network':
            obj_ = NetworkType6.factory()
            obj_.build(child_)
            self.Network.append(obj_)
            obj_.original_tagname_ = 'Network'
        else:
            obj_ = self.gds_build_any(child_, 'NetworkSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(NetworkSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkSection_Type


class DiskSection_Type(Section_Type):
    """Descriptions of virtual disks used within the package"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Disk=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(DiskSection_Type, self).__init__()
        if Disk is None:
            self.Disk = []
        else:
            self.Disk = Disk
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if DiskSection_Type.subclass:
            return DiskSection_Type.subclass(*args_, **kwargs_)
        else:
            return DiskSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Disk(self): return self.Disk
    def set_Disk(self, Disk): self.Disk = Disk
    def add_Disk(self, value): self.Disk.append(value)
    def insert_Disk_at(self, index, value): self.Disk.insert(index, value)
    def replace_Disk_at(self, index, value): self.Disk[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Disk or
            self.anytypeobjs_ or
            super(DiskSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiskSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiskSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DiskSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiskSection_Type'):
        super(DiskSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DiskSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DiskSection_Type', fromsubclass_=False, pretty_print=True):
        super(DiskSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Disk_ in self.Disk:
            Disk_.export(outfile, level, namespace_, name_='Disk', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DiskSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DiskSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DiskSection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Disk=[\n')
        level += 1
        for Disk_ in self.Disk:
            showIndent(outfile, level)
            outfile.write('model_.VirtualDiskDesc_Type(\n')
            Disk_.exportLiteral(outfile, level, name_='VirtualDiskDesc_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DiskSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Disk':
            obj_ = VirtualDiskDesc_Type.factory()
            obj_.build(child_)
            self.Disk.append(obj_)
            obj_.original_tagname_ = 'Disk'
        else:
            obj_ = self.gds_build_any(child_, 'DiskSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(DiskSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class DiskSection_Type


class VirtualDiskDesc_Type(GeneratedsSuper):
    """Type for virtual disk descriptorIdentifier for virtual diskReference
    to virtual disk content. If not specified a blank virtual disk
    is created of size given by capacity attributeVirtual disk
    capacity, can be specified as either an xs:long size or as a
    reference to a property using ${property_name}. Unit of
    allocation for ovf:capacity. If not specified default value is
    bytes. Value shall match a recognized value for the UNITS
    qualifier in DSP0004.Format of virtual disk given as a URI that
    identifies the disk typeEstimated populated size of disk in
    bytesReference to potential parent disk"""
    subclass = None
    superclass = None
    def __init__(self, capacityAllocationUnits='byte', capacity=None, format=None, parentRef=None, fileRef=None, populatedSize=None, diskId=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.capacityAllocationUnits = _cast(None, capacityAllocationUnits)
        self.capacity = _cast(None, capacity)
        self.format = _cast(None, format)
        self.parentRef = _cast(None, parentRef)
        self.fileRef = _cast(None, fileRef)
        self.populatedSize = _cast(int, populatedSize)
        self.diskId = _cast(None, diskId)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if VirtualDiskDesc_Type.subclass:
            return VirtualDiskDesc_Type.subclass(*args_, **kwargs_)
        else:
            return VirtualDiskDesc_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_capacityAllocationUnits(self): return self.capacityAllocationUnits
    def set_capacityAllocationUnits(self, capacityAllocationUnits): self.capacityAllocationUnits = capacityAllocationUnits
    def get_capacity(self): return self.capacity
    def set_capacity(self, capacity): self.capacity = capacity
    def get_format(self): return self.format
    def set_format(self, format): self.format = format
    def get_parentRef(self): return self.parentRef
    def set_parentRef(self, parentRef): self.parentRef = parentRef
    def get_fileRef(self): return self.fileRef
    def set_fileRef(self, fileRef): self.fileRef = fileRef
    def get_populatedSize(self): return self.populatedSize
    def set_populatedSize(self, populatedSize): self.populatedSize = populatedSize
    def get_diskId(self): return self.diskId
    def set_diskId(self, diskId): self.diskId = diskId
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VirtualDiskDesc_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualDiskDesc_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VirtualDiskDesc_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualDiskDesc_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.capacityAllocationUnits is not None and 'capacityAllocationUnits' not in already_processed:
            already_processed.add('capacityAllocationUnits')
            outfile.write(' capacityAllocationUnits=%s' % (self.gds_format_string(quote_attrib(self.capacityAllocationUnits).encode(ExternalEncoding), input_name='capacityAllocationUnits'), ))
        if self.capacity is not None and 'capacity' not in already_processed:
            already_processed.add('capacity')
            outfile.write(' capacity=%s' % (self.gds_format_string(quote_attrib(self.capacity).encode(ExternalEncoding), input_name='capacity'), ))
        if self.format is not None and 'format' not in already_processed:
            already_processed.add('format')
            outfile.write(' format=%s' % (self.gds_format_string(quote_attrib(self.format).encode(ExternalEncoding), input_name='format'), ))
        if self.parentRef is not None and 'parentRef' not in already_processed:
            already_processed.add('parentRef')
            outfile.write(' parentRef=%s' % (self.gds_format_string(quote_attrib(self.parentRef).encode(ExternalEncoding), input_name='parentRef'), ))
        if self.fileRef is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            outfile.write(' fileRef=%s' % (self.gds_format_string(quote_attrib(self.fileRef).encode(ExternalEncoding), input_name='fileRef'), ))
        if self.populatedSize is not None and 'populatedSize' not in already_processed:
            already_processed.add('populatedSize')
            outfile.write(' populatedSize="%s"' % self.gds_format_integer(self.populatedSize, input_name='populatedSize'))
        if self.diskId is not None and 'diskId' not in already_processed:
            already_processed.add('diskId')
            outfile.write(' diskId=%s' % (self.gds_format_string(quote_attrib(self.diskId).encode(ExternalEncoding), input_name='diskId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualDiskDesc_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VirtualDiskDesc_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.capacityAllocationUnits is not None and 'capacityAllocationUnits' not in already_processed:
            already_processed.add('capacityAllocationUnits')
            showIndent(outfile, level)
            outfile.write('capacityAllocationUnits="%s",\n' % (self.capacityAllocationUnits,))
        if self.capacity is not None and 'capacity' not in already_processed:
            already_processed.add('capacity')
            showIndent(outfile, level)
            outfile.write('capacity="%s",\n' % (self.capacity,))
        if self.format is not None and 'format' not in already_processed:
            already_processed.add('format')
            showIndent(outfile, level)
            outfile.write('format="%s",\n' % (self.format,))
        if self.parentRef is not None and 'parentRef' not in already_processed:
            already_processed.add('parentRef')
            showIndent(outfile, level)
            outfile.write('parentRef="%s",\n' % (self.parentRef,))
        if self.fileRef is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            showIndent(outfile, level)
            outfile.write('fileRef="%s",\n' % (self.fileRef,))
        if self.populatedSize is not None and 'populatedSize' not in already_processed:
            already_processed.add('populatedSize')
            showIndent(outfile, level)
            outfile.write('populatedSize=%d,\n' % (self.populatedSize,))
        if self.diskId is not None and 'diskId' not in already_processed:
            already_processed.add('diskId')
            showIndent(outfile, level)
            outfile.write('diskId="%s",\n' % (self.diskId,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('capacityAllocationUnits', node)
        if value is not None and 'capacityAllocationUnits' not in already_processed:
            already_processed.add('capacityAllocationUnits')
            self.capacityAllocationUnits = value
        value = find_attr_value_('capacity', node)
        if value is not None and 'capacity' not in already_processed:
            already_processed.add('capacity')
            self.capacity = value
        value = find_attr_value_('format', node)
        if value is not None and 'format' not in already_processed:
            already_processed.add('format')
            self.format = value
        value = find_attr_value_('parentRef', node)
        if value is not None and 'parentRef' not in already_processed:
            already_processed.add('parentRef')
            self.parentRef = value
        value = find_attr_value_('fileRef', node)
        if value is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            self.fileRef = value
        value = find_attr_value_('populatedSize', node)
        if value is not None and 'populatedSize' not in already_processed:
            already_processed.add('populatedSize')
            try:
                self.populatedSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('diskId', node)
        if value is not None and 'diskId' not in already_processed:
            already_processed.add('diskId')
            self.diskId = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'VirtualDiskDesc_Type')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class VirtualDiskDesc_Type


class OperatingSystemSection_Type(Section_Type):
    """Specification of the operating system installed in the
    guestIdentifier defined by the CIM_OperatingSystem.OsType
    enumerationVersion defined by the CIM_OperatingSystem.Version
    field"""
    subclass = None
    superclass = Section_Type
    def __init__(self, version=None, id=None, Description=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(OperatingSystemSection_Type, self).__init__()
        self.version = _cast(None, version)
        self.id = _cast(int, id)
        self.Description = Description
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if OperatingSystemSection_Type.subclass:
            return OperatingSystemSection_Type.subclass(*args_, **kwargs_)
        else:
            return OperatingSystemSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Description is not None or
            self.anytypeobjs_ or
            super(OperatingSystemSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OperatingSystemSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperatingSystemSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OperatingSystemSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperatingSystemSection_Type'):
        super(OperatingSystemSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OperatingSystemSection_Type')
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespace_='', name_='OperatingSystemSection_Type', fromsubclass_=False, pretty_print=True):
        super(OperatingSystemSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OperatingSystemSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%d,\n' % (self.id,))
        super(OperatingSystemSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OperatingSystemSection_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Msg_Type(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            try:
                self.id = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(OperatingSystemSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        else:
            obj_ = self.gds_build_any(child_, 'OperatingSystemSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(OperatingSystemSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class OperatingSystemSection_Type


class EulaSection_Type(Section_Type):
    """End-User License Agreement"""
    subclass = None
    superclass = Section_Type
    def __init__(self, License=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(EulaSection_Type, self).__init__()
        self.License = License
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if EulaSection_Type.subclass:
            return EulaSection_Type.subclass(*args_, **kwargs_)
        else:
            return EulaSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_License(self): return self.License
    def set_License(self, License): self.License = License
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.License is not None or
            self.anytypeobjs_ or
            super(EulaSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EulaSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EulaSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EulaSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EulaSection_Type'):
        super(EulaSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EulaSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='EulaSection_Type', fromsubclass_=False, pretty_print=True):
        super(EulaSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.License is not None:
            self.License.export(outfile, level, namespace_, name_='License', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EulaSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EulaSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EulaSection_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.License is not None:
            showIndent(outfile, level)
            outfile.write('License=model_.Msg_Type(\n')
            self.License.exportLiteral(outfile, level, name_='License')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EulaSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'License':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.License = obj_
            obj_.original_tagname_ = 'License'
        else:
            obj_ = self.gds_build_any(child_, 'EulaSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(EulaSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class EulaSection_Type


class VirtualHardwareSection_Type(Section_Type):
    """Specifies virtual hardware requirements for a virtual machineUnique
    identifier of this VirtualHardwareSection (within a
    VirtualSystem)"""
    subclass = None
    superclass = Section_Type
    def __init__(self, id='', transport=None, System=None, Item=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(VirtualHardwareSection_Type, self).__init__()
        self.id = _cast(None, id)
        self.transport = _cast(None, transport)
        self.System = System
        if Item is None:
            self.Item = []
        else:
            self.Item = Item
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if VirtualHardwareSection_Type.subclass:
            return VirtualHardwareSection_Type.subclass(*args_, **kwargs_)
        else:
            return VirtualHardwareSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_System(self): return self.System
    def set_System(self, System): self.System = System
    def get_Item(self): return self.Item
    def set_Item(self, Item): self.Item = Item
    def add_Item(self, value): self.Item.append(value)
    def insert_Item_at(self, index, value): self.Item.insert(index, value)
    def replace_Item_at(self, index, value): self.Item[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_transport(self): return self.transport
    def set_transport(self, transport): self.transport = transport
    def hasContent_(self):
        if (
            self.System is not None or
            self.Item or
            self.anytypeobjs_ or
            super(VirtualHardwareSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VirtualHardwareSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualHardwareSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VirtualHardwareSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VirtualHardwareSection_Type'):
        super(VirtualHardwareSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VirtualHardwareSection_Type')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.transport is not None and 'transport' not in already_processed:
            already_processed.add('transport')
            outfile.write(' transport=%s' % (self.gds_format_string(quote_attrib(self.transport).encode(ExternalEncoding), input_name='transport'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VirtualHardwareSection_Type', fromsubclass_=False, pretty_print=True):
        super(VirtualHardwareSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.System is not None:
            self.System.export(outfile, level, namespace_, name_='System', pretty_print=pretty_print)
        for Item_ in self.Item:
            Item_.export(outfile, level, namespace_, name_='Item', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VirtualHardwareSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        if self.transport is not None and 'transport' not in already_processed:
            already_processed.add('transport')
            showIndent(outfile, level)
            outfile.write('transport="%s",\n' % (self.transport,))
        super(VirtualHardwareSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VirtualHardwareSection_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.System is not None:
            showIndent(outfile, level)
            outfile.write('System=model_.VSSD_Type(\n')
            self.System.exportLiteral(outfile, level, name_='System')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Item=[\n')
        level += 1
        for Item_ in self.Item:
            showIndent(outfile, level)
            outfile.write('model_.RASD_Type(\n')
            Item_.exportLiteral(outfile, level, name_='RASD_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('transport', node)
        if value is not None and 'transport' not in already_processed:
            already_processed.add('transport')
            self.transport = value
        super(VirtualHardwareSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'System':
            obj_ = VSSD_Type.factory()
            obj_.build(child_)
            self.System = obj_
            obj_.original_tagname_ = 'System'
        elif nodeName_ == 'Item':
            obj_ = RASD_Type.factory()
            obj_.build(child_)
            self.Item.append(obj_)
            obj_.original_tagname_ = 'Item'
        else:
            obj_ = self.gds_build_any(child_, 'VirtualHardwareSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(VirtualHardwareSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class VirtualHardwareSection_Type


class ResourceAllocationSection_Type(Section_Type):
    """Resource constraints on a VirtualSystemCollection"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Item=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(ResourceAllocationSection_Type, self).__init__()
        if Item is None:
            self.Item = []
        else:
            self.Item = Item
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if ResourceAllocationSection_Type.subclass:
            return ResourceAllocationSection_Type.subclass(*args_, **kwargs_)
        else:
            return ResourceAllocationSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Item(self): return self.Item
    def set_Item(self, Item): self.Item = Item
    def add_Item(self, value): self.Item.append(value)
    def insert_Item_at(self, index, value): self.Item.insert(index, value)
    def replace_Item_at(self, index, value): self.Item[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Item or
            self.anytypeobjs_ or
            super(ResourceAllocationSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResourceAllocationSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceAllocationSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResourceAllocationSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResourceAllocationSection_Type'):
        super(ResourceAllocationSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResourceAllocationSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='ResourceAllocationSection_Type', fromsubclass_=False, pretty_print=True):
        super(ResourceAllocationSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Item_ in self.Item:
            Item_.export(outfile, level, namespace_, name_='Item', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResourceAllocationSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ResourceAllocationSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResourceAllocationSection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Item=[\n')
        level += 1
        for Item_ in self.Item:
            showIndent(outfile, level)
            outfile.write('model_.RASD_Type(\n')
            Item_.exportLiteral(outfile, level, name_='RASD_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResourceAllocationSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Item':
            obj_ = RASD_Type.factory()
            obj_.build(child_)
            self.Item.append(obj_)
            obj_.original_tagname_ = 'Item'
        else:
            obj_ = self.gds_build_any(child_, 'ResourceAllocationSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(ResourceAllocationSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class ResourceAllocationSection_Type


class InstallSection_Type(Section_Type):
    """If present indicates that the virtual machine needs to be initially
    booted to install and configure the softwareDelay in seconds to
    wait for power off to complete after initial boot"""
    subclass = None
    superclass = Section_Type
    def __init__(self, initialBootStopDelay=0, anytypeobjs_=None):
        self.original_tagname_ = None
        super(InstallSection_Type, self).__init__()
        self.initialBootStopDelay = _cast(int, initialBootStopDelay)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if InstallSection_Type.subclass:
            return InstallSection_Type.subclass(*args_, **kwargs_)
        else:
            return InstallSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_initialBootStopDelay(self): return self.initialBootStopDelay
    def set_initialBootStopDelay(self, initialBootStopDelay): self.initialBootStopDelay = initialBootStopDelay
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            super(InstallSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InstallSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InstallSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InstallSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InstallSection_Type'):
        super(InstallSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='InstallSection_Type')
        if self.initialBootStopDelay is not None and 'initialBootStopDelay' not in already_processed:
            already_processed.add('initialBootStopDelay')
            outfile.write(' initialBootStopDelay="%s"' % self.gds_format_integer(self.initialBootStopDelay, input_name='initialBootStopDelay'))
    def exportChildren(self, outfile, level, namespace_='', name_='InstallSection_Type', fromsubclass_=False, pretty_print=True):
        super(InstallSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='InstallSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.initialBootStopDelay is not None and 'initialBootStopDelay' not in already_processed:
            already_processed.add('initialBootStopDelay')
            showIndent(outfile, level)
            outfile.write('initialBootStopDelay=%d,\n' % (self.initialBootStopDelay,))
        super(InstallSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(InstallSection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('initialBootStopDelay', node)
        if value is not None and 'initialBootStopDelay' not in already_processed:
            already_processed.add('initialBootStopDelay')
            try:
                self.initialBootStopDelay = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(InstallSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'InstallSection_Type')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
        super(InstallSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class InstallSection_Type


class StartupSection_Type(Section_Type):
    """Specifies the order in which entities in a VirtualSystemCollection
    are powered on and shut down"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Item=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(StartupSection_Type, self).__init__()
        if Item is None:
            self.Item = []
        else:
            self.Item = Item
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if StartupSection_Type.subclass:
            return StartupSection_Type.subclass(*args_, **kwargs_)
        else:
            return StartupSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Item(self): return self.Item
    def set_Item(self, Item): self.Item = Item
    def add_Item(self, value): self.Item.append(value)
    def insert_Item_at(self, index, value): self.Item.insert(index, value)
    def replace_Item_at(self, index, value): self.Item[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Item or
            self.anytypeobjs_ or
            super(StartupSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StartupSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StartupSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StartupSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StartupSection_Type'):
        super(StartupSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StartupSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='StartupSection_Type', fromsubclass_=False, pretty_print=True):
        super(StartupSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Item_ in self.Item:
            Item_.export(outfile, level, namespace_, name_='Item', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StartupSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StartupSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StartupSection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Item=[\n')
        level += 1
        for Item_ in self.Item:
            showIndent(outfile, level)
            outfile.write('model_.ItemType(\n')
            Item_.exportLiteral(outfile, level, name_='ItemType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StartupSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Item':
            obj_ = ItemType.factory()
            obj_.build(child_)
            self.Item.append(obj_)
            obj_.original_tagname_ = 'Item'
        else:
            obj_ = self.gds_build_any(child_, 'StartupSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(StartupSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class StartupSection_Type


class DeploymentOptionSection_Type(Section_Type):
    """Enumeration of discrete deployment options"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Configuration=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(DeploymentOptionSection_Type, self).__init__()
        if Configuration is None:
            self.Configuration = []
        else:
            self.Configuration = Configuration
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if DeploymentOptionSection_Type.subclass:
            return DeploymentOptionSection_Type.subclass(*args_, **kwargs_)
        else:
            return DeploymentOptionSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Configuration(self): return self.Configuration
    def set_Configuration(self, Configuration): self.Configuration = Configuration
    def add_Configuration(self, value): self.Configuration.append(value)
    def insert_Configuration_at(self, index, value): self.Configuration.insert(index, value)
    def replace_Configuration_at(self, index, value): self.Configuration[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Configuration or
            self.anytypeobjs_ or
            super(DeploymentOptionSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeploymentOptionSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeploymentOptionSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeploymentOptionSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeploymentOptionSection_Type'):
        super(DeploymentOptionSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeploymentOptionSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DeploymentOptionSection_Type', fromsubclass_=False, pretty_print=True):
        super(DeploymentOptionSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Configuration_ in self.Configuration:
            Configuration_.export(outfile, level, namespace_, name_='Configuration', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DeploymentOptionSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DeploymentOptionSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DeploymentOptionSection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Configuration=[\n')
        level += 1
        for Configuration_ in self.Configuration:
            showIndent(outfile, level)
            outfile.write('model_.ConfigurationType(\n')
            Configuration_.exportLiteral(outfile, level, name_='ConfigurationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DeploymentOptionSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Configuration':
            obj_ = ConfigurationType.factory()
            obj_.build(child_)
            self.Configuration.append(obj_)
            obj_.original_tagname_ = 'Configuration'
        else:
            obj_ = self.gds_build_any(child_, 'DeploymentOptionSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(DeploymentOptionSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class DeploymentOptionSection_Type


class cimDateTime(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CIM_DateTime=None, Interval=None, Date=None, Time=None, Datetime=None):
        self.original_tagname_ = None
        self.CIM_DateTime = CIM_DateTime
        self.Interval = Interval
        if isinstance(Date, basestring):
            initvalue_ = datetime_.datetime.strptime(Date, '%Y-%m-%d').date()
        else:
            initvalue_ = Date
        self.Date = initvalue_
        if isinstance(Time, basestring):
            initvalue_ = datetime_.datetime.strptime(Time, '%H:%M:%S').time()
        else:
            initvalue_ = Time
        self.Time = initvalue_
        if isinstance(Datetime, basestring):
            initvalue_ = datetime_.datetime.strptime(Datetime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Datetime
        self.Datetime = initvalue_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimDateTime.subclass:
            return cimDateTime.subclass(*args_, **kwargs_)
        else:
            return cimDateTime(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CIM_DateTime(self): return self.CIM_DateTime
    def set_CIM_DateTime(self, CIM_DateTime): self.CIM_DateTime = CIM_DateTime
    def get_Interval(self): return self.Interval
    def set_Interval(self, Interval): self.Interval = Interval
    def get_Date(self): return self.Date
    def set_Date(self, Date): self.Date = Date
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_Datetime(self): return self.Datetime
    def set_Datetime(self, Datetime): self.Datetime = Datetime
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.CIM_DateTime is not None or
            self.Interval is not None or
            self.Date is not None or
            self.Time is not None or
            self.Datetime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimDateTime', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimDateTime')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimDateTime', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimDateTime'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimDateTime', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CIM_DateTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCIM_DateTime>%s</%sCIM_DateTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.CIM_DateTime).encode(ExternalEncoding), input_name='CIM_DateTime'), namespace_, eol_))
        if self.Interval is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInterval>%s</%sInterval>%s' % (namespace_, self.gds_format_string(quote_xml(self.Interval).encode(ExternalEncoding), input_name='Interval'), namespace_, eol_))
        if self.Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDate>%s</%sDate>%s' % (namespace_, self.gds_format_date(self.Date, input_name='Date'), namespace_, eol_))
        if self.Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTime>%s</%sTime>%s' % (namespace_, self.gds_format_time(self.Time, input_name='Time'), namespace_, eol_))
        if self.Datetime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDatetime>%s</%sDatetime>%s' % (namespace_, self.gds_format_datetime(self.Datetime, input_name='Datetime'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='cimDateTime'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CIM_DateTime is not None:
            showIndent(outfile, level)
            outfile.write('CIM_DateTime=%s,\n' % quote_python(self.CIM_DateTime).encode(ExternalEncoding))
        if self.Interval is not None:
            showIndent(outfile, level)
            outfile.write('Interval=%s,\n' % quote_python(self.Interval).encode(ExternalEncoding))
        if self.Date is not None:
            showIndent(outfile, level)
            outfile.write('Date=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.Date, input_name='Date'))
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=model_.GeneratedsSuper.gds_parse_time("%s"),\n' % self.gds_format_time(self.Time, input_name='Time'))
        if self.Datetime is not None:
            showIndent(outfile, level)
            outfile.write('Datetime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.Datetime, input_name='Datetime'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CIM_DateTime':
            CIM_DateTime_ = child_.text
            CIM_DateTime_ = self.gds_validate_string(CIM_DateTime_, node, 'CIM_DateTime')
            self.CIM_DateTime = CIM_DateTime_
        elif nodeName_ == 'Interval':
            Interval_ = child_.text
            Interval_ = self.gds_validate_string(Interval_, node, 'Interval')
            self.Interval = Interval_
        elif nodeName_ == 'Date':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.Date = dval_
        elif nodeName_ == 'Time':
            sval_ = child_.text
            dval_ = self.gds_parse_time(sval_)
            self.Time = dval_
        elif nodeName_ == 'Datetime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Datetime = dval_
# end class cimDateTime


class cimUnsignedByte(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimUnsignedByte.subclass:
            return cimUnsignedByte.subclass(*args_, **kwargs_)
        else:
            return cimUnsignedByte(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimUnsignedByte', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimUnsignedByte')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimUnsignedByte', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimUnsignedByte'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimUnsignedByte', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimUnsignedByte'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimUnsignedByte


class cimByte(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimByte.subclass:
            return cimByte.subclass(*args_, **kwargs_)
        else:
            return cimByte(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimByte', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimByte')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimByte', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimByte'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimByte', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimByte'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimByte


class cimUnsignedShort(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimUnsignedShort.subclass:
            return cimUnsignedShort.subclass(*args_, **kwargs_)
        else:
            return cimUnsignedShort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimUnsignedShort', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimUnsignedShort')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimUnsignedShort', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimUnsignedShort'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimUnsignedShort', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimUnsignedShort'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimUnsignedShort


class cimShort(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimShort.subclass:
            return cimShort.subclass(*args_, **kwargs_)
        else:
            return cimShort(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimShort', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimShort')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimShort', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimShort'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimShort', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimShort'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimShort


class cimUnsignedInt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cimUnsignedInt.subclass:
            return cimUnsignedInt.subclass(*args_, **kwargs_)
        else:
            return cimUnsignedInt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimUnsignedInt', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimUnsignedInt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimUnsignedInt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimUnsignedInt'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimUnsignedInt', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimUnsignedInt'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimUnsignedInt


class cimInt(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimInt.subclass:
            return cimInt.subclass(*args_, **kwargs_)
        else:
            return cimInt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimInt', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimInt')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimInt', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimInt'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimInt', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimInt'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimInt


class cimUnsignedLong(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimUnsignedLong.subclass:
            return cimUnsignedLong.subclass(*args_, **kwargs_)
        else:
            return cimUnsignedLong(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimUnsignedLong', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimUnsignedLong')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimUnsignedLong', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimUnsignedLong'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimUnsignedLong', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimUnsignedLong'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimUnsignedLong


class cimLong(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cimLong.subclass:
            return cimLong.subclass(*args_, **kwargs_)
        else:
            return cimLong(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimLong', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimLong')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimLong', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimLong'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimLong', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimLong'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimLong


class cimString(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cimString.subclass:
            return cimString.subclass(*args_, **kwargs_)
        else:
            return cimString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimString', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimString')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimString', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimString'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimString', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimString'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimString


class cimBoolean(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cimBoolean.subclass:
            return cimBoolean.subclass(*args_, **kwargs_)
        else:
            return cimBoolean(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimBoolean', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimBoolean')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimBoolean', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimBoolean'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimBoolean', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimBoolean'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimBoolean


class cimFloat(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimFloat.subclass:
            return cimFloat.subclass(*args_, **kwargs_)
        else:
            return cimFloat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimFloat', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimFloat')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimFloat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimFloat'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimFloat', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimFloat'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimFloat


class cimDouble(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimDouble.subclass:
            return cimDouble.subclass(*args_, **kwargs_)
        else:
            return cimDouble(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimDouble', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimDouble')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimDouble', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimDouble'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimDouble', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimDouble'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimDouble


class cimChar16(cimString):
    subclass = None
    superclass = cimString
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(cimChar16, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimChar16.subclass:
            return cimChar16.subclass(*args_, **kwargs_)
        else:
            return cimChar16(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(cimChar16, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimChar16', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimChar16')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimChar16', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimChar16'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(cimChar16, self).exportAttributes(outfile, level, already_processed, namespace_, name_='cimChar16')
    def exportChildren(self, outfile, level, namespace_='', name_='cimChar16', fromsubclass_=False, pretty_print=True):
        super(cimChar16, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='cimChar16'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(cimChar16, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(cimChar16, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(cimChar16, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimChar16


class cimBase64Binary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimBase64Binary.subclass:
            return cimBase64Binary.subclass(*args_, **kwargs_)
        else:
            return cimBase64Binary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimBase64Binary', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimBase64Binary')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimBase64Binary', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimBase64Binary'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimBase64Binary', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimBase64Binary'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimBase64Binary


class cimReference(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimReference.subclass:
            return cimReference.subclass(*args_, **kwargs_)
        else:
            return cimReference(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimReference', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimReference')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimReference', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimReference'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimReference', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='cimReference'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        obj_ = self.gds_build_any(child_, 'cimReference')
        if obj_ is not None:
            self.add_anytypeobjs_(obj_)
# end class cimReference


class cimHexBinary(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if cimHexBinary.subclass:
            return cimHexBinary.subclass(*args_, **kwargs_)
        else:
            return cimHexBinary(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimHexBinary', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimHexBinary')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimHexBinary', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimHexBinary'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimHexBinary', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimHexBinary'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimHexBinary


class cimAnySimpleType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if cimAnySimpleType.subclass:
            return cimAnySimpleType.subclass(*args_, **kwargs_)
        else:
            return cimAnySimpleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='cimAnySimpleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cimAnySimpleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='cimAnySimpleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='cimAnySimpleType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='cimAnySimpleType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='cimAnySimpleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cimAnySimpleType


class qualifierString(cimString):
    subclass = None
    superclass = cimString
    def __init__(self, qualifier=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        super(qualifierString, self).__init__(valueOf_, extensiontype_, )
        self.qualifier = _cast(None, qualifier)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if qualifierString.subclass:
            return qualifierString.subclass(*args_, **kwargs_)
        else:
            return qualifierString(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(qualifierString, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qualifierString', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierString')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qualifierString', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qualifierString'):
        super(qualifierString, self).exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierString')
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier=%s' % (self.gds_format_string(quote_attrib(self.qualifier).encode(ExternalEncoding), input_name='qualifier'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='qualifierString', fromsubclass_=False, pretty_print=True):
        super(qualifierString, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='qualifierString'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            showIndent(outfile, level)
            outfile.write('qualifier="%s",\n' % (self.qualifier,))
        super(qualifierString, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(qualifierString, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            self.qualifier = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(qualifierString, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qualifierString


class qualifierBoolean(cimBoolean):
    subclass = None
    superclass = cimBoolean
    def __init__(self, qualifier=None, valueOf_=None):
        self.original_tagname_ = None
        super(qualifierBoolean, self).__init__(valueOf_, )
        self.qualifier = _cast(None, qualifier)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if qualifierBoolean.subclass:
            return qualifierBoolean.subclass(*args_, **kwargs_)
        else:
            return qualifierBoolean(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(qualifierBoolean, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qualifierBoolean', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierBoolean')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qualifierBoolean', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qualifierBoolean'):
        super(qualifierBoolean, self).exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierBoolean')
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier=%s' % (self.gds_format_string(quote_attrib(self.qualifier).encode(ExternalEncoding), input_name='qualifier'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='qualifierBoolean', fromsubclass_=False, pretty_print=True):
        super(qualifierBoolean, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='qualifierBoolean'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            showIndent(outfile, level)
            outfile.write('qualifier="%s",\n' % (self.qualifier,))
        super(qualifierBoolean, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(qualifierBoolean, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            self.qualifier = value
        super(qualifierBoolean, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qualifierBoolean


class qualifierUInt32(cimUnsignedInt):
    subclass = None
    superclass = cimUnsignedInt
    def __init__(self, qualifier=None, valueOf_=None):
        self.original_tagname_ = None
        super(qualifierUInt32, self).__init__(valueOf_, )
        self.qualifier = _cast(None, qualifier)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if qualifierUInt32.subclass:
            return qualifierUInt32.subclass(*args_, **kwargs_)
        else:
            return qualifierUInt32(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(qualifierUInt32, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qualifierUInt32', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierUInt32')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qualifierUInt32', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qualifierUInt32'):
        super(qualifierUInt32, self).exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierUInt32')
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier=%s' % (self.gds_format_string(quote_attrib(self.qualifier).encode(ExternalEncoding), input_name='qualifier'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='qualifierUInt32', fromsubclass_=False, pretty_print=True):
        super(qualifierUInt32, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='qualifierUInt32'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            showIndent(outfile, level)
            outfile.write('qualifier="%s",\n' % (self.qualifier,))
        super(qualifierUInt32, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(qualifierUInt32, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            self.qualifier = value
        super(qualifierUInt32, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qualifierUInt32


class qualifierSInt64(cimLong):
    subclass = None
    superclass = cimLong
    def __init__(self, qualifier=None, valueOf_=None):
        self.original_tagname_ = None
        super(qualifierSInt64, self).__init__(valueOf_, )
        self.qualifier = _cast(None, qualifier)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if qualifierSInt64.subclass:
            return qualifierSInt64.subclass(*args_, **kwargs_)
        else:
            return qualifierSInt64(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qualifier(self): return self.qualifier
    def set_qualifier(self, qualifier): self.qualifier = qualifier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(qualifierSInt64, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qualifierSInt64', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierSInt64')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qualifierSInt64', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qualifierSInt64'):
        super(qualifierSInt64, self).exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierSInt64')
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            outfile.write(' qualifier=%s' % (self.gds_format_string(quote_attrib(self.qualifier).encode(ExternalEncoding), input_name='qualifier'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='qualifierSInt64', fromsubclass_=False, pretty_print=True):
        super(qualifierSInt64, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='qualifierSInt64'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.qualifier is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            showIndent(outfile, level)
            outfile.write('qualifier="%s",\n' % (self.qualifier,))
        super(qualifierSInt64, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(qualifierSInt64, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('qualifier', node)
        if value is not None and 'qualifier' not in already_processed:
            already_processed.add('qualifier')
            self.qualifier = value
        super(qualifierSInt64, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class qualifierSInt64


class qualifierSArray(qualifierString):
    subclass = None
    superclass = qualifierString
    def __init__(self, qualifier=None):
        self.original_tagname_ = None
        super(qualifierSArray, self).__init__(qualifier, )
    def factory(*args_, **kwargs_):
        if qualifierSArray.subclass:
            return qualifierSArray.subclass(*args_, **kwargs_)
        else:
            return qualifierSArray(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(qualifierSArray, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='qualifierSArray', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierSArray')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='qualifierSArray', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='qualifierSArray'):
        super(qualifierSArray, self).exportAttributes(outfile, level, already_processed, namespace_, name_='qualifierSArray')
    def exportChildren(self, outfile, level, namespace_='', name_='qualifierSArray', fromsubclass_=False, pretty_print=True):
        super(qualifierSArray, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='qualifierSArray'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(qualifierSArray, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(qualifierSArray, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(qualifierSArray, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(qualifierSArray, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class qualifierSArray


class AutomaticStartupAction(cimAnySimpleType):
    subclass = None
    superclass = cimAnySimpleType
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(AutomaticStartupAction, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if AutomaticStartupAction.subclass:
            return AutomaticStartupAction.subclass(*args_, **kwargs_)
        else:
            return AutomaticStartupAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AutomaticStartupAction, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AutomaticStartupAction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticStartupAction')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AutomaticStartupAction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AutomaticStartupAction'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(AutomaticStartupAction, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticStartupAction')
    def exportChildren(self, outfile, level, namespace_='', name_='AutomaticStartupAction', fromsubclass_=False, pretty_print=True):
        super(AutomaticStartupAction, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AutomaticStartupAction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(AutomaticStartupAction, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AutomaticStartupAction, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(AutomaticStartupAction, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AutomaticStartupAction


class AutomaticShutdownAction(cimAnySimpleType):
    subclass = None
    superclass = cimAnySimpleType
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(AutomaticShutdownAction, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if AutomaticShutdownAction.subclass:
            return AutomaticShutdownAction.subclass(*args_, **kwargs_)
        else:
            return AutomaticShutdownAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AutomaticShutdownAction, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AutomaticShutdownAction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticShutdownAction')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AutomaticShutdownAction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AutomaticShutdownAction'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(AutomaticShutdownAction, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticShutdownAction')
    def exportChildren(self, outfile, level, namespace_='', name_='AutomaticShutdownAction', fromsubclass_=False, pretty_print=True):
        super(AutomaticShutdownAction, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AutomaticShutdownAction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(AutomaticShutdownAction, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AutomaticShutdownAction, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(AutomaticShutdownAction, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AutomaticShutdownAction


class AutomaticRecoveryAction(cimAnySimpleType):
    subclass = None
    superclass = cimAnySimpleType
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(AutomaticRecoveryAction, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if AutomaticRecoveryAction.subclass:
            return AutomaticRecoveryAction.subclass(*args_, **kwargs_)
        else:
            return AutomaticRecoveryAction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(AutomaticRecoveryAction, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AutomaticRecoveryAction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticRecoveryAction')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AutomaticRecoveryAction', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AutomaticRecoveryAction'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(AutomaticRecoveryAction, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AutomaticRecoveryAction')
    def exportChildren(self, outfile, level, namespace_='', name_='AutomaticRecoveryAction', fromsubclass_=False, pretty_print=True):
        super(AutomaticRecoveryAction, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AutomaticRecoveryAction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(AutomaticRecoveryAction, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AutomaticRecoveryAction, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(AutomaticRecoveryAction, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AutomaticRecoveryAction


class Caption(cimString):
    subclass = None
    superclass = cimString
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(Caption, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Caption.subclass:
            return Caption.subclass(*args_, **kwargs_)
        else:
            return Caption(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(Caption, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Caption', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Caption')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Caption', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Caption'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(Caption, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Caption')
    def exportChildren(self, outfile, level, namespace_='', name_='Caption', fromsubclass_=False, pretty_print=True):
        super(Caption, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='Caption'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(Caption, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Caption, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(Caption, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Caption


class CIM_VirtualSystemSettingData_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, AutomaticRecoveryAction=None, AutomaticShutdownAction=None, AutomaticStartupAction=None, AutomaticStartupActionDelay=None, AutomaticStartupActionSequenceNumber=None, Caption=None, ConfigurationDataRoot=None, ConfigurationFile=None, ConfigurationID=None, CreationTime=None, Description=None, ElementName=None, InstanceID=None, LogDataRoot=None, Notes=None, RecoveryFile=None, SnapshotDataRoot=None, SuspendDataRoot=None, SwapFileDataRoot=None, VirtualSystemIdentifier=None, VirtualSystemType=None, anytypeobjs_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.AutomaticRecoveryAction = AutomaticRecoveryAction
        self.AutomaticShutdownAction = AutomaticShutdownAction
        self.AutomaticStartupAction = AutomaticStartupAction
        self.AutomaticStartupActionDelay = AutomaticStartupActionDelay
        self.AutomaticStartupActionSequenceNumber = AutomaticStartupActionSequenceNumber
        self.Caption = Caption
        self.ConfigurationDataRoot = ConfigurationDataRoot
        self.ConfigurationFile = ConfigurationFile
        self.ConfigurationID = ConfigurationID
        self.CreationTime = CreationTime
        self.Description = Description
        self.ElementName = ElementName
        self.InstanceID = InstanceID
        self.LogDataRoot = LogDataRoot
        if Notes is None:
            self.Notes = []
        else:
            self.Notes = Notes
        self.RecoveryFile = RecoveryFile
        self.SnapshotDataRoot = SnapshotDataRoot
        self.SuspendDataRoot = SuspendDataRoot
        self.SwapFileDataRoot = SwapFileDataRoot
        self.VirtualSystemIdentifier = VirtualSystemIdentifier
        self.VirtualSystemType = VirtualSystemType
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CIM_VirtualSystemSettingData_Type.subclass:
            return CIM_VirtualSystemSettingData_Type.subclass(*args_, **kwargs_)
        else:
            return CIM_VirtualSystemSettingData_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AutomaticRecoveryAction(self): return self.AutomaticRecoveryAction
    def set_AutomaticRecoveryAction(self, AutomaticRecoveryAction): self.AutomaticRecoveryAction = AutomaticRecoveryAction
    def get_AutomaticShutdownAction(self): return self.AutomaticShutdownAction
    def set_AutomaticShutdownAction(self, AutomaticShutdownAction): self.AutomaticShutdownAction = AutomaticShutdownAction
    def get_AutomaticStartupAction(self): return self.AutomaticStartupAction
    def set_AutomaticStartupAction(self, AutomaticStartupAction): self.AutomaticStartupAction = AutomaticStartupAction
    def get_AutomaticStartupActionDelay(self): return self.AutomaticStartupActionDelay
    def set_AutomaticStartupActionDelay(self, AutomaticStartupActionDelay): self.AutomaticStartupActionDelay = AutomaticStartupActionDelay
    def get_AutomaticStartupActionSequenceNumber(self): return self.AutomaticStartupActionSequenceNumber
    def set_AutomaticStartupActionSequenceNumber(self, AutomaticStartupActionSequenceNumber): self.AutomaticStartupActionSequenceNumber = AutomaticStartupActionSequenceNumber
    def get_Caption(self): return self.Caption
    def set_Caption(self, Caption): self.Caption = Caption
    def get_ConfigurationDataRoot(self): return self.ConfigurationDataRoot
    def set_ConfigurationDataRoot(self, ConfigurationDataRoot): self.ConfigurationDataRoot = ConfigurationDataRoot
    def get_ConfigurationFile(self): return self.ConfigurationFile
    def set_ConfigurationFile(self, ConfigurationFile): self.ConfigurationFile = ConfigurationFile
    def get_ConfigurationID(self): return self.ConfigurationID
    def set_ConfigurationID(self, ConfigurationID): self.ConfigurationID = ConfigurationID
    def get_CreationTime(self): return self.CreationTime
    def set_CreationTime(self, CreationTime): self.CreationTime = CreationTime
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ElementName(self): return self.ElementName
    def set_ElementName(self, ElementName): self.ElementName = ElementName
    def get_InstanceID(self): return self.InstanceID
    def set_InstanceID(self, InstanceID): self.InstanceID = InstanceID
    def get_LogDataRoot(self): return self.LogDataRoot
    def set_LogDataRoot(self, LogDataRoot): self.LogDataRoot = LogDataRoot
    def get_Notes(self): return self.Notes
    def set_Notes(self, Notes): self.Notes = Notes
    def add_Notes(self, value): self.Notes.append(value)
    def insert_Notes_at(self, index, value): self.Notes.insert(index, value)
    def replace_Notes_at(self, index, value): self.Notes[index] = value
    def get_RecoveryFile(self): return self.RecoveryFile
    def set_RecoveryFile(self, RecoveryFile): self.RecoveryFile = RecoveryFile
    def get_SnapshotDataRoot(self): return self.SnapshotDataRoot
    def set_SnapshotDataRoot(self, SnapshotDataRoot): self.SnapshotDataRoot = SnapshotDataRoot
    def get_SuspendDataRoot(self): return self.SuspendDataRoot
    def set_SuspendDataRoot(self, SuspendDataRoot): self.SuspendDataRoot = SuspendDataRoot
    def get_SwapFileDataRoot(self): return self.SwapFileDataRoot
    def set_SwapFileDataRoot(self, SwapFileDataRoot): self.SwapFileDataRoot = SwapFileDataRoot
    def get_VirtualSystemIdentifier(self): return self.VirtualSystemIdentifier
    def set_VirtualSystemIdentifier(self, VirtualSystemIdentifier): self.VirtualSystemIdentifier = VirtualSystemIdentifier
    def get_VirtualSystemType(self): return self.VirtualSystemType
    def set_VirtualSystemType(self, VirtualSystemType): self.VirtualSystemType = VirtualSystemType
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_AutomaticRecoveryAction(self, value):
        # Validate type AutomaticRecoveryAction, a restriction on xs:unsignedShort.
        pass
    def validate_AutomaticShutdownAction(self, value):
        # Validate type AutomaticShutdownAction, a restriction on xs:unsignedShort.
        pass
    def validate_AutomaticStartupAction(self, value):
        # Validate type AutomaticStartupAction, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.AutomaticRecoveryAction is not None or
            self.AutomaticShutdownAction is not None or
            self.AutomaticStartupAction is not None or
            self.AutomaticStartupActionDelay is not None or
            self.AutomaticStartupActionSequenceNumber is not None or
            self.Caption is not None or
            self.ConfigurationDataRoot is not None or
            self.ConfigurationFile is not None or
            self.ConfigurationID is not None or
            self.CreationTime is not None or
            self.Description is not None or
            self.ElementName is not None or
            self.InstanceID is not None or
            self.LogDataRoot is not None or
            self.Notes or
            self.RecoveryFile is not None or
            self.SnapshotDataRoot is not None or
            self.SuspendDataRoot is not None or
            self.SwapFileDataRoot is not None or
            self.VirtualSystemIdentifier is not None or
            self.VirtualSystemType is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CIM_VirtualSystemSettingData_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CIM_VirtualSystemSettingData_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CIM_VirtualSystemSettingData_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CIM_VirtualSystemSettingData_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CIM_VirtualSystemSettingData_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AutomaticRecoveryAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAutomaticRecoveryAction>%s</%sAutomaticRecoveryAction>%s' % (namespace_, self.gds_format_integer(self.AutomaticRecoveryAction, input_name='AutomaticRecoveryAction'), namespace_, eol_))
        if self.AutomaticShutdownAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAutomaticShutdownAction>%s</%sAutomaticShutdownAction>%s' % (namespace_, self.gds_format_integer(self.AutomaticShutdownAction, input_name='AutomaticShutdownAction'), namespace_, eol_))
        if self.AutomaticStartupAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAutomaticStartupAction>%s</%sAutomaticStartupAction>%s' % (namespace_, self.gds_format_integer(self.AutomaticStartupAction, input_name='AutomaticStartupAction'), namespace_, eol_))
        if self.AutomaticStartupActionDelay is not None:
            self.AutomaticStartupActionDelay.export(outfile, level, namespace_='class:', name_='AutomaticStartupActionDelay', pretty_print=pretty_print)
        if self.AutomaticStartupActionSequenceNumber is not None:
            self.AutomaticStartupActionSequenceNumber.export(outfile, level, namespace_='class:', name_='AutomaticStartupActionSequenceNumber', pretty_print=pretty_print)
        if self.Caption is not None:
            self.Caption.export(outfile, level, namespace_='class:', name_='Caption', pretty_print=pretty_print)
        if self.ConfigurationDataRoot is not None:
            self.ConfigurationDataRoot.export(outfile, level, namespace_='class:', name_='ConfigurationDataRoot', pretty_print=pretty_print)
        if self.ConfigurationFile is not None:
            self.ConfigurationFile.export(outfile, level, namespace_='class:', name_='ConfigurationFile', pretty_print=pretty_print)
        if self.ConfigurationID is not None:
            self.ConfigurationID.export(outfile, level, namespace_='class:', name_='ConfigurationID', pretty_print=pretty_print)
        if self.CreationTime is not None:
            self.CreationTime.export(outfile, level, namespace_='class:', name_='CreationTime', pretty_print=pretty_print)
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_='class:', name_='Description', pretty_print=pretty_print)
        if self.ElementName is not None:
            self.ElementName.export(outfile, level, namespace_='class:', name_='ElementName', pretty_print=pretty_print)
        if self.InstanceID is not None:
            self.InstanceID.export(outfile, level, namespace_='class:', name_='InstanceID', pretty_print=pretty_print)
        if self.LogDataRoot is not None:
            self.LogDataRoot.export(outfile, level, namespace_='class:', name_='LogDataRoot', pretty_print=pretty_print)
        for Notes_ in self.Notes:
            Notes_.export(outfile, level, namespace_='class:', name_='Notes', pretty_print=pretty_print)
        if self.RecoveryFile is not None:
            self.RecoveryFile.export(outfile, level, namespace_='class:', name_='RecoveryFile', pretty_print=pretty_print)
        if self.SnapshotDataRoot is not None:
            self.SnapshotDataRoot.export(outfile, level, namespace_='class:', name_='SnapshotDataRoot', pretty_print=pretty_print)
        if self.SuspendDataRoot is not None:
            self.SuspendDataRoot.export(outfile, level, namespace_='class:', name_='SuspendDataRoot', pretty_print=pretty_print)
        if self.SwapFileDataRoot is not None:
            self.SwapFileDataRoot.export(outfile, level, namespace_='class:', name_='SwapFileDataRoot', pretty_print=pretty_print)
        if self.VirtualSystemIdentifier is not None:
            self.VirtualSystemIdentifier.export(outfile, level, namespace_='class:', name_='VirtualSystemIdentifier', pretty_print=pretty_print)
        if self.VirtualSystemType is not None:
            self.VirtualSystemType.export(outfile, level, namespace_='class:', name_='VirtualSystemType', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CIM_VirtualSystemSettingData_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AutomaticRecoveryAction is not None:
            showIndent(outfile, level)
            outfile.write('AutomaticRecoveryAction=%d,\n' % self.AutomaticRecoveryAction)
        if self.AutomaticShutdownAction is not None:
            showIndent(outfile, level)
            outfile.write('AutomaticShutdownAction=%d,\n' % self.AutomaticShutdownAction)
        if self.AutomaticStartupAction is not None:
            showIndent(outfile, level)
            outfile.write('AutomaticStartupAction=%d,\n' % self.AutomaticStartupAction)
        if self.AutomaticStartupActionDelay is not None:
            showIndent(outfile, level)
            outfile.write('AutomaticStartupActionDelay=model_.AutomaticStartupActionDelay(\n')
            self.AutomaticStartupActionDelay.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AutomaticStartupActionSequenceNumber is not None:
            showIndent(outfile, level)
            outfile.write('AutomaticStartupActionSequenceNumber=model_.AutomaticStartupActionSequenceNumber(\n')
            self.AutomaticStartupActionSequenceNumber.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Caption is not None:
            showIndent(outfile, level)
            outfile.write('Caption=model_.Caption(\n')
            self.Caption.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ConfigurationDataRoot is not None:
            showIndent(outfile, level)
            outfile.write('ConfigurationDataRoot=model_.ConfigurationDataRoot(\n')
            self.ConfigurationDataRoot.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ConfigurationFile is not None:
            showIndent(outfile, level)
            outfile.write('ConfigurationFile=model_.ConfigurationFile(\n')
            self.ConfigurationFile.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ConfigurationID is not None:
            showIndent(outfile, level)
            outfile.write('ConfigurationID=model_.ConfigurationID(\n')
            self.ConfigurationID.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CreationTime is not None:
            showIndent(outfile, level)
            outfile.write('CreationTime=model_.CreationTime(\n')
            self.CreationTime.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Description(\n')
            self.Description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ElementName is not None:
            showIndent(outfile, level)
            outfile.write('ElementName=model_.ElementName(\n')
            self.ElementName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.InstanceID is not None:
            showIndent(outfile, level)
            outfile.write('InstanceID=model_.InstanceID(\n')
            self.InstanceID.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LogDataRoot is not None:
            showIndent(outfile, level)
            outfile.write('LogDataRoot=model_.LogDataRoot(\n')
            self.LogDataRoot.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Notes=[\n')
        level += 1
        for Notes_ in self.Notes:
            showIndent(outfile, level)
            outfile.write('model_.Notes(\n')
            Notes_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.RecoveryFile is not None:
            showIndent(outfile, level)
            outfile.write('RecoveryFile=model_.RecoveryFile(\n')
            self.RecoveryFile.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SnapshotDataRoot is not None:
            showIndent(outfile, level)
            outfile.write('SnapshotDataRoot=model_.SnapshotDataRoot(\n')
            self.SnapshotDataRoot.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SuspendDataRoot is not None:
            showIndent(outfile, level)
            outfile.write('SuspendDataRoot=model_.SuspendDataRoot(\n')
            self.SuspendDataRoot.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SwapFileDataRoot is not None:
            showIndent(outfile, level)
            outfile.write('SwapFileDataRoot=model_.SwapFileDataRoot(\n')
            self.SwapFileDataRoot.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VirtualSystemIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('VirtualSystemIdentifier=model_.VirtualSystemIdentifier(\n')
            self.VirtualSystemIdentifier.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VirtualSystemType is not None:
            showIndent(outfile, level)
            outfile.write('VirtualSystemType=model_.VirtualSystemType(\n')
            self.VirtualSystemType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AutomaticRecoveryAction':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AutomaticRecoveryAction')
            self.AutomaticRecoveryAction = ival_
            self.validate_AutomaticRecoveryAction(self.AutomaticRecoveryAction)    # validate type AutomaticRecoveryAction
        elif nodeName_ == 'AutomaticShutdownAction':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AutomaticShutdownAction')
            self.AutomaticShutdownAction = ival_
            self.validate_AutomaticShutdownAction(self.AutomaticShutdownAction)    # validate type AutomaticShutdownAction
        elif nodeName_ == 'AutomaticStartupAction':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AutomaticStartupAction')
            self.AutomaticStartupAction = ival_
            self.validate_AutomaticStartupAction(self.AutomaticStartupAction)    # validate type AutomaticStartupAction
        elif nodeName_ == 'AutomaticStartupActionDelay':
            obj_ = cimDateTime.factory()
            obj_.build(child_)
            self.AutomaticStartupActionDelay = obj_
            obj_.original_tagname_ = 'AutomaticStartupActionDelay'
        elif nodeName_ == 'AutomaticStartupActionSequenceNumber':
            obj_ = cimUnsignedShort.factory()
            obj_.build(child_)
            self.AutomaticStartupActionSequenceNumber = obj_
            obj_.original_tagname_ = 'AutomaticStartupActionSequenceNumber'
        elif nodeName_ == 'Caption':
            obj_ = Caption.factory()
            obj_.build(child_)
            self.Caption = obj_
            obj_.original_tagname_ = 'Caption'
        elif nodeName_ == 'ConfigurationDataRoot':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ConfigurationDataRoot = obj_
            obj_.original_tagname_ = 'ConfigurationDataRoot'
        elif nodeName_ == 'ConfigurationFile':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ConfigurationFile = obj_
            obj_.original_tagname_ = 'ConfigurationFile'
        elif nodeName_ == 'ConfigurationID':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ConfigurationID = obj_
            obj_.original_tagname_ = 'ConfigurationID'
        elif nodeName_ == 'CreationTime':
            obj_ = cimDateTime.factory()
            obj_.build(child_)
            self.CreationTime = obj_
            obj_.original_tagname_ = 'CreationTime'
        elif nodeName_ == 'Description':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'ElementName':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ElementName = obj_
            obj_.original_tagname_ = 'ElementName'
        elif nodeName_ == 'InstanceID':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.InstanceID = obj_
            obj_.original_tagname_ = 'InstanceID'
        elif nodeName_ == 'LogDataRoot':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.LogDataRoot = obj_
            obj_.original_tagname_ = 'LogDataRoot'
        elif nodeName_ == 'Notes':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Notes.append(obj_)
            obj_.original_tagname_ = 'Notes'
        elif nodeName_ == 'RecoveryFile':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.RecoveryFile = obj_
            obj_.original_tagname_ = 'RecoveryFile'
        elif nodeName_ == 'SnapshotDataRoot':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.SnapshotDataRoot = obj_
            obj_.original_tagname_ = 'SnapshotDataRoot'
        elif nodeName_ == 'SuspendDataRoot':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.SuspendDataRoot = obj_
            obj_.original_tagname_ = 'SuspendDataRoot'
        elif nodeName_ == 'SwapFileDataRoot':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.SwapFileDataRoot = obj_
            obj_.original_tagname_ = 'SwapFileDataRoot'
        elif nodeName_ == 'VirtualSystemIdentifier':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VirtualSystemIdentifier = obj_
            obj_.original_tagname_ = 'VirtualSystemIdentifier'
        elif nodeName_ == 'VirtualSystemType':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VirtualSystemType = obj_
            obj_.original_tagname_ = 'VirtualSystemType'
        else:
            obj_ = self.gds_build_any(child_, 'CIM_VirtualSystemSettingData_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class CIM_VirtualSystemSettingData_Type


class ConsumerVisibility(cimAnySimpleType):
    subclass = None
    superclass = cimAnySimpleType
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(ConsumerVisibility, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ConsumerVisibility.subclass:
            return ConsumerVisibility.subclass(*args_, **kwargs_)
        else:
            return ConsumerVisibility(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(ConsumerVisibility, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConsumerVisibility', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConsumerVisibility')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConsumerVisibility', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConsumerVisibility'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(ConsumerVisibility, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConsumerVisibility')
    def exportChildren(self, outfile, level, namespace_='', name_='ConsumerVisibility', fromsubclass_=False, pretty_print=True):
        super(ConsumerVisibility, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ConsumerVisibility'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(ConsumerVisibility, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConsumerVisibility, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(ConsumerVisibility, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ConsumerVisibility


class MappingBehavior(cimAnySimpleType):
    subclass = None
    superclass = cimAnySimpleType
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        super(MappingBehavior, self).__init__(valueOf_, )
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if MappingBehavior.subclass:
            return MappingBehavior.subclass(*args_, **kwargs_)
        else:
            return MappingBehavior(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(MappingBehavior, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MappingBehavior', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MappingBehavior')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MappingBehavior', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MappingBehavior'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(MappingBehavior, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MappingBehavior')
    def exportChildren(self, outfile, level, namespace_='', name_='MappingBehavior', fromsubclass_=False, pretty_print=True):
        super(MappingBehavior, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='MappingBehavior'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(MappingBehavior, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MappingBehavior, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(MappingBehavior, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MappingBehavior


class CIM_ResourceAllocationSettingData_Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Address=None, AddressOnParent=None, AllocationUnits=None, AutomaticAllocation=None, AutomaticDeallocation=None, Caption=None, Connection=None, ConsumerVisibility=None, Description=None, ElementName=None, HostResource=None, InstanceID=None, Limit=None, MappingBehavior=None, OtherResourceType=None, Parent=None, PoolID=None, Reservation=None, ResourceSubType=None, ResourceType=None, VirtualQuantity=None, VirtualQuantityUnits=None, Weight=None, anytypeobjs_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.Address = Address
        self.AddressOnParent = AddressOnParent
        self.AllocationUnits = AllocationUnits
        self.AutomaticAllocation = AutomaticAllocation
        self.AutomaticDeallocation = AutomaticDeallocation
        self.Caption = Caption
        if Connection is None:
            self.Connection = []
        else:
            self.Connection = Connection
        self.ConsumerVisibility = ConsumerVisibility
        self.Description = Description
        self.ElementName = ElementName
        if HostResource is None:
            self.HostResource = []
        else:
            self.HostResource = HostResource
        self.InstanceID = InstanceID
        self.Limit = Limit
        self.MappingBehavior = MappingBehavior
        self.OtherResourceType = OtherResourceType
        self.Parent = Parent
        self.PoolID = PoolID
        self.Reservation = Reservation
        self.ResourceSubType = ResourceSubType
        self.ResourceType = ResourceType
        self.VirtualQuantity = VirtualQuantity
        self.VirtualQuantityUnits = VirtualQuantityUnits
        self.Weight = Weight
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CIM_ResourceAllocationSettingData_Type.subclass:
            return CIM_ResourceAllocationSettingData_Type.subclass(*args_, **kwargs_)
        else:
            return CIM_ResourceAllocationSettingData_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_AddressOnParent(self): return self.AddressOnParent
    def set_AddressOnParent(self, AddressOnParent): self.AddressOnParent = AddressOnParent
    def get_AllocationUnits(self): return self.AllocationUnits
    def set_AllocationUnits(self, AllocationUnits): self.AllocationUnits = AllocationUnits
    def get_AutomaticAllocation(self): return self.AutomaticAllocation
    def set_AutomaticAllocation(self, AutomaticAllocation): self.AutomaticAllocation = AutomaticAllocation
    def get_AutomaticDeallocation(self): return self.AutomaticDeallocation
    def set_AutomaticDeallocation(self, AutomaticDeallocation): self.AutomaticDeallocation = AutomaticDeallocation
    def get_Caption(self): return self.Caption
    def set_Caption(self, Caption): self.Caption = Caption
    def get_Connection(self): return self.Connection
    def set_Connection(self, Connection): self.Connection = Connection
    def add_Connection(self, value): self.Connection.append(value)
    def insert_Connection_at(self, index, value): self.Connection.insert(index, value)
    def replace_Connection_at(self, index, value): self.Connection[index] = value
    def get_ConsumerVisibility(self): return self.ConsumerVisibility
    def set_ConsumerVisibility(self, ConsumerVisibility): self.ConsumerVisibility = ConsumerVisibility
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_ElementName(self): return self.ElementName
    def set_ElementName(self, ElementName): self.ElementName = ElementName
    def get_HostResource(self): return self.HostResource
    def set_HostResource(self, HostResource): self.HostResource = HostResource
    def add_HostResource(self, value): self.HostResource.append(value)
    def insert_HostResource_at(self, index, value): self.HostResource.insert(index, value)
    def replace_HostResource_at(self, index, value): self.HostResource[index] = value
    def get_InstanceID(self): return self.InstanceID
    def set_InstanceID(self, InstanceID): self.InstanceID = InstanceID
    def get_Limit(self): return self.Limit
    def set_Limit(self, Limit): self.Limit = Limit
    def get_MappingBehavior(self): return self.MappingBehavior
    def set_MappingBehavior(self, MappingBehavior): self.MappingBehavior = MappingBehavior
    def get_OtherResourceType(self): return self.OtherResourceType
    def set_OtherResourceType(self, OtherResourceType): self.OtherResourceType = OtherResourceType
    def get_Parent(self): return self.Parent
    def set_Parent(self, Parent): self.Parent = Parent
    def get_PoolID(self): return self.PoolID
    def set_PoolID(self, PoolID): self.PoolID = PoolID
    def get_Reservation(self): return self.Reservation
    def set_Reservation(self, Reservation): self.Reservation = Reservation
    def get_ResourceSubType(self): return self.ResourceSubType
    def set_ResourceSubType(self, ResourceSubType): self.ResourceSubType = ResourceSubType
    def get_ResourceType(self): return self.ResourceType
    def set_ResourceType(self, ResourceType): self.ResourceType = ResourceType
    def get_VirtualQuantity(self): return self.VirtualQuantity
    def set_VirtualQuantity(self, VirtualQuantity): self.VirtualQuantity = VirtualQuantity
    def get_VirtualQuantityUnits(self): return self.VirtualQuantityUnits
    def set_VirtualQuantityUnits(self, VirtualQuantityUnits): self.VirtualQuantityUnits = VirtualQuantityUnits
    def get_Weight(self): return self.Weight
    def set_Weight(self, Weight): self.Weight = Weight
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ConsumerVisibility(self, value):
        # Validate type ConsumerVisibility, a restriction on xs:unsignedShort.
        pass
    def validate_MappingBehavior(self, value):
        # Validate type MappingBehavior, a restriction on xs:unsignedShort.
        pass
    def validate_ResourceType(self, value):
        # Validate type ResourceType, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.Address is not None or
            self.AddressOnParent is not None or
            self.AllocationUnits is not None or
            self.AutomaticAllocation is not None or
            self.AutomaticDeallocation is not None or
            self.Caption is not None or
            self.Connection or
            self.ConsumerVisibility is not None or
            self.Description is not None or
            self.ElementName is not None or
            self.HostResource or
            self.InstanceID is not None or
            self.Limit is not None or
            self.MappingBehavior is not None or
            self.OtherResourceType is not None or
            self.Parent is not None or
            self.PoolID is not None or
            self.Reservation is not None or
            self.ResourceSubType is not None or
            self.ResourceType is not None or
            self.VirtualQuantity is not None or
            self.VirtualQuantityUnits is not None or
            self.Weight is not None or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CIM_ResourceAllocationSettingData_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CIM_ResourceAllocationSettingData_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CIM_ResourceAllocationSettingData_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CIM_ResourceAllocationSettingData_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CIM_ResourceAllocationSettingData_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_='class:', name_='Address', pretty_print=pretty_print)
        if self.AddressOnParent is not None:
            self.AddressOnParent.export(outfile, level, namespace_='class:', name_='AddressOnParent', pretty_print=pretty_print)
        if self.AllocationUnits is not None:
            self.AllocationUnits.export(outfile, level, namespace_='class:', name_='AllocationUnits', pretty_print=pretty_print)
        if self.AutomaticAllocation is not None:
            self.AutomaticAllocation.export(outfile, level, namespace_='class:', name_='AutomaticAllocation', pretty_print=pretty_print)
        if self.AutomaticDeallocation is not None:
            self.AutomaticDeallocation.export(outfile, level, namespace_='class:', name_='AutomaticDeallocation', pretty_print=pretty_print)
        if self.Caption is not None:
            self.Caption.export(outfile, level, namespace_='class:', name_='Caption', pretty_print=pretty_print)
        for Connection_ in self.Connection:
            Connection_.export(outfile, level, namespace_='class:', name_='Connection', pretty_print=pretty_print)
        if self.ConsumerVisibility is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConsumerVisibility>%s</%sConsumerVisibility>%s' % (namespace_, self.gds_format_integer(self.ConsumerVisibility, input_name='ConsumerVisibility'), namespace_, eol_))
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_='class:', name_='Description', pretty_print=pretty_print)
        if self.ElementName is not None:
            self.ElementName.export(outfile, level, namespace_='class:', name_='ElementName', pretty_print=pretty_print)
        for HostResource_ in self.HostResource:
            HostResource_.export(outfile, level, namespace_='class:', name_='HostResource', pretty_print=pretty_print)
        if self.InstanceID is not None:
            self.InstanceID.export(outfile, level, namespace_='class:', name_='InstanceID', pretty_print=pretty_print)
        if self.Limit is not None:
            self.Limit.export(outfile, level, namespace_='class:', name_='Limit', pretty_print=pretty_print)
        if self.MappingBehavior is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMappingBehavior>%s</%sMappingBehavior>%s' % (namespace_, self.gds_format_integer(self.MappingBehavior, input_name='MappingBehavior'), namespace_, eol_))
        if self.OtherResourceType is not None:
            self.OtherResourceType.export(outfile, level, namespace_='class:', name_='OtherResourceType', pretty_print=pretty_print)
        if self.Parent is not None:
            self.Parent.export(outfile, level, namespace_='class:', name_='Parent', pretty_print=pretty_print)
        if self.PoolID is not None:
            self.PoolID.export(outfile, level, namespace_='class:', name_='PoolID', pretty_print=pretty_print)
        if self.Reservation is not None:
            self.Reservation.export(outfile, level, namespace_='class:', name_='Reservation', pretty_print=pretty_print)
        if self.ResourceSubType is not None:
            self.ResourceSubType.export(outfile, level, namespace_='class:', name_='ResourceSubType', pretty_print=pretty_print)
        if self.ResourceType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResourceType>%s</%sResourceType>%s' % (namespace_, self.gds_format_integer(self.ResourceType, input_name='ResourceType'), namespace_, eol_))
        if self.VirtualQuantity is not None:
            self.VirtualQuantity.export(outfile, level, namespace_='class:', name_='VirtualQuantity', pretty_print=pretty_print)
        if self.VirtualQuantityUnits is not None:
            self.VirtualQuantityUnits.export(outfile, level, namespace_='class:', name_='VirtualQuantityUnits', pretty_print=pretty_print)
        if self.Weight is not None:
            self.Weight.export(outfile, level, namespace_='class:', name_='Weight', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CIM_ResourceAllocationSettingData_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Address is not None:
            showIndent(outfile, level)
            outfile.write('Address=model_.Address(\n')
            self.Address.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AddressOnParent is not None:
            showIndent(outfile, level)
            outfile.write('AddressOnParent=model_.AddressOnParent(\n')
            self.AddressOnParent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AllocationUnits is not None:
            showIndent(outfile, level)
            outfile.write('AllocationUnits=model_.AllocationUnits(\n')
            self.AllocationUnits.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AutomaticAllocation is not None:
            showIndent(outfile, level)
            outfile.write('AutomaticAllocation=model_.AutomaticAllocation(\n')
            self.AutomaticAllocation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AutomaticDeallocation is not None:
            showIndent(outfile, level)
            outfile.write('AutomaticDeallocation=model_.AutomaticDeallocation(\n')
            self.AutomaticDeallocation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Caption is not None:
            showIndent(outfile, level)
            outfile.write('Caption=model_.Caption(\n')
            self.Caption.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Connection=[\n')
        level += 1
        for Connection_ in self.Connection:
            showIndent(outfile, level)
            outfile.write('model_.Connection(\n')
            Connection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ConsumerVisibility is not None:
            showIndent(outfile, level)
            outfile.write('ConsumerVisibility=%d,\n' % self.ConsumerVisibility)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Description(\n')
            self.Description.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ElementName is not None:
            showIndent(outfile, level)
            outfile.write('ElementName=model_.ElementName(\n')
            self.ElementName.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('HostResource=[\n')
        level += 1
        for HostResource_ in self.HostResource:
            showIndent(outfile, level)
            outfile.write('model_.HostResource(\n')
            HostResource_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.InstanceID is not None:
            showIndent(outfile, level)
            outfile.write('InstanceID=model_.InstanceID(\n')
            self.InstanceID.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Limit is not None:
            showIndent(outfile, level)
            outfile.write('Limit=model_.Limit(\n')
            self.Limit.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MappingBehavior is not None:
            showIndent(outfile, level)
            outfile.write('MappingBehavior=%d,\n' % self.MappingBehavior)
        if self.OtherResourceType is not None:
            showIndent(outfile, level)
            outfile.write('OtherResourceType=model_.OtherResourceType(\n')
            self.OtherResourceType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Parent is not None:
            showIndent(outfile, level)
            outfile.write('Parent=model_.Parent(\n')
            self.Parent.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PoolID is not None:
            showIndent(outfile, level)
            outfile.write('PoolID=model_.PoolID(\n')
            self.PoolID.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Reservation is not None:
            showIndent(outfile, level)
            outfile.write('Reservation=model_.Reservation(\n')
            self.Reservation.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ResourceSubType is not None:
            showIndent(outfile, level)
            outfile.write('ResourceSubType=model_.ResourceSubType(\n')
            self.ResourceSubType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ResourceType is not None:
            showIndent(outfile, level)
            outfile.write('ResourceType=%d,\n' % self.ResourceType)
        if self.VirtualQuantity is not None:
            showIndent(outfile, level)
            outfile.write('VirtualQuantity=model_.VirtualQuantity(\n')
            self.VirtualQuantity.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VirtualQuantityUnits is not None:
            showIndent(outfile, level)
            outfile.write('VirtualQuantityUnits=model_.VirtualQuantityUnits(\n')
            self.VirtualQuantityUnits.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Weight is not None:
            showIndent(outfile, level)
            outfile.write('Weight=model_.Weight(\n')
            self.Weight.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'AddressOnParent':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AddressOnParent = obj_
            obj_.original_tagname_ = 'AddressOnParent'
        elif nodeName_ == 'AllocationUnits':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AllocationUnits = obj_
            obj_.original_tagname_ = 'AllocationUnits'
        elif nodeName_ == 'AutomaticAllocation':
            class_obj_ = self.get_class_obj_(child_, cimBoolean)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AutomaticAllocation = obj_
            obj_.original_tagname_ = 'AutomaticAllocation'
        elif nodeName_ == 'AutomaticDeallocation':
            class_obj_ = self.get_class_obj_(child_, cimBoolean)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.AutomaticDeallocation = obj_
            obj_.original_tagname_ = 'AutomaticDeallocation'
        elif nodeName_ == 'Caption':
            obj_ = Caption.factory()
            obj_.build(child_)
            self.Caption = obj_
            obj_.original_tagname_ = 'Caption'
        elif nodeName_ == 'Connection':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Connection.append(obj_)
            obj_.original_tagname_ = 'Connection'
        elif nodeName_ == 'ConsumerVisibility':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ConsumerVisibility')
            self.ConsumerVisibility = ival_
            self.validate_ConsumerVisibility(self.ConsumerVisibility)    # validate type ConsumerVisibility
        elif nodeName_ == 'Description':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'ElementName':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ElementName = obj_
            obj_.original_tagname_ = 'ElementName'
        elif nodeName_ == 'HostResource':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.HostResource.append(obj_)
            obj_.original_tagname_ = 'HostResource'
        elif nodeName_ == 'InstanceID':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.InstanceID = obj_
            obj_.original_tagname_ = 'InstanceID'
        elif nodeName_ == 'Limit':
            obj_ = cimUnsignedLong.factory()
            obj_.build(child_)
            self.Limit = obj_
            obj_.original_tagname_ = 'Limit'
        elif nodeName_ == 'MappingBehavior':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MappingBehavior')
            self.MappingBehavior = ival_
            self.validate_MappingBehavior(self.MappingBehavior)    # validate type MappingBehavior
        elif nodeName_ == 'OtherResourceType':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.OtherResourceType = obj_
            obj_.original_tagname_ = 'OtherResourceType'
        elif nodeName_ == 'Parent':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Parent = obj_
            obj_.original_tagname_ = 'Parent'
        elif nodeName_ == 'PoolID':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.PoolID = obj_
            obj_.original_tagname_ = 'PoolID'
        elif nodeName_ == 'Reservation':
            obj_ = cimUnsignedLong.factory()
            obj_.build(child_)
            self.Reservation = obj_
            obj_.original_tagname_ = 'Reservation'
        elif nodeName_ == 'ResourceSubType':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ResourceSubType = obj_
            obj_.original_tagname_ = 'ResourceSubType'
        elif nodeName_ == 'ResourceType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ResourceType')
            self.ResourceType = ival_
            self.validate_ResourceType(self.ResourceType)    # validate type ResourceType
        elif nodeName_ == 'VirtualQuantity':
            obj_ = cimUnsignedLong.factory()
            obj_.build(child_)
            self.VirtualQuantity = obj_
            obj_.original_tagname_ = 'VirtualQuantity'
        elif nodeName_ == 'VirtualQuantityUnits':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VirtualQuantityUnits = obj_
            obj_.original_tagname_ = 'VirtualQuantityUnits'
        elif nodeName_ == 'Weight':
            class_obj_ = self.get_class_obj_(child_, cimUnsignedInt)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Weight = obj_
            obj_.original_tagname_ = 'Weight'
        else:
            obj_ = self.gds_build_any(child_, 'CIM_ResourceAllocationSettingData_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class CIM_ResourceAllocationSettingData_Type


class Environment_Type(GeneratedsSuper):
    """Type for root OVF environmentIdentifier matching recipient of this
    environment"""
    subclass = None
    superclass = None
    def __init__(self, id='', Section=None, Entity=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
        if Entity is None:
            self.Entity = []
        else:
            self.Entity = Entity
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Environment_Type.subclass:
            return Environment_Type.subclass(*args_, **kwargs_)
        else:
            return Environment_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def get_Entity(self): return self.Entity
    def set_Entity(self, Entity): self.Entity = Entity
    def add_Entity(self, value): self.Entity.append(value)
    def insert_Entity_at(self, index, value): self.Entity.insert(index, value)
    def replace_Entity_at(self, index, value): self.Entity[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Section or
            self.Entity or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Environment_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Environment_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Environment_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Environment_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Environment_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovfenv:', name_='Section', pretty_print=pretty_print)
        for Entity_ in self.Entity:
            Entity_.export(outfile, level, namespace_, name_='Entity', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Environment_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Entity=[\n')
        level += 1
        for Entity_ in self.Entity:
            showIndent(outfile, level)
            outfile.write('model_.Entity_Type(\n')
            Entity_.exportLiteral(outfile, level, name_='Entity_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
        elif nodeName_ == 'CustomizationSection':
            obj_ = CustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CustomizationSection'
        elif nodeName_ == 'Entity':
            obj_ = Entity_Type.factory()
            obj_.build(child_)
            self.Entity.append(obj_)
            obj_.original_tagname_ = 'Entity'
        else:
            obj_ = self.gds_build_any(child_, 'Environment_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class Environment_Type


class Entity_Type(GeneratedsSuper):
    """Container of sections for a specific entity Entity identifier"""
    subclass = None
    superclass = None
    def __init__(self, id=None, Section=None, anytypeobjs_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if Entity_Type.subclass:
            return Entity_Type.subclass(*args_, **kwargs_)
        else:
            return Entity_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Section or
            self.anytypeobjs_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Entity_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Entity_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Entity_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Entity_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Entity_Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovfenv:', name_='Section', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Entity_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
        elif nodeName_ == 'CustomizationSection':
            obj_ = CustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CustomizationSection'
        else:
            obj_ = self.gds_build_any(child_, 'Entity_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class Entity_Type


class PropertySection_Type(Section_Type):
    """Key/value pairs of assigned properties for an entity"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Property=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(PropertySection_Type, self).__init__()
        if Property is None:
            self.Property = []
        else:
            self.Property = Property
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if PropertySection_Type.subclass:
            return PropertySection_Type.subclass(*args_, **kwargs_)
        else:
            return PropertySection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Property(self): return self.Property
    def set_Property(self, Property): self.Property = Property
    def add_Property(self, value): self.Property.append(value)
    def insert_Property_at(self, index, value): self.Property.insert(index, value)
    def replace_Property_at(self, index, value): self.Property[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Property or
            self.anytypeobjs_ or
            super(PropertySection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertySection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertySection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PropertySection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertySection_Type'):
        super(PropertySection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PropertySection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='PropertySection_Type', fromsubclass_=False, pretty_print=True):
        super(PropertySection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Property_ in self.Property:
            Property_.export(outfile, level, namespace_, name_='Property', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PropertySection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PropertySection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PropertySection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Property=[\n')
        level += 1
        for Property_ in self.Property:
            showIndent(outfile, level)
            outfile.write('model_.PropertyType7(\n')
            Property_.exportLiteral(outfile, level, name_='PropertyType7')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PropertySection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Property':
            obj_ = PropertyType7.factory()
            obj_.build(child_)
            self.Property.append(obj_)
            obj_.original_tagname_ = 'Property'
        else:
            obj_ = self.gds_build_any(child_, 'PropertySection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(PropertySection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class PropertySection_Type


class PlatformSection_Type(Section_Type):
    """Information about deployment platform"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Kind=None, Version=None, Vendor=None, Locale=None, Timezone=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(PlatformSection_Type, self).__init__()
        self.Kind = Kind
        self.Version = Version
        self.Vendor = Vendor
        self.Locale = Locale
        self.Timezone = Timezone
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if PlatformSection_Type.subclass:
            return PlatformSection_Type.subclass(*args_, **kwargs_)
        else:
            return PlatformSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Kind(self): return self.Kind
    def set_Kind(self, Kind): self.Kind = Kind
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Vendor(self): return self.Vendor
    def set_Vendor(self, Vendor): self.Vendor = Vendor
    def get_Locale(self): return self.Locale
    def set_Locale(self, Locale): self.Locale = Locale
    def get_Timezone(self): return self.Timezone
    def set_Timezone(self, Timezone): self.Timezone = Timezone
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.Kind is not None or
            self.Version is not None or
            self.Vendor is not None or
            self.Locale is not None or
            self.Timezone is not None or
            self.anytypeobjs_ or
            super(PlatformSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PlatformSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PlatformSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PlatformSection_Type'):
        super(PlatformSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='PlatformSection_Type', fromsubclass_=False, pretty_print=True):
        super(PlatformSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Kind is not None:
            self.Kind.export(outfile, level, namespace_, name_='Kind', pretty_print=pretty_print)
        if self.Version is not None:
            self.Version.export(outfile, level, namespace_, name_='Version', pretty_print=pretty_print)
        if self.Vendor is not None:
            self.Vendor.export(outfile, level, namespace_, name_='Vendor', pretty_print=pretty_print)
        if self.Locale is not None:
            self.Locale.export(outfile, level, namespace_, name_='Locale', pretty_print=pretty_print)
        if self.Timezone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTimezone>%s</%sTimezone>%s' % (namespace_, self.gds_format_integer(self.Timezone, input_name='Timezone'), namespace_, eol_))
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PlatformSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PlatformSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PlatformSection_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.Kind is not None:
            showIndent(outfile, level)
            outfile.write('Kind=model_.cimString(\n')
            self.Kind.exportLiteral(outfile, level, name_='Kind')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=model_.cimString(\n')
            self.Version.exportLiteral(outfile, level, name_='Version')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Vendor is not None:
            showIndent(outfile, level)
            outfile.write('Vendor=model_.cimString(\n')
            self.Vendor.exportLiteral(outfile, level, name_='Vendor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Locale is not None:
            showIndent(outfile, level)
            outfile.write('Locale=model_.cimString(\n')
            self.Locale.exportLiteral(outfile, level, name_='Locale')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Timezone is not None:
            showIndent(outfile, level)
            outfile.write('Timezone=%d,\n' % self.Timezone)
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PlatformSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Kind':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Kind = obj_
            obj_.original_tagname_ = 'Kind'
        elif nodeName_ == 'Version':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Version = obj_
            obj_.original_tagname_ = 'Version'
        elif nodeName_ == 'Vendor':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Vendor = obj_
            obj_.original_tagname_ = 'Vendor'
        elif nodeName_ == 'Locale':
            class_obj_ = self.get_class_obj_(child_, cimString)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Locale = obj_
            obj_.original_tagname_ = 'Locale'
        elif nodeName_ == 'Timezone':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Timezone')
            self.Timezone = ival_
        else:
            obj_ = self.gds_build_any(child_, 'PlatformSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(PlatformSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class PlatformSection_Type


class IpAssignmentSection_Type(Section_Type):
    """Specifies the IP Assignment policy that is supportedList of
    supported IP assignment schemes. Valid values are: dhcp and
    ovfenvList of supported IP protocols. Valid values are: IPv4 and
    IPv6"""
    subclass = None
    superclass = Section_Type
    def __init__(self, schemes='', protocols='IPv4'):
        self.original_tagname_ = None
        super(IpAssignmentSection_Type, self).__init__()
        self.schemes = _cast(None, schemes)
        self.protocols = _cast(None, protocols)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if IpAssignmentSection_Type.subclass:
            return IpAssignmentSection_Type.subclass(*args_, **kwargs_)
        else:
            return IpAssignmentSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_schemes(self): return self.schemes
    def set_schemes(self, schemes): self.schemes = schemes
    def get_protocols(self): return self.protocols
    def set_protocols(self, protocols): self.protocols = protocols
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            super(IpAssignmentSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IpAssignmentSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IpAssignmentSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IpAssignmentSection_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IpAssignmentSection_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(IpAssignmentSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IpAssignmentSection_Type')
        if self.schemes is not None and 'schemes' not in already_processed:
            already_processed.add('schemes')
            outfile.write(' schemes=%s' % (self.gds_format_string(quote_attrib(self.schemes).encode(ExternalEncoding), input_name='schemes'), ))
        if self.protocols is not None and 'protocols' not in already_processed:
            already_processed.add('protocols')
            outfile.write(' protocols=%s' % (self.gds_format_string(quote_attrib(self.protocols).encode(ExternalEncoding), input_name='protocols'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='IpAssignmentSection_Type', fromsubclass_=False, pretty_print=True):
        super(IpAssignmentSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='IpAssignmentSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.schemes is not None and 'schemes' not in already_processed:
            already_processed.add('schemes')
            showIndent(outfile, level)
            outfile.write('schemes="%s",\n' % (self.schemes,))
        if self.protocols is not None and 'protocols' not in already_processed:
            already_processed.add('protocols')
            showIndent(outfile, level)
            outfile.write('protocols="%s",\n' % (self.protocols,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(IpAssignmentSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IpAssignmentSection_Type, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('schemes', node)
        if value is not None and 'schemes' not in already_processed:
            already_processed.add('schemes')
            self.schemes = value
        value = find_attr_value_('protocols', node)
        if value is not None and 'protocols' not in already_processed:
            already_processed.add('protocols')
            self.protocols = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(IpAssignmentSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IpAssignmentSection_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IpAssignmentSection_Type


class CpuCompatibilitySection_Type(Section_Type):
    """CPU Architecture requirements for guest software"""
    subclass = None
    superclass = Section_Type
    def __init__(self, Level=None):
        self.original_tagname_ = None
        super(CpuCompatibilitySection_Type, self).__init__()
        if Level is None:
            self.Level = []
        else:
            self.Level = Level
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CpuCompatibilitySection_Type.subclass:
            return CpuCompatibilitySection_Type.subclass(*args_, **kwargs_)
        else:
            return CpuCompatibilitySection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Level(self): return self.Level
    def set_Level(self, Level): self.Level = Level
    def add_Level(self, value): self.Level.append(value)
    def insert_Level_at(self, index, value): self.Level.insert(index, value)
    def replace_Level_at(self, index, value): self.Level[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Level or
            super(CpuCompatibilitySection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CpuCompatibilitySection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CpuCompatibilitySection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CpuCompatibilitySection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CpuCompatibilitySection_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(CpuCompatibilitySection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CpuCompatibilitySection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='CpuCompatibilitySection_Type', fromsubclass_=False, pretty_print=True):
        super(CpuCompatibilitySection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Level_ in self.Level:
            Level_.export(outfile, level, namespace_, name_='Level', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CpuCompatibilitySection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(CpuCompatibilitySection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CpuCompatibilitySection_Type, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Level=[\n')
        level += 1
        for Level_ in self.Level:
            showIndent(outfile, level)
            outfile.write('model_.LevelType(\n')
            Level_.exportLiteral(outfile, level, name_='LevelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(CpuCompatibilitySection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Level':
            obj_ = LevelType.factory()
            obj_.build(child_)
            self.Level.append(obj_)
            obj_.original_tagname_ = 'Level'
        super(CpuCompatibilitySection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class CpuCompatibilitySection_Type


class BootOrderSection_Type(Section_Type):
    """Specifies the boot device for this VirtualSystemType of bootable
    device. Supported values are: cdrom, floppy, net, or disk
    Instance ID of ethernet card if boot device type is net."""
    subclass = None
    superclass = Section_Type
    def __init__(self, instanceId=None, type_=''):
        self.original_tagname_ = None
        super(BootOrderSection_Type, self).__init__()
        self.instanceId = _cast(int, instanceId)
        self.type_ = _cast(None, type_)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if BootOrderSection_Type.subclass:
            return BootOrderSection_Type.subclass(*args_, **kwargs_)
        else:
            return BootOrderSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_instanceId(self): return self.instanceId
    def set_instanceId(self, instanceId): self.instanceId = instanceId
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            super(BootOrderSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BootOrderSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BootOrderSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BootOrderSection_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BootOrderSection_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(BootOrderSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BootOrderSection_Type')
        if self.instanceId is not None and 'instanceId' not in already_processed:
            already_processed.add('instanceId')
            outfile.write(' instanceId="%s"' % self.gds_format_integer(self.instanceId, input_name='instanceId'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BootOrderSection_Type', fromsubclass_=False, pretty_print=True):
        super(BootOrderSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='BootOrderSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instanceId is not None and 'instanceId' not in already_processed:
            already_processed.add('instanceId')
            showIndent(outfile, level)
            outfile.write('instanceId=%d,\n' % (self.instanceId,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(BootOrderSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BootOrderSection_Type, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instanceId', node)
        if value is not None and 'instanceId' not in already_processed:
            already_processed.add('instanceId')
            try:
                self.instanceId = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(BootOrderSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BootOrderSection_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BootOrderSection_Type


class ConfigKeyValue_Type(GeneratedsSuper):
    """Config keyConfig value"""
    subclass = None
    superclass = None
    def __init__(self, required=None, value=None, key=None, extensiontype_=None):
        self.original_tagname_ = None
        self.required = _cast(None, required)
        self.value = _cast(None, value)
        self.key = _cast(None, key)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ConfigKeyValue_Type.subclass:
            return ConfigKeyValue_Type.subclass(*args_, **kwargs_)
        else:
            return ConfigKeyValue_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_required(self): return self.required
    def set_required(self, required): self.required = required
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConfigKeyValue_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConfigKeyValue_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConfigKeyValue_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConfigKeyValue_Type'):
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required=%s' % (self.gds_format_string(quote_attrib(self.required).encode(ExternalEncoding), input_name='required'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ConfigKeyValue_Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ConfigKeyValue_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            showIndent(outfile, level)
            outfile.write('required="%s",\n' % (self.required,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            showIndent(outfile, level)
            outfile.write('key="%s",\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            self.required = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            self.key = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ConfigKeyValue_Type


class Config_Type(ConfigKeyValue_Type):
    """Config element"""
    subclass = None
    superclass = ConfigKeyValue_Type
    def __init__(self, required=None, value=None, key=None):
        self.original_tagname_ = None
        super(Config_Type, self).__init__(required, value, key, )
    def factory(*args_, **kwargs_):
        if Config_Type.subclass:
            return Config_Type.subclass(*args_, **kwargs_)
        else:
            return Config_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(Config_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Config_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Config_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Config_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Config_Type'):
        super(Config_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Config_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='Config_Type', fromsubclass_=False, pretty_print=True):
        super(Config_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='Config_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Config_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Config_Type, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Config_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(Config_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class Config_Type


class ExtraConfig_Type(ConfigKeyValue_Type):
    """ExtraConfig element"""
    subclass = None
    superclass = ConfigKeyValue_Type
    def __init__(self, required=None, value=None, key=None):
        self.original_tagname_ = None
        super(ExtraConfig_Type, self).__init__(required, value, key, )
    def factory(*args_, **kwargs_):
        if ExtraConfig_Type.subclass:
            return ExtraConfig_Type.subclass(*args_, **kwargs_)
        else:
            return ExtraConfig_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ExtraConfig_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExtraConfig_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExtraConfig_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExtraConfig_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExtraConfig_Type'):
        super(ExtraConfig_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExtraConfig_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='ExtraConfig_Type', fromsubclass_=False, pretty_print=True):
        super(ExtraConfig_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ExtraConfig_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ExtraConfig_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ExtraConfig_Type, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExtraConfig_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ExtraConfig_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExtraConfig_Type


class CoresPerSocket_Type(cimUnsignedInt):
    """5.5Type for CoresPerSocket element"""
    subclass = None
    superclass = cimUnsignedInt
    def __init__(self, required=None, valueOf_=None):
        self.original_tagname_ = None
        super(CoresPerSocket_Type, self).__init__(valueOf_, )
        self.required = _cast(None, required)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if CoresPerSocket_Type.subclass:
            return CoresPerSocket_Type.subclass(*args_, **kwargs_)
        else:
            return CoresPerSocket_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_required(self): return self.required
    def set_required(self, required): self.required = required
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(CoresPerSocket_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CoresPerSocket_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CoresPerSocket_Type')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CoresPerSocket_Type', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CoresPerSocket_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(CoresPerSocket_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CoresPerSocket_Type')
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required=%s' % (self.gds_format_string(quote_attrib(self.required).encode(ExternalEncoding), input_name='required'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='CoresPerSocket_Type', fromsubclass_=False, pretty_print=True):
        super(CoresPerSocket_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='CoresPerSocket_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            showIndent(outfile, level)
            outfile.write('required="%s",\n' % (self.required,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(CoresPerSocket_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CoresPerSocket_Type, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            self.required = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(CoresPerSocket_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CoresPerSocket_Type


class MediaType(ResourceEntityType):
    """0.9 Represents a Media object. create Media image type. One of: iso,
    floppy truecreate Size of the media file, in bytes. true"""
    subclass = None
    superclass = ResourceEntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, Files=None, imageType=None, size=None, Owner=None, VdcStorageProfile=None):
        self.original_tagname_ = None
        super(MediaType, self).__init__(operationKey, id, name, Description, Tasks, status, Files, )
        self.imageType = _cast(None, imageType)
        self.size = _cast(int, size)
        self.Owner = Owner
        self.VdcStorageProfile = VdcStorageProfile
    def factory(*args_, **kwargs_):
        if MediaType.subclass:
            return MediaType.subclass(*args_, **kwargs_)
        else:
            return MediaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Owner(self): return self.Owner
    def set_Owner(self, Owner): self.Owner = Owner
    def get_VdcStorageProfile(self): return self.VdcStorageProfile
    def set_VdcStorageProfile(self, VdcStorageProfile): self.VdcStorageProfile = VdcStorageProfile
    def get_imageType(self): return self.imageType
    def set_imageType(self, imageType): self.imageType = imageType
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            self.Owner is not None or
            self.VdcStorageProfile is not None or
            super(MediaType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MediaType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MediaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MediaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MediaType'):
        super(MediaType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MediaType')
        if self.imageType is not None and 'imageType' not in already_processed:
            already_processed.add('imageType')
            outfile.write(' imageType=%s' % (self.gds_format_string(quote_attrib(self.imageType).encode(ExternalEncoding), input_name='imageType'), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespace_='', name_='MediaType', fromsubclass_=False, pretty_print=True):
        super(MediaType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Owner is not None:
            self.Owner.export(outfile, level, namespace_, name_='Owner', pretty_print=pretty_print)
        if self.VdcStorageProfile is not None:
            self.VdcStorageProfile.export(outfile, level, namespace_, name_='VdcStorageProfile', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MediaType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.imageType is not None and 'imageType' not in already_processed:
            already_processed.add('imageType')
            showIndent(outfile, level)
            outfile.write('imageType="%s",\n' % (self.imageType,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % (self.size,))
        super(MediaType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MediaType, self).exportLiteralChildren(outfile, level, name_)
        if self.Owner is not None:
            showIndent(outfile, level)
            outfile.write('Owner=model_.OwnerType(\n')
            self.Owner.exportLiteral(outfile, level, name_='Owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.VdcStorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('VdcStorageProfile=model_.ReferenceType(\n')
            self.VdcStorageProfile.exportLiteral(outfile, level, name_='VdcStorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('imageType', node)
        if value is not None and 'imageType' not in already_processed:
            already_processed.add('imageType')
            self.imageType = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(MediaType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Owner':
            obj_ = OwnerType.factory()
            obj_.build(child_)
            self.Owner = obj_
            obj_.original_tagname_ = 'Owner'
        elif nodeName_ == 'VdcStorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VdcStorageProfile = obj_
            obj_.original_tagname_ = 'VdcStorageProfile'
        super(MediaType, self).buildChildren(child_, node, nodeName_, True)
# end class MediaType


class CloneMediaParamsType(ParamsType):
    """0.9 Parameters required by a cloneMedia request."""
    subclass = None
    superclass = ParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, Source=None, IsSourceDelete=None, VdcStorageProfile=None):
        self.original_tagname_ = None
        super(CloneMediaParamsType, self).__init__(VCloudExtension, name, Description, )
        self.Source = Source
        self.IsSourceDelete = IsSourceDelete
        self.VdcStorageProfile = VdcStorageProfile
    def factory(*args_, **kwargs_):
        if CloneMediaParamsType.subclass:
            return CloneMediaParamsType.subclass(*args_, **kwargs_)
        else:
            return CloneMediaParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_IsSourceDelete(self): return self.IsSourceDelete
    def set_IsSourceDelete(self, IsSourceDelete): self.IsSourceDelete = IsSourceDelete
    def get_VdcStorageProfile(self): return self.VdcStorageProfile
    def set_VdcStorageProfile(self, VdcStorageProfile): self.VdcStorageProfile = VdcStorageProfile
    def hasContent_(self):
        if (
            self.Source is not None or
            self.IsSourceDelete is not None or
            self.VdcStorageProfile is not None or
            super(CloneMediaParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CloneMediaParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CloneMediaParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CloneMediaParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CloneMediaParamsType'):
        super(CloneMediaParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CloneMediaParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='CloneMediaParamsType', fromsubclass_=False, pretty_print=True):
        super(CloneMediaParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Source is not None:
            self.Source.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
        if self.IsSourceDelete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsSourceDelete>%s</%sIsSourceDelete>%s' % (namespace_, self.gds_format_boolean(self.IsSourceDelete, input_name='IsSourceDelete'), namespace_, eol_))
        if self.VdcStorageProfile is not None:
            self.VdcStorageProfile.export(outfile, level, namespace_, name_='VdcStorageProfile', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CloneMediaParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CloneMediaParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CloneMediaParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.ReferenceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IsSourceDelete is not None:
            showIndent(outfile, level)
            outfile.write('IsSourceDelete=%s,\n' % self.IsSourceDelete)
        if self.VdcStorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('VdcStorageProfile=model_.ReferenceType(\n')
            self.VdcStorageProfile.exportLiteral(outfile, level, name_='VdcStorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CloneMediaParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Source = obj_
            obj_.original_tagname_ = 'Source'
        elif nodeName_ == 'IsSourceDelete':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsSourceDelete')
            self.IsSourceDelete = ival_
        elif nodeName_ == 'VdcStorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VdcStorageProfile = obj_
            obj_.original_tagname_ = 'VdcStorageProfile'
        super(CloneMediaParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class CloneMediaParamsType


class TimeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.original_tagname_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if TimeType.subclass:
            return TimeType.subclass(*args_, **kwargs_)
        else:
            return TimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TimeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TimeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimeType


class RelativeTimeType(TimeType):
    """5.6 Specifies an earlier time relative to the current time 5.6true
    numeric portion of time specification 5.6true time unit
    enumeration value"""
    subclass = None
    superclass = TimeType
    def __init__(self, interval=None, unit=None):
        self.original_tagname_ = None
        super(RelativeTimeType, self).__init__()
        self.interval = _cast(int, interval)
        self.unit = _cast(None, unit)
    def factory(*args_, **kwargs_):
        if RelativeTimeType.subclass:
            return RelativeTimeType.subclass(*args_, **kwargs_)
        else:
            return RelativeTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_interval(self): return self.interval
    def set_interval(self, interval): self.interval = interval
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def validate_TimeUnitType(self, value):
        # Validate type TimeUnitType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            super(RelativeTimeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RelativeTimeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RelativeTimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RelativeTimeType'):
        super(RelativeTimeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RelativeTimeType')
        if self.interval is not None and 'interval' not in already_processed:
            already_processed.add('interval')
            outfile.write(' interval="%s"' % self.gds_format_integer(self.interval, input_name='interval'))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RelativeTimeType', fromsubclass_=False, pretty_print=True):
        super(RelativeTimeType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='RelativeTimeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.interval is not None and 'interval' not in already_processed:
            already_processed.add('interval')
            showIndent(outfile, level)
            outfile.write('interval=%d,\n' % (self.interval,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
        super(RelativeTimeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RelativeTimeType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('interval', node)
        if value is not None and 'interval' not in already_processed:
            already_processed.add('interval')
            try:
                self.interval = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.validate_TimeUnitType(self.unit)    # validate type TimeUnitType
        super(RelativeTimeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RelativeTimeType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RelativeTimeType


class AbsoluteTimeType(TimeType):
    """5.6 Specifies an absolute time in UTC 5.6true absolute UTC time
    value"""
    subclass = None
    superclass = TimeType
    def __init__(self, time=None):
        self.original_tagname_ = None
        super(AbsoluteTimeType, self).__init__()
        if isinstance(time, basestring):
            initvalue_ = datetime_.datetime.strptime(time, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = time
        self.time = initvalue_
    def factory(*args_, **kwargs_):
        if AbsoluteTimeType.subclass:
            return AbsoluteTimeType.subclass(*args_, **kwargs_)
        else:
            return AbsoluteTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def hasContent_(self):
        if (
            super(AbsoluteTimeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AbsoluteTimeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbsoluteTimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AbsoluteTimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbsoluteTimeType'):
        super(AbsoluteTimeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbsoluteTimeType')
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            outfile.write(' time="%s"' % self.gds_format_datetime(self.time, input_name='time'))
    def exportChildren(self, outfile, level, namespace_='', name_='AbsoluteTimeType', fromsubclass_=False, pretty_print=True):
        super(AbsoluteTimeType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AbsoluteTimeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.time is not None and 'time' not in already_processed:
            already_processed.add('time')
            showIndent(outfile, level)
            outfile.write('time=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.time, input_name='time'))
        super(AbsoluteTimeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbsoluteTimeType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.add('time')
            try:
                self.time = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (time): %s' % exp)
        super(AbsoluteTimeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbsoluteTimeType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbsoluteTimeType


class SimpleMetricType(GeneratedsSuper):
    """5.6 A simple scalar metric value 5.6true name of metric 5.6true Unit
    of measure for this metric 5.6true metric value"""
    subclass = None
    superclass = None
    def __init__(self, value=None, name=None, unit=None):
        self.original_tagname_ = None
        self.value = _cast(float, value)
        self.name = _cast(None, name)
        self.unit = _cast(None, unit)
    def factory(*args_, **kwargs_):
        if SimpleMetricType.subclass:
            return SimpleMetricType.subclass(*args_, **kwargs_)
        else:
            return SimpleMetricType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SimpleMetricType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SimpleMetricType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SimpleMetricType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SimpleMetricType'):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_float(self.value, input_name='value'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SimpleMetricType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SimpleMetricType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value=%f,\n' % (self.value,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SimpleMetricType


class SampleType(GeneratedsSuper):
    """5.6 Represents a data point in a metric series"""
    subclass = None
    superclass = None
    def __init__(self, timestamp=None, value=None):
        self.original_tagname_ = None
        if isinstance(timestamp, basestring):
            initvalue_ = datetime_.datetime.strptime(timestamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timestamp
        self.timestamp = initvalue_
        self.value = _cast(float, value)
    def factory(*args_, **kwargs_):
        if SampleType.subclass:
            return SampleType.subclass(*args_, **kwargs_)
        else:
            return SampleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SampleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SampleType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SampleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SampleType'):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            outfile.write(' timestamp="%s"' % self.gds_format_datetime(self.timestamp, input_name='timestamp'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_float(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='', name_='SampleType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SampleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.timestamp is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            showIndent(outfile, level)
            outfile.write('timestamp=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.timestamp, input_name='timestamp'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value=%f,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timestamp', node)
        if value is not None and 'timestamp' not in already_processed:
            already_processed.add('timestamp')
            try:
                self.timestamp = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timestamp): %s' % exp)
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SampleType


class TimeSeriesMetricType(GeneratedsSuper):
    """5.6 A sequence of metric values measured at specified times 5.6true
    name of metric 5.6true Unit of measure for this metric 5.6true
    Integer number of seconds between samples."""
    subclass = None
    superclass = None
    def __init__(self, expectedInterval=None, name=None, unit=None, Sample=None):
        self.original_tagname_ = None
        self.expectedInterval = _cast(int, expectedInterval)
        self.name = _cast(None, name)
        self.unit = _cast(None, unit)
        if Sample is None:
            self.Sample = []
        else:
            self.Sample = Sample
    def factory(*args_, **kwargs_):
        if TimeSeriesMetricType.subclass:
            return TimeSeriesMetricType.subclass(*args_, **kwargs_)
        else:
            return TimeSeriesMetricType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Sample(self): return self.Sample
    def set_Sample(self, Sample): self.Sample = Sample
    def add_Sample(self, value): self.Sample.append(value)
    def insert_Sample_at(self, index, value): self.Sample.insert(index, value)
    def replace_Sample_at(self, index, value): self.Sample[index] = value
    def get_expectedInterval(self): return self.expectedInterval
    def set_expectedInterval(self, expectedInterval): self.expectedInterval = expectedInterval
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def hasContent_(self):
        if (
            self.Sample
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeSeriesMetricType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeSeriesMetricType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeSeriesMetricType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeSeriesMetricType'):
        if self.expectedInterval is not None and 'expectedInterval' not in already_processed:
            already_processed.add('expectedInterval')
            outfile.write(' expectedInterval="%s"' % self.gds_format_integer(self.expectedInterval, input_name='expectedInterval'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (self.gds_format_string(quote_attrib(self.unit).encode(ExternalEncoding), input_name='unit'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TimeSeriesMetricType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Sample_ in self.Sample:
            Sample_.export(outfile, level, namespace_, name_='Sample', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TimeSeriesMetricType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.expectedInterval is not None and 'expectedInterval' not in already_processed:
            already_processed.add('expectedInterval')
            showIndent(outfile, level)
            outfile.write('expectedInterval=%d,\n' % (self.expectedInterval,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            showIndent(outfile, level)
            outfile.write('unit="%s",\n' % (self.unit,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Sample=[\n')
        level += 1
        for Sample_ in self.Sample:
            showIndent(outfile, level)
            outfile.write('model_.SampleType(\n')
            Sample_.exportLiteral(outfile, level, name_='SampleType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('expectedInterval', node)
        if value is not None and 'expectedInterval' not in already_processed:
            already_processed.add('expectedInterval')
            try:
                self.expectedInterval = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Sample':
            obj_ = SampleType.factory()
            obj_.build(child_)
            self.Sample.append(obj_)
            obj_.original_tagname_ = 'Sample'
# end class TimeSeriesMetricType


class CurrentUsageSpecType(GeneratedsSuper):
    """5.6 Specifies which current usage metrics to retrieve"""
    subclass = None
    superclass = None
    def __init__(self, MetricPattern=None):
        self.original_tagname_ = None
        if MetricPattern is None:
            self.MetricPattern = []
        else:
            self.MetricPattern = MetricPattern
    def factory(*args_, **kwargs_):
        if CurrentUsageSpecType.subclass:
            return CurrentUsageSpecType.subclass(*args_, **kwargs_)
        else:
            return CurrentUsageSpecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MetricPattern(self): return self.MetricPattern
    def set_MetricPattern(self, MetricPattern): self.MetricPattern = MetricPattern
    def add_MetricPattern(self, value): self.MetricPattern.append(value)
    def insert_MetricPattern_at(self, index, value): self.MetricPattern.insert(index, value)
    def replace_MetricPattern_at(self, index, value): self.MetricPattern[index] = value
    def hasContent_(self):
        if (
            self.MetricPattern
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrentUsageSpecType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentUsageSpecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrentUsageSpecType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentUsageSpecType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentUsageSpecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MetricPattern_ in self.MetricPattern:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetricPattern>%s</%sMetricPattern>%s' % (namespace_, self.gds_format_string(quote_xml(MetricPattern_).encode(ExternalEncoding), input_name='MetricPattern'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CurrentUsageSpecType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('MetricPattern=[\n')
        level += 1
        for MetricPattern_ in self.MetricPattern:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MetricPattern_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MetricPattern':
            MetricPattern_ = child_.text
            MetricPattern_ = self.gds_validate_string(MetricPattern_, node, 'MetricPattern')
            self.MetricPattern.append(MetricPattern_)
# end class CurrentUsageSpecType


class CurrentUsageType(ResourceType):
    """5.6 A collection of simple metrics representing real time usage
    statistics"""
    subclass = None
    superclass = ResourceType
    def __init__(self, Metric=None):
        self.original_tagname_ = None
        super(CurrentUsageType, self).__init__()
        if Metric is None:
            self.Metric = []
        else:
            self.Metric = Metric
    def factory(*args_, **kwargs_):
        if CurrentUsageType.subclass:
            return CurrentUsageType.subclass(*args_, **kwargs_)
        else:
            return CurrentUsageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Metric(self): return self.Metric
    def set_Metric(self, Metric): self.Metric = Metric
    def add_Metric(self, value): self.Metric.append(value)
    def insert_Metric_at(self, index, value): self.Metric.insert(index, value)
    def replace_Metric_at(self, index, value): self.Metric[index] = value
    def hasContent_(self):
        if (
            self.Metric or
            super(CurrentUsageType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrentUsageType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentUsageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrentUsageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentUsageType'):
        super(CurrentUsageType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentUsageType')
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentUsageType', fromsubclass_=False, pretty_print=True):
        super(CurrentUsageType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Metric_ in self.Metric:
            Metric_.export(outfile, level, namespace_, name_='Metric', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CurrentUsageType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CurrentUsageType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CurrentUsageType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Metric=[\n')
        level += 1
        for Metric_ in self.Metric:
            showIndent(outfile, level)
            outfile.write('model_.SimpleMetricType(\n')
            Metric_.exportLiteral(outfile, level, name_='SimpleMetricType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CurrentUsageType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Metric':
            obj_ = SimpleMetricType.factory()
            obj_.build(child_)
            self.Metric.append(obj_)
            obj_.original_tagname_ = 'Metric'
        super(CurrentUsageType, self).buildChildren(child_, node, nodeName_, True)
# end class CurrentUsageType


class HistoricUsageSpecType(GeneratedsSuper):
    """5.6 Specifies which historic usage metrics to retrieve"""
    subclass = None
    superclass = None
    def __init__(self, AbsoluteStartTime=None, RelativeStartTime=None, AbsoluteEndTime=None, RelativeEndTime=None, MetricPattern=None):
        self.original_tagname_ = None
        self.AbsoluteStartTime = AbsoluteStartTime
        self.RelativeStartTime = RelativeStartTime
        self.AbsoluteEndTime = AbsoluteEndTime
        self.RelativeEndTime = RelativeEndTime
        if MetricPattern is None:
            self.MetricPattern = []
        else:
            self.MetricPattern = MetricPattern
    def factory(*args_, **kwargs_):
        if HistoricUsageSpecType.subclass:
            return HistoricUsageSpecType.subclass(*args_, **kwargs_)
        else:
            return HistoricUsageSpecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AbsoluteStartTime(self): return self.AbsoluteStartTime
    def set_AbsoluteStartTime(self, AbsoluteStartTime): self.AbsoluteStartTime = AbsoluteStartTime
    def get_RelativeStartTime(self): return self.RelativeStartTime
    def set_RelativeStartTime(self, RelativeStartTime): self.RelativeStartTime = RelativeStartTime
    def get_AbsoluteEndTime(self): return self.AbsoluteEndTime
    def set_AbsoluteEndTime(self, AbsoluteEndTime): self.AbsoluteEndTime = AbsoluteEndTime
    def get_RelativeEndTime(self): return self.RelativeEndTime
    def set_RelativeEndTime(self, RelativeEndTime): self.RelativeEndTime = RelativeEndTime
    def get_MetricPattern(self): return self.MetricPattern
    def set_MetricPattern(self, MetricPattern): self.MetricPattern = MetricPattern
    def add_MetricPattern(self, value): self.MetricPattern.append(value)
    def insert_MetricPattern_at(self, index, value): self.MetricPattern.insert(index, value)
    def replace_MetricPattern_at(self, index, value): self.MetricPattern[index] = value
    def hasContent_(self):
        if (
            self.AbsoluteStartTime is not None or
            self.RelativeStartTime is not None or
            self.AbsoluteEndTime is not None or
            self.RelativeEndTime is not None or
            self.MetricPattern
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HistoricUsageSpecType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HistoricUsageSpecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HistoricUsageSpecType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HistoricUsageSpecType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HistoricUsageSpecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AbsoluteStartTime is not None:
            self.AbsoluteStartTime.export(outfile, level, namespace_, name_='AbsoluteStartTime', pretty_print=pretty_print)
        if self.RelativeStartTime is not None:
            self.RelativeStartTime.export(outfile, level, namespace_, name_='RelativeStartTime', pretty_print=pretty_print)
        if self.AbsoluteEndTime is not None:
            self.AbsoluteEndTime.export(outfile, level, namespace_, name_='AbsoluteEndTime', pretty_print=pretty_print)
        if self.RelativeEndTime is not None:
            self.RelativeEndTime.export(outfile, level, namespace_, name_='RelativeEndTime', pretty_print=pretty_print)
        for MetricPattern_ in self.MetricPattern:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetricPattern>%s</%sMetricPattern>%s' % (namespace_, self.gds_format_string(quote_xml(MetricPattern_).encode(ExternalEncoding), input_name='MetricPattern'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='HistoricUsageSpecType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AbsoluteStartTime is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteStartTime=model_.AbsoluteTimeType(\n')
            self.AbsoluteStartTime.exportLiteral(outfile, level, name_='AbsoluteStartTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RelativeStartTime is not None:
            showIndent(outfile, level)
            outfile.write('RelativeStartTime=model_.RelativeTimeType(\n')
            self.RelativeStartTime.exportLiteral(outfile, level, name_='RelativeStartTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AbsoluteEndTime is not None:
            showIndent(outfile, level)
            outfile.write('AbsoluteEndTime=model_.AbsoluteTimeType(\n')
            self.AbsoluteEndTime.exportLiteral(outfile, level, name_='AbsoluteEndTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RelativeEndTime is not None:
            showIndent(outfile, level)
            outfile.write('RelativeEndTime=model_.RelativeTimeType(\n')
            self.RelativeEndTime.exportLiteral(outfile, level, name_='RelativeEndTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('MetricPattern=[\n')
        level += 1
        for MetricPattern_ in self.MetricPattern:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MetricPattern_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AbsoluteStartTime':
            obj_ = AbsoluteTimeType.factory()
            obj_.build(child_)
            self.AbsoluteStartTime = obj_
            obj_.original_tagname_ = 'AbsoluteStartTime'
        elif nodeName_ == 'RelativeStartTime':
            obj_ = RelativeTimeType.factory()
            obj_.build(child_)
            self.RelativeStartTime = obj_
            obj_.original_tagname_ = 'RelativeStartTime'
        elif nodeName_ == 'AbsoluteEndTime':
            obj_ = AbsoluteTimeType.factory()
            obj_.build(child_)
            self.AbsoluteEndTime = obj_
            obj_.original_tagname_ = 'AbsoluteEndTime'
        elif nodeName_ == 'RelativeEndTime':
            obj_ = RelativeTimeType.factory()
            obj_.build(child_)
            self.RelativeEndTime = obj_
            obj_.original_tagname_ = 'RelativeEndTime'
        elif nodeName_ == 'MetricPattern':
            MetricPattern_ = child_.text
            MetricPattern_ = self.gds_validate_string(MetricPattern_, node, 'MetricPattern')
            self.MetricPattern.append(MetricPattern_)
# end class HistoricUsageSpecType


class HistoricUsageType(ResourceType):
    """5.6 A collection of time-based metrics representing historic usage
    statistics"""
    subclass = None
    superclass = ResourceType
    def __init__(self, MetricSeries=None):
        self.original_tagname_ = None
        super(HistoricUsageType, self).__init__()
        if MetricSeries is None:
            self.MetricSeries = []
        else:
            self.MetricSeries = MetricSeries
    def factory(*args_, **kwargs_):
        if HistoricUsageType.subclass:
            return HistoricUsageType.subclass(*args_, **kwargs_)
        else:
            return HistoricUsageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MetricSeries(self): return self.MetricSeries
    def set_MetricSeries(self, MetricSeries): self.MetricSeries = MetricSeries
    def add_MetricSeries(self, value): self.MetricSeries.append(value)
    def insert_MetricSeries_at(self, index, value): self.MetricSeries.insert(index, value)
    def replace_MetricSeries_at(self, index, value): self.MetricSeries[index] = value
    def hasContent_(self):
        if (
            self.MetricSeries or
            super(HistoricUsageType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HistoricUsageType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HistoricUsageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HistoricUsageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HistoricUsageType'):
        super(HistoricUsageType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HistoricUsageType')
    def exportChildren(self, outfile, level, namespace_='', name_='HistoricUsageType', fromsubclass_=False, pretty_print=True):
        super(HistoricUsageType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MetricSeries_ in self.MetricSeries:
            MetricSeries_.export(outfile, level, namespace_, name_='MetricSeries', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HistoricUsageType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(HistoricUsageType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HistoricUsageType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('MetricSeries=[\n')
        level += 1
        for MetricSeries_ in self.MetricSeries:
            showIndent(outfile, level)
            outfile.write('model_.TimeSeriesMetricType(\n')
            MetricSeries_.exportLiteral(outfile, level, name_='TimeSeriesMetricType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HistoricUsageType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MetricSeries':
            obj_ = TimeSeriesMetricType.factory()
            obj_.build(child_)
            self.MetricSeries.append(obj_)
            obj_.original_tagname_ = 'MetricSeries'
        super(HistoricUsageType, self).buildChildren(child_, node, nodeName_, True)
# end class HistoricUsageType


class MksTicketType(VCloudExtensibleType):
    """5.5 A ticket and connection information for accessing the console of
    a VM."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Host=None, Vmx=None, Ticket=None, Port=None):
        self.original_tagname_ = None
        super(MksTicketType, self).__init__(VCloudExtension, )
        self.Host = Host
        self.Vmx = Vmx
        self.Ticket = Ticket
        self.Port = Port
    def factory(*args_, **kwargs_):
        if MksTicketType.subclass:
            return MksTicketType.subclass(*args_, **kwargs_)
        else:
            return MksTicketType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Host(self): return self.Host
    def set_Host(self, Host): self.Host = Host
    def get_Vmx(self): return self.Vmx
    def set_Vmx(self, Vmx): self.Vmx = Vmx
    def get_Ticket(self): return self.Ticket
    def set_Ticket(self, Ticket): self.Ticket = Ticket
    def get_Port(self): return self.Port
    def set_Port(self, Port): self.Port = Port
    def hasContent_(self):
        if (
            self.Host is not None or
            self.Vmx is not None or
            self.Ticket is not None or
            self.Port is not None or
            super(MksTicketType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MksTicketType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MksTicketType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MksTicketType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MksTicketType'):
        super(MksTicketType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MksTicketType')
    def exportChildren(self, outfile, level, namespace_='', name_='MksTicketType', fromsubclass_=False, pretty_print=True):
        super(MksTicketType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Host is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHost>%s</%sHost>%s' % (namespace_, self.gds_format_string(quote_xml(self.Host).encode(ExternalEncoding), input_name='Host'), namespace_, eol_))
        if self.Vmx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVmx>%s</%sVmx>%s' % (namespace_, self.gds_format_string(quote_xml(self.Vmx).encode(ExternalEncoding), input_name='Vmx'), namespace_, eol_))
        if self.Ticket is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTicket>%s</%sTicket>%s' % (namespace_, self.gds_format_string(quote_xml(self.Ticket).encode(ExternalEncoding), input_name='Ticket'), namespace_, eol_))
        if self.Port is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPort>%s</%sPort>%s' % (namespace_, self.gds_format_integer(self.Port, input_name='Port'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MksTicketType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MksTicketType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MksTicketType, self).exportLiteralChildren(outfile, level, name_)
        if self.Host is not None:
            showIndent(outfile, level)
            outfile.write('Host=%s,\n' % quote_python(self.Host).encode(ExternalEncoding))
        if self.Vmx is not None:
            showIndent(outfile, level)
            outfile.write('Vmx=%s,\n' % quote_python(self.Vmx).encode(ExternalEncoding))
        if self.Ticket is not None:
            showIndent(outfile, level)
            outfile.write('Ticket=%s,\n' % quote_python(self.Ticket).encode(ExternalEncoding))
        if self.Port is not None:
            showIndent(outfile, level)
            outfile.write('Port=%d,\n' % self.Port)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MksTicketType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Host':
            Host_ = child_.text
            Host_ = self.gds_validate_string(Host_, node, 'Host')
            self.Host = Host_
        elif nodeName_ == 'Vmx':
            Vmx_ = child_.text
            Vmx_ = self.gds_validate_string(Vmx_, node, 'Vmx')
            self.Vmx = Vmx_
        elif nodeName_ == 'Ticket':
            Ticket_ = child_.text
            Ticket_ = self.gds_validate_string(Ticket_, node, 'Ticket')
            self.Ticket = Ticket_
        elif nodeName_ == 'Port':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Port')
            self.Port = ival_
        super(MksTicketType, self).buildChildren(child_, node, nodeName_, True)
# end class MksTicketType


class OrgType(EntityType):
    """0.9 Represents the user view of a vCloud Director organization."""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, FullName=None, IsEnabled=None):
        self.original_tagname_ = None
        super(OrgType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.FullName = FullName
        self.IsEnabled = IsEnabled
    def factory(*args_, **kwargs_):
        if OrgType.subclass:
            return OrgType.subclass(*args_, **kwargs_)
        else:
            return OrgType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FullName(self): return self.FullName
    def set_FullName(self, FullName): self.FullName = FullName
    def get_IsEnabled(self): return self.IsEnabled
    def set_IsEnabled(self, IsEnabled): self.IsEnabled = IsEnabled
    def hasContent_(self):
        if (
            self.FullName is not None or
            self.IsEnabled is not None or
            super(OrgType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrgType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrgType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrgType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrgType'):
        super(OrgType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrgType')
    def exportChildren(self, outfile, level, namespace_='', name_='OrgType', fromsubclass_=False, pretty_print=True):
        super(OrgType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FullName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFullName>%s</%sFullName>%s' % (namespace_, self.gds_format_string(quote_xml(self.FullName).encode(ExternalEncoding), input_name='FullName'), namespace_, eol_))
        if self.IsEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsEnabled>%s</%sIsEnabled>%s' % (namespace_, self.gds_format_boolean(self.IsEnabled, input_name='IsEnabled'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OrgType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OrgType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrgType, self).exportLiteralChildren(outfile, level, name_)
        if self.FullName is not None:
            showIndent(outfile, level)
            outfile.write('FullName=%s,\n' % quote_python(self.FullName).encode(ExternalEncoding))
        if self.IsEnabled is not None:
            showIndent(outfile, level)
            outfile.write('IsEnabled=%s,\n' % self.IsEnabled)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OrgType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FullName':
            FullName_ = child_.text
            FullName_ = self.gds_validate_string(FullName_, node, 'FullName')
            self.FullName = FullName_
        elif nodeName_ == 'IsEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsEnabled')
            self.IsEnabled = ival_
        super(OrgType, self).buildChildren(child_, node, nodeName_, True)
# end class OrgType


class OrgListType(ResourceType):
    """0.9 Represents a list of organizations."""
    subclass = None
    superclass = ResourceType
    def __init__(self, Org=None):
        self.original_tagname_ = None
        super(OrgListType, self).__init__()
        if Org is None:
            self.Org = []
        else:
            self.Org = Org
    def factory(*args_, **kwargs_):
        if OrgListType.subclass:
            return OrgListType.subclass(*args_, **kwargs_)
        else:
            return OrgListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Org(self): return self.Org
    def set_Org(self, Org): self.Org = Org
    def add_Org(self, value): self.Org.append(value)
    def insert_Org_at(self, index, value): self.Org.insert(index, value)
    def replace_Org_at(self, index, value): self.Org[index] = value
    def hasContent_(self):
        if (
            self.Org or
            super(OrgListType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OrgListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrgListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OrgListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OrgListType'):
        super(OrgListType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OrgListType')
    def exportChildren(self, outfile, level, namespace_='', name_='OrgListType', fromsubclass_=False, pretty_print=True):
        super(OrgListType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Org_ in self.Org:
            Org_.export(outfile, level, namespace_, name_='Org', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OrgListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OrgListType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OrgListType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Org=[\n')
        level += 1
        for Org_ in self.Org:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            Org_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OrgListType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Org':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Org.append(obj_)
            obj_.original_tagname_ = 'Org'
        super(OrgListType, self).buildChildren(child_, node, nodeName_, True)
# end class OrgListType


class ProductSectionListType(ResourceType):
    """Container for all ProductSection elements in a VAppTemplate, VApp,
    or Vm object."""
    subclass = None
    superclass = ResourceType
    def __init__(self, ProductSection=None):
        self.original_tagname_ = None
        super(ProductSectionListType, self).__init__()
        if ProductSection is None:
            self.ProductSection = []
        else:
            self.ProductSection = ProductSection
    def factory(*args_, **kwargs_):
        if ProductSectionListType.subclass:
            return ProductSectionListType.subclass(*args_, **kwargs_)
        else:
            return ProductSectionListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProductSection(self): return self.ProductSection
    def set_ProductSection(self, ProductSection): self.ProductSection = ProductSection
    def add_ProductSection(self, value): self.ProductSection.append(value)
    def insert_ProductSection_at(self, index, value): self.ProductSection.insert(index, value)
    def replace_ProductSection_at(self, index, value): self.ProductSection[index] = value
    def hasContent_(self):
        if (
            self.ProductSection or
            super(ProductSectionListType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProductSectionListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProductSectionListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProductSectionListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProductSectionListType'):
        super(ProductSectionListType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProductSectionListType')
    def exportChildren(self, outfile, level, namespace_='', name_='ProductSectionListType', fromsubclass_=False, pretty_print=True):
        super(ProductSectionListType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ProductSection_ in self.ProductSection:
            ProductSection_.export(outfile, level, namespace_='ovf:', name_='ProductSection', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProductSectionListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ProductSectionListType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ProductSectionListType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('ProductSection=[\n')
        level += 1
        for ProductSection_ in self.ProductSection:
            showIndent(outfile, level)
            outfile.write('model_.ProductSection(\n')
            ProductSection_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ProductSectionListType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.ProductSection.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        super(ProductSectionListType, self).buildChildren(child_, node, nodeName_, True)
# end class ProductSectionListType


class ScreenTicketType(GeneratedsSuper):
    """0.9 The ticket for accessing the console of a VM."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ScreenTicketType.subclass:
            return ScreenTicketType.subclass(*args_, **kwargs_)
        else:
            return ScreenTicketType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ScreenTicketType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScreenTicketType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ScreenTicketType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ScreenTicketType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ScreenTicketType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ScreenTicketType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ScreenTicketType


class TasksListType(EntityType):
    """0.9 A list of tasks."""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, Task=None):
        self.original_tagname_ = None
        super(TasksListType, self).__init__(operationKey, id, name, Description, Tasks, )
        if Task is None:
            self.Task = []
        else:
            self.Task = Task
    def factory(*args_, **kwargs_):
        if TasksListType.subclass:
            return TasksListType.subclass(*args_, **kwargs_)
        else:
            return TasksListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Task(self): return self.Task
    def set_Task(self, Task): self.Task = Task
    def add_Task(self, value): self.Task.append(value)
    def insert_Task_at(self, index, value): self.Task.insert(index, value)
    def replace_Task_at(self, index, value): self.Task[index] = value
    def hasContent_(self):
        if (
            self.Task or
            super(TasksListType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TasksListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TasksListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TasksListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TasksListType'):
        super(TasksListType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TasksListType')
    def exportChildren(self, outfile, level, namespace_='', name_='TasksListType', fromsubclass_=False, pretty_print=True):
        super(TasksListType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Task_ in self.Task:
            Task_.export(outfile, level, namespace_, name_='Task', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TasksListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TasksListType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TasksListType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Task=[\n')
        level += 1
        for Task_ in self.Task:
            showIndent(outfile, level)
            outfile.write('model_.TaskType(\n')
            Task_.exportLiteral(outfile, level, name_='TaskType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TasksListType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Task':
            obj_ = TaskType.factory()
            obj_.build(child_)
            self.Task.append(obj_)
            obj_.original_tagname_ = 'Task'
        super(TasksListType, self).buildChildren(child_, node, nodeName_, True)
# end class TasksListType


class VAppTemplateType(ResourceEntityType):
    """0.9 Represents a vApp template. none True if the OVF descriptor for
    this template has been uploaded. falsealways1.5 True if this
    template is a gold master. false"""
    subclass = None
    superclass = ResourceEntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, Files=None, ovfDescriptorUploaded=None, goldMaster=False, Owner=None, Children=None, Section=None, VAppScopedLocalId=None, DefaultStorageProfile=None, DateCreated=None):
        self.original_tagname_ = None
        super(VAppTemplateType, self).__init__(operationKey, id, name, Description, Tasks, status, Files, )
        self.ovfDescriptorUploaded = _cast(bool, ovfDescriptorUploaded)
        self.goldMaster = _cast(bool, goldMaster)
        self.Owner = Owner
        self.Children = Children
        if Section is None:
            self.Section = []
        else:
            self.Section = Section
        self.VAppScopedLocalId = VAppScopedLocalId
        self.DefaultStorageProfile = DefaultStorageProfile
        if isinstance(DateCreated, basestring):
            initvalue_ = datetime_.datetime.strptime(DateCreated, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DateCreated
        self.DateCreated = initvalue_
    def factory(*args_, **kwargs_):
        if VAppTemplateType.subclass:
            return VAppTemplateType.subclass(*args_, **kwargs_)
        else:
            return VAppTemplateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Owner(self): return self.Owner
    def set_Owner(self, Owner): self.Owner = Owner
    def get_Children(self): return self.Children
    def set_Children(self, Children): self.Children = Children
    def get_Section(self): return self.Section
    def set_Section(self, Section): self.Section = Section
    def add_Section(self, value): self.Section.append(value)
    def insert_Section_at(self, index, value): self.Section.insert(index, value)
    def replace_Section_at(self, index, value): self.Section[index] = value
    def get_VAppScopedLocalId(self): return self.VAppScopedLocalId
    def set_VAppScopedLocalId(self, VAppScopedLocalId): self.VAppScopedLocalId = VAppScopedLocalId
    def get_DefaultStorageProfile(self): return self.DefaultStorageProfile
    def set_DefaultStorageProfile(self, DefaultStorageProfile): self.DefaultStorageProfile = DefaultStorageProfile
    def get_DateCreated(self): return self.DateCreated
    def set_DateCreated(self, DateCreated): self.DateCreated = DateCreated
    def get_ovfDescriptorUploaded(self): return self.ovfDescriptorUploaded
    def set_ovfDescriptorUploaded(self, ovfDescriptorUploaded): self.ovfDescriptorUploaded = ovfDescriptorUploaded
    def get_goldMaster(self): return self.goldMaster
    def set_goldMaster(self, goldMaster): self.goldMaster = goldMaster
    def hasContent_(self):
        if (
            self.Owner is not None or
            self.Children is not None or
            self.Section or
            self.VAppScopedLocalId is not None or
            self.DefaultStorageProfile is not None or
            self.DateCreated is not None or
            super(VAppTemplateType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VAppTemplateType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VAppTemplateType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VAppTemplateType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VAppTemplateType'):
        super(VAppTemplateType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VAppTemplateType')
        if self.ovfDescriptorUploaded is not None and 'ovfDescriptorUploaded' not in already_processed:
            already_processed.add('ovfDescriptorUploaded')
            outfile.write(' ovfDescriptorUploaded="%s"' % self.gds_format_boolean(self.ovfDescriptorUploaded, input_name='ovfDescriptorUploaded'))
        if self.goldMaster is not None and 'goldMaster' not in already_processed:
            already_processed.add('goldMaster')
            outfile.write(' goldMaster="%s"' % self.gds_format_boolean(self.goldMaster, input_name='goldMaster'))
    def exportChildren(self, outfile, level, namespace_='', name_='VAppTemplateType', fromsubclass_=False, pretty_print=True):
        super(VAppTemplateType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Owner is not None:
            self.Owner.export(outfile, level, namespace_, name_='Owner', pretty_print=pretty_print)
        if self.Children is not None:
            self.Children.export(outfile, level, namespace_, name_='Children', pretty_print=pretty_print)
        for Section_ in self.Section:
            Section_.export(outfile, level, namespace_='ovf:', name_='Section', pretty_print=pretty_print)
        if self.VAppScopedLocalId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVAppScopedLocalId>%s</%sVAppScopedLocalId>%s' % (namespace_, self.gds_format_string(quote_xml(self.VAppScopedLocalId).encode(ExternalEncoding), input_name='VAppScopedLocalId'), namespace_, eol_))
        if self.DefaultStorageProfile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefaultStorageProfile>%s</%sDefaultStorageProfile>%s' % (namespace_, self.gds_format_string(quote_xml(self.DefaultStorageProfile).encode(ExternalEncoding), input_name='DefaultStorageProfile'), namespace_, eol_))
        if self.DateCreated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateCreated>%s</%sDateCreated>%s' % (namespace_, self.gds_format_datetime(self.DateCreated, input_name='DateCreated'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VAppTemplateType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ovfDescriptorUploaded is not None and 'ovfDescriptorUploaded' not in already_processed:
            already_processed.add('ovfDescriptorUploaded')
            showIndent(outfile, level)
            outfile.write('ovfDescriptorUploaded=%s,\n' % (self.ovfDescriptorUploaded,))
        if self.goldMaster is not None and 'goldMaster' not in already_processed:
            already_processed.add('goldMaster')
            showIndent(outfile, level)
            outfile.write('goldMaster=%s,\n' % (self.goldMaster,))
        super(VAppTemplateType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VAppTemplateType, self).exportLiteralChildren(outfile, level, name_)
        if self.Owner is not None:
            showIndent(outfile, level)
            outfile.write('Owner=model_.OwnerType(\n')
            self.Owner.exportLiteral(outfile, level, name_='Owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Children is not None:
            showIndent(outfile, level)
            outfile.write('Children=model_.VAppTemplateChildrenType(\n')
            self.Children.exportLiteral(outfile, level, name_='Children')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Section=[\n')
        level += 1
        for Section_ in self.Section:
            showIndent(outfile, level)
            outfile.write('model_.Section(\n')
            Section_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.VAppScopedLocalId is not None:
            showIndent(outfile, level)
            outfile.write('VAppScopedLocalId=%s,\n' % quote_python(self.VAppScopedLocalId).encode(ExternalEncoding))
        if self.DefaultStorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('DefaultStorageProfile=%s,\n' % quote_python(self.DefaultStorageProfile).encode(ExternalEncoding))
        if self.DateCreated is not None:
            showIndent(outfile, level)
            outfile.write('DateCreated=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.DateCreated, input_name='DateCreated'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ovfDescriptorUploaded', node)
        if value is not None and 'ovfDescriptorUploaded' not in already_processed:
            already_processed.add('ovfDescriptorUploaded')
            if value in ('true', '1'):
                self.ovfDescriptorUploaded = True
            elif value in ('false', '0'):
                self.ovfDescriptorUploaded = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('goldMaster', node)
        if value is not None and 'goldMaster' not in already_processed:
            already_processed.add('goldMaster')
            if value in ('true', '1'):
                self.goldMaster = True
            elif value in ('false', '0'):
                self.goldMaster = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(VAppTemplateType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Owner':
            obj_ = OwnerType.factory()
            obj_.build(child_)
            self.Owner = obj_
            obj_.original_tagname_ = 'Owner'
        elif nodeName_ == 'Children':
            obj_ = VAppTemplateChildrenType.factory()
            obj_.build(child_)
            self.Children = obj_
            obj_.original_tagname_ = 'Children'
        elif nodeName_ == 'Section':
            class_obj_ = self.get_class_obj_(child_, Section_Type)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'Section'
        elif nodeName_ == 'NetworkConfigSection':
            obj_ = NetworkConfigSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConfigSection'
        elif nodeName_ == 'LeaseSettingsSection':
            obj_ = LeaseSettingsSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'LeaseSettingsSection'
        elif nodeName_ == 'NetworkConnectionSection':
            obj_ = NetworkConnectionSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkConnectionSection'
        elif nodeName_ == 'RuntimeInfoSection':
            obj_ = RuntimeInfoSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'RuntimeInfoSection'
        elif nodeName_ == 'GuestCustomizationSection':
            obj_ = GuestCustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'GuestCustomizationSection'
        elif nodeName_ == 'SnapshotSection':
            obj_ = SnapshotSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'SnapshotSection'
        elif nodeName_ == 'DefaultStorageProfileSection':
            obj_ = DefaultStorageProfileSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DefaultStorageProfileSection'
        elif nodeName_ == 'AnnotationSection':
            obj_ = AnnotationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'AnnotationSection'
        elif nodeName_ == 'ProductSection':
            obj_ = ProductSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ProductSection'
        elif nodeName_ == 'NetworkSection':
            obj_ = NetworkSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'NetworkSection'
        elif nodeName_ == 'DiskSection':
            obj_ = DiskSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DiskSection'
        elif nodeName_ == 'OperatingSystemSection':
            obj_ = OperatingSystemSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemSection'
        elif nodeName_ == 'EulaSection':
            obj_ = EulaSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'EulaSection'
        elif nodeName_ == 'VirtualHardwareSection':
            obj_ = VirtualHardwareSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'VirtualHardwareSection'
        elif nodeName_ == 'ResourceAllocationSection':
            obj_ = ResourceAllocationSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'ResourceAllocationSection'
        elif nodeName_ == 'InstallSection':
            obj_ = InstallSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'InstallSection'
        elif nodeName_ == 'StartupSection':
            obj_ = StartupSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'StartupSection'
        elif nodeName_ == 'DeploymentOptionSection':
            obj_ = DeploymentOptionSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'DeploymentOptionSection'
        elif nodeName_ == 'PropertySection':
            obj_ = PropertySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PropertySection'
        elif nodeName_ == 'PlatformSection':
            obj_ = PlatformSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'PlatformSection'
        elif nodeName_ == 'IpAssignmentSection':
            obj_ = IpAssignmentSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'IpAssignmentSection'
        elif nodeName_ == 'CpuCompatibilitySection':
            obj_ = CpuCompatibilitySection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CpuCompatibilitySection'
        elif nodeName_ == 'BootOrderSection':
            obj_ = BootOrderSection_Type.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'BootOrderSection'
        elif nodeName_ == 'CustomizationSection':
            obj_ = CustomizationSectionType.factory()
            obj_.build(child_)
            self.Section.append(obj_)
            obj_.original_tagname_ = 'CustomizationSection'
        elif nodeName_ == 'VAppScopedLocalId':
            VAppScopedLocalId_ = child_.text
            VAppScopedLocalId_ = self.gds_validate_string(VAppScopedLocalId_, node, 'VAppScopedLocalId')
            self.VAppScopedLocalId = VAppScopedLocalId_
        elif nodeName_ == 'DefaultStorageProfile':
            DefaultStorageProfile_ = child_.text
            DefaultStorageProfile_ = self.gds_validate_string(DefaultStorageProfile_, node, 'DefaultStorageProfile')
            self.DefaultStorageProfile = DefaultStorageProfile_
        elif nodeName_ == 'DateCreated':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DateCreated = dval_
        super(VAppTemplateType, self).buildChildren(child_, node, nodeName_, True)
# end class VAppTemplateType


class VAppTemplateChildrenType(VCloudExtensibleType):
    """0.9 Container for virtual machines included in this vApp template."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Vm=None):
        self.original_tagname_ = None
        super(VAppTemplateChildrenType, self).__init__(VCloudExtension, )
        if Vm is None:
            self.Vm = []
        else:
            self.Vm = Vm
    def factory(*args_, **kwargs_):
        if VAppTemplateChildrenType.subclass:
            return VAppTemplateChildrenType.subclass(*args_, **kwargs_)
        else:
            return VAppTemplateChildrenType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Vm(self): return self.Vm
    def set_Vm(self, Vm): self.Vm = Vm
    def add_Vm(self, value): self.Vm.append(value)
    def insert_Vm_at(self, index, value): self.Vm.insert(index, value)
    def replace_Vm_at(self, index, value): self.Vm[index] = value
    def hasContent_(self):
        if (
            self.Vm or
            super(VAppTemplateChildrenType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VAppTemplateChildrenType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VAppTemplateChildrenType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VAppTemplateChildrenType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VAppTemplateChildrenType'):
        super(VAppTemplateChildrenType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VAppTemplateChildrenType')
    def exportChildren(self, outfile, level, namespace_='', name_='VAppTemplateChildrenType', fromsubclass_=False, pretty_print=True):
        super(VAppTemplateChildrenType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Vm_ in self.Vm:
            Vm_.export(outfile, level, namespace_, name_='Vm', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VAppTemplateChildrenType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VAppTemplateChildrenType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VAppTemplateChildrenType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Vm=[\n')
        level += 1
        for Vm_ in self.Vm:
            showIndent(outfile, level)
            outfile.write('model_.VAppTemplateType(\n')
            Vm_.exportLiteral(outfile, level, name_='VAppTemplateType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VAppTemplateChildrenType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Vm':
            obj_ = VAppTemplateType.factory()
            obj_.build(child_)
            self.Vm.append(obj_)
            obj_.original_tagname_ = 'Vm'
        super(VAppTemplateChildrenType, self).buildChildren(child_, node, nodeName_, True)
# end class VAppTemplateChildrenType


class UploadVAppTemplateParamsType(ParamsType):
    """0.9 Parameters for an uploadVappTemplate request. always Reserved.
    Unimplemented. falsealways True if an OVF manifest is included
    in the upload. Default value is false. falsealways5.5 Source URL
    of the OVF package. false"""
    subclass = None
    superclass = ParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, manifestRequired=None, transferFormat=None, sourceHref=None, VdcStorageProfile=None):
        self.original_tagname_ = None
        super(UploadVAppTemplateParamsType, self).__init__(VCloudExtension, name, Description, )
        self.manifestRequired = _cast(bool, manifestRequired)
        self.transferFormat = _cast(None, transferFormat)
        self.sourceHref = _cast(None, sourceHref)
        self.VdcStorageProfile = VdcStorageProfile
    def factory(*args_, **kwargs_):
        if UploadVAppTemplateParamsType.subclass:
            return UploadVAppTemplateParamsType.subclass(*args_, **kwargs_)
        else:
            return UploadVAppTemplateParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VdcStorageProfile(self): return self.VdcStorageProfile
    def set_VdcStorageProfile(self, VdcStorageProfile): self.VdcStorageProfile = VdcStorageProfile
    def get_manifestRequired(self): return self.manifestRequired
    def set_manifestRequired(self, manifestRequired): self.manifestRequired = manifestRequired
    def get_transferFormat(self): return self.transferFormat
    def set_transferFormat(self, transferFormat): self.transferFormat = transferFormat
    def get_sourceHref(self): return self.sourceHref
    def set_sourceHref(self, sourceHref): self.sourceHref = sourceHref
    def hasContent_(self):
        if (
            self.VdcStorageProfile is not None or
            super(UploadVAppTemplateParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UploadVAppTemplateParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UploadVAppTemplateParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UploadVAppTemplateParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UploadVAppTemplateParamsType'):
        super(UploadVAppTemplateParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UploadVAppTemplateParamsType')
        if self.manifestRequired is not None and 'manifestRequired' not in already_processed:
            already_processed.add('manifestRequired')
            outfile.write(' manifestRequired="%s"' % self.gds_format_boolean(self.manifestRequired, input_name='manifestRequired'))
        if self.transferFormat is not None and 'transferFormat' not in already_processed:
            already_processed.add('transferFormat')
            outfile.write(' transferFormat=%s' % (self.gds_format_string(quote_attrib(self.transferFormat).encode(ExternalEncoding), input_name='transferFormat'), ))
        if self.sourceHref is not None and 'sourceHref' not in already_processed:
            already_processed.add('sourceHref')
            outfile.write(' sourceHref=%s' % (self.gds_format_string(quote_attrib(self.sourceHref).encode(ExternalEncoding), input_name='sourceHref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='UploadVAppTemplateParamsType', fromsubclass_=False, pretty_print=True):
        super(UploadVAppTemplateParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VdcStorageProfile is not None:
            self.VdcStorageProfile.export(outfile, level, namespace_, name_='VdcStorageProfile', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='UploadVAppTemplateParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.manifestRequired is not None and 'manifestRequired' not in already_processed:
            already_processed.add('manifestRequired')
            showIndent(outfile, level)
            outfile.write('manifestRequired=%s,\n' % (self.manifestRequired,))
        if self.transferFormat is not None and 'transferFormat' not in already_processed:
            already_processed.add('transferFormat')
            showIndent(outfile, level)
            outfile.write('transferFormat="%s",\n' % (self.transferFormat,))
        if self.sourceHref is not None and 'sourceHref' not in already_processed:
            already_processed.add('sourceHref')
            showIndent(outfile, level)
            outfile.write('sourceHref="%s",\n' % (self.sourceHref,))
        super(UploadVAppTemplateParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UploadVAppTemplateParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.VdcStorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('VdcStorageProfile=model_.ReferenceType(\n')
            self.VdcStorageProfile.exportLiteral(outfile, level, name_='VdcStorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('manifestRequired', node)
        if value is not None and 'manifestRequired' not in already_processed:
            already_processed.add('manifestRequired')
            if value in ('true', '1'):
                self.manifestRequired = True
            elif value in ('false', '0'):
                self.manifestRequired = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('transferFormat', node)
        if value is not None and 'transferFormat' not in already_processed:
            already_processed.add('transferFormat')
            self.transferFormat = value
        value = find_attr_value_('sourceHref', node)
        if value is not None and 'sourceHref' not in already_processed:
            already_processed.add('sourceHref')
            self.sourceHref = value
        super(UploadVAppTemplateParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VdcStorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VdcStorageProfile = obj_
            obj_.original_tagname_ = 'VdcStorageProfile'
        super(UploadVAppTemplateParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class UploadVAppTemplateParamsType


class CloneVAppTemplateParamsType(ParamsType):
    """0.9 Parameters for a cloneVappTemplate request."""
    subclass = None
    superclass = ParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, Source=None, IsSourceDelete=None, VdcStorageProfile=None):
        self.original_tagname_ = None
        super(CloneVAppTemplateParamsType, self).__init__(VCloudExtension, name, Description, )
        self.Source = Source
        self.IsSourceDelete = IsSourceDelete
        self.VdcStorageProfile = VdcStorageProfile
    def factory(*args_, **kwargs_):
        if CloneVAppTemplateParamsType.subclass:
            return CloneVAppTemplateParamsType.subclass(*args_, **kwargs_)
        else:
            return CloneVAppTemplateParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_IsSourceDelete(self): return self.IsSourceDelete
    def set_IsSourceDelete(self, IsSourceDelete): self.IsSourceDelete = IsSourceDelete
    def get_VdcStorageProfile(self): return self.VdcStorageProfile
    def set_VdcStorageProfile(self, VdcStorageProfile): self.VdcStorageProfile = VdcStorageProfile
    def hasContent_(self):
        if (
            self.Source is not None or
            self.IsSourceDelete is not None or
            self.VdcStorageProfile is not None or
            super(CloneVAppTemplateParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CloneVAppTemplateParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CloneVAppTemplateParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CloneVAppTemplateParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CloneVAppTemplateParamsType'):
        super(CloneVAppTemplateParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CloneVAppTemplateParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='CloneVAppTemplateParamsType', fromsubclass_=False, pretty_print=True):
        super(CloneVAppTemplateParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Source is not None:
            self.Source.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
        if self.IsSourceDelete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsSourceDelete>%s</%sIsSourceDelete>%s' % (namespace_, self.gds_format_boolean(self.IsSourceDelete, input_name='IsSourceDelete'), namespace_, eol_))
        if self.VdcStorageProfile is not None:
            self.VdcStorageProfile.export(outfile, level, namespace_, name_='VdcStorageProfile', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CloneVAppTemplateParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CloneVAppTemplateParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CloneVAppTemplateParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.ReferenceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IsSourceDelete is not None:
            showIndent(outfile, level)
            outfile.write('IsSourceDelete=%s,\n' % self.IsSourceDelete)
        if self.VdcStorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('VdcStorageProfile=model_.ReferenceType(\n')
            self.VdcStorageProfile.exportLiteral(outfile, level, name_='VdcStorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CloneVAppTemplateParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Source = obj_
            obj_.original_tagname_ = 'Source'
        elif nodeName_ == 'IsSourceDelete':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsSourceDelete')
            self.IsSourceDelete = ival_
        elif nodeName_ == 'VdcStorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VdcStorageProfile = obj_
            obj_.original_tagname_ = 'VdcStorageProfile'
        super(CloneVAppTemplateParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class CloneVAppTemplateParamsType


class CustomizationSectionType(Section_Type):
    """1.0 Represents a vApp template customization settings. always5.1
    True if this template is a gold master. falsenone Link to the
    section. falsenone MIME type of the section. false"""
    subclass = None
    superclass = Section_Type
    def __init__(self, href=None, type_=None, goldMaster=False, CustomizeOnInstantiate=None, Link=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(CustomizationSectionType, self).__init__()
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        self.goldMaster = _cast(bool, goldMaster)
        self.CustomizeOnInstantiate = CustomizeOnInstantiate
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if CustomizationSectionType.subclass:
            return CustomizationSectionType.subclass(*args_, **kwargs_)
        else:
            return CustomizationSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomizeOnInstantiate(self): return self.CustomizeOnInstantiate
    def set_CustomizeOnInstantiate(self, CustomizeOnInstantiate): self.CustomizeOnInstantiate = CustomizeOnInstantiate
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def add_Link(self, value): self.Link.append(value)
    def insert_Link_at(self, index, value): self.Link.insert(index, value)
    def replace_Link_at(self, index, value): self.Link[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_goldMaster(self): return self.goldMaster
    def set_goldMaster(self, goldMaster): self.goldMaster = goldMaster
    def hasContent_(self):
        if (
            self.CustomizeOnInstantiate is not None or
            self.Link or
            self.anytypeobjs_ or
            super(CustomizationSectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomizationSectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomizationSectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomizationSectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomizationSectionType'):
        super(CustomizationSectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CustomizationSectionType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.goldMaster is not None and 'goldMaster' not in already_processed:
            already_processed.add('goldMaster')
            outfile.write(' goldMaster="%s"' % self.gds_format_boolean(self.goldMaster, input_name='goldMaster'))
    def exportChildren(self, outfile, level, namespace_='', name_='CustomizationSectionType', fromsubclass_=False, pretty_print=True):
        super(CustomizationSectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomizeOnInstantiate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustomizeOnInstantiate>%s</%sCustomizeOnInstantiate>%s' % (namespace_, self.gds_format_boolean(self.CustomizeOnInstantiate, input_name='CustomizeOnInstantiate'), namespace_, eol_))
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CustomizationSectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.goldMaster is not None and 'goldMaster' not in already_processed:
            already_processed.add('goldMaster')
            showIndent(outfile, level)
            outfile.write('goldMaster=%s,\n' % (self.goldMaster,))
        super(CustomizationSectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CustomizationSectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.CustomizeOnInstantiate is not None:
            showIndent(outfile, level)
            outfile.write('CustomizeOnInstantiate=%s,\n' % self.CustomizeOnInstantiate)
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            Link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('goldMaster', node)
        if value is not None and 'goldMaster' not in already_processed:
            already_processed.add('goldMaster')
            if value in ('true', '1'):
                self.goldMaster = True
            elif value in ('false', '0'):
                self.goldMaster = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(CustomizationSectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomizeOnInstantiate':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'CustomizeOnInstantiate')
            self.CustomizeOnInstantiate = ival_
        elif nodeName_ == 'Link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.Link.append(obj_)
            obj_.original_tagname_ = 'Link'
        else:
            obj_ = self.gds_build_any(child_, 'CustomizationSectionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(CustomizationSectionType, self).buildChildren(child_, node, nodeName_, True)
# end class CustomizationSectionType


class VmsType(ResourceType):
    """5.1 Represents a list of virtual machines."""
    subclass = None
    superclass = ResourceType
    def __init__(self, VmReference=None):
        self.original_tagname_ = None
        super(VmsType, self).__init__()
        if VmReference is None:
            self.VmReference = []
        else:
            self.VmReference = VmReference
    def factory(*args_, **kwargs_):
        if VmsType.subclass:
            return VmsType.subclass(*args_, **kwargs_)
        else:
            return VmsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VmReference(self): return self.VmReference
    def set_VmReference(self, VmReference): self.VmReference = VmReference
    def add_VmReference(self, value): self.VmReference.append(value)
    def insert_VmReference_at(self, index, value): self.VmReference.insert(index, value)
    def replace_VmReference_at(self, index, value): self.VmReference[index] = value
    def hasContent_(self):
        if (
            self.VmReference or
            super(VmsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VmsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VmsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VmsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VmsType'):
        super(VmsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VmsType')
    def exportChildren(self, outfile, level, namespace_='', name_='VmsType', fromsubclass_=False, pretty_print=True):
        super(VmsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VmReference_ in self.VmReference:
            VmReference_.export(outfile, level, namespace_, name_='VmReference', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VmsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VmsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VmsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('VmReference=[\n')
        level += 1
        for VmReference_ in self.VmReference:
            showIndent(outfile, level)
            outfile.write('model_.ReferenceType(\n')
            VmReference_.exportLiteral(outfile, level, name_='ReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VmsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VmReference':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VmReference.append(obj_)
            obj_.original_tagname_ = 'VmReference'
        super(VmsType, self).buildChildren(child_, node, nodeName_, True)
# end class VmsType


class SupportedOperatingSystemsInfoType(ResourceType):
    """5.1 Operating systems available for use on virtual machines owned by
    this organization."""
    subclass = None
    superclass = ResourceType
    def __init__(self, OperatingSystemFamilyInfo=None):
        self.original_tagname_ = None
        super(SupportedOperatingSystemsInfoType, self).__init__()
        if OperatingSystemFamilyInfo is None:
            self.OperatingSystemFamilyInfo = []
        else:
            self.OperatingSystemFamilyInfo = OperatingSystemFamilyInfo
    def factory(*args_, **kwargs_):
        if SupportedOperatingSystemsInfoType.subclass:
            return SupportedOperatingSystemsInfoType.subclass(*args_, **kwargs_)
        else:
            return SupportedOperatingSystemsInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OperatingSystemFamilyInfo(self): return self.OperatingSystemFamilyInfo
    def set_OperatingSystemFamilyInfo(self, OperatingSystemFamilyInfo): self.OperatingSystemFamilyInfo = OperatingSystemFamilyInfo
    def add_OperatingSystemFamilyInfo(self, value): self.OperatingSystemFamilyInfo.append(value)
    def insert_OperatingSystemFamilyInfo_at(self, index, value): self.OperatingSystemFamilyInfo.insert(index, value)
    def replace_OperatingSystemFamilyInfo_at(self, index, value): self.OperatingSystemFamilyInfo[index] = value
    def hasContent_(self):
        if (
            self.OperatingSystemFamilyInfo or
            super(SupportedOperatingSystemsInfoType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupportedOperatingSystemsInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupportedOperatingSystemsInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupportedOperatingSystemsInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupportedOperatingSystemsInfoType'):
        super(SupportedOperatingSystemsInfoType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SupportedOperatingSystemsInfoType')
    def exportChildren(self, outfile, level, namespace_='', name_='SupportedOperatingSystemsInfoType', fromsubclass_=False, pretty_print=True):
        super(SupportedOperatingSystemsInfoType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OperatingSystemFamilyInfo_ in self.OperatingSystemFamilyInfo:
            OperatingSystemFamilyInfo_.export(outfile, level, namespace_, name_='OperatingSystemFamilyInfo', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SupportedOperatingSystemsInfoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SupportedOperatingSystemsInfoType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SupportedOperatingSystemsInfoType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('OperatingSystemFamilyInfo=[\n')
        level += 1
        for OperatingSystemFamilyInfo_ in self.OperatingSystemFamilyInfo:
            showIndent(outfile, level)
            outfile.write('model_.OperatingSystemFamilyInfoType(\n')
            OperatingSystemFamilyInfo_.exportLiteral(outfile, level, name_='OperatingSystemFamilyInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SupportedOperatingSystemsInfoType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OperatingSystemFamilyInfo':
            obj_ = OperatingSystemFamilyInfoType.factory()
            obj_.build(child_)
            self.OperatingSystemFamilyInfo.append(obj_)
            obj_.original_tagname_ = 'OperatingSystemFamilyInfo'
        super(SupportedOperatingSystemsInfoType, self).buildChildren(child_, node, nodeName_, True)
# end class SupportedOperatingSystemsInfoType


class OperatingSystemFamilyInfoType(VCloudExtensibleType):
    """5.1 Represents an operating system family."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Name=None, OperatingSystemFamilyId=None, OperatingSystem=None):
        self.original_tagname_ = None
        super(OperatingSystemFamilyInfoType, self).__init__(VCloudExtension, )
        self.Name = Name
        self.OperatingSystemFamilyId = OperatingSystemFamilyId
        if OperatingSystem is None:
            self.OperatingSystem = []
        else:
            self.OperatingSystem = OperatingSystem
    def factory(*args_, **kwargs_):
        if OperatingSystemFamilyInfoType.subclass:
            return OperatingSystemFamilyInfoType.subclass(*args_, **kwargs_)
        else:
            return OperatingSystemFamilyInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_OperatingSystemFamilyId(self): return self.OperatingSystemFamilyId
    def set_OperatingSystemFamilyId(self, OperatingSystemFamilyId): self.OperatingSystemFamilyId = OperatingSystemFamilyId
    def get_OperatingSystem(self): return self.OperatingSystem
    def set_OperatingSystem(self, OperatingSystem): self.OperatingSystem = OperatingSystem
    def add_OperatingSystem(self, value): self.OperatingSystem.append(value)
    def insert_OperatingSystem_at(self, index, value): self.OperatingSystem.insert(index, value)
    def replace_OperatingSystem_at(self, index, value): self.OperatingSystem[index] = value
    def hasContent_(self):
        if (
            self.Name is not None or
            self.OperatingSystemFamilyId is not None or
            self.OperatingSystem or
            super(OperatingSystemFamilyInfoType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OperatingSystemFamilyInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperatingSystemFamilyInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OperatingSystemFamilyInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperatingSystemFamilyInfoType'):
        super(OperatingSystemFamilyInfoType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OperatingSystemFamilyInfoType')
    def exportChildren(self, outfile, level, namespace_='', name_='OperatingSystemFamilyInfoType', fromsubclass_=False, pretty_print=True):
        super(OperatingSystemFamilyInfoType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.OperatingSystemFamilyId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOperatingSystemFamilyId>%s</%sOperatingSystemFamilyId>%s' % (namespace_, self.gds_format_integer(self.OperatingSystemFamilyId, input_name='OperatingSystemFamilyId'), namespace_, eol_))
        for OperatingSystem_ in self.OperatingSystem:
            OperatingSystem_.export(outfile, level, namespace_, name_='OperatingSystem', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OperatingSystemFamilyInfoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OperatingSystemFamilyInfoType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OperatingSystemFamilyInfoType, self).exportLiteralChildren(outfile, level, name_)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.OperatingSystemFamilyId is not None:
            showIndent(outfile, level)
            outfile.write('OperatingSystemFamilyId=%d,\n' % self.OperatingSystemFamilyId)
        showIndent(outfile, level)
        outfile.write('OperatingSystem=[\n')
        level += 1
        for OperatingSystem_ in self.OperatingSystem:
            showIndent(outfile, level)
            outfile.write('model_.OperatingSystemInfoType(\n')
            OperatingSystem_.exportLiteral(outfile, level, name_='OperatingSystemInfoType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OperatingSystemFamilyInfoType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'OperatingSystemFamilyId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OperatingSystemFamilyId')
            self.OperatingSystemFamilyId = ival_
        elif nodeName_ == 'OperatingSystem':
            obj_ = OperatingSystemInfoType.factory()
            obj_.build(child_)
            self.OperatingSystem.append(obj_)
            obj_.original_tagname_ = 'OperatingSystem'
        super(OperatingSystemFamilyInfoType, self).buildChildren(child_, node, nodeName_, True)
# end class OperatingSystemFamilyInfoType


class OperatingSystemInfoType(VCloudExtensibleType):
    """5.1 Information about an individual operating system."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, OperatingSystemId=None, DefaultHardDiskAdapterType=None, MinimumHardDiskSizeGigabytes=None, MinimumMemoryMegabytes=None, Name=None, InternalName=None, Supported=None, x64=None, MaximumCpuCount=None, MinimumHardwareVersion=None, PersonalizationEnabled=None, PersonalizationAuto=None, SysprepPackagingSupported=None, SupportsMemHotAdd=None, cimOsId=None, CimVersion=None, SupportedForCreate=None):
        self.original_tagname_ = None
        super(OperatingSystemInfoType, self).__init__(VCloudExtension, )
        self.OperatingSystemId = OperatingSystemId
        self.DefaultHardDiskAdapterType = DefaultHardDiskAdapterType
        self.MinimumHardDiskSizeGigabytes = MinimumHardDiskSizeGigabytes
        self.MinimumMemoryMegabytes = MinimumMemoryMegabytes
        self.Name = Name
        self.InternalName = InternalName
        self.Supported = Supported
        self.x64 = x64
        self.MaximumCpuCount = MaximumCpuCount
        self.MinimumHardwareVersion = MinimumHardwareVersion
        self.PersonalizationEnabled = PersonalizationEnabled
        self.PersonalizationAuto = PersonalizationAuto
        self.SysprepPackagingSupported = SysprepPackagingSupported
        self.SupportsMemHotAdd = SupportsMemHotAdd
        self.cimOsId = cimOsId
        self.CimVersion = CimVersion
        self.SupportedForCreate = SupportedForCreate
    def factory(*args_, **kwargs_):
        if OperatingSystemInfoType.subclass:
            return OperatingSystemInfoType.subclass(*args_, **kwargs_)
        else:
            return OperatingSystemInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OperatingSystemId(self): return self.OperatingSystemId
    def set_OperatingSystemId(self, OperatingSystemId): self.OperatingSystemId = OperatingSystemId
    def get_DefaultHardDiskAdapterType(self): return self.DefaultHardDiskAdapterType
    def set_DefaultHardDiskAdapterType(self, DefaultHardDiskAdapterType): self.DefaultHardDiskAdapterType = DefaultHardDiskAdapterType
    def get_MinimumHardDiskSizeGigabytes(self): return self.MinimumHardDiskSizeGigabytes
    def set_MinimumHardDiskSizeGigabytes(self, MinimumHardDiskSizeGigabytes): self.MinimumHardDiskSizeGigabytes = MinimumHardDiskSizeGigabytes
    def get_MinimumMemoryMegabytes(self): return self.MinimumMemoryMegabytes
    def set_MinimumMemoryMegabytes(self, MinimumMemoryMegabytes): self.MinimumMemoryMegabytes = MinimumMemoryMegabytes
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def get_InternalName(self): return self.InternalName
    def set_InternalName(self, InternalName): self.InternalName = InternalName
    def get_Supported(self): return self.Supported
    def set_Supported(self, Supported): self.Supported = Supported
    def get_x64(self): return self.x64
    def set_x64(self, x64): self.x64 = x64
    def get_MaximumCpuCount(self): return self.MaximumCpuCount
    def set_MaximumCpuCount(self, MaximumCpuCount): self.MaximumCpuCount = MaximumCpuCount
    def get_MinimumHardwareVersion(self): return self.MinimumHardwareVersion
    def set_MinimumHardwareVersion(self, MinimumHardwareVersion): self.MinimumHardwareVersion = MinimumHardwareVersion
    def get_PersonalizationEnabled(self): return self.PersonalizationEnabled
    def set_PersonalizationEnabled(self, PersonalizationEnabled): self.PersonalizationEnabled = PersonalizationEnabled
    def get_PersonalizationAuto(self): return self.PersonalizationAuto
    def set_PersonalizationAuto(self, PersonalizationAuto): self.PersonalizationAuto = PersonalizationAuto
    def get_SysprepPackagingSupported(self): return self.SysprepPackagingSupported
    def set_SysprepPackagingSupported(self, SysprepPackagingSupported): self.SysprepPackagingSupported = SysprepPackagingSupported
    def get_SupportsMemHotAdd(self): return self.SupportsMemHotAdd
    def set_SupportsMemHotAdd(self, SupportsMemHotAdd): self.SupportsMemHotAdd = SupportsMemHotAdd
    def get_cimOsId(self): return self.cimOsId
    def set_cimOsId(self, cimOsId): self.cimOsId = cimOsId
    def get_CimVersion(self): return self.CimVersion
    def set_CimVersion(self, CimVersion): self.CimVersion = CimVersion
    def get_SupportedForCreate(self): return self.SupportedForCreate
    def set_SupportedForCreate(self, SupportedForCreate): self.SupportedForCreate = SupportedForCreate
    def hasContent_(self):
        if (
            self.OperatingSystemId is not None or
            self.DefaultHardDiskAdapterType is not None or
            self.MinimumHardDiskSizeGigabytes is not None or
            self.MinimumMemoryMegabytes is not None or
            self.Name is not None or
            self.InternalName is not None or
            self.Supported is not None or
            self.x64 is not None or
            self.MaximumCpuCount is not None or
            self.MinimumHardwareVersion is not None or
            self.PersonalizationEnabled is not None or
            self.PersonalizationAuto is not None or
            self.SysprepPackagingSupported is not None or
            self.SupportsMemHotAdd is not None or
            self.cimOsId is not None or
            self.CimVersion is not None or
            self.SupportedForCreate is not None or
            super(OperatingSystemInfoType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OperatingSystemInfoType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperatingSystemInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OperatingSystemInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperatingSystemInfoType'):
        super(OperatingSystemInfoType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='OperatingSystemInfoType')
    def exportChildren(self, outfile, level, namespace_='', name_='OperatingSystemInfoType', fromsubclass_=False, pretty_print=True):
        super(OperatingSystemInfoType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OperatingSystemId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOperatingSystemId>%s</%sOperatingSystemId>%s' % (namespace_, self.gds_format_integer(self.OperatingSystemId, input_name='OperatingSystemId'), namespace_, eol_))
        if self.DefaultHardDiskAdapterType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDefaultHardDiskAdapterType>%s</%sDefaultHardDiskAdapterType>%s' % (namespace_, self.gds_format_integer(self.DefaultHardDiskAdapterType, input_name='DefaultHardDiskAdapterType'), namespace_, eol_))
        if self.MinimumHardDiskSizeGigabytes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMinimumHardDiskSizeGigabytes>%s</%sMinimumHardDiskSizeGigabytes>%s' % (namespace_, self.gds_format_integer(self.MinimumHardDiskSizeGigabytes, input_name='MinimumHardDiskSizeGigabytes'), namespace_, eol_))
        if self.MinimumMemoryMegabytes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMinimumMemoryMegabytes>%s</%sMinimumMemoryMegabytes>%s' % (namespace_, self.gds_format_integer(self.MinimumMemoryMegabytes, input_name='MinimumMemoryMegabytes'), namespace_, eol_))
        if self.Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sName>%s</%sName>%s' % (namespace_, self.gds_format_string(quote_xml(self.Name).encode(ExternalEncoding), input_name='Name'), namespace_, eol_))
        if self.InternalName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInternalName>%s</%sInternalName>%s' % (namespace_, self.gds_format_string(quote_xml(self.InternalName).encode(ExternalEncoding), input_name='InternalName'), namespace_, eol_))
        if self.Supported is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSupported>%s</%sSupported>%s' % (namespace_, self.gds_format_boolean(self.Supported, input_name='Supported'), namespace_, eol_))
        if self.x64 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sx64>%s</%sx64>%s' % (namespace_, self.gds_format_boolean(self.x64, input_name='x64'), namespace_, eol_))
        if self.MaximumCpuCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMaximumCpuCount>%s</%sMaximumCpuCount>%s' % (namespace_, self.gds_format_integer(self.MaximumCpuCount, input_name='MaximumCpuCount'), namespace_, eol_))
        if self.MinimumHardwareVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMinimumHardwareVersion>%s</%sMinimumHardwareVersion>%s' % (namespace_, self.gds_format_integer(self.MinimumHardwareVersion, input_name='MinimumHardwareVersion'), namespace_, eol_))
        if self.PersonalizationEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPersonalizationEnabled>%s</%sPersonalizationEnabled>%s' % (namespace_, self.gds_format_boolean(self.PersonalizationEnabled, input_name='PersonalizationEnabled'), namespace_, eol_))
        if self.PersonalizationAuto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPersonalizationAuto>%s</%sPersonalizationAuto>%s' % (namespace_, self.gds_format_boolean(self.PersonalizationAuto, input_name='PersonalizationAuto'), namespace_, eol_))
        if self.SysprepPackagingSupported is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSysprepPackagingSupported>%s</%sSysprepPackagingSupported>%s' % (namespace_, self.gds_format_boolean(self.SysprepPackagingSupported, input_name='SysprepPackagingSupported'), namespace_, eol_))
        if self.SupportsMemHotAdd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSupportsMemHotAdd>%s</%sSupportsMemHotAdd>%s' % (namespace_, self.gds_format_boolean(self.SupportsMemHotAdd, input_name='SupportsMemHotAdd'), namespace_, eol_))
        if self.cimOsId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scimOsId>%s</%scimOsId>%s' % (namespace_, self.gds_format_integer(self.cimOsId, input_name='cimOsId'), namespace_, eol_))
        if self.CimVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCimVersion>%s</%sCimVersion>%s' % (namespace_, self.gds_format_integer(self.CimVersion, input_name='CimVersion'), namespace_, eol_))
        if self.SupportedForCreate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSupportedForCreate>%s</%sSupportedForCreate>%s' % (namespace_, self.gds_format_boolean(self.SupportedForCreate, input_name='SupportedForCreate'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OperatingSystemInfoType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(OperatingSystemInfoType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(OperatingSystemInfoType, self).exportLiteralChildren(outfile, level, name_)
        if self.OperatingSystemId is not None:
            showIndent(outfile, level)
            outfile.write('OperatingSystemId=%d,\n' % self.OperatingSystemId)
        if self.DefaultHardDiskAdapterType is not None:
            showIndent(outfile, level)
            outfile.write('DefaultHardDiskAdapterType=%d,\n' % self.DefaultHardDiskAdapterType)
        if self.MinimumHardDiskSizeGigabytes is not None:
            showIndent(outfile, level)
            outfile.write('MinimumHardDiskSizeGigabytes=%d,\n' % self.MinimumHardDiskSizeGigabytes)
        if self.MinimumMemoryMegabytes is not None:
            showIndent(outfile, level)
            outfile.write('MinimumMemoryMegabytes=%d,\n' % self.MinimumMemoryMegabytes)
        if self.Name is not None:
            showIndent(outfile, level)
            outfile.write('Name=%s,\n' % quote_python(self.Name).encode(ExternalEncoding))
        if self.InternalName is not None:
            showIndent(outfile, level)
            outfile.write('InternalName=%s,\n' % quote_python(self.InternalName).encode(ExternalEncoding))
        if self.Supported is not None:
            showIndent(outfile, level)
            outfile.write('Supported=%s,\n' % self.Supported)
        if self.x64 is not None:
            showIndent(outfile, level)
            outfile.write('x64=%s,\n' % self.x64)
        if self.MaximumCpuCount is not None:
            showIndent(outfile, level)
            outfile.write('MaximumCpuCount=%d,\n' % self.MaximumCpuCount)
        if self.MinimumHardwareVersion is not None:
            showIndent(outfile, level)
            outfile.write('MinimumHardwareVersion=%d,\n' % self.MinimumHardwareVersion)
        if self.PersonalizationEnabled is not None:
            showIndent(outfile, level)
            outfile.write('PersonalizationEnabled=%s,\n' % self.PersonalizationEnabled)
        if self.PersonalizationAuto is not None:
            showIndent(outfile, level)
            outfile.write('PersonalizationAuto=%s,\n' % self.PersonalizationAuto)
        if self.SysprepPackagingSupported is not None:
            showIndent(outfile, level)
            outfile.write('SysprepPackagingSupported=%s,\n' % self.SysprepPackagingSupported)
        if self.SupportsMemHotAdd is not None:
            showIndent(outfile, level)
            outfile.write('SupportsMemHotAdd=%s,\n' % self.SupportsMemHotAdd)
        if self.cimOsId is not None:
            showIndent(outfile, level)
            outfile.write('cimOsId=%d,\n' % self.cimOsId)
        if self.CimVersion is not None:
            showIndent(outfile, level)
            outfile.write('CimVersion=%d,\n' % self.CimVersion)
        if self.SupportedForCreate is not None:
            showIndent(outfile, level)
            outfile.write('SupportedForCreate=%s,\n' % self.SupportedForCreate)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(OperatingSystemInfoType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OperatingSystemId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'OperatingSystemId')
            self.OperatingSystemId = ival_
        elif nodeName_ == 'DefaultHardDiskAdapterType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DefaultHardDiskAdapterType')
            self.DefaultHardDiskAdapterType = ival_
        elif nodeName_ == 'MinimumHardDiskSizeGigabytes':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MinimumHardDiskSizeGigabytes')
            self.MinimumHardDiskSizeGigabytes = ival_
        elif nodeName_ == 'MinimumMemoryMegabytes':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MinimumMemoryMegabytes')
            self.MinimumMemoryMegabytes = ival_
        elif nodeName_ == 'Name':
            Name_ = child_.text
            Name_ = self.gds_validate_string(Name_, node, 'Name')
            self.Name = Name_
        elif nodeName_ == 'InternalName':
            InternalName_ = child_.text
            InternalName_ = self.gds_validate_string(InternalName_, node, 'InternalName')
            self.InternalName = InternalName_
        elif nodeName_ == 'Supported':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Supported')
            self.Supported = ival_
        elif nodeName_ == 'x64':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'x64')
            self.x64 = ival_
        elif nodeName_ == 'MaximumCpuCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MaximumCpuCount')
            self.MaximumCpuCount = ival_
        elif nodeName_ == 'MinimumHardwareVersion':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MinimumHardwareVersion')
            self.MinimumHardwareVersion = ival_
        elif nodeName_ == 'PersonalizationEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'PersonalizationEnabled')
            self.PersonalizationEnabled = ival_
        elif nodeName_ == 'PersonalizationAuto':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'PersonalizationAuto')
            self.PersonalizationAuto = ival_
        elif nodeName_ == 'SysprepPackagingSupported':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SysprepPackagingSupported')
            self.SysprepPackagingSupported = ival_
        elif nodeName_ == 'SupportsMemHotAdd':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SupportsMemHotAdd')
            self.SupportsMemHotAdd = ival_
        elif nodeName_ == 'cimOsId':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'cimOsId')
            self.cimOsId = ival_
        elif nodeName_ == 'CimVersion':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CimVersion')
            self.CimVersion = ival_
        elif nodeName_ == 'SupportedForCreate':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'SupportedForCreate')
            self.SupportedForCreate = ival_
        super(OperatingSystemInfoType, self).buildChildren(child_, node, nodeName_, True)
# end class OperatingSystemInfoType


class QueryResultType(ResourceType):
    """1.5 Container type for query results in records format. none The
    name of the query that generated this result set. none The size
    of the pages into which the full result list is split. none The
    presented page of the full result list."""
    subclass = None
    superclass = ResourceType
    def __init__(self, name=None, pageSize=None, page=None):
        self.original_tagname_ = None
        super(QueryResultType, self).__init__()
        self.name = _cast(None, name)
        self.pageSize = _cast(int, pageSize)
        self.page = _cast(int, page)
    def factory(*args_, **kwargs_):
        if QueryResultType.subclass:
            return QueryResultType.subclass(*args_, **kwargs_)
        else:
            return QueryResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_pageSize(self): return self.pageSize
    def set_pageSize(self, pageSize): self.pageSize = pageSize
    def get_page(self): return self.page
    def set_page(self, page): self.page = page
    def hasContent_(self):
        if (
            super(QueryResultType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultType'):
        super(QueryResultType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.pageSize is not None and 'pageSize' not in already_processed:
            already_processed.add('pageSize')
            outfile.write(' pageSize="%s"' % self.gds_format_integer(self.pageSize, input_name='pageSize'))
        if self.page is not None and 'page' not in already_processed:
            already_processed.add('page')
            outfile.write(' page="%s"' % self.gds_format_integer(self.page, input_name='page'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultType', fromsubclass_=False, pretty_print=True):
        super(QueryResultType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='QueryResultType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.pageSize is not None and 'pageSize' not in already_processed:
            already_processed.add('pageSize')
            showIndent(outfile, level)
            outfile.write('pageSize=%d,\n' % (self.pageSize,))
        if self.page is not None and 'page' not in already_processed:
            already_processed.add('page')
            showIndent(outfile, level)
            outfile.write('page=%d,\n' % (self.page,))
        super(QueryResultType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('pageSize', node)
        if value is not None and 'pageSize' not in already_processed:
            already_processed.add('pageSize')
            try:
                self.pageSize = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('page', node)
        if value is not None and 'page' not in already_processed:
            already_processed.add('page')
            try:
                self.page = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(QueryResultType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultType


class QueryResultRecordsType(ContainerType):
    """1.5 Container for query results in records format."""
    subclass = None
    superclass = ContainerType
    def __init__(self, total=None, name=None, pageSize=None, page=None, Record=None):
        self.original_tagname_ = None
        super(QueryResultRecordsType, self).__init__(total, name, pageSize, page, )
        if Record is None:
            self.Record = []
        else:
            self.Record = Record
    def factory(*args_, **kwargs_):
        if QueryResultRecordsType.subclass:
            return QueryResultRecordsType.subclass(*args_, **kwargs_)
        else:
            return QueryResultRecordsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Record(self): return self.Record
    def set_Record(self, Record): self.Record = Record
    def add_Record(self, value): self.Record.append(value)
    def insert_Record_at(self, index, value): self.Record.insert(index, value)
    def replace_Record_at(self, index, value): self.Record[index] = value
    def hasContent_(self):
        if (
            self.Record or
            super(QueryResultRecordsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultRecordsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultRecordsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultRecordsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultRecordsType'):
        super(QueryResultRecordsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultRecordsType')
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultRecordsType', fromsubclass_=False, pretty_print=True):
        super(QueryResultRecordsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Record_ in self.Record:
            Record_.export(outfile, level, namespace_, name_='Record', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultRecordsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryResultRecordsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultRecordsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Record=[\n')
        level += 1
        for Record_ in self.Record:
            showIndent(outfile, level)
            outfile.write('model_.Record(\n')
            Record_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(QueryResultRecordsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Record':
            class_obj_ = self.get_class_obj_(child_, QueryResultRecordType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'Record'
        elif nodeName_ == 'OrgRecord':
            obj_ = QueryResultOrgRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'OrgRecord'
        elif nodeName_ == 'OrgVdcRecord':
            obj_ = QueryResultOrgVdcRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'OrgVdcRecord'
        elif nodeName_ == 'MediaRecord':
            obj_ = QueryResultMediaRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'MediaRecord'
        elif nodeName_ == 'VAppTemplateRecord':
            obj_ = QueryResultVAppTemplateRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'VAppTemplateRecord'
        elif nodeName_ == 'VAppRecord':
            obj_ = QueryResultVAppRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'VAppRecord'
        elif nodeName_ == 'VMRecord':
            obj_ = QueryResultVMRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'VMRecord'
        elif nodeName_ == 'OrgNetworkRecord':
            obj_ = QueryResultOrgNetworkRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'OrgNetworkRecord'
        elif nodeName_ == 'AdminOrgNetworkRecord':
            obj_ = QueryResultAdminOrgNetworkRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminOrgNetworkRecord'
        elif nodeName_ == 'VAppNetworkRecord':
            obj_ = QueryResultVAppNetworkRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'VAppNetworkRecord'
        elif nodeName_ == 'CatalogRecord':
            obj_ = QueryResultCatalogRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'CatalogRecord'
        elif nodeName_ == 'AdminVdcRecord':
            obj_ = QueryResultAdminVdcRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminVdcRecord'
        elif nodeName_ == 'VMWProviderVdcRecord':
            obj_ = QueryResultVMWProviderVdcRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'VMWProviderVdcRecord'
        elif nodeName_ == 'NetworkRecord':
            obj_ = QueryResultNetworkRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'NetworkRecord'
        elif nodeName_ == 'GroupRecord':
            obj_ = QueryResultGroupRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'GroupRecord'
        elif nodeName_ == 'UserRecord':
            obj_ = QueryResultUserRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'UserRecord'
        elif nodeName_ == 'StrandedUserRecord':
            obj_ = QueryResultStrandedUserRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'StrandedUserRecord'
        elif nodeName_ == 'RoleRecord':
            obj_ = QueryResultRoleRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'RoleRecord'
        elif nodeName_ == 'AllocatedExternalAddressRecord':
            obj_ = QueryResultAllocatedExternalAddressRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AllocatedExternalAddressRecord'
        elif nodeName_ == 'EventRecord':
            obj_ = QueryResultEventRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'EventRecord'
        elif nodeName_ == 'ResourcePoolRecord':
            obj_ = QueryResultResourcePoolRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'ResourcePoolRecord'
        elif nodeName_ == 'DatastoreRecord':
            obj_ = QueryResultDatastoreRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'DatastoreRecord'
        elif nodeName_ == 'NetworkPoolRecord':
            obj_ = QueryResultNetworkPoolRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'NetworkPoolRecord'
        elif nodeName_ == 'PortgroupRecord':
            obj_ = QueryResultPortgroupRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'PortgroupRecord'
        elif nodeName_ == 'DvSwitchRecord':
            obj_ = QueryResultDvSwitchRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'DvSwitchRecord'
        elif nodeName_ == 'CellRecord':
            obj_ = QueryResultCellRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'CellRecord'
        elif nodeName_ == 'VirtualCenterRecord':
            obj_ = QueryResultVirtualCenterRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'VirtualCenterRecord'
        elif nodeName_ == 'HostRecord':
            obj_ = QueryResultHostRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'HostRecord'
        elif nodeName_ == 'AdminVAppRecord':
            obj_ = QueryResultAdminVAppRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminVAppRecord'
        elif nodeName_ == 'RightRecord':
            obj_ = QueryResultRightRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'RightRecord'
        elif nodeName_ == 'AdminVMRecord':
            obj_ = QueryResultAdminVMRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminVMRecord'
        elif nodeName_ == 'AdminAllocatedExternalAddressRecord':
            obj_ = QueryResultAdminAllocatedExternalAddressRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminAllocatedExternalAddressRecord'
        elif nodeName_ == 'VAppOrgNetworkRelationRecord':
            obj_ = QueryResultVAppOrgNetworkRelationRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'VAppOrgNetworkRelationRecord'
        elif nodeName_ == 'OrgVdcResourcePoolRelationRecord':
            obj_ = QueryResultOrgVdcResourcePoolRelationRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'OrgVdcResourcePoolRelationRecord'
        elif nodeName_ == 'ProviderVdcResourcePoolRelationRecord':
            obj_ = QueryResultProviderVdcResourcePoolRelationRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'ProviderVdcResourcePoolRelationRecord'
        elif nodeName_ == 'DatastoreProviderVdcRelationRecord':
            obj_ = QueryResultDatastoreProviderVdcRelationRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'DatastoreProviderVdcRelationRecord'
        elif nodeName_ == 'AdminUserRecord':
            obj_ = QueryResultAdminUserRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminUserRecord'
        elif nodeName_ == 'AdminGroupRecord':
            obj_ = QueryResultAdminGroupRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminGroupRecord'
        elif nodeName_ == 'AdminVAppNetworkRecord':
            obj_ = QueryResultAdminVAppNetworkRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminVAppNetworkRecord'
        elif nodeName_ == 'AdminCatalogRecord':
            obj_ = QueryResultAdminCatalogRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminCatalogRecord'
        elif nodeName_ == 'AdminCatalogItemRecord':
            obj_ = QueryResultAdminCatalogItemRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminCatalogItemRecord'
        elif nodeName_ == 'CatalogItemRecord':
            obj_ = QueryResultCatalogItemRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'CatalogItemRecord'
        elif nodeName_ == 'AdminMediaRecord':
            obj_ = QueryResultAdminMediaRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminMediaRecord'
        elif nodeName_ == 'AdminVAppTemplateRecord':
            obj_ = QueryResultAdminVAppTemplateRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminVAppTemplateRecord'
        elif nodeName_ == 'AdminShadowVMRecord':
            obj_ = QueryResultAdminShadowVMRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminShadowVMRecord'
        elif nodeName_ == 'TaskRecord':
            obj_ = QueryResultTaskRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'TaskRecord'
        elif nodeName_ == 'AdminTaskRecord':
            obj_ = QueryResultAdminTaskRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminTaskRecord'
        elif nodeName_ == 'BlockingTaskRecord':
            obj_ = QueryResultBlockingTaskRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'BlockingTaskRecord'
        elif nodeName_ == 'DiskRecord':
            obj_ = QueryResultDiskRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'DiskRecord'
        elif nodeName_ == 'VmDiskRelationRecord':
            obj_ = QueryResultVmDiskRelationRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'VmDiskRelationRecord'
        elif nodeName_ == 'AdminDiskRecord':
            obj_ = QueryResultAdminDiskRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminDiskRecord'
        elif nodeName_ == 'AdminVmDiskRelationRecord':
            obj_ = QueryResultAdminVmDiskRelationRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminVmDiskRelationRecord'
        elif nodeName_ == 'ConditionRecord':
            obj_ = QueryResultConditionRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'ConditionRecord'
        elif nodeName_ == 'AdminEventRecord':
            obj_ = QueryResultAdminEventRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminEventRecord'
        elif nodeName_ == 'StrandedItemRecord':
            obj_ = QueryResultStrandedItemRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'StrandedItemRecord'
        elif nodeName_ == 'AdminServiceRecord':
            obj_ = QueryResultAdminServiceRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminServiceRecord'
        elif nodeName_ == 'ServiceRecord':
            obj_ = QueryResultServiceRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'ServiceRecord'
        elif nodeName_ == 'ServiceLinkRecord':
            obj_ = QueryResultServiceLinkRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'ServiceLinkRecord'
        elif nodeName_ == 'OrgVdcStorageProfileRecord':
            obj_ = QueryResultOrgVdcStorageProfileRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'OrgVdcStorageProfileRecord'
        elif nodeName_ == 'AdminOrgVdcStorageProfileRecord':
            obj_ = QueryResultAdminOrgVdcStorageProfileRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminOrgVdcStorageProfileRecord'
        elif nodeName_ == 'ProviderVdcStorageProfileRecord':
            obj_ = QueryResultProviderVdcStorageProfileRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'ProviderVdcStorageProfileRecord'
        elif nodeName_ == 'ApiFilterRecord':
            obj_ = QueryResultApiFilterRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'ApiFilterRecord'
        elif nodeName_ == 'AdminApiDefinitionRecord':
            obj_ = QueryResultAdminApiDefinitionRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminApiDefinitionRecord'
        elif nodeName_ == 'ApiDefinitionRecord':
            obj_ = QueryResultApiDefinitionRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'ApiDefinitionRecord'
        elif nodeName_ == 'AdminFileDescriptorRecord':
            obj_ = QueryResultAdminFileDescriptorRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AdminFileDescriptorRecord'
        elif nodeName_ == 'FileDescriptorRecord':
            obj_ = QueryResultFileDescriptorRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'FileDescriptorRecord'
        elif nodeName_ == 'ResourceClassActionRecord':
            obj_ = QueryResultResourceClassActionRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'ResourceClassActionRecord'
        elif nodeName_ == 'AclRuleRecord':
            obj_ = QueryResultAclRuleRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'AclRuleRecord'
        elif nodeName_ == 'ResourceClassRecord':
            obj_ = QueryResultResourceClassRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'ResourceClassRecord'
        elif nodeName_ == 'ServiceResourceRecord':
            obj_ = QueryResultServiceResourceRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'ServiceResourceRecord'
        elif nodeName_ == 'EdgeGatewayRecord':
            obj_ = QueryResultEdgeGatewayRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'EdgeGatewayRecord'
        elif nodeName_ == 'OrgVdcNetworkRecord':
            obj_ = QueryResultOrgVdcNetworkRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'OrgVdcNetworkRecord'
        elif nodeName_ == 'VAppOrgVdcNetworkRelationRecord':
            obj_ = QueryResultVAppOrgVdcNetworkRelationRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'VAppOrgVdcNetworkRelationRecord'
        elif nodeName_ == 'ExternalLocalizationRecord':
            obj_ = QueryResultExternalLocalizationRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'ExternalLocalizationRecord'
        elif nodeName_ == 'ResourcePoolVMRecord':
            obj_ = QueryResultResourcePoolVMRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'ResourcePoolVMRecord'
        elif nodeName_ == 'ToCloudTunnelRecord':
            obj_ = QueryResultToCloudTunnelRecordType.factory()
            obj_.build(child_)
            self.Record.append(obj_)
            obj_.original_tagname_ = 'ToCloudTunnelRecord'
        super(QueryResultRecordsType, self).buildChildren(child_, node, nodeName_, True)
# end class QueryResultRecordsType


class QueryResultRecordType(GeneratedsSuper):
    """always Base type for a single record from query result in records
    format. Subtypes define more specific elements. always Contains
    the URI to the resource. always The resource identifier,
    expressed in URN format. The value of this attribute uniquely
    identifies the resource, persists for the life of the resource,
    and is never reused. always Contains the type of the resource."""
    subclass = None
    superclass = None
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, extensiontype_=None):
        self.original_tagname_ = None
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        self.id = _cast(None, id)
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
        self.Metadata = Metadata
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if QueryResultRecordType.subclass:
            return QueryResultRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def add_Link(self, value): self.Link.append(value)
    def insert_Link_at(self, index, value): self.Link.insert(index, value)
    def replace_Link_at(self, index, value): self.Link[index] = value
    def get_Metadata(self): return self.Metadata
    def set_Metadata(self, Metadata): self.Metadata = Metadata
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Link or
            self.Metadata is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultRecordType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultRecordType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
        if self.Metadata is not None:
            self.Metadata.export(outfile, level, namespace_, name_='Metadata', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            Link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Metadata is not None:
            showIndent(outfile, level)
            outfile.write('Metadata=model_.MetadataType(\n')
            self.Metadata.exportLiteral(outfile, level, name_='Metadata')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.Link.append(obj_)
            obj_.original_tagname_ = 'Link'
        elif nodeName_ == 'Metadata':
            obj_ = MetadataType.factory()
            obj_.build(child_)
            self.Metadata = obj_
            obj_.original_tagname_ = 'Metadata'
# end class QueryResultRecordType


class QueryResultOrgRecordType(QueryResultRecordType):
    """1.5 Type for a single organization query result in records format.
    1.5none Organization name 1.5none True if this organization is
    read only 1.5none True if this organization is enabled 1.5none
    Deployed VM quota 1.5none Stored VM Quota 1.5none Display name
    1.5none True if users from the organization can publish catalogs
    1.5none Number of catalogs 1.5none Number of VDCs 1.5none Number
    of vApps 1.5none Number of groups 5.1none Number of disks"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, numberOfVdcs=None, displayName=None, name=None, numberOfDisks=None, isReadOnly=None, isEnabled=None, deployedVMQuota=None, storedVMQuota=None, canPublishCatalogs=None, numberOfVApps=None, numberOfCatalogs=None, numberOfGroups=None):
        self.original_tagname_ = None
        super(QueryResultOrgRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.numberOfVdcs = _cast(int, numberOfVdcs)
        self.displayName = _cast(None, displayName)
        self.name = _cast(None, name)
        self.numberOfDisks = _cast(int, numberOfDisks)
        self.isReadOnly = _cast(bool, isReadOnly)
        self.isEnabled = _cast(bool, isEnabled)
        self.deployedVMQuota = _cast(int, deployedVMQuota)
        self.storedVMQuota = _cast(int, storedVMQuota)
        self.canPublishCatalogs = _cast(bool, canPublishCatalogs)
        self.numberOfVApps = _cast(int, numberOfVApps)
        self.numberOfCatalogs = _cast(int, numberOfCatalogs)
        self.numberOfGroups = _cast(int, numberOfGroups)
    def factory(*args_, **kwargs_):
        if QueryResultOrgRecordType.subclass:
            return QueryResultOrgRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultOrgRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfVdcs(self): return self.numberOfVdcs
    def set_numberOfVdcs(self, numberOfVdcs): self.numberOfVdcs = numberOfVdcs
    def get_displayName(self): return self.displayName
    def set_displayName(self, displayName): self.displayName = displayName
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_numberOfDisks(self): return self.numberOfDisks
    def set_numberOfDisks(self, numberOfDisks): self.numberOfDisks = numberOfDisks
    def get_isReadOnly(self): return self.isReadOnly
    def set_isReadOnly(self, isReadOnly): self.isReadOnly = isReadOnly
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_deployedVMQuota(self): return self.deployedVMQuota
    def set_deployedVMQuota(self, deployedVMQuota): self.deployedVMQuota = deployedVMQuota
    def get_storedVMQuota(self): return self.storedVMQuota
    def set_storedVMQuota(self, storedVMQuota): self.storedVMQuota = storedVMQuota
    def get_canPublishCatalogs(self): return self.canPublishCatalogs
    def set_canPublishCatalogs(self, canPublishCatalogs): self.canPublishCatalogs = canPublishCatalogs
    def get_numberOfVApps(self): return self.numberOfVApps
    def set_numberOfVApps(self, numberOfVApps): self.numberOfVApps = numberOfVApps
    def get_numberOfCatalogs(self): return self.numberOfCatalogs
    def set_numberOfCatalogs(self, numberOfCatalogs): self.numberOfCatalogs = numberOfCatalogs
    def get_numberOfGroups(self): return self.numberOfGroups
    def set_numberOfGroups(self, numberOfGroups): self.numberOfGroups = numberOfGroups
    def hasContent_(self):
        if (
            super(QueryResultOrgRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultOrgRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultOrgRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultOrgRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultOrgRecordType'):
        super(QueryResultOrgRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultOrgRecordType')
        if self.numberOfVdcs is not None and 'numberOfVdcs' not in already_processed:
            already_processed.add('numberOfVdcs')
            outfile.write(' numberOfVdcs="%s"' % self.gds_format_integer(self.numberOfVdcs, input_name='numberOfVdcs'))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            outfile.write(' displayName=%s' % (self.gds_format_string(quote_attrib(self.displayName).encode(ExternalEncoding), input_name='displayName'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.numberOfDisks is not None and 'numberOfDisks' not in already_processed:
            already_processed.add('numberOfDisks')
            outfile.write(' numberOfDisks="%s"' % self.gds_format_integer(self.numberOfDisks, input_name='numberOfDisks'))
        if self.isReadOnly is not None and 'isReadOnly' not in already_processed:
            already_processed.add('isReadOnly')
            outfile.write(' isReadOnly="%s"' % self.gds_format_boolean(self.isReadOnly, input_name='isReadOnly'))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.deployedVMQuota is not None and 'deployedVMQuota' not in already_processed:
            already_processed.add('deployedVMQuota')
            outfile.write(' deployedVMQuota="%s"' % self.gds_format_integer(self.deployedVMQuota, input_name='deployedVMQuota'))
        if self.storedVMQuota is not None and 'storedVMQuota' not in already_processed:
            already_processed.add('storedVMQuota')
            outfile.write(' storedVMQuota="%s"' % self.gds_format_integer(self.storedVMQuota, input_name='storedVMQuota'))
        if self.canPublishCatalogs is not None and 'canPublishCatalogs' not in already_processed:
            already_processed.add('canPublishCatalogs')
            outfile.write(' canPublishCatalogs="%s"' % self.gds_format_boolean(self.canPublishCatalogs, input_name='canPublishCatalogs'))
        if self.numberOfVApps is not None and 'numberOfVApps' not in already_processed:
            already_processed.add('numberOfVApps')
            outfile.write(' numberOfVApps="%s"' % self.gds_format_integer(self.numberOfVApps, input_name='numberOfVApps'))
        if self.numberOfCatalogs is not None and 'numberOfCatalogs' not in already_processed:
            already_processed.add('numberOfCatalogs')
            outfile.write(' numberOfCatalogs="%s"' % self.gds_format_integer(self.numberOfCatalogs, input_name='numberOfCatalogs'))
        if self.numberOfGroups is not None and 'numberOfGroups' not in already_processed:
            already_processed.add('numberOfGroups')
            outfile.write(' numberOfGroups="%s"' % self.gds_format_integer(self.numberOfGroups, input_name='numberOfGroups'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultOrgRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultOrgRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultOrgRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfVdcs is not None and 'numberOfVdcs' not in already_processed:
            already_processed.add('numberOfVdcs')
            showIndent(outfile, level)
            outfile.write('numberOfVdcs=%d,\n' % (self.numberOfVdcs,))
        if self.displayName is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            showIndent(outfile, level)
            outfile.write('displayName="%s",\n' % (self.displayName,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.numberOfDisks is not None and 'numberOfDisks' not in already_processed:
            already_processed.add('numberOfDisks')
            showIndent(outfile, level)
            outfile.write('numberOfDisks=%d,\n' % (self.numberOfDisks,))
        if self.isReadOnly is not None and 'isReadOnly' not in already_processed:
            already_processed.add('isReadOnly')
            showIndent(outfile, level)
            outfile.write('isReadOnly=%s,\n' % (self.isReadOnly,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.deployedVMQuota is not None and 'deployedVMQuota' not in already_processed:
            already_processed.add('deployedVMQuota')
            showIndent(outfile, level)
            outfile.write('deployedVMQuota=%d,\n' % (self.deployedVMQuota,))
        if self.storedVMQuota is not None and 'storedVMQuota' not in already_processed:
            already_processed.add('storedVMQuota')
            showIndent(outfile, level)
            outfile.write('storedVMQuota=%d,\n' % (self.storedVMQuota,))
        if self.canPublishCatalogs is not None and 'canPublishCatalogs' not in already_processed:
            already_processed.add('canPublishCatalogs')
            showIndent(outfile, level)
            outfile.write('canPublishCatalogs=%s,\n' % (self.canPublishCatalogs,))
        if self.numberOfVApps is not None and 'numberOfVApps' not in already_processed:
            already_processed.add('numberOfVApps')
            showIndent(outfile, level)
            outfile.write('numberOfVApps=%d,\n' % (self.numberOfVApps,))
        if self.numberOfCatalogs is not None and 'numberOfCatalogs' not in already_processed:
            already_processed.add('numberOfCatalogs')
            showIndent(outfile, level)
            outfile.write('numberOfCatalogs=%d,\n' % (self.numberOfCatalogs,))
        if self.numberOfGroups is not None and 'numberOfGroups' not in already_processed:
            already_processed.add('numberOfGroups')
            showIndent(outfile, level)
            outfile.write('numberOfGroups=%d,\n' % (self.numberOfGroups,))
        super(QueryResultOrgRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultOrgRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfVdcs', node)
        if value is not None and 'numberOfVdcs' not in already_processed:
            already_processed.add('numberOfVdcs')
            try:
                self.numberOfVdcs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('displayName', node)
        if value is not None and 'displayName' not in already_processed:
            already_processed.add('displayName')
            self.displayName = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('numberOfDisks', node)
        if value is not None and 'numberOfDisks' not in already_processed:
            already_processed.add('numberOfDisks')
            try:
                self.numberOfDisks = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isReadOnly', node)
        if value is not None and 'isReadOnly' not in already_processed:
            already_processed.add('isReadOnly')
            if value in ('true', '1'):
                self.isReadOnly = True
            elif value in ('false', '0'):
                self.isReadOnly = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('deployedVMQuota', node)
        if value is not None and 'deployedVMQuota' not in already_processed:
            already_processed.add('deployedVMQuota')
            try:
                self.deployedVMQuota = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storedVMQuota', node)
        if value is not None and 'storedVMQuota' not in already_processed:
            already_processed.add('storedVMQuota')
            try:
                self.storedVMQuota = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('canPublishCatalogs', node)
        if value is not None and 'canPublishCatalogs' not in already_processed:
            already_processed.add('canPublishCatalogs')
            if value in ('true', '1'):
                self.canPublishCatalogs = True
            elif value in ('false', '0'):
                self.canPublishCatalogs = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('numberOfVApps', node)
        if value is not None and 'numberOfVApps' not in already_processed:
            already_processed.add('numberOfVApps')
            try:
                self.numberOfVApps = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfCatalogs', node)
        if value is not None and 'numberOfCatalogs' not in already_processed:
            already_processed.add('numberOfCatalogs')
            try:
                self.numberOfCatalogs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfGroups', node)
        if value is not None and 'numberOfGroups' not in already_processed:
            already_processed.add('numberOfGroups')
            try:
                self.numberOfGroups = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(QueryResultOrgRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultOrgRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultOrgRecordType


class QueryResultOrgVdcRecordType(QueryResultRecordType):
    """1.5 Type for a single orgVdc query result in records format. 1.5none
    VDC name 1.5none True if this entity is enabled 1.5none CPU
    allocation in Mhz 1.5none CPU limit in Mhz 1.5none CPU used in
    Mhz 1.5none Memory allocation in MB 1.5none Memory limit in MB
    1.5none Memory used in MB 1.55.1none Storage allocation in MB
    1.5none Storage limit in MB 1.5none Storage used in MB 1.5none
    Provider VDC name 1.5none Provider VDC reference or id 1.5none
    Organization name 1.5none Number of vApps 1.5none Number of
    media 5.1none Number of disks 1.5none Number of vApp templates
    1.55.1none True if this VDC is used exclusively to support
    vShield Edge devices. 1.5none True if this entity is busy
    1.5none VDC status 1.5none Number of datastores 5.1none Number
    of storage profiles"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, numberOfStorageProfiles=None, memoryUsedMB=None, orgName=None, isSystemVdc=None, storageAllocationMB=None, numberOfVAppTemplates=None, isEnabled=None, cpuLimitMhz=None, memoryAllocationMB=None, isBusy=None, providerVdcName=None, cpuUsedMhz=None, status=None, memoryLimitMB=None, providerVdc=None, numberOfDatastores=None, numberOfVApps=None, storageUsedMB=None, name=None, numberOfDisks=None, storageLimitMB=None, numberOfMedia=None, cpuAllocationMhz=None):
        self.original_tagname_ = None
        super(QueryResultOrgVdcRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.numberOfStorageProfiles = _cast(int, numberOfStorageProfiles)
        self.memoryUsedMB = _cast(int, memoryUsedMB)
        self.orgName = _cast(None, orgName)
        self.isSystemVdc = _cast(bool, isSystemVdc)
        self.storageAllocationMB = _cast(int, storageAllocationMB)
        self.numberOfVAppTemplates = _cast(int, numberOfVAppTemplates)
        self.isEnabled = _cast(bool, isEnabled)
        self.cpuLimitMhz = _cast(int, cpuLimitMhz)
        self.memoryAllocationMB = _cast(int, memoryAllocationMB)
        self.isBusy = _cast(bool, isBusy)
        self.providerVdcName = _cast(None, providerVdcName)
        self.cpuUsedMhz = _cast(int, cpuUsedMhz)
        self.status = _cast(None, status)
        self.memoryLimitMB = _cast(int, memoryLimitMB)
        self.providerVdc = _cast(None, providerVdc)
        self.numberOfDatastores = _cast(int, numberOfDatastores)
        self.numberOfVApps = _cast(int, numberOfVApps)
        self.storageUsedMB = _cast(int, storageUsedMB)
        self.name = _cast(None, name)
        self.numberOfDisks = _cast(int, numberOfDisks)
        self.storageLimitMB = _cast(int, storageLimitMB)
        self.numberOfMedia = _cast(int, numberOfMedia)
        self.cpuAllocationMhz = _cast(int, cpuAllocationMhz)
    def factory(*args_, **kwargs_):
        if QueryResultOrgVdcRecordType.subclass:
            return QueryResultOrgVdcRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultOrgVdcRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfStorageProfiles(self): return self.numberOfStorageProfiles
    def set_numberOfStorageProfiles(self, numberOfStorageProfiles): self.numberOfStorageProfiles = numberOfStorageProfiles
    def get_memoryUsedMB(self): return self.memoryUsedMB
    def set_memoryUsedMB(self, memoryUsedMB): self.memoryUsedMB = memoryUsedMB
    def get_orgName(self): return self.orgName
    def set_orgName(self, orgName): self.orgName = orgName
    def get_isSystemVdc(self): return self.isSystemVdc
    def set_isSystemVdc(self, isSystemVdc): self.isSystemVdc = isSystemVdc
    def get_storageAllocationMB(self): return self.storageAllocationMB
    def set_storageAllocationMB(self, storageAllocationMB): self.storageAllocationMB = storageAllocationMB
    def get_numberOfVAppTemplates(self): return self.numberOfVAppTemplates
    def set_numberOfVAppTemplates(self, numberOfVAppTemplates): self.numberOfVAppTemplates = numberOfVAppTemplates
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_cpuLimitMhz(self): return self.cpuLimitMhz
    def set_cpuLimitMhz(self, cpuLimitMhz): self.cpuLimitMhz = cpuLimitMhz
    def get_memoryAllocationMB(self): return self.memoryAllocationMB
    def set_memoryAllocationMB(self, memoryAllocationMB): self.memoryAllocationMB = memoryAllocationMB
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_providerVdcName(self): return self.providerVdcName
    def set_providerVdcName(self, providerVdcName): self.providerVdcName = providerVdcName
    def get_cpuUsedMhz(self): return self.cpuUsedMhz
    def set_cpuUsedMhz(self, cpuUsedMhz): self.cpuUsedMhz = cpuUsedMhz
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_memoryLimitMB(self): return self.memoryLimitMB
    def set_memoryLimitMB(self, memoryLimitMB): self.memoryLimitMB = memoryLimitMB
    def get_providerVdc(self): return self.providerVdc
    def set_providerVdc(self, providerVdc): self.providerVdc = providerVdc
    def get_numberOfDatastores(self): return self.numberOfDatastores
    def set_numberOfDatastores(self, numberOfDatastores): self.numberOfDatastores = numberOfDatastores
    def get_numberOfVApps(self): return self.numberOfVApps
    def set_numberOfVApps(self, numberOfVApps): self.numberOfVApps = numberOfVApps
    def get_storageUsedMB(self): return self.storageUsedMB
    def set_storageUsedMB(self, storageUsedMB): self.storageUsedMB = storageUsedMB
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_numberOfDisks(self): return self.numberOfDisks
    def set_numberOfDisks(self, numberOfDisks): self.numberOfDisks = numberOfDisks
    def get_storageLimitMB(self): return self.storageLimitMB
    def set_storageLimitMB(self, storageLimitMB): self.storageLimitMB = storageLimitMB
    def get_numberOfMedia(self): return self.numberOfMedia
    def set_numberOfMedia(self, numberOfMedia): self.numberOfMedia = numberOfMedia
    def get_cpuAllocationMhz(self): return self.cpuAllocationMhz
    def set_cpuAllocationMhz(self, cpuAllocationMhz): self.cpuAllocationMhz = cpuAllocationMhz
    def hasContent_(self):
        if (
            super(QueryResultOrgVdcRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultOrgVdcRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultOrgVdcRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultOrgVdcRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultOrgVdcRecordType'):
        super(QueryResultOrgVdcRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultOrgVdcRecordType')
        if self.numberOfStorageProfiles is not None and 'numberOfStorageProfiles' not in already_processed:
            already_processed.add('numberOfStorageProfiles')
            outfile.write(' numberOfStorageProfiles="%s"' % self.gds_format_integer(self.numberOfStorageProfiles, input_name='numberOfStorageProfiles'))
        if self.memoryUsedMB is not None and 'memoryUsedMB' not in already_processed:
            already_processed.add('memoryUsedMB')
            outfile.write(' memoryUsedMB="%s"' % self.gds_format_integer(self.memoryUsedMB, input_name='memoryUsedMB'))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            outfile.write(' orgName=%s' % (self.gds_format_string(quote_attrib(self.orgName).encode(ExternalEncoding), input_name='orgName'), ))
        if self.isSystemVdc is not None and 'isSystemVdc' not in already_processed:
            already_processed.add('isSystemVdc')
            outfile.write(' isSystemVdc="%s"' % self.gds_format_boolean(self.isSystemVdc, input_name='isSystemVdc'))
        if self.storageAllocationMB is not None and 'storageAllocationMB' not in already_processed:
            already_processed.add('storageAllocationMB')
            outfile.write(' storageAllocationMB="%s"' % self.gds_format_integer(self.storageAllocationMB, input_name='storageAllocationMB'))
        if self.numberOfVAppTemplates is not None and 'numberOfVAppTemplates' not in already_processed:
            already_processed.add('numberOfVAppTemplates')
            outfile.write(' numberOfVAppTemplates="%s"' % self.gds_format_integer(self.numberOfVAppTemplates, input_name='numberOfVAppTemplates'))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.cpuLimitMhz is not None and 'cpuLimitMhz' not in already_processed:
            already_processed.add('cpuLimitMhz')
            outfile.write(' cpuLimitMhz="%s"' % self.gds_format_integer(self.cpuLimitMhz, input_name='cpuLimitMhz'))
        if self.memoryAllocationMB is not None and 'memoryAllocationMB' not in already_processed:
            already_processed.add('memoryAllocationMB')
            outfile.write(' memoryAllocationMB="%s"' % self.gds_format_integer(self.memoryAllocationMB, input_name='memoryAllocationMB'))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.providerVdcName is not None and 'providerVdcName' not in already_processed:
            already_processed.add('providerVdcName')
            outfile.write(' providerVdcName=%s' % (self.gds_format_string(quote_attrib(self.providerVdcName).encode(ExternalEncoding), input_name='providerVdcName'), ))
        if self.cpuUsedMhz is not None and 'cpuUsedMhz' not in already_processed:
            already_processed.add('cpuUsedMhz')
            outfile.write(' cpuUsedMhz="%s"' % self.gds_format_integer(self.cpuUsedMhz, input_name='cpuUsedMhz'))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.memoryLimitMB is not None and 'memoryLimitMB' not in already_processed:
            already_processed.add('memoryLimitMB')
            outfile.write(' memoryLimitMB="%s"' % self.gds_format_integer(self.memoryLimitMB, input_name='memoryLimitMB'))
        if self.providerVdc is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            outfile.write(' providerVdc=%s' % (self.gds_format_string(quote_attrib(self.providerVdc).encode(ExternalEncoding), input_name='providerVdc'), ))
        if self.numberOfDatastores is not None and 'numberOfDatastores' not in already_processed:
            already_processed.add('numberOfDatastores')
            outfile.write(' numberOfDatastores="%s"' % self.gds_format_integer(self.numberOfDatastores, input_name='numberOfDatastores'))
        if self.numberOfVApps is not None and 'numberOfVApps' not in already_processed:
            already_processed.add('numberOfVApps')
            outfile.write(' numberOfVApps="%s"' % self.gds_format_integer(self.numberOfVApps, input_name='numberOfVApps'))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            outfile.write(' storageUsedMB="%s"' % self.gds_format_integer(self.storageUsedMB, input_name='storageUsedMB'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.numberOfDisks is not None and 'numberOfDisks' not in already_processed:
            already_processed.add('numberOfDisks')
            outfile.write(' numberOfDisks="%s"' % self.gds_format_integer(self.numberOfDisks, input_name='numberOfDisks'))
        if self.storageLimitMB is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            outfile.write(' storageLimitMB="%s"' % self.gds_format_integer(self.storageLimitMB, input_name='storageLimitMB'))
        if self.numberOfMedia is not None and 'numberOfMedia' not in already_processed:
            already_processed.add('numberOfMedia')
            outfile.write(' numberOfMedia="%s"' % self.gds_format_integer(self.numberOfMedia, input_name='numberOfMedia'))
        if self.cpuAllocationMhz is not None and 'cpuAllocationMhz' not in already_processed:
            already_processed.add('cpuAllocationMhz')
            outfile.write(' cpuAllocationMhz="%s"' % self.gds_format_integer(self.cpuAllocationMhz, input_name='cpuAllocationMhz'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultOrgVdcRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultOrgVdcRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultOrgVdcRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfStorageProfiles is not None and 'numberOfStorageProfiles' not in already_processed:
            already_processed.add('numberOfStorageProfiles')
            showIndent(outfile, level)
            outfile.write('numberOfStorageProfiles=%d,\n' % (self.numberOfStorageProfiles,))
        if self.memoryUsedMB is not None and 'memoryUsedMB' not in already_processed:
            already_processed.add('memoryUsedMB')
            showIndent(outfile, level)
            outfile.write('memoryUsedMB=%d,\n' % (self.memoryUsedMB,))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            showIndent(outfile, level)
            outfile.write('orgName="%s",\n' % (self.orgName,))
        if self.isSystemVdc is not None and 'isSystemVdc' not in already_processed:
            already_processed.add('isSystemVdc')
            showIndent(outfile, level)
            outfile.write('isSystemVdc=%s,\n' % (self.isSystemVdc,))
        if self.storageAllocationMB is not None and 'storageAllocationMB' not in already_processed:
            already_processed.add('storageAllocationMB')
            showIndent(outfile, level)
            outfile.write('storageAllocationMB=%d,\n' % (self.storageAllocationMB,))
        if self.numberOfVAppTemplates is not None and 'numberOfVAppTemplates' not in already_processed:
            already_processed.add('numberOfVAppTemplates')
            showIndent(outfile, level)
            outfile.write('numberOfVAppTemplates=%d,\n' % (self.numberOfVAppTemplates,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.cpuLimitMhz is not None and 'cpuLimitMhz' not in already_processed:
            already_processed.add('cpuLimitMhz')
            showIndent(outfile, level)
            outfile.write('cpuLimitMhz=%d,\n' % (self.cpuLimitMhz,))
        if self.memoryAllocationMB is not None and 'memoryAllocationMB' not in already_processed:
            already_processed.add('memoryAllocationMB')
            showIndent(outfile, level)
            outfile.write('memoryAllocationMB=%d,\n' % (self.memoryAllocationMB,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.providerVdcName is not None and 'providerVdcName' not in already_processed:
            already_processed.add('providerVdcName')
            showIndent(outfile, level)
            outfile.write('providerVdcName="%s",\n' % (self.providerVdcName,))
        if self.cpuUsedMhz is not None and 'cpuUsedMhz' not in already_processed:
            already_processed.add('cpuUsedMhz')
            showIndent(outfile, level)
            outfile.write('cpuUsedMhz=%d,\n' % (self.cpuUsedMhz,))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.memoryLimitMB is not None and 'memoryLimitMB' not in already_processed:
            already_processed.add('memoryLimitMB')
            showIndent(outfile, level)
            outfile.write('memoryLimitMB=%d,\n' % (self.memoryLimitMB,))
        if self.providerVdc is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            showIndent(outfile, level)
            outfile.write('providerVdc="%s",\n' % (self.providerVdc,))
        if self.numberOfDatastores is not None and 'numberOfDatastores' not in already_processed:
            already_processed.add('numberOfDatastores')
            showIndent(outfile, level)
            outfile.write('numberOfDatastores=%d,\n' % (self.numberOfDatastores,))
        if self.numberOfVApps is not None and 'numberOfVApps' not in already_processed:
            already_processed.add('numberOfVApps')
            showIndent(outfile, level)
            outfile.write('numberOfVApps=%d,\n' % (self.numberOfVApps,))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            showIndent(outfile, level)
            outfile.write('storageUsedMB=%d,\n' % (self.storageUsedMB,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.numberOfDisks is not None and 'numberOfDisks' not in already_processed:
            already_processed.add('numberOfDisks')
            showIndent(outfile, level)
            outfile.write('numberOfDisks=%d,\n' % (self.numberOfDisks,))
        if self.storageLimitMB is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            showIndent(outfile, level)
            outfile.write('storageLimitMB=%d,\n' % (self.storageLimitMB,))
        if self.numberOfMedia is not None and 'numberOfMedia' not in already_processed:
            already_processed.add('numberOfMedia')
            showIndent(outfile, level)
            outfile.write('numberOfMedia=%d,\n' % (self.numberOfMedia,))
        if self.cpuAllocationMhz is not None and 'cpuAllocationMhz' not in already_processed:
            already_processed.add('cpuAllocationMhz')
            showIndent(outfile, level)
            outfile.write('cpuAllocationMhz=%d,\n' % (self.cpuAllocationMhz,))
        super(QueryResultOrgVdcRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultOrgVdcRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfStorageProfiles', node)
        if value is not None and 'numberOfStorageProfiles' not in already_processed:
            already_processed.add('numberOfStorageProfiles')
            try:
                self.numberOfStorageProfiles = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('memoryUsedMB', node)
        if value is not None and 'memoryUsedMB' not in already_processed:
            already_processed.add('memoryUsedMB')
            try:
                self.memoryUsedMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('orgName', node)
        if value is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            self.orgName = value
        value = find_attr_value_('isSystemVdc', node)
        if value is not None and 'isSystemVdc' not in already_processed:
            already_processed.add('isSystemVdc')
            if value in ('true', '1'):
                self.isSystemVdc = True
            elif value in ('false', '0'):
                self.isSystemVdc = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('storageAllocationMB', node)
        if value is not None and 'storageAllocationMB' not in already_processed:
            already_processed.add('storageAllocationMB')
            try:
                self.storageAllocationMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfVAppTemplates', node)
        if value is not None and 'numberOfVAppTemplates' not in already_processed:
            already_processed.add('numberOfVAppTemplates')
            try:
                self.numberOfVAppTemplates = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('cpuLimitMhz', node)
        if value is not None and 'cpuLimitMhz' not in already_processed:
            already_processed.add('cpuLimitMhz')
            try:
                self.cpuLimitMhz = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('memoryAllocationMB', node)
        if value is not None and 'memoryAllocationMB' not in already_processed:
            already_processed.add('memoryAllocationMB')
            try:
                self.memoryAllocationMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('providerVdcName', node)
        if value is not None and 'providerVdcName' not in already_processed:
            already_processed.add('providerVdcName')
            self.providerVdcName = value
        value = find_attr_value_('cpuUsedMhz', node)
        if value is not None and 'cpuUsedMhz' not in already_processed:
            already_processed.add('cpuUsedMhz')
            try:
                self.cpuUsedMhz = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('memoryLimitMB', node)
        if value is not None and 'memoryLimitMB' not in already_processed:
            already_processed.add('memoryLimitMB')
            try:
                self.memoryLimitMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('providerVdc', node)
        if value is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            self.providerVdc = value
        value = find_attr_value_('numberOfDatastores', node)
        if value is not None and 'numberOfDatastores' not in already_processed:
            already_processed.add('numberOfDatastores')
            try:
                self.numberOfDatastores = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfVApps', node)
        if value is not None and 'numberOfVApps' not in already_processed:
            already_processed.add('numberOfVApps')
            try:
                self.numberOfVApps = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storageUsedMB', node)
        if value is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            try:
                self.storageUsedMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('numberOfDisks', node)
        if value is not None and 'numberOfDisks' not in already_processed:
            already_processed.add('numberOfDisks')
            try:
                self.numberOfDisks = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storageLimitMB', node)
        if value is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            try:
                self.storageLimitMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfMedia', node)
        if value is not None and 'numberOfMedia' not in already_processed:
            already_processed.add('numberOfMedia')
            try:
                self.numberOfMedia = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('cpuAllocationMhz', node)
        if value is not None and 'cpuAllocationMhz' not in already_processed:
            already_processed.add('cpuAllocationMhz')
            try:
                self.cpuAllocationMhz = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(QueryResultOrgVdcRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultOrgVdcRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultOrgVdcRecordType


class QueryResultMediaRecordType(QueryResultRecordType):
    """1.5 Type for a single media query result in records format. 1.5none
    Owner name 1.5none Catalog name 1.5none True if this media file
    is in a published catalog. 1.5none Media name 1.5none VDC
    reference or id 1.5none VDC name 1.5none Organization reference
    or id 1.5none Creation date 1.5none True if this entity is busy
    1.5none Media storage in Bytes 1.5none Owner reference or id
    1.5none Catalog reference or id 1.5none Catalog item reference
    or id 1.5none Media status 5.1none Storage profile name"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, storageProfileName=None, name=None, storageB=None, isPublished=None, vdcName=None, catalog=None, vdc=None, catalogItem=None, ownerName=None, isBusy=None, owner=None, org=None, creationDate=None, catalogName=None):
        self.original_tagname_ = None
        super(QueryResultMediaRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        self.storageProfileName = _cast(None, storageProfileName)
        self.name = _cast(None, name)
        self.storageB = _cast(int, storageB)
        self.isPublished = _cast(bool, isPublished)
        self.vdcName = _cast(None, vdcName)
        self.catalog = _cast(None, catalog)
        self.vdc = _cast(None, vdc)
        self.catalogItem = _cast(None, catalogItem)
        self.ownerName = _cast(None, ownerName)
        self.isBusy = _cast(bool, isBusy)
        self.owner = _cast(None, owner)
        self.org = _cast(None, org)
        if isinstance(creationDate, basestring):
            initvalue_ = datetime_.datetime.strptime(creationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationDate
        self.creationDate = initvalue_
        self.catalogName = _cast(None, catalogName)
    def factory(*args_, **kwargs_):
        if QueryResultMediaRecordType.subclass:
            return QueryResultMediaRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultMediaRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_storageProfileName(self): return self.storageProfileName
    def set_storageProfileName(self, storageProfileName): self.storageProfileName = storageProfileName
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_storageB(self): return self.storageB
    def set_storageB(self, storageB): self.storageB = storageB
    def get_isPublished(self): return self.isPublished
    def set_isPublished(self, isPublished): self.isPublished = isPublished
    def get_vdcName(self): return self.vdcName
    def set_vdcName(self, vdcName): self.vdcName = vdcName
    def get_catalog(self): return self.catalog
    def set_catalog(self, catalog): self.catalog = catalog
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_catalogItem(self): return self.catalogItem
    def set_catalogItem(self, catalogItem): self.catalogItem = catalogItem
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_owner(self): return self.owner
    def set_owner(self, owner): self.owner = owner
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_creationDate(self): return self.creationDate
    def set_creationDate(self, creationDate): self.creationDate = creationDate
    def get_catalogName(self): return self.catalogName
    def set_catalogName(self, catalogName): self.catalogName = catalogName
    def hasContent_(self):
        if (
            super(QueryResultMediaRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultMediaRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultMediaRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultMediaRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultMediaRecordType'):
        super(QueryResultMediaRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultMediaRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            outfile.write(' storageProfileName=%s' % (self.gds_format_string(quote_attrib(self.storageProfileName).encode(ExternalEncoding), input_name='storageProfileName'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.storageB is not None and 'storageB' not in already_processed:
            already_processed.add('storageB')
            outfile.write(' storageB="%s"' % self.gds_format_integer(self.storageB, input_name='storageB'))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            outfile.write(' isPublished="%s"' % self.gds_format_boolean(self.isPublished, input_name='isPublished'))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            outfile.write(' vdcName=%s' % (self.gds_format_string(quote_attrib(self.vdcName).encode(ExternalEncoding), input_name='vdcName'), ))
        if self.catalog is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            outfile.write(' catalog=%s' % (self.gds_format_string(quote_attrib(self.catalog).encode(ExternalEncoding), input_name='catalog'), ))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.catalogItem is not None and 'catalogItem' not in already_processed:
            already_processed.add('catalogItem')
            outfile.write(' catalogItem=%s' % (self.gds_format_string(quote_attrib(self.catalogItem).encode(ExternalEncoding), input_name='catalogItem'), ))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            outfile.write(' owner=%s' % (self.gds_format_string(quote_attrib(self.owner).encode(ExternalEncoding), input_name='owner'), ))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            outfile.write(' creationDate="%s"' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            outfile.write(' catalogName=%s' % (self.gds_format_string(quote_attrib(self.catalogName).encode(ExternalEncoding), input_name='catalogName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultMediaRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultMediaRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultMediaRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            showIndent(outfile, level)
            outfile.write('storageProfileName="%s",\n' % (self.storageProfileName,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.storageB is not None and 'storageB' not in already_processed:
            already_processed.add('storageB')
            showIndent(outfile, level)
            outfile.write('storageB=%d,\n' % (self.storageB,))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            showIndent(outfile, level)
            outfile.write('isPublished=%s,\n' % (self.isPublished,))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            showIndent(outfile, level)
            outfile.write('vdcName="%s",\n' % (self.vdcName,))
        if self.catalog is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            showIndent(outfile, level)
            outfile.write('catalog="%s",\n' % (self.catalog,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.catalogItem is not None and 'catalogItem' not in already_processed:
            already_processed.add('catalogItem')
            showIndent(outfile, level)
            outfile.write('catalogItem="%s",\n' % (self.catalogItem,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            showIndent(outfile, level)
            outfile.write('owner="%s",\n' % (self.owner,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            showIndent(outfile, level)
            outfile.write('creationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            showIndent(outfile, level)
            outfile.write('catalogName="%s",\n' % (self.catalogName,))
        super(QueryResultMediaRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultMediaRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('storageProfileName', node)
        if value is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            self.storageProfileName = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('storageB', node)
        if value is not None and 'storageB' not in already_processed:
            already_processed.add('storageB')
            try:
                self.storageB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isPublished', node)
        if value is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            if value in ('true', '1'):
                self.isPublished = True
            elif value in ('false', '0'):
                self.isPublished = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vdcName', node)
        if value is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            self.vdcName = value
        value = find_attr_value_('catalog', node)
        if value is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            self.catalog = value
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('catalogItem', node)
        if value is not None and 'catalogItem' not in already_processed:
            already_processed.add('catalogItem')
            self.catalogItem = value
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('owner', node)
        if value is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            self.owner = value
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('creationDate', node)
        if value is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            try:
                self.creationDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (creationDate): %s' % exp)
        value = find_attr_value_('catalogName', node)
        if value is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            self.catalogName = value
        super(QueryResultMediaRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultMediaRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultMediaRecordType


class QueryResultVAppTemplateRecordType(QueryResultRecordType):
    """1.5 Type for a single vAppTemplate query result in records format.
    1.5none Owner name 1.5none Catalog name 1.5none True if this
    template is in a published catalog. 1.5none Vapp template name
    1.5none VDC reference or id 1.5none VDC name 1.5none
    Organization reference or id 1.5none Creation date 1.5none True
    if this entity is busy 1.5none True if this vApp template is a
    gold master. 1.5none True if the containing VDC is enabled
    1.5none Vapp template status 1.5none True if this vApp template
    is deployed 5.1none True if this vApp template is expired.
    5.1none Storage profile name"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, isGoldMaster=None, status=None, isDeployed=None, name=None, storageProfileName=None, isEnabled=None, isPublished=None, vdcName=None, vdc=None, ownerName=None, isBusy=None, org=None, isExpired=None, creationDate=None, catalogName=None):
        self.original_tagname_ = None
        super(QueryResultVAppTemplateRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.isGoldMaster = _cast(bool, isGoldMaster)
        self.status = _cast(None, status)
        self.isDeployed = _cast(bool, isDeployed)
        self.name = _cast(None, name)
        self.storageProfileName = _cast(None, storageProfileName)
        self.isEnabled = _cast(bool, isEnabled)
        self.isPublished = _cast(bool, isPublished)
        self.vdcName = _cast(None, vdcName)
        self.vdc = _cast(None, vdc)
        self.ownerName = _cast(None, ownerName)
        self.isBusy = _cast(bool, isBusy)
        self.org = _cast(None, org)
        self.isExpired = _cast(bool, isExpired)
        if isinstance(creationDate, basestring):
            initvalue_ = datetime_.datetime.strptime(creationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationDate
        self.creationDate = initvalue_
        self.catalogName = _cast(None, catalogName)
    def factory(*args_, **kwargs_):
        if QueryResultVAppTemplateRecordType.subclass:
            return QueryResultVAppTemplateRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultVAppTemplateRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isGoldMaster(self): return self.isGoldMaster
    def set_isGoldMaster(self, isGoldMaster): self.isGoldMaster = isGoldMaster
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_isDeployed(self): return self.isDeployed
    def set_isDeployed(self, isDeployed): self.isDeployed = isDeployed
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_storageProfileName(self): return self.storageProfileName
    def set_storageProfileName(self, storageProfileName): self.storageProfileName = storageProfileName
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_isPublished(self): return self.isPublished
    def set_isPublished(self, isPublished): self.isPublished = isPublished
    def get_vdcName(self): return self.vdcName
    def set_vdcName(self, vdcName): self.vdcName = vdcName
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_isExpired(self): return self.isExpired
    def set_isExpired(self, isExpired): self.isExpired = isExpired
    def get_creationDate(self): return self.creationDate
    def set_creationDate(self, creationDate): self.creationDate = creationDate
    def get_catalogName(self): return self.catalogName
    def set_catalogName(self, catalogName): self.catalogName = catalogName
    def hasContent_(self):
        if (
            super(QueryResultVAppTemplateRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultVAppTemplateRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVAppTemplateRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultVAppTemplateRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultVAppTemplateRecordType'):
        super(QueryResultVAppTemplateRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVAppTemplateRecordType')
        if self.isGoldMaster is not None and 'isGoldMaster' not in already_processed:
            already_processed.add('isGoldMaster')
            outfile.write(' isGoldMaster="%s"' % self.gds_format_boolean(self.isGoldMaster, input_name='isGoldMaster'))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            outfile.write(' isDeployed="%s"' % self.gds_format_boolean(self.isDeployed, input_name='isDeployed'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            outfile.write(' storageProfileName=%s' % (self.gds_format_string(quote_attrib(self.storageProfileName).encode(ExternalEncoding), input_name='storageProfileName'), ))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            outfile.write(' isPublished="%s"' % self.gds_format_boolean(self.isPublished, input_name='isPublished'))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            outfile.write(' vdcName=%s' % (self.gds_format_string(quote_attrib(self.vdcName).encode(ExternalEncoding), input_name='vdcName'), ))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.isExpired is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            outfile.write(' isExpired="%s"' % self.gds_format_boolean(self.isExpired, input_name='isExpired'))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            outfile.write(' creationDate="%s"' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            outfile.write(' catalogName=%s' % (self.gds_format_string(quote_attrib(self.catalogName).encode(ExternalEncoding), input_name='catalogName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultVAppTemplateRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultVAppTemplateRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultVAppTemplateRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isGoldMaster is not None and 'isGoldMaster' not in already_processed:
            already_processed.add('isGoldMaster')
            showIndent(outfile, level)
            outfile.write('isGoldMaster=%s,\n' % (self.isGoldMaster,))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            showIndent(outfile, level)
            outfile.write('isDeployed=%s,\n' % (self.isDeployed,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            showIndent(outfile, level)
            outfile.write('storageProfileName="%s",\n' % (self.storageProfileName,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            showIndent(outfile, level)
            outfile.write('isPublished=%s,\n' % (self.isPublished,))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            showIndent(outfile, level)
            outfile.write('vdcName="%s",\n' % (self.vdcName,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.isExpired is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            showIndent(outfile, level)
            outfile.write('isExpired=%s,\n' % (self.isExpired,))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            showIndent(outfile, level)
            outfile.write('creationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            showIndent(outfile, level)
            outfile.write('catalogName="%s",\n' % (self.catalogName,))
        super(QueryResultVAppTemplateRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultVAppTemplateRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isGoldMaster', node)
        if value is not None and 'isGoldMaster' not in already_processed:
            already_processed.add('isGoldMaster')
            if value in ('true', '1'):
                self.isGoldMaster = True
            elif value in ('false', '0'):
                self.isGoldMaster = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('isDeployed', node)
        if value is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            if value in ('true', '1'):
                self.isDeployed = True
            elif value in ('false', '0'):
                self.isDeployed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('storageProfileName', node)
        if value is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            self.storageProfileName = value
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isPublished', node)
        if value is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            if value in ('true', '1'):
                self.isPublished = True
            elif value in ('false', '0'):
                self.isPublished = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vdcName', node)
        if value is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            self.vdcName = value
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('isExpired', node)
        if value is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            if value in ('true', '1'):
                self.isExpired = True
            elif value in ('false', '0'):
                self.isExpired = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('creationDate', node)
        if value is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            try:
                self.creationDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (creationDate): %s' % exp)
        value = find_attr_value_('catalogName', node)
        if value is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            self.catalogName = value
        super(QueryResultVAppTemplateRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultVAppTemplateRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultVAppTemplateRecordType


class QueryResultVAppRecordType(QueryResultRecordType):
    """1.5 Type for a single vApp query result in records format. 1.5none
    vApp name 1.5none VDC reference or id 1.5none VDC name 1.5none
    True if this entity is public 1.5none True if this entity is
    enabled 1.5none True if this entity is busy 1.5none Creation
    date 1.5none Status 1.5none Owner name 1.5none True if this
    entity is deployed 1.5none True if this entity is in maintenance
    mode 5.1none True if this vApp is expired."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, isDeployed=None, name=None, isEnabled=None, isPublic=None, vdcName=None, vdc=None, ownerName=None, isBusy=None, isInMaintenanceMode=None, creationDate=None, isExpired=None):
        self.original_tagname_ = None
        super(QueryResultVAppRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        self.isDeployed = _cast(bool, isDeployed)
        self.name = _cast(None, name)
        self.isEnabled = _cast(bool, isEnabled)
        self.isPublic = _cast(bool, isPublic)
        self.vdcName = _cast(None, vdcName)
        self.vdc = _cast(None, vdc)
        self.ownerName = _cast(None, ownerName)
        self.isBusy = _cast(bool, isBusy)
        self.isInMaintenanceMode = _cast(bool, isInMaintenanceMode)
        if isinstance(creationDate, basestring):
            initvalue_ = datetime_.datetime.strptime(creationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationDate
        self.creationDate = initvalue_
        self.isExpired = _cast(bool, isExpired)
    def factory(*args_, **kwargs_):
        if QueryResultVAppRecordType.subclass:
            return QueryResultVAppRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultVAppRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_isDeployed(self): return self.isDeployed
    def set_isDeployed(self, isDeployed): self.isDeployed = isDeployed
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_isPublic(self): return self.isPublic
    def set_isPublic(self, isPublic): self.isPublic = isPublic
    def get_vdcName(self): return self.vdcName
    def set_vdcName(self, vdcName): self.vdcName = vdcName
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_isInMaintenanceMode(self): return self.isInMaintenanceMode
    def set_isInMaintenanceMode(self, isInMaintenanceMode): self.isInMaintenanceMode = isInMaintenanceMode
    def get_creationDate(self): return self.creationDate
    def set_creationDate(self, creationDate): self.creationDate = creationDate
    def get_isExpired(self): return self.isExpired
    def set_isExpired(self, isExpired): self.isExpired = isExpired
    def hasContent_(self):
        if (
            super(QueryResultVAppRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultVAppRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVAppRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultVAppRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultVAppRecordType'):
        super(QueryResultVAppRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVAppRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            outfile.write(' isDeployed="%s"' % self.gds_format_boolean(self.isDeployed, input_name='isDeployed'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.isPublic is not None and 'isPublic' not in already_processed:
            already_processed.add('isPublic')
            outfile.write(' isPublic="%s"' % self.gds_format_boolean(self.isPublic, input_name='isPublic'))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            outfile.write(' vdcName=%s' % (self.gds_format_string(quote_attrib(self.vdcName).encode(ExternalEncoding), input_name='vdcName'), ))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.isInMaintenanceMode is not None and 'isInMaintenanceMode' not in already_processed:
            already_processed.add('isInMaintenanceMode')
            outfile.write(' isInMaintenanceMode="%s"' % self.gds_format_boolean(self.isInMaintenanceMode, input_name='isInMaintenanceMode'))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            outfile.write(' creationDate="%s"' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.isExpired is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            outfile.write(' isExpired="%s"' % self.gds_format_boolean(self.isExpired, input_name='isExpired'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultVAppRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultVAppRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultVAppRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            showIndent(outfile, level)
            outfile.write('isDeployed=%s,\n' % (self.isDeployed,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.isPublic is not None and 'isPublic' not in already_processed:
            already_processed.add('isPublic')
            showIndent(outfile, level)
            outfile.write('isPublic=%s,\n' % (self.isPublic,))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            showIndent(outfile, level)
            outfile.write('vdcName="%s",\n' % (self.vdcName,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.isInMaintenanceMode is not None and 'isInMaintenanceMode' not in already_processed:
            already_processed.add('isInMaintenanceMode')
            showIndent(outfile, level)
            outfile.write('isInMaintenanceMode=%s,\n' % (self.isInMaintenanceMode,))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            showIndent(outfile, level)
            outfile.write('creationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.isExpired is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            showIndent(outfile, level)
            outfile.write('isExpired=%s,\n' % (self.isExpired,))
        super(QueryResultVAppRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultVAppRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('isDeployed', node)
        if value is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            if value in ('true', '1'):
                self.isDeployed = True
            elif value in ('false', '0'):
                self.isDeployed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isPublic', node)
        if value is not None and 'isPublic' not in already_processed:
            already_processed.add('isPublic')
            if value in ('true', '1'):
                self.isPublic = True
            elif value in ('false', '0'):
                self.isPublic = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vdcName', node)
        if value is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            self.vdcName = value
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isInMaintenanceMode', node)
        if value is not None and 'isInMaintenanceMode' not in already_processed:
            already_processed.add('isInMaintenanceMode')
            if value in ('true', '1'):
                self.isInMaintenanceMode = True
            elif value in ('false', '0'):
                self.isInMaintenanceMode = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('creationDate', node)
        if value is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            try:
                self.creationDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (creationDate): %s' % exp)
        value = find_attr_value_('isExpired', node)
        if value is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            if value in ('true', '1'):
                self.isExpired = True
            elif value in ('false', '0'):
                self.isExpired = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(QueryResultVAppRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultVAppRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultVAppRecordType


class QueryResultVMRecordType(QueryResultRecordType):
    """1.5 Type for a single vm query result in records format. 1.5none The
    name of the VM. 1.5none The name of the vApp or vApp template
    that contains this VM. 1.5none The ID of the vApp or vApp
    template that contains this VM. 1.5none VDC reference or id
    1.5none True if the VM belongs to a vApp template. 1.5none True
    if this entity is deleted 1.5none Guest operating system 1.5none
    Number of CPUs 1.5none Memory in MB 1.5none Status 1.5none True
    if this entity is busy 1.5none True if this entity is deployed
    1.5none True if this entity is in a published catalog 1.5none
    Catalog name 1.5none Hardware version 1.5none True if this
    entity is in maintenance mode 5.1none Storage profile name"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, containerName=None, isDeployed=None, container=None, name=None, storageProfileName=None, isPublished=None, memoryMB=None, numberOfCpus=None, vdc=None, hardwareVersion=None, isBusy=None, guestOs=None, isInMaintenanceMode=None, isVAppTemplate=None, isDeleted=None, catalogName=None):
        self.original_tagname_ = None
        super(QueryResultVMRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        self.containerName = _cast(None, containerName)
        self.isDeployed = _cast(bool, isDeployed)
        self.container = _cast(None, container)
        self.name = _cast(None, name)
        self.storageProfileName = _cast(None, storageProfileName)
        self.isPublished = _cast(bool, isPublished)
        self.memoryMB = _cast(int, memoryMB)
        self.numberOfCpus = _cast(int, numberOfCpus)
        self.vdc = _cast(None, vdc)
        self.hardwareVersion = _cast(int, hardwareVersion)
        self.isBusy = _cast(bool, isBusy)
        self.guestOs = _cast(None, guestOs)
        self.isInMaintenanceMode = _cast(bool, isInMaintenanceMode)
        self.isVAppTemplate = _cast(bool, isVAppTemplate)
        self.isDeleted = _cast(bool, isDeleted)
        self.catalogName = _cast(None, catalogName)
    def factory(*args_, **kwargs_):
        if QueryResultVMRecordType.subclass:
            return QueryResultVMRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultVMRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_containerName(self): return self.containerName
    def set_containerName(self, containerName): self.containerName = containerName
    def get_isDeployed(self): return self.isDeployed
    def set_isDeployed(self, isDeployed): self.isDeployed = isDeployed
    def get_container(self): return self.container
    def set_container(self, container): self.container = container
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_storageProfileName(self): return self.storageProfileName
    def set_storageProfileName(self, storageProfileName): self.storageProfileName = storageProfileName
    def get_isPublished(self): return self.isPublished
    def set_isPublished(self, isPublished): self.isPublished = isPublished
    def get_memoryMB(self): return self.memoryMB
    def set_memoryMB(self, memoryMB): self.memoryMB = memoryMB
    def get_numberOfCpus(self): return self.numberOfCpus
    def set_numberOfCpus(self, numberOfCpus): self.numberOfCpus = numberOfCpus
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_hardwareVersion(self): return self.hardwareVersion
    def set_hardwareVersion(self, hardwareVersion): self.hardwareVersion = hardwareVersion
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_guestOs(self): return self.guestOs
    def set_guestOs(self, guestOs): self.guestOs = guestOs
    def get_isInMaintenanceMode(self): return self.isInMaintenanceMode
    def set_isInMaintenanceMode(self, isInMaintenanceMode): self.isInMaintenanceMode = isInMaintenanceMode
    def get_isVAppTemplate(self): return self.isVAppTemplate
    def set_isVAppTemplate(self, isVAppTemplate): self.isVAppTemplate = isVAppTemplate
    def get_isDeleted(self): return self.isDeleted
    def set_isDeleted(self, isDeleted): self.isDeleted = isDeleted
    def get_catalogName(self): return self.catalogName
    def set_catalogName(self, catalogName): self.catalogName = catalogName
    def hasContent_(self):
        if (
            super(QueryResultVMRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultVMRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVMRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultVMRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultVMRecordType'):
        super(QueryResultVMRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVMRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.containerName is not None and 'containerName' not in already_processed:
            already_processed.add('containerName')
            outfile.write(' containerName=%s' % (self.gds_format_string(quote_attrib(self.containerName).encode(ExternalEncoding), input_name='containerName'), ))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            outfile.write(' isDeployed="%s"' % self.gds_format_boolean(self.isDeployed, input_name='isDeployed'))
        if self.container is not None and 'container' not in already_processed:
            already_processed.add('container')
            outfile.write(' container=%s' % (self.gds_format_string(quote_attrib(self.container).encode(ExternalEncoding), input_name='container'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            outfile.write(' storageProfileName=%s' % (self.gds_format_string(quote_attrib(self.storageProfileName).encode(ExternalEncoding), input_name='storageProfileName'), ))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            outfile.write(' isPublished="%s"' % self.gds_format_boolean(self.isPublished, input_name='isPublished'))
        if self.memoryMB is not None and 'memoryMB' not in already_processed:
            already_processed.add('memoryMB')
            outfile.write(' memoryMB="%s"' % self.gds_format_integer(self.memoryMB, input_name='memoryMB'))
        if self.numberOfCpus is not None and 'numberOfCpus' not in already_processed:
            already_processed.add('numberOfCpus')
            outfile.write(' numberOfCpus="%s"' % self.gds_format_integer(self.numberOfCpus, input_name='numberOfCpus'))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.hardwareVersion is not None and 'hardwareVersion' not in already_processed:
            already_processed.add('hardwareVersion')
            outfile.write(' hardwareVersion="%s"' % self.gds_format_integer(self.hardwareVersion, input_name='hardwareVersion'))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.guestOs is not None and 'guestOs' not in already_processed:
            already_processed.add('guestOs')
            outfile.write(' guestOs=%s' % (self.gds_format_string(quote_attrib(self.guestOs).encode(ExternalEncoding), input_name='guestOs'), ))
        if self.isInMaintenanceMode is not None and 'isInMaintenanceMode' not in already_processed:
            already_processed.add('isInMaintenanceMode')
            outfile.write(' isInMaintenanceMode="%s"' % self.gds_format_boolean(self.isInMaintenanceMode, input_name='isInMaintenanceMode'))
        if self.isVAppTemplate is not None and 'isVAppTemplate' not in already_processed:
            already_processed.add('isVAppTemplate')
            outfile.write(' isVAppTemplate="%s"' % self.gds_format_boolean(self.isVAppTemplate, input_name='isVAppTemplate'))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            outfile.write(' isDeleted="%s"' % self.gds_format_boolean(self.isDeleted, input_name='isDeleted'))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            outfile.write(' catalogName=%s' % (self.gds_format_string(quote_attrib(self.catalogName).encode(ExternalEncoding), input_name='catalogName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultVMRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultVMRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultVMRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.containerName is not None and 'containerName' not in already_processed:
            already_processed.add('containerName')
            showIndent(outfile, level)
            outfile.write('containerName="%s",\n' % (self.containerName,))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            showIndent(outfile, level)
            outfile.write('isDeployed=%s,\n' % (self.isDeployed,))
        if self.container is not None and 'container' not in already_processed:
            already_processed.add('container')
            showIndent(outfile, level)
            outfile.write('container="%s",\n' % (self.container,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            showIndent(outfile, level)
            outfile.write('storageProfileName="%s",\n' % (self.storageProfileName,))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            showIndent(outfile, level)
            outfile.write('isPublished=%s,\n' % (self.isPublished,))
        if self.memoryMB is not None and 'memoryMB' not in already_processed:
            already_processed.add('memoryMB')
            showIndent(outfile, level)
            outfile.write('memoryMB=%d,\n' % (self.memoryMB,))
        if self.numberOfCpus is not None and 'numberOfCpus' not in already_processed:
            already_processed.add('numberOfCpus')
            showIndent(outfile, level)
            outfile.write('numberOfCpus=%d,\n' % (self.numberOfCpus,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.hardwareVersion is not None and 'hardwareVersion' not in already_processed:
            already_processed.add('hardwareVersion')
            showIndent(outfile, level)
            outfile.write('hardwareVersion=%d,\n' % (self.hardwareVersion,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.guestOs is not None and 'guestOs' not in already_processed:
            already_processed.add('guestOs')
            showIndent(outfile, level)
            outfile.write('guestOs="%s",\n' % (self.guestOs,))
        if self.isInMaintenanceMode is not None and 'isInMaintenanceMode' not in already_processed:
            already_processed.add('isInMaintenanceMode')
            showIndent(outfile, level)
            outfile.write('isInMaintenanceMode=%s,\n' % (self.isInMaintenanceMode,))
        if self.isVAppTemplate is not None and 'isVAppTemplate' not in already_processed:
            already_processed.add('isVAppTemplate')
            showIndent(outfile, level)
            outfile.write('isVAppTemplate=%s,\n' % (self.isVAppTemplate,))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            showIndent(outfile, level)
            outfile.write('isDeleted=%s,\n' % (self.isDeleted,))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            showIndent(outfile, level)
            outfile.write('catalogName="%s",\n' % (self.catalogName,))
        super(QueryResultVMRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultVMRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('containerName', node)
        if value is not None and 'containerName' not in already_processed:
            already_processed.add('containerName')
            self.containerName = value
        value = find_attr_value_('isDeployed', node)
        if value is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            if value in ('true', '1'):
                self.isDeployed = True
            elif value in ('false', '0'):
                self.isDeployed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('container', node)
        if value is not None and 'container' not in already_processed:
            already_processed.add('container')
            self.container = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('storageProfileName', node)
        if value is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            self.storageProfileName = value
        value = find_attr_value_('isPublished', node)
        if value is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            if value in ('true', '1'):
                self.isPublished = True
            elif value in ('false', '0'):
                self.isPublished = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('memoryMB', node)
        if value is not None and 'memoryMB' not in already_processed:
            already_processed.add('memoryMB')
            try:
                self.memoryMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfCpus', node)
        if value is not None and 'numberOfCpus' not in already_processed:
            already_processed.add('numberOfCpus')
            try:
                self.numberOfCpus = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('hardwareVersion', node)
        if value is not None and 'hardwareVersion' not in already_processed:
            already_processed.add('hardwareVersion')
            try:
                self.hardwareVersion = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('guestOs', node)
        if value is not None and 'guestOs' not in already_processed:
            already_processed.add('guestOs')
            self.guestOs = value
        value = find_attr_value_('isInMaintenanceMode', node)
        if value is not None and 'isInMaintenanceMode' not in already_processed:
            already_processed.add('isInMaintenanceMode')
            if value in ('true', '1'):
                self.isInMaintenanceMode = True
            elif value in ('false', '0'):
                self.isInMaintenanceMode = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isVAppTemplate', node)
        if value is not None and 'isVAppTemplate' not in already_processed:
            already_processed.add('isVAppTemplate')
            if value in ('true', '1'):
                self.isVAppTemplate = True
            elif value in ('false', '0'):
                self.isVAppTemplate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isDeleted', node)
        if value is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            if value in ('true', '1'):
                self.isDeleted = True
            elif value in ('false', '0'):
                self.isDeleted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('catalogName', node)
        if value is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            self.catalogName = value
        super(QueryResultVMRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultVMRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultVMRecordType


class QueryResultOrgNetworkRecordType(QueryResultRecordType):
    """1.5 Type for a single orgNetwork query result in records format.
    1.5none The name of this network. 1.5none Network pool reference
    or id 1.5none Network pool name 1.5none Organization reference
    or id 1.5none IP scope object 1.5none True if this network's IP
    scope is inherited. 1.5none Gateway 1.5none Netmask 1.5none
    Primary DNS 1.5none Secondary DNS 1.5none DNS suffix 1.5none
    True if this entity is busy"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, name=None, isBusy=None, dns2=None, dns1=None, netmask=None, isIpScopeInherited=None, networkPoolName=None, dnsSuffix=None, org=None, networkPool=None, gateway=None, ipScopeId=None):
        self.original_tagname_ = None
        super(QueryResultOrgNetworkRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.name = _cast(None, name)
        self.isBusy = _cast(bool, isBusy)
        self.dns2 = _cast(None, dns2)
        self.dns1 = _cast(None, dns1)
        self.netmask = _cast(None, netmask)
        self.isIpScopeInherited = _cast(bool, isIpScopeInherited)
        self.networkPoolName = _cast(None, networkPoolName)
        self.dnsSuffix = _cast(None, dnsSuffix)
        self.org = _cast(None, org)
        self.networkPool = _cast(None, networkPool)
        self.gateway = _cast(None, gateway)
        self.ipScopeId = _cast(None, ipScopeId)
    def factory(*args_, **kwargs_):
        if QueryResultOrgNetworkRecordType.subclass:
            return QueryResultOrgNetworkRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultOrgNetworkRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_dns2(self): return self.dns2
    def set_dns2(self, dns2): self.dns2 = dns2
    def get_dns1(self): return self.dns1
    def set_dns1(self, dns1): self.dns1 = dns1
    def get_netmask(self): return self.netmask
    def set_netmask(self, netmask): self.netmask = netmask
    def get_isIpScopeInherited(self): return self.isIpScopeInherited
    def set_isIpScopeInherited(self, isIpScopeInherited): self.isIpScopeInherited = isIpScopeInherited
    def get_networkPoolName(self): return self.networkPoolName
    def set_networkPoolName(self, networkPoolName): self.networkPoolName = networkPoolName
    def get_dnsSuffix(self): return self.dnsSuffix
    def set_dnsSuffix(self, dnsSuffix): self.dnsSuffix = dnsSuffix
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_networkPool(self): return self.networkPool
    def set_networkPool(self, networkPool): self.networkPool = networkPool
    def get_gateway(self): return self.gateway
    def set_gateway(self, gateway): self.gateway = gateway
    def get_ipScopeId(self): return self.ipScopeId
    def set_ipScopeId(self, ipScopeId): self.ipScopeId = ipScopeId
    def hasContent_(self):
        if (
            super(QueryResultOrgNetworkRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultOrgNetworkRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultOrgNetworkRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultOrgNetworkRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultOrgNetworkRecordType'):
        super(QueryResultOrgNetworkRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultOrgNetworkRecordType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.dns2 is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            outfile.write(' dns2=%s' % (self.gds_format_string(quote_attrib(self.dns2).encode(ExternalEncoding), input_name='dns2'), ))
        if self.dns1 is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            outfile.write(' dns1=%s' % (self.gds_format_string(quote_attrib(self.dns1).encode(ExternalEncoding), input_name='dns1'), ))
        if self.netmask is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            outfile.write(' netmask=%s' % (self.gds_format_string(quote_attrib(self.netmask).encode(ExternalEncoding), input_name='netmask'), ))
        if self.isIpScopeInherited is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            outfile.write(' isIpScopeInherited="%s"' % self.gds_format_boolean(self.isIpScopeInherited, input_name='isIpScopeInherited'))
        if self.networkPoolName is not None and 'networkPoolName' not in already_processed:
            already_processed.add('networkPoolName')
            outfile.write(' networkPoolName=%s' % (self.gds_format_string(quote_attrib(self.networkPoolName).encode(ExternalEncoding), input_name='networkPoolName'), ))
        if self.dnsSuffix is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            outfile.write(' dnsSuffix=%s' % (self.gds_format_string(quote_attrib(self.dnsSuffix).encode(ExternalEncoding), input_name='dnsSuffix'), ))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.networkPool is not None and 'networkPool' not in already_processed:
            already_processed.add('networkPool')
            outfile.write(' networkPool=%s' % (self.gds_format_string(quote_attrib(self.networkPool).encode(ExternalEncoding), input_name='networkPool'), ))
        if self.gateway is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            outfile.write(' gateway=%s' % (self.gds_format_string(quote_attrib(self.gateway).encode(ExternalEncoding), input_name='gateway'), ))
        if self.ipScopeId is not None and 'ipScopeId' not in already_processed:
            already_processed.add('ipScopeId')
            outfile.write(' ipScopeId=%s' % (self.gds_format_string(quote_attrib(self.ipScopeId).encode(ExternalEncoding), input_name='ipScopeId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultOrgNetworkRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultOrgNetworkRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultOrgNetworkRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.dns2 is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            showIndent(outfile, level)
            outfile.write('dns2="%s",\n' % (self.dns2,))
        if self.dns1 is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            showIndent(outfile, level)
            outfile.write('dns1="%s",\n' % (self.dns1,))
        if self.netmask is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            showIndent(outfile, level)
            outfile.write('netmask="%s",\n' % (self.netmask,))
        if self.isIpScopeInherited is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            showIndent(outfile, level)
            outfile.write('isIpScopeInherited=%s,\n' % (self.isIpScopeInherited,))
        if self.networkPoolName is not None and 'networkPoolName' not in already_processed:
            already_processed.add('networkPoolName')
            showIndent(outfile, level)
            outfile.write('networkPoolName="%s",\n' % (self.networkPoolName,))
        if self.dnsSuffix is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            showIndent(outfile, level)
            outfile.write('dnsSuffix="%s",\n' % (self.dnsSuffix,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.networkPool is not None and 'networkPool' not in already_processed:
            already_processed.add('networkPool')
            showIndent(outfile, level)
            outfile.write('networkPool="%s",\n' % (self.networkPool,))
        if self.gateway is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            showIndent(outfile, level)
            outfile.write('gateway="%s",\n' % (self.gateway,))
        if self.ipScopeId is not None and 'ipScopeId' not in already_processed:
            already_processed.add('ipScopeId')
            showIndent(outfile, level)
            outfile.write('ipScopeId="%s",\n' % (self.ipScopeId,))
        super(QueryResultOrgNetworkRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultOrgNetworkRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('dns2', node)
        if value is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            self.dns2 = value
        value = find_attr_value_('dns1', node)
        if value is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            self.dns1 = value
        value = find_attr_value_('netmask', node)
        if value is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            self.netmask = value
        value = find_attr_value_('isIpScopeInherited', node)
        if value is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            if value in ('true', '1'):
                self.isIpScopeInherited = True
            elif value in ('false', '0'):
                self.isIpScopeInherited = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('networkPoolName', node)
        if value is not None and 'networkPoolName' not in already_processed:
            already_processed.add('networkPoolName')
            self.networkPoolName = value
        value = find_attr_value_('dnsSuffix', node)
        if value is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            self.dnsSuffix = value
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('networkPool', node)
        if value is not None and 'networkPool' not in already_processed:
            already_processed.add('networkPool')
            self.networkPool = value
        value = find_attr_value_('gateway', node)
        if value is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            self.gateway = value
        value = find_attr_value_('ipScopeId', node)
        if value is not None and 'ipScopeId' not in already_processed:
            already_processed.add('ipScopeId')
            self.ipScopeId = value
        super(QueryResultOrgNetworkRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultOrgNetworkRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultOrgNetworkRecordType


class QueryResultAdminOrgNetworkRecordType(QueryResultRecordType):
    """1.55.1 Type for a single adminOrgNetwork query result in records
    format. 1.5none The name of this network. 1.5none Organization
    name 1.5none Network pool reference or id 1.5none Network pool
    name 1.5none Organization reference or id 1.5none IP scope
    object 1.5none True if this network's IP scope is inherited.
    1.5none Gateway 1.5none Netmask 1.5none Primary DNS 1.5none
    Secondary DNS 1.5none True if this entity is busy"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, name=None, orgName=None, dns2=None, dns1=None, netmask=None, isIpScopeInherited=None, networkPoolName=None, isBusy=None, org=None, networkPool=None, gateway=None, ipScopeId=None):
        self.original_tagname_ = None
        super(QueryResultAdminOrgNetworkRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.name = _cast(None, name)
        self.orgName = _cast(None, orgName)
        self.dns2 = _cast(None, dns2)
        self.dns1 = _cast(None, dns1)
        self.netmask = _cast(None, netmask)
        self.isIpScopeInherited = _cast(bool, isIpScopeInherited)
        self.networkPoolName = _cast(None, networkPoolName)
        self.isBusy = _cast(bool, isBusy)
        self.org = _cast(None, org)
        self.networkPool = _cast(None, networkPool)
        self.gateway = _cast(None, gateway)
        self.ipScopeId = _cast(None, ipScopeId)
    def factory(*args_, **kwargs_):
        if QueryResultAdminOrgNetworkRecordType.subclass:
            return QueryResultAdminOrgNetworkRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminOrgNetworkRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_orgName(self): return self.orgName
    def set_orgName(self, orgName): self.orgName = orgName
    def get_dns2(self): return self.dns2
    def set_dns2(self, dns2): self.dns2 = dns2
    def get_dns1(self): return self.dns1
    def set_dns1(self, dns1): self.dns1 = dns1
    def get_netmask(self): return self.netmask
    def set_netmask(self, netmask): self.netmask = netmask
    def get_isIpScopeInherited(self): return self.isIpScopeInherited
    def set_isIpScopeInherited(self, isIpScopeInherited): self.isIpScopeInherited = isIpScopeInherited
    def get_networkPoolName(self): return self.networkPoolName
    def set_networkPoolName(self, networkPoolName): self.networkPoolName = networkPoolName
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_networkPool(self): return self.networkPool
    def set_networkPool(self, networkPool): self.networkPool = networkPool
    def get_gateway(self): return self.gateway
    def set_gateway(self, gateway): self.gateway = gateway
    def get_ipScopeId(self): return self.ipScopeId
    def set_ipScopeId(self, ipScopeId): self.ipScopeId = ipScopeId
    def hasContent_(self):
        if (
            super(QueryResultAdminOrgNetworkRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminOrgNetworkRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminOrgNetworkRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminOrgNetworkRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminOrgNetworkRecordType'):
        super(QueryResultAdminOrgNetworkRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminOrgNetworkRecordType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            outfile.write(' orgName=%s' % (self.gds_format_string(quote_attrib(self.orgName).encode(ExternalEncoding), input_name='orgName'), ))
        if self.dns2 is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            outfile.write(' dns2=%s' % (self.gds_format_string(quote_attrib(self.dns2).encode(ExternalEncoding), input_name='dns2'), ))
        if self.dns1 is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            outfile.write(' dns1=%s' % (self.gds_format_string(quote_attrib(self.dns1).encode(ExternalEncoding), input_name='dns1'), ))
        if self.netmask is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            outfile.write(' netmask=%s' % (self.gds_format_string(quote_attrib(self.netmask).encode(ExternalEncoding), input_name='netmask'), ))
        if self.isIpScopeInherited is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            outfile.write(' isIpScopeInherited="%s"' % self.gds_format_boolean(self.isIpScopeInherited, input_name='isIpScopeInherited'))
        if self.networkPoolName is not None and 'networkPoolName' not in already_processed:
            already_processed.add('networkPoolName')
            outfile.write(' networkPoolName=%s' % (self.gds_format_string(quote_attrib(self.networkPoolName).encode(ExternalEncoding), input_name='networkPoolName'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.networkPool is not None and 'networkPool' not in already_processed:
            already_processed.add('networkPool')
            outfile.write(' networkPool=%s' % (self.gds_format_string(quote_attrib(self.networkPool).encode(ExternalEncoding), input_name='networkPool'), ))
        if self.gateway is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            outfile.write(' gateway=%s' % (self.gds_format_string(quote_attrib(self.gateway).encode(ExternalEncoding), input_name='gateway'), ))
        if self.ipScopeId is not None and 'ipScopeId' not in already_processed:
            already_processed.add('ipScopeId')
            outfile.write(' ipScopeId=%s' % (self.gds_format_string(quote_attrib(self.ipScopeId).encode(ExternalEncoding), input_name='ipScopeId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminOrgNetworkRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminOrgNetworkRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminOrgNetworkRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            showIndent(outfile, level)
            outfile.write('orgName="%s",\n' % (self.orgName,))
        if self.dns2 is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            showIndent(outfile, level)
            outfile.write('dns2="%s",\n' % (self.dns2,))
        if self.dns1 is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            showIndent(outfile, level)
            outfile.write('dns1="%s",\n' % (self.dns1,))
        if self.netmask is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            showIndent(outfile, level)
            outfile.write('netmask="%s",\n' % (self.netmask,))
        if self.isIpScopeInherited is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            showIndent(outfile, level)
            outfile.write('isIpScopeInherited=%s,\n' % (self.isIpScopeInherited,))
        if self.networkPoolName is not None and 'networkPoolName' not in already_processed:
            already_processed.add('networkPoolName')
            showIndent(outfile, level)
            outfile.write('networkPoolName="%s",\n' % (self.networkPoolName,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.networkPool is not None and 'networkPool' not in already_processed:
            already_processed.add('networkPool')
            showIndent(outfile, level)
            outfile.write('networkPool="%s",\n' % (self.networkPool,))
        if self.gateway is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            showIndent(outfile, level)
            outfile.write('gateway="%s",\n' % (self.gateway,))
        if self.ipScopeId is not None and 'ipScopeId' not in already_processed:
            already_processed.add('ipScopeId')
            showIndent(outfile, level)
            outfile.write('ipScopeId="%s",\n' % (self.ipScopeId,))
        super(QueryResultAdminOrgNetworkRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminOrgNetworkRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('orgName', node)
        if value is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            self.orgName = value
        value = find_attr_value_('dns2', node)
        if value is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            self.dns2 = value
        value = find_attr_value_('dns1', node)
        if value is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            self.dns1 = value
        value = find_attr_value_('netmask', node)
        if value is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            self.netmask = value
        value = find_attr_value_('isIpScopeInherited', node)
        if value is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            if value in ('true', '1'):
                self.isIpScopeInherited = True
            elif value in ('false', '0'):
                self.isIpScopeInherited = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('networkPoolName', node)
        if value is not None and 'networkPoolName' not in already_processed:
            already_processed.add('networkPoolName')
            self.networkPoolName = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('networkPool', node)
        if value is not None and 'networkPool' not in already_processed:
            already_processed.add('networkPool')
            self.networkPool = value
        value = find_attr_value_('gateway', node)
        if value is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            self.gateway = value
        value = find_attr_value_('ipScopeId', node)
        if value is not None and 'ipScopeId' not in already_processed:
            already_processed.add('ipScopeId')
            self.ipScopeId = value
        super(QueryResultAdminOrgNetworkRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminOrgNetworkRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminOrgNetworkRecordType


class QueryResultVAppNetworkRecordType(QueryResultRecordType):
    """1.5 Type for a single vAppNetwork query result in records format.
    1.5none The name of this network. 1.5none IP scope object
    1.5none True if this network's IP scope is inherited. 1.5none
    Gateway 1.5none Netmask 1.5none Primary DNS 1.5none Secondary
    DNS 1.5none DNS suffix 1.5none VApp reference or id 1.5none Vapp
    name 1.5none True if this entity is busy"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, name=None, vAppName=None, dns2=None, dns1=None, isIpScopeInherited=None, netmask=None, dnsSuffix=None, isBusy=None, vApp=None, gateway=None, ipScopeId=None):
        self.original_tagname_ = None
        super(QueryResultVAppNetworkRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.name = _cast(None, name)
        self.vAppName = _cast(None, vAppName)
        self.dns2 = _cast(None, dns2)
        self.dns1 = _cast(None, dns1)
        self.isIpScopeInherited = _cast(bool, isIpScopeInherited)
        self.netmask = _cast(None, netmask)
        self.dnsSuffix = _cast(None, dnsSuffix)
        self.isBusy = _cast(bool, isBusy)
        self.vApp = _cast(None, vApp)
        self.gateway = _cast(None, gateway)
        self.ipScopeId = _cast(None, ipScopeId)
    def factory(*args_, **kwargs_):
        if QueryResultVAppNetworkRecordType.subclass:
            return QueryResultVAppNetworkRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultVAppNetworkRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_vAppName(self): return self.vAppName
    def set_vAppName(self, vAppName): self.vAppName = vAppName
    def get_dns2(self): return self.dns2
    def set_dns2(self, dns2): self.dns2 = dns2
    def get_dns1(self): return self.dns1
    def set_dns1(self, dns1): self.dns1 = dns1
    def get_isIpScopeInherited(self): return self.isIpScopeInherited
    def set_isIpScopeInherited(self, isIpScopeInherited): self.isIpScopeInherited = isIpScopeInherited
    def get_netmask(self): return self.netmask
    def set_netmask(self, netmask): self.netmask = netmask
    def get_dnsSuffix(self): return self.dnsSuffix
    def set_dnsSuffix(self, dnsSuffix): self.dnsSuffix = dnsSuffix
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_vApp(self): return self.vApp
    def set_vApp(self, vApp): self.vApp = vApp
    def get_gateway(self): return self.gateway
    def set_gateway(self, gateway): self.gateway = gateway
    def get_ipScopeId(self): return self.ipScopeId
    def set_ipScopeId(self, ipScopeId): self.ipScopeId = ipScopeId
    def hasContent_(self):
        if (
            super(QueryResultVAppNetworkRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultVAppNetworkRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVAppNetworkRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultVAppNetworkRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultVAppNetworkRecordType'):
        super(QueryResultVAppNetworkRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVAppNetworkRecordType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.vAppName is not None and 'vAppName' not in already_processed:
            already_processed.add('vAppName')
            outfile.write(' vAppName=%s' % (self.gds_format_string(quote_attrib(self.vAppName).encode(ExternalEncoding), input_name='vAppName'), ))
        if self.dns2 is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            outfile.write(' dns2=%s' % (self.gds_format_string(quote_attrib(self.dns2).encode(ExternalEncoding), input_name='dns2'), ))
        if self.dns1 is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            outfile.write(' dns1=%s' % (self.gds_format_string(quote_attrib(self.dns1).encode(ExternalEncoding), input_name='dns1'), ))
        if self.isIpScopeInherited is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            outfile.write(' isIpScopeInherited="%s"' % self.gds_format_boolean(self.isIpScopeInherited, input_name='isIpScopeInherited'))
        if self.netmask is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            outfile.write(' netmask=%s' % (self.gds_format_string(quote_attrib(self.netmask).encode(ExternalEncoding), input_name='netmask'), ))
        if self.dnsSuffix is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            outfile.write(' dnsSuffix=%s' % (self.gds_format_string(quote_attrib(self.dnsSuffix).encode(ExternalEncoding), input_name='dnsSuffix'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.vApp is not None and 'vApp' not in already_processed:
            already_processed.add('vApp')
            outfile.write(' vApp=%s' % (self.gds_format_string(quote_attrib(self.vApp).encode(ExternalEncoding), input_name='vApp'), ))
        if self.gateway is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            outfile.write(' gateway=%s' % (self.gds_format_string(quote_attrib(self.gateway).encode(ExternalEncoding), input_name='gateway'), ))
        if self.ipScopeId is not None and 'ipScopeId' not in already_processed:
            already_processed.add('ipScopeId')
            outfile.write(' ipScopeId=%s' % (self.gds_format_string(quote_attrib(self.ipScopeId).encode(ExternalEncoding), input_name='ipScopeId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultVAppNetworkRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultVAppNetworkRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultVAppNetworkRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.vAppName is not None and 'vAppName' not in already_processed:
            already_processed.add('vAppName')
            showIndent(outfile, level)
            outfile.write('vAppName="%s",\n' % (self.vAppName,))
        if self.dns2 is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            showIndent(outfile, level)
            outfile.write('dns2="%s",\n' % (self.dns2,))
        if self.dns1 is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            showIndent(outfile, level)
            outfile.write('dns1="%s",\n' % (self.dns1,))
        if self.isIpScopeInherited is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            showIndent(outfile, level)
            outfile.write('isIpScopeInherited=%s,\n' % (self.isIpScopeInherited,))
        if self.netmask is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            showIndent(outfile, level)
            outfile.write('netmask="%s",\n' % (self.netmask,))
        if self.dnsSuffix is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            showIndent(outfile, level)
            outfile.write('dnsSuffix="%s",\n' % (self.dnsSuffix,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.vApp is not None and 'vApp' not in already_processed:
            already_processed.add('vApp')
            showIndent(outfile, level)
            outfile.write('vApp="%s",\n' % (self.vApp,))
        if self.gateway is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            showIndent(outfile, level)
            outfile.write('gateway="%s",\n' % (self.gateway,))
        if self.ipScopeId is not None and 'ipScopeId' not in already_processed:
            already_processed.add('ipScopeId')
            showIndent(outfile, level)
            outfile.write('ipScopeId="%s",\n' % (self.ipScopeId,))
        super(QueryResultVAppNetworkRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultVAppNetworkRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('vAppName', node)
        if value is not None and 'vAppName' not in already_processed:
            already_processed.add('vAppName')
            self.vAppName = value
        value = find_attr_value_('dns2', node)
        if value is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            self.dns2 = value
        value = find_attr_value_('dns1', node)
        if value is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            self.dns1 = value
        value = find_attr_value_('isIpScopeInherited', node)
        if value is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            if value in ('true', '1'):
                self.isIpScopeInherited = True
            elif value in ('false', '0'):
                self.isIpScopeInherited = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('netmask', node)
        if value is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            self.netmask = value
        value = find_attr_value_('dnsSuffix', node)
        if value is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            self.dnsSuffix = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vApp', node)
        if value is not None and 'vApp' not in already_processed:
            already_processed.add('vApp')
            self.vApp = value
        value = find_attr_value_('gateway', node)
        if value is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            self.gateway = value
        value = find_attr_value_('ipScopeId', node)
        if value is not None and 'ipScopeId' not in already_processed:
            already_processed.add('ipScopeId')
            self.ipScopeId = value
        super(QueryResultVAppNetworkRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultVAppNetworkRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultVAppNetworkRecordType


class QueryResultCatalogRecordType(QueryResultRecordType):
    """1.5 Type for a single catalog query result in records format.
    1.5none The name of this catalog. 1.5none True if this catalog
    is published. 1.5none True if this catalog is shared. 1.5none
    Creation date 1.5none Organization name 1.5none Owner name
    1.5none Number of vApp templates 1.5none Number of media 1.5none
    Owner reference or id"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, name=None, numberOfVAppTemplates=None, orgName=None, isPublished=None, ownerName=None, numberOfMedia=None, owner=None, creationDate=None, isShared=None):
        self.original_tagname_ = None
        super(QueryResultCatalogRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.name = _cast(None, name)
        self.numberOfVAppTemplates = _cast(int, numberOfVAppTemplates)
        self.orgName = _cast(None, orgName)
        self.isPublished = _cast(bool, isPublished)
        self.ownerName = _cast(None, ownerName)
        self.numberOfMedia = _cast(int, numberOfMedia)
        self.owner = _cast(None, owner)
        if isinstance(creationDate, basestring):
            initvalue_ = datetime_.datetime.strptime(creationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationDate
        self.creationDate = initvalue_
        self.isShared = _cast(bool, isShared)
    def factory(*args_, **kwargs_):
        if QueryResultCatalogRecordType.subclass:
            return QueryResultCatalogRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultCatalogRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_numberOfVAppTemplates(self): return self.numberOfVAppTemplates
    def set_numberOfVAppTemplates(self, numberOfVAppTemplates): self.numberOfVAppTemplates = numberOfVAppTemplates
    def get_orgName(self): return self.orgName
    def set_orgName(self, orgName): self.orgName = orgName
    def get_isPublished(self): return self.isPublished
    def set_isPublished(self, isPublished): self.isPublished = isPublished
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_numberOfMedia(self): return self.numberOfMedia
    def set_numberOfMedia(self, numberOfMedia): self.numberOfMedia = numberOfMedia
    def get_owner(self): return self.owner
    def set_owner(self, owner): self.owner = owner
    def get_creationDate(self): return self.creationDate
    def set_creationDate(self, creationDate): self.creationDate = creationDate
    def get_isShared(self): return self.isShared
    def set_isShared(self, isShared): self.isShared = isShared
    def hasContent_(self):
        if (
            super(QueryResultCatalogRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultCatalogRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultCatalogRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultCatalogRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultCatalogRecordType'):
        super(QueryResultCatalogRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultCatalogRecordType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.numberOfVAppTemplates is not None and 'numberOfVAppTemplates' not in already_processed:
            already_processed.add('numberOfVAppTemplates')
            outfile.write(' numberOfVAppTemplates="%s"' % self.gds_format_integer(self.numberOfVAppTemplates, input_name='numberOfVAppTemplates'))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            outfile.write(' orgName=%s' % (self.gds_format_string(quote_attrib(self.orgName).encode(ExternalEncoding), input_name='orgName'), ))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            outfile.write(' isPublished="%s"' % self.gds_format_boolean(self.isPublished, input_name='isPublished'))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.numberOfMedia is not None and 'numberOfMedia' not in already_processed:
            already_processed.add('numberOfMedia')
            outfile.write(' numberOfMedia="%s"' % self.gds_format_integer(self.numberOfMedia, input_name='numberOfMedia'))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            outfile.write(' owner=%s' % (self.gds_format_string(quote_attrib(self.owner).encode(ExternalEncoding), input_name='owner'), ))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            outfile.write(' creationDate="%s"' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.isShared is not None and 'isShared' not in already_processed:
            already_processed.add('isShared')
            outfile.write(' isShared="%s"' % self.gds_format_boolean(self.isShared, input_name='isShared'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultCatalogRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultCatalogRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultCatalogRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.numberOfVAppTemplates is not None and 'numberOfVAppTemplates' not in already_processed:
            already_processed.add('numberOfVAppTemplates')
            showIndent(outfile, level)
            outfile.write('numberOfVAppTemplates=%d,\n' % (self.numberOfVAppTemplates,))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            showIndent(outfile, level)
            outfile.write('orgName="%s",\n' % (self.orgName,))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            showIndent(outfile, level)
            outfile.write('isPublished=%s,\n' % (self.isPublished,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.numberOfMedia is not None and 'numberOfMedia' not in already_processed:
            already_processed.add('numberOfMedia')
            showIndent(outfile, level)
            outfile.write('numberOfMedia=%d,\n' % (self.numberOfMedia,))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            showIndent(outfile, level)
            outfile.write('owner="%s",\n' % (self.owner,))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            showIndent(outfile, level)
            outfile.write('creationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.isShared is not None and 'isShared' not in already_processed:
            already_processed.add('isShared')
            showIndent(outfile, level)
            outfile.write('isShared=%s,\n' % (self.isShared,))
        super(QueryResultCatalogRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultCatalogRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('numberOfVAppTemplates', node)
        if value is not None and 'numberOfVAppTemplates' not in already_processed:
            already_processed.add('numberOfVAppTemplates')
            try:
                self.numberOfVAppTemplates = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('orgName', node)
        if value is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            self.orgName = value
        value = find_attr_value_('isPublished', node)
        if value is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            if value in ('true', '1'):
                self.isPublished = True
            elif value in ('false', '0'):
                self.isPublished = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('numberOfMedia', node)
        if value is not None and 'numberOfMedia' not in already_processed:
            already_processed.add('numberOfMedia')
            try:
                self.numberOfMedia = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('owner', node)
        if value is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            self.owner = value
        value = find_attr_value_('creationDate', node)
        if value is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            try:
                self.creationDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (creationDate): %s' % exp)
        value = find_attr_value_('isShared', node)
        if value is not None and 'isShared' not in already_processed:
            already_processed.add('isShared')
            if value in ('true', '1'):
                self.isShared = True
            elif value in ('false', '0'):
                self.isShared = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(QueryResultCatalogRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultCatalogRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultCatalogRecordType


class QueryResultAdminVdcRecordType(QueryResultRecordType):
    """1.5 Type for a single adminOrgVdc query result in records format.
    1.5none The name of this VDC. 1.5none True if this entity is
    enabled 1.5none CPU allocation in Mhz 1.5none CPU limit in Mhz
    1.5none CPU used in Mhz 1.5none Memory allocation in MB 1.5none
    Memory limit in MB 1.5none Memory used in MB 1.55.1none Storage
    allocation in MB 1.5none Storage limit in MB 1.5none Storage
    used in MB 1.5none Provider VDC name 1.5none Provider VDC
    reference or id 1.5none Organization name 1.5none Organization
    reference or id 1.5none Number of vApps 1.5none Number of media
    5.1none Number of disks 1.5none Number of vApp templates
    1.55.1none True if this VDC is used exclusively to support
    vShield Edge devices. 1.5none True if this entity is busy
    1.5none Status 1.5none Network pool reference or id 5.1none
    Number of storage profiles"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, numberOfStorageProfiles=None, memoryUsedMB=None, orgName=None, isSystemVdc=None, storageAllocationMB=None, numberOfVAppTemplates=None, isEnabled=None, cpuLimitMhz=None, memoryAllocationMB=None, isBusy=None, providerVdcName=None, cpuUsedMhz=None, networkPool=None, status=None, memoryLimitMB=None, providerVdc=None, numberOfVApps=None, org=None, storageUsedMB=None, name=None, numberOfDisks=None, storageLimitMB=None, numberOfMedia=None, cpuAllocationMhz=None):
        self.original_tagname_ = None
        super(QueryResultAdminVdcRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.numberOfStorageProfiles = _cast(int, numberOfStorageProfiles)
        self.memoryUsedMB = _cast(int, memoryUsedMB)
        self.orgName = _cast(None, orgName)
        self.isSystemVdc = _cast(bool, isSystemVdc)
        self.storageAllocationMB = _cast(int, storageAllocationMB)
        self.numberOfVAppTemplates = _cast(int, numberOfVAppTemplates)
        self.isEnabled = _cast(bool, isEnabled)
        self.cpuLimitMhz = _cast(int, cpuLimitMhz)
        self.memoryAllocationMB = _cast(int, memoryAllocationMB)
        self.isBusy = _cast(bool, isBusy)
        self.providerVdcName = _cast(None, providerVdcName)
        self.cpuUsedMhz = _cast(int, cpuUsedMhz)
        self.networkPool = _cast(None, networkPool)
        self.status = _cast(None, status)
        self.memoryLimitMB = _cast(int, memoryLimitMB)
        self.providerVdc = _cast(None, providerVdc)
        self.numberOfVApps = _cast(int, numberOfVApps)
        self.org = _cast(None, org)
        self.storageUsedMB = _cast(int, storageUsedMB)
        self.name = _cast(None, name)
        self.numberOfDisks = _cast(int, numberOfDisks)
        self.storageLimitMB = _cast(int, storageLimitMB)
        self.numberOfMedia = _cast(int, numberOfMedia)
        self.cpuAllocationMhz = _cast(int, cpuAllocationMhz)
    def factory(*args_, **kwargs_):
        if QueryResultAdminVdcRecordType.subclass:
            return QueryResultAdminVdcRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminVdcRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfStorageProfiles(self): return self.numberOfStorageProfiles
    def set_numberOfStorageProfiles(self, numberOfStorageProfiles): self.numberOfStorageProfiles = numberOfStorageProfiles
    def get_memoryUsedMB(self): return self.memoryUsedMB
    def set_memoryUsedMB(self, memoryUsedMB): self.memoryUsedMB = memoryUsedMB
    def get_orgName(self): return self.orgName
    def set_orgName(self, orgName): self.orgName = orgName
    def get_isSystemVdc(self): return self.isSystemVdc
    def set_isSystemVdc(self, isSystemVdc): self.isSystemVdc = isSystemVdc
    def get_storageAllocationMB(self): return self.storageAllocationMB
    def set_storageAllocationMB(self, storageAllocationMB): self.storageAllocationMB = storageAllocationMB
    def get_numberOfVAppTemplates(self): return self.numberOfVAppTemplates
    def set_numberOfVAppTemplates(self, numberOfVAppTemplates): self.numberOfVAppTemplates = numberOfVAppTemplates
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_cpuLimitMhz(self): return self.cpuLimitMhz
    def set_cpuLimitMhz(self, cpuLimitMhz): self.cpuLimitMhz = cpuLimitMhz
    def get_memoryAllocationMB(self): return self.memoryAllocationMB
    def set_memoryAllocationMB(self, memoryAllocationMB): self.memoryAllocationMB = memoryAllocationMB
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_providerVdcName(self): return self.providerVdcName
    def set_providerVdcName(self, providerVdcName): self.providerVdcName = providerVdcName
    def get_cpuUsedMhz(self): return self.cpuUsedMhz
    def set_cpuUsedMhz(self, cpuUsedMhz): self.cpuUsedMhz = cpuUsedMhz
    def get_networkPool(self): return self.networkPool
    def set_networkPool(self, networkPool): self.networkPool = networkPool
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_memoryLimitMB(self): return self.memoryLimitMB
    def set_memoryLimitMB(self, memoryLimitMB): self.memoryLimitMB = memoryLimitMB
    def get_providerVdc(self): return self.providerVdc
    def set_providerVdc(self, providerVdc): self.providerVdc = providerVdc
    def get_numberOfVApps(self): return self.numberOfVApps
    def set_numberOfVApps(self, numberOfVApps): self.numberOfVApps = numberOfVApps
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_storageUsedMB(self): return self.storageUsedMB
    def set_storageUsedMB(self, storageUsedMB): self.storageUsedMB = storageUsedMB
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_numberOfDisks(self): return self.numberOfDisks
    def set_numberOfDisks(self, numberOfDisks): self.numberOfDisks = numberOfDisks
    def get_storageLimitMB(self): return self.storageLimitMB
    def set_storageLimitMB(self, storageLimitMB): self.storageLimitMB = storageLimitMB
    def get_numberOfMedia(self): return self.numberOfMedia
    def set_numberOfMedia(self, numberOfMedia): self.numberOfMedia = numberOfMedia
    def get_cpuAllocationMhz(self): return self.cpuAllocationMhz
    def set_cpuAllocationMhz(self, cpuAllocationMhz): self.cpuAllocationMhz = cpuAllocationMhz
    def hasContent_(self):
        if (
            super(QueryResultAdminVdcRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminVdcRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminVdcRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminVdcRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminVdcRecordType'):
        super(QueryResultAdminVdcRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminVdcRecordType')
        if self.numberOfStorageProfiles is not None and 'numberOfStorageProfiles' not in already_processed:
            already_processed.add('numberOfStorageProfiles')
            outfile.write(' numberOfStorageProfiles="%s"' % self.gds_format_integer(self.numberOfStorageProfiles, input_name='numberOfStorageProfiles'))
        if self.memoryUsedMB is not None and 'memoryUsedMB' not in already_processed:
            already_processed.add('memoryUsedMB')
            outfile.write(' memoryUsedMB="%s"' % self.gds_format_integer(self.memoryUsedMB, input_name='memoryUsedMB'))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            outfile.write(' orgName=%s' % (self.gds_format_string(quote_attrib(self.orgName).encode(ExternalEncoding), input_name='orgName'), ))
        if self.isSystemVdc is not None and 'isSystemVdc' not in already_processed:
            already_processed.add('isSystemVdc')
            outfile.write(' isSystemVdc="%s"' % self.gds_format_boolean(self.isSystemVdc, input_name='isSystemVdc'))
        if self.storageAllocationMB is not None and 'storageAllocationMB' not in already_processed:
            already_processed.add('storageAllocationMB')
            outfile.write(' storageAllocationMB="%s"' % self.gds_format_integer(self.storageAllocationMB, input_name='storageAllocationMB'))
        if self.numberOfVAppTemplates is not None and 'numberOfVAppTemplates' not in already_processed:
            already_processed.add('numberOfVAppTemplates')
            outfile.write(' numberOfVAppTemplates="%s"' % self.gds_format_integer(self.numberOfVAppTemplates, input_name='numberOfVAppTemplates'))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.cpuLimitMhz is not None and 'cpuLimitMhz' not in already_processed:
            already_processed.add('cpuLimitMhz')
            outfile.write(' cpuLimitMhz="%s"' % self.gds_format_integer(self.cpuLimitMhz, input_name='cpuLimitMhz'))
        if self.memoryAllocationMB is not None and 'memoryAllocationMB' not in already_processed:
            already_processed.add('memoryAllocationMB')
            outfile.write(' memoryAllocationMB="%s"' % self.gds_format_integer(self.memoryAllocationMB, input_name='memoryAllocationMB'))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.providerVdcName is not None and 'providerVdcName' not in already_processed:
            already_processed.add('providerVdcName')
            outfile.write(' providerVdcName=%s' % (self.gds_format_string(quote_attrib(self.providerVdcName).encode(ExternalEncoding), input_name='providerVdcName'), ))
        if self.cpuUsedMhz is not None and 'cpuUsedMhz' not in already_processed:
            already_processed.add('cpuUsedMhz')
            outfile.write(' cpuUsedMhz="%s"' % self.gds_format_integer(self.cpuUsedMhz, input_name='cpuUsedMhz'))
        if self.networkPool is not None and 'networkPool' not in already_processed:
            already_processed.add('networkPool')
            outfile.write(' networkPool=%s' % (self.gds_format_string(quote_attrib(self.networkPool).encode(ExternalEncoding), input_name='networkPool'), ))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.memoryLimitMB is not None and 'memoryLimitMB' not in already_processed:
            already_processed.add('memoryLimitMB')
            outfile.write(' memoryLimitMB="%s"' % self.gds_format_integer(self.memoryLimitMB, input_name='memoryLimitMB'))
        if self.providerVdc is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            outfile.write(' providerVdc=%s' % (self.gds_format_string(quote_attrib(self.providerVdc).encode(ExternalEncoding), input_name='providerVdc'), ))
        if self.numberOfVApps is not None and 'numberOfVApps' not in already_processed:
            already_processed.add('numberOfVApps')
            outfile.write(' numberOfVApps="%s"' % self.gds_format_integer(self.numberOfVApps, input_name='numberOfVApps'))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            outfile.write(' storageUsedMB="%s"' % self.gds_format_integer(self.storageUsedMB, input_name='storageUsedMB'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.numberOfDisks is not None and 'numberOfDisks' not in already_processed:
            already_processed.add('numberOfDisks')
            outfile.write(' numberOfDisks="%s"' % self.gds_format_integer(self.numberOfDisks, input_name='numberOfDisks'))
        if self.storageLimitMB is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            outfile.write(' storageLimitMB="%s"' % self.gds_format_integer(self.storageLimitMB, input_name='storageLimitMB'))
        if self.numberOfMedia is not None and 'numberOfMedia' not in already_processed:
            already_processed.add('numberOfMedia')
            outfile.write(' numberOfMedia="%s"' % self.gds_format_integer(self.numberOfMedia, input_name='numberOfMedia'))
        if self.cpuAllocationMhz is not None and 'cpuAllocationMhz' not in already_processed:
            already_processed.add('cpuAllocationMhz')
            outfile.write(' cpuAllocationMhz="%s"' % self.gds_format_integer(self.cpuAllocationMhz, input_name='cpuAllocationMhz'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminVdcRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminVdcRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminVdcRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfStorageProfiles is not None and 'numberOfStorageProfiles' not in already_processed:
            already_processed.add('numberOfStorageProfiles')
            showIndent(outfile, level)
            outfile.write('numberOfStorageProfiles=%d,\n' % (self.numberOfStorageProfiles,))
        if self.memoryUsedMB is not None and 'memoryUsedMB' not in already_processed:
            already_processed.add('memoryUsedMB')
            showIndent(outfile, level)
            outfile.write('memoryUsedMB=%d,\n' % (self.memoryUsedMB,))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            showIndent(outfile, level)
            outfile.write('orgName="%s",\n' % (self.orgName,))
        if self.isSystemVdc is not None and 'isSystemVdc' not in already_processed:
            already_processed.add('isSystemVdc')
            showIndent(outfile, level)
            outfile.write('isSystemVdc=%s,\n' % (self.isSystemVdc,))
        if self.storageAllocationMB is not None and 'storageAllocationMB' not in already_processed:
            already_processed.add('storageAllocationMB')
            showIndent(outfile, level)
            outfile.write('storageAllocationMB=%d,\n' % (self.storageAllocationMB,))
        if self.numberOfVAppTemplates is not None and 'numberOfVAppTemplates' not in already_processed:
            already_processed.add('numberOfVAppTemplates')
            showIndent(outfile, level)
            outfile.write('numberOfVAppTemplates=%d,\n' % (self.numberOfVAppTemplates,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.cpuLimitMhz is not None and 'cpuLimitMhz' not in already_processed:
            already_processed.add('cpuLimitMhz')
            showIndent(outfile, level)
            outfile.write('cpuLimitMhz=%d,\n' % (self.cpuLimitMhz,))
        if self.memoryAllocationMB is not None and 'memoryAllocationMB' not in already_processed:
            already_processed.add('memoryAllocationMB')
            showIndent(outfile, level)
            outfile.write('memoryAllocationMB=%d,\n' % (self.memoryAllocationMB,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.providerVdcName is not None and 'providerVdcName' not in already_processed:
            already_processed.add('providerVdcName')
            showIndent(outfile, level)
            outfile.write('providerVdcName="%s",\n' % (self.providerVdcName,))
        if self.cpuUsedMhz is not None and 'cpuUsedMhz' not in already_processed:
            already_processed.add('cpuUsedMhz')
            showIndent(outfile, level)
            outfile.write('cpuUsedMhz=%d,\n' % (self.cpuUsedMhz,))
        if self.networkPool is not None and 'networkPool' not in already_processed:
            already_processed.add('networkPool')
            showIndent(outfile, level)
            outfile.write('networkPool="%s",\n' % (self.networkPool,))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.memoryLimitMB is not None and 'memoryLimitMB' not in already_processed:
            already_processed.add('memoryLimitMB')
            showIndent(outfile, level)
            outfile.write('memoryLimitMB=%d,\n' % (self.memoryLimitMB,))
        if self.providerVdc is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            showIndent(outfile, level)
            outfile.write('providerVdc="%s",\n' % (self.providerVdc,))
        if self.numberOfVApps is not None and 'numberOfVApps' not in already_processed:
            already_processed.add('numberOfVApps')
            showIndent(outfile, level)
            outfile.write('numberOfVApps=%d,\n' % (self.numberOfVApps,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            showIndent(outfile, level)
            outfile.write('storageUsedMB=%d,\n' % (self.storageUsedMB,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.numberOfDisks is not None and 'numberOfDisks' not in already_processed:
            already_processed.add('numberOfDisks')
            showIndent(outfile, level)
            outfile.write('numberOfDisks=%d,\n' % (self.numberOfDisks,))
        if self.storageLimitMB is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            showIndent(outfile, level)
            outfile.write('storageLimitMB=%d,\n' % (self.storageLimitMB,))
        if self.numberOfMedia is not None and 'numberOfMedia' not in already_processed:
            already_processed.add('numberOfMedia')
            showIndent(outfile, level)
            outfile.write('numberOfMedia=%d,\n' % (self.numberOfMedia,))
        if self.cpuAllocationMhz is not None and 'cpuAllocationMhz' not in already_processed:
            already_processed.add('cpuAllocationMhz')
            showIndent(outfile, level)
            outfile.write('cpuAllocationMhz=%d,\n' % (self.cpuAllocationMhz,))
        super(QueryResultAdminVdcRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminVdcRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfStorageProfiles', node)
        if value is not None and 'numberOfStorageProfiles' not in already_processed:
            already_processed.add('numberOfStorageProfiles')
            try:
                self.numberOfStorageProfiles = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('memoryUsedMB', node)
        if value is not None and 'memoryUsedMB' not in already_processed:
            already_processed.add('memoryUsedMB')
            try:
                self.memoryUsedMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('orgName', node)
        if value is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            self.orgName = value
        value = find_attr_value_('isSystemVdc', node)
        if value is not None and 'isSystemVdc' not in already_processed:
            already_processed.add('isSystemVdc')
            if value in ('true', '1'):
                self.isSystemVdc = True
            elif value in ('false', '0'):
                self.isSystemVdc = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('storageAllocationMB', node)
        if value is not None and 'storageAllocationMB' not in already_processed:
            already_processed.add('storageAllocationMB')
            try:
                self.storageAllocationMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfVAppTemplates', node)
        if value is not None and 'numberOfVAppTemplates' not in already_processed:
            already_processed.add('numberOfVAppTemplates')
            try:
                self.numberOfVAppTemplates = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('cpuLimitMhz', node)
        if value is not None and 'cpuLimitMhz' not in already_processed:
            already_processed.add('cpuLimitMhz')
            try:
                self.cpuLimitMhz = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('memoryAllocationMB', node)
        if value is not None and 'memoryAllocationMB' not in already_processed:
            already_processed.add('memoryAllocationMB')
            try:
                self.memoryAllocationMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('providerVdcName', node)
        if value is not None and 'providerVdcName' not in already_processed:
            already_processed.add('providerVdcName')
            self.providerVdcName = value
        value = find_attr_value_('cpuUsedMhz', node)
        if value is not None and 'cpuUsedMhz' not in already_processed:
            already_processed.add('cpuUsedMhz')
            try:
                self.cpuUsedMhz = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('networkPool', node)
        if value is not None and 'networkPool' not in already_processed:
            already_processed.add('networkPool')
            self.networkPool = value
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('memoryLimitMB', node)
        if value is not None and 'memoryLimitMB' not in already_processed:
            already_processed.add('memoryLimitMB')
            try:
                self.memoryLimitMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('providerVdc', node)
        if value is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            self.providerVdc = value
        value = find_attr_value_('numberOfVApps', node)
        if value is not None and 'numberOfVApps' not in already_processed:
            already_processed.add('numberOfVApps')
            try:
                self.numberOfVApps = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('storageUsedMB', node)
        if value is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            try:
                self.storageUsedMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('numberOfDisks', node)
        if value is not None and 'numberOfDisks' not in already_processed:
            already_processed.add('numberOfDisks')
            try:
                self.numberOfDisks = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storageLimitMB', node)
        if value is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            try:
                self.storageLimitMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfMedia', node)
        if value is not None and 'numberOfMedia' not in already_processed:
            already_processed.add('numberOfMedia')
            try:
                self.numberOfMedia = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('cpuAllocationMhz', node)
        if value is not None and 'cpuAllocationMhz' not in already_processed:
            already_processed.add('cpuAllocationMhz')
            try:
                self.cpuAllocationMhz = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(QueryResultAdminVdcRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminVdcRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminVdcRecordType


class QueryResultVMWProviderVdcRecordType(QueryResultRecordType):
    """1.5 Type for a single providerVdc query result in records format.
    1.5none The name of this Provider VDC. 1.5none True if this
    entity is enabled 1.5none True if this entity is deleted
    1.55.5none vCpu rating in Mhz 1.5none CPU used in Mhz 1.5none
    CPU limit in Mhz 1.5none CPU allocation in Mhz 1.5none Memory
    used in MB 1.5none Memory limit in MB 1.5none Memory allocation
    in MB 1.5none Storage used in MB 1.5none Storage limit in MB
    1.5none Storage allocation in MB 1.5none Number of datastores
    1.5none Number of vDCs 1.5none True if this entity is busy
    1.5none Status 5.1none Number of storage profiles"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, numberOfVdcs=None, status=None, numberOfStorageProfiles=None, vcpuRatingMhz=None, storageUsedMB=None, name=None, memoryLimitMB=None, isEnabled=None, storageLimitMB=None, numberOfDatastores=None, cpuLimitMhz=None, memoryUsedMB=None, cpuUsedMhz=None, cpuAllocationMhz=None, memoryAllocationMB=None, isBusy=None, storageAllocationMB=None, isDeleted=None):
        self.original_tagname_ = None
        super(QueryResultVMWProviderVdcRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.numberOfVdcs = _cast(int, numberOfVdcs)
        self.status = _cast(None, status)
        self.numberOfStorageProfiles = _cast(int, numberOfStorageProfiles)
        self.vcpuRatingMhz = _cast(int, vcpuRatingMhz)
        self.storageUsedMB = _cast(int, storageUsedMB)
        self.name = _cast(None, name)
        self.memoryLimitMB = _cast(int, memoryLimitMB)
        self.isEnabled = _cast(bool, isEnabled)
        self.storageLimitMB = _cast(int, storageLimitMB)
        self.numberOfDatastores = _cast(int, numberOfDatastores)
        self.cpuLimitMhz = _cast(int, cpuLimitMhz)
        self.memoryUsedMB = _cast(int, memoryUsedMB)
        self.cpuUsedMhz = _cast(int, cpuUsedMhz)
        self.cpuAllocationMhz = _cast(int, cpuAllocationMhz)
        self.memoryAllocationMB = _cast(int, memoryAllocationMB)
        self.isBusy = _cast(bool, isBusy)
        self.storageAllocationMB = _cast(int, storageAllocationMB)
        self.isDeleted = _cast(bool, isDeleted)
    def factory(*args_, **kwargs_):
        if QueryResultVMWProviderVdcRecordType.subclass:
            return QueryResultVMWProviderVdcRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultVMWProviderVdcRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numberOfVdcs(self): return self.numberOfVdcs
    def set_numberOfVdcs(self, numberOfVdcs): self.numberOfVdcs = numberOfVdcs
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_numberOfStorageProfiles(self): return self.numberOfStorageProfiles
    def set_numberOfStorageProfiles(self, numberOfStorageProfiles): self.numberOfStorageProfiles = numberOfStorageProfiles
    def get_vcpuRatingMhz(self): return self.vcpuRatingMhz
    def set_vcpuRatingMhz(self, vcpuRatingMhz): self.vcpuRatingMhz = vcpuRatingMhz
    def get_storageUsedMB(self): return self.storageUsedMB
    def set_storageUsedMB(self, storageUsedMB): self.storageUsedMB = storageUsedMB
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_memoryLimitMB(self): return self.memoryLimitMB
    def set_memoryLimitMB(self, memoryLimitMB): self.memoryLimitMB = memoryLimitMB
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_storageLimitMB(self): return self.storageLimitMB
    def set_storageLimitMB(self, storageLimitMB): self.storageLimitMB = storageLimitMB
    def get_numberOfDatastores(self): return self.numberOfDatastores
    def set_numberOfDatastores(self, numberOfDatastores): self.numberOfDatastores = numberOfDatastores
    def get_cpuLimitMhz(self): return self.cpuLimitMhz
    def set_cpuLimitMhz(self, cpuLimitMhz): self.cpuLimitMhz = cpuLimitMhz
    def get_memoryUsedMB(self): return self.memoryUsedMB
    def set_memoryUsedMB(self, memoryUsedMB): self.memoryUsedMB = memoryUsedMB
    def get_cpuUsedMhz(self): return self.cpuUsedMhz
    def set_cpuUsedMhz(self, cpuUsedMhz): self.cpuUsedMhz = cpuUsedMhz
    def get_cpuAllocationMhz(self): return self.cpuAllocationMhz
    def set_cpuAllocationMhz(self, cpuAllocationMhz): self.cpuAllocationMhz = cpuAllocationMhz
    def get_memoryAllocationMB(self): return self.memoryAllocationMB
    def set_memoryAllocationMB(self, memoryAllocationMB): self.memoryAllocationMB = memoryAllocationMB
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_storageAllocationMB(self): return self.storageAllocationMB
    def set_storageAllocationMB(self, storageAllocationMB): self.storageAllocationMB = storageAllocationMB
    def get_isDeleted(self): return self.isDeleted
    def set_isDeleted(self, isDeleted): self.isDeleted = isDeleted
    def hasContent_(self):
        if (
            super(QueryResultVMWProviderVdcRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultVMWProviderVdcRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVMWProviderVdcRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultVMWProviderVdcRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultVMWProviderVdcRecordType'):
        super(QueryResultVMWProviderVdcRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVMWProviderVdcRecordType')
        if self.numberOfVdcs is not None and 'numberOfVdcs' not in already_processed:
            already_processed.add('numberOfVdcs')
            outfile.write(' numberOfVdcs="%s"' % self.gds_format_integer(self.numberOfVdcs, input_name='numberOfVdcs'))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.numberOfStorageProfiles is not None and 'numberOfStorageProfiles' not in already_processed:
            already_processed.add('numberOfStorageProfiles')
            outfile.write(' numberOfStorageProfiles="%s"' % self.gds_format_integer(self.numberOfStorageProfiles, input_name='numberOfStorageProfiles'))
        if self.vcpuRatingMhz is not None and 'vcpuRatingMhz' not in already_processed:
            already_processed.add('vcpuRatingMhz')
            outfile.write(' vcpuRatingMhz="%s"' % self.gds_format_integer(self.vcpuRatingMhz, input_name='vcpuRatingMhz'))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            outfile.write(' storageUsedMB="%s"' % self.gds_format_integer(self.storageUsedMB, input_name='storageUsedMB'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.memoryLimitMB is not None and 'memoryLimitMB' not in already_processed:
            already_processed.add('memoryLimitMB')
            outfile.write(' memoryLimitMB="%s"' % self.gds_format_integer(self.memoryLimitMB, input_name='memoryLimitMB'))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.storageLimitMB is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            outfile.write(' storageLimitMB="%s"' % self.gds_format_integer(self.storageLimitMB, input_name='storageLimitMB'))
        if self.numberOfDatastores is not None and 'numberOfDatastores' not in already_processed:
            already_processed.add('numberOfDatastores')
            outfile.write(' numberOfDatastores="%s"' % self.gds_format_integer(self.numberOfDatastores, input_name='numberOfDatastores'))
        if self.cpuLimitMhz is not None and 'cpuLimitMhz' not in already_processed:
            already_processed.add('cpuLimitMhz')
            outfile.write(' cpuLimitMhz="%s"' % self.gds_format_integer(self.cpuLimitMhz, input_name='cpuLimitMhz'))
        if self.memoryUsedMB is not None and 'memoryUsedMB' not in already_processed:
            already_processed.add('memoryUsedMB')
            outfile.write(' memoryUsedMB="%s"' % self.gds_format_integer(self.memoryUsedMB, input_name='memoryUsedMB'))
        if self.cpuUsedMhz is not None and 'cpuUsedMhz' not in already_processed:
            already_processed.add('cpuUsedMhz')
            outfile.write(' cpuUsedMhz="%s"' % self.gds_format_integer(self.cpuUsedMhz, input_name='cpuUsedMhz'))
        if self.cpuAllocationMhz is not None and 'cpuAllocationMhz' not in already_processed:
            already_processed.add('cpuAllocationMhz')
            outfile.write(' cpuAllocationMhz="%s"' % self.gds_format_integer(self.cpuAllocationMhz, input_name='cpuAllocationMhz'))
        if self.memoryAllocationMB is not None and 'memoryAllocationMB' not in already_processed:
            already_processed.add('memoryAllocationMB')
            outfile.write(' memoryAllocationMB="%s"' % self.gds_format_integer(self.memoryAllocationMB, input_name='memoryAllocationMB'))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.storageAllocationMB is not None and 'storageAllocationMB' not in already_processed:
            already_processed.add('storageAllocationMB')
            outfile.write(' storageAllocationMB="%s"' % self.gds_format_integer(self.storageAllocationMB, input_name='storageAllocationMB'))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            outfile.write(' isDeleted="%s"' % self.gds_format_boolean(self.isDeleted, input_name='isDeleted'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultVMWProviderVdcRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultVMWProviderVdcRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultVMWProviderVdcRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numberOfVdcs is not None and 'numberOfVdcs' not in already_processed:
            already_processed.add('numberOfVdcs')
            showIndent(outfile, level)
            outfile.write('numberOfVdcs=%d,\n' % (self.numberOfVdcs,))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.numberOfStorageProfiles is not None and 'numberOfStorageProfiles' not in already_processed:
            already_processed.add('numberOfStorageProfiles')
            showIndent(outfile, level)
            outfile.write('numberOfStorageProfiles=%d,\n' % (self.numberOfStorageProfiles,))
        if self.vcpuRatingMhz is not None and 'vcpuRatingMhz' not in already_processed:
            already_processed.add('vcpuRatingMhz')
            showIndent(outfile, level)
            outfile.write('vcpuRatingMhz=%d,\n' % (self.vcpuRatingMhz,))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            showIndent(outfile, level)
            outfile.write('storageUsedMB=%d,\n' % (self.storageUsedMB,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.memoryLimitMB is not None and 'memoryLimitMB' not in already_processed:
            already_processed.add('memoryLimitMB')
            showIndent(outfile, level)
            outfile.write('memoryLimitMB=%d,\n' % (self.memoryLimitMB,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.storageLimitMB is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            showIndent(outfile, level)
            outfile.write('storageLimitMB=%d,\n' % (self.storageLimitMB,))
        if self.numberOfDatastores is not None and 'numberOfDatastores' not in already_processed:
            already_processed.add('numberOfDatastores')
            showIndent(outfile, level)
            outfile.write('numberOfDatastores=%d,\n' % (self.numberOfDatastores,))
        if self.cpuLimitMhz is not None and 'cpuLimitMhz' not in already_processed:
            already_processed.add('cpuLimitMhz')
            showIndent(outfile, level)
            outfile.write('cpuLimitMhz=%d,\n' % (self.cpuLimitMhz,))
        if self.memoryUsedMB is not None and 'memoryUsedMB' not in already_processed:
            already_processed.add('memoryUsedMB')
            showIndent(outfile, level)
            outfile.write('memoryUsedMB=%d,\n' % (self.memoryUsedMB,))
        if self.cpuUsedMhz is not None and 'cpuUsedMhz' not in already_processed:
            already_processed.add('cpuUsedMhz')
            showIndent(outfile, level)
            outfile.write('cpuUsedMhz=%d,\n' % (self.cpuUsedMhz,))
        if self.cpuAllocationMhz is not None and 'cpuAllocationMhz' not in already_processed:
            already_processed.add('cpuAllocationMhz')
            showIndent(outfile, level)
            outfile.write('cpuAllocationMhz=%d,\n' % (self.cpuAllocationMhz,))
        if self.memoryAllocationMB is not None and 'memoryAllocationMB' not in already_processed:
            already_processed.add('memoryAllocationMB')
            showIndent(outfile, level)
            outfile.write('memoryAllocationMB=%d,\n' % (self.memoryAllocationMB,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.storageAllocationMB is not None and 'storageAllocationMB' not in already_processed:
            already_processed.add('storageAllocationMB')
            showIndent(outfile, level)
            outfile.write('storageAllocationMB=%d,\n' % (self.storageAllocationMB,))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            showIndent(outfile, level)
            outfile.write('isDeleted=%s,\n' % (self.isDeleted,))
        super(QueryResultVMWProviderVdcRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultVMWProviderVdcRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numberOfVdcs', node)
        if value is not None and 'numberOfVdcs' not in already_processed:
            already_processed.add('numberOfVdcs')
            try:
                self.numberOfVdcs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('numberOfStorageProfiles', node)
        if value is not None and 'numberOfStorageProfiles' not in already_processed:
            already_processed.add('numberOfStorageProfiles')
            try:
                self.numberOfStorageProfiles = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('vcpuRatingMhz', node)
        if value is not None and 'vcpuRatingMhz' not in already_processed:
            already_processed.add('vcpuRatingMhz')
            try:
                self.vcpuRatingMhz = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storageUsedMB', node)
        if value is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            try:
                self.storageUsedMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('memoryLimitMB', node)
        if value is not None and 'memoryLimitMB' not in already_processed:
            already_processed.add('memoryLimitMB')
            try:
                self.memoryLimitMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('storageLimitMB', node)
        if value is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            try:
                self.storageLimitMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfDatastores', node)
        if value is not None and 'numberOfDatastores' not in already_processed:
            already_processed.add('numberOfDatastores')
            try:
                self.numberOfDatastores = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('cpuLimitMhz', node)
        if value is not None and 'cpuLimitMhz' not in already_processed:
            already_processed.add('cpuLimitMhz')
            try:
                self.cpuLimitMhz = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('memoryUsedMB', node)
        if value is not None and 'memoryUsedMB' not in already_processed:
            already_processed.add('memoryUsedMB')
            try:
                self.memoryUsedMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('cpuUsedMhz', node)
        if value is not None and 'cpuUsedMhz' not in already_processed:
            already_processed.add('cpuUsedMhz')
            try:
                self.cpuUsedMhz = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('cpuAllocationMhz', node)
        if value is not None and 'cpuAllocationMhz' not in already_processed:
            already_processed.add('cpuAllocationMhz')
            try:
                self.cpuAllocationMhz = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('memoryAllocationMB', node)
        if value is not None and 'memoryAllocationMB' not in already_processed:
            already_processed.add('memoryAllocationMB')
            try:
                self.memoryAllocationMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('storageAllocationMB', node)
        if value is not None and 'storageAllocationMB' not in already_processed:
            already_processed.add('storageAllocationMB')
            try:
                self.storageAllocationMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isDeleted', node)
        if value is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            if value in ('true', '1'):
                self.isDeleted = True
            elif value in ('false', '0'):
                self.isDeleted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(QueryResultVMWProviderVdcRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultVMWProviderVdcRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultVMWProviderVdcRecordType


class QueryResultNetworkRecordType(QueryResultRecordType):
    """1.5 Type for a single externalNetwork query result in records
    format. 1.5none The name of this network. 1.5none IP scope
    object of this network. 1.5none Gateway for the network 1.5none
    Netmask for the network 1.5none Primary DNS for the network
    1.5none Secondary DNS for the network 1.5none DNS suffix for the
    network 1.5none True if this entity is busy"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, name=None, dns2=None, dns1=None, netmask=None, dnsSuffix=None, isBusy=None, gateway=None, ipScopeId=None):
        self.original_tagname_ = None
        super(QueryResultNetworkRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.name = _cast(None, name)
        self.dns2 = _cast(None, dns2)
        self.dns1 = _cast(None, dns1)
        self.netmask = _cast(None, netmask)
        self.dnsSuffix = _cast(None, dnsSuffix)
        self.isBusy = _cast(bool, isBusy)
        self.gateway = _cast(None, gateway)
        self.ipScopeId = _cast(None, ipScopeId)
    def factory(*args_, **kwargs_):
        if QueryResultNetworkRecordType.subclass:
            return QueryResultNetworkRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultNetworkRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_dns2(self): return self.dns2
    def set_dns2(self, dns2): self.dns2 = dns2
    def get_dns1(self): return self.dns1
    def set_dns1(self, dns1): self.dns1 = dns1
    def get_netmask(self): return self.netmask
    def set_netmask(self, netmask): self.netmask = netmask
    def get_dnsSuffix(self): return self.dnsSuffix
    def set_dnsSuffix(self, dnsSuffix): self.dnsSuffix = dnsSuffix
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_gateway(self): return self.gateway
    def set_gateway(self, gateway): self.gateway = gateway
    def get_ipScopeId(self): return self.ipScopeId
    def set_ipScopeId(self, ipScopeId): self.ipScopeId = ipScopeId
    def hasContent_(self):
        if (
            super(QueryResultNetworkRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultNetworkRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultNetworkRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultNetworkRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultNetworkRecordType'):
        super(QueryResultNetworkRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultNetworkRecordType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.dns2 is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            outfile.write(' dns2=%s' % (self.gds_format_string(quote_attrib(self.dns2).encode(ExternalEncoding), input_name='dns2'), ))
        if self.dns1 is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            outfile.write(' dns1=%s' % (self.gds_format_string(quote_attrib(self.dns1).encode(ExternalEncoding), input_name='dns1'), ))
        if self.netmask is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            outfile.write(' netmask=%s' % (self.gds_format_string(quote_attrib(self.netmask).encode(ExternalEncoding), input_name='netmask'), ))
        if self.dnsSuffix is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            outfile.write(' dnsSuffix=%s' % (self.gds_format_string(quote_attrib(self.dnsSuffix).encode(ExternalEncoding), input_name='dnsSuffix'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.gateway is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            outfile.write(' gateway=%s' % (self.gds_format_string(quote_attrib(self.gateway).encode(ExternalEncoding), input_name='gateway'), ))
        if self.ipScopeId is not None and 'ipScopeId' not in already_processed:
            already_processed.add('ipScopeId')
            outfile.write(' ipScopeId=%s' % (self.gds_format_string(quote_attrib(self.ipScopeId).encode(ExternalEncoding), input_name='ipScopeId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultNetworkRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultNetworkRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultNetworkRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.dns2 is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            showIndent(outfile, level)
            outfile.write('dns2="%s",\n' % (self.dns2,))
        if self.dns1 is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            showIndent(outfile, level)
            outfile.write('dns1="%s",\n' % (self.dns1,))
        if self.netmask is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            showIndent(outfile, level)
            outfile.write('netmask="%s",\n' % (self.netmask,))
        if self.dnsSuffix is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            showIndent(outfile, level)
            outfile.write('dnsSuffix="%s",\n' % (self.dnsSuffix,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.gateway is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            showIndent(outfile, level)
            outfile.write('gateway="%s",\n' % (self.gateway,))
        if self.ipScopeId is not None and 'ipScopeId' not in already_processed:
            already_processed.add('ipScopeId')
            showIndent(outfile, level)
            outfile.write('ipScopeId="%s",\n' % (self.ipScopeId,))
        super(QueryResultNetworkRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultNetworkRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('dns2', node)
        if value is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            self.dns2 = value
        value = find_attr_value_('dns1', node)
        if value is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            self.dns1 = value
        value = find_attr_value_('netmask', node)
        if value is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            self.netmask = value
        value = find_attr_value_('dnsSuffix', node)
        if value is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            self.dnsSuffix = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('gateway', node)
        if value is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            self.gateway = value
        value = find_attr_value_('ipScopeId', node)
        if value is not None and 'ipScopeId' not in already_processed:
            already_processed.add('ipScopeId')
            self.ipScopeId = value
        super(QueryResultNetworkRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultNetworkRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultNetworkRecordType


class QueryResultGroupRecordType(QueryResultRecordType):
    """1.5 Type for a single group query result in records format. 1.5none
    The name of this group. 1.5none Role name 1.5none True if this
    entity is read-only. 5.1none Shows the identity provider type of
    the group"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, isReadOnly=None, roleName=None, name=None, identityProviderType=None):
        self.original_tagname_ = None
        super(QueryResultGroupRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.isReadOnly = _cast(bool, isReadOnly)
        self.roleName = _cast(None, roleName)
        self.name = _cast(None, name)
        self.identityProviderType = _cast(None, identityProviderType)
    def factory(*args_, **kwargs_):
        if QueryResultGroupRecordType.subclass:
            return QueryResultGroupRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultGroupRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isReadOnly(self): return self.isReadOnly
    def set_isReadOnly(self, isReadOnly): self.isReadOnly = isReadOnly
    def get_roleName(self): return self.roleName
    def set_roleName(self, roleName): self.roleName = roleName
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_identityProviderType(self): return self.identityProviderType
    def set_identityProviderType(self, identityProviderType): self.identityProviderType = identityProviderType
    def hasContent_(self):
        if (
            super(QueryResultGroupRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultGroupRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultGroupRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultGroupRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultGroupRecordType'):
        super(QueryResultGroupRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultGroupRecordType')
        if self.isReadOnly is not None and 'isReadOnly' not in already_processed:
            already_processed.add('isReadOnly')
            outfile.write(' isReadOnly="%s"' % self.gds_format_boolean(self.isReadOnly, input_name='isReadOnly'))
        if self.roleName is not None and 'roleName' not in already_processed:
            already_processed.add('roleName')
            outfile.write(' roleName=%s' % (self.gds_format_string(quote_attrib(self.roleName).encode(ExternalEncoding), input_name='roleName'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.identityProviderType is not None and 'identityProviderType' not in already_processed:
            already_processed.add('identityProviderType')
            outfile.write(' identityProviderType=%s' % (self.gds_format_string(quote_attrib(self.identityProviderType).encode(ExternalEncoding), input_name='identityProviderType'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultGroupRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultGroupRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultGroupRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isReadOnly is not None and 'isReadOnly' not in already_processed:
            already_processed.add('isReadOnly')
            showIndent(outfile, level)
            outfile.write('isReadOnly=%s,\n' % (self.isReadOnly,))
        if self.roleName is not None and 'roleName' not in already_processed:
            already_processed.add('roleName')
            showIndent(outfile, level)
            outfile.write('roleName="%s",\n' % (self.roleName,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.identityProviderType is not None and 'identityProviderType' not in already_processed:
            already_processed.add('identityProviderType')
            showIndent(outfile, level)
            outfile.write('identityProviderType="%s",\n' % (self.identityProviderType,))
        super(QueryResultGroupRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultGroupRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isReadOnly', node)
        if value is not None and 'isReadOnly' not in already_processed:
            already_processed.add('isReadOnly')
            if value in ('true', '1'):
                self.isReadOnly = True
            elif value in ('false', '0'):
                self.isReadOnly = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('roleName', node)
        if value is not None and 'roleName' not in already_processed:
            already_processed.add('roleName')
            self.roleName = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('identityProviderType', node)
        if value is not None and 'identityProviderType' not in already_processed:
            already_processed.add('identityProviderType')
            self.identityProviderType = value
        super(QueryResultGroupRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultGroupRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultGroupRecordType


class QueryResultUserRecordType(QueryResultRecordType):
    """1.5 Type for a single user query result in records format. 1.5none
    The name of this user. 1.5none The full name of this user.
    1.5none True if this entity is enabled 1.5none Number of
    deployed VMs 1.5none Deployed VM quota 1.5none Number of stored
    VMs 1.5none Stored VM Quota 1.5none If the identity provider
    type is INTEGRATED, true if the user was imported from LDAP
    5.1none Shows the identity provider type of the user"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, isLdapUser=None, name=None, isEnabled=None, deployedVMQuota=None, storedVMQuota=None, numberOfStoredVMs=None, numberOfDeployedVMs=None, identityProviderType=None, fullName=None):
        self.original_tagname_ = None
        super(QueryResultUserRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.isLdapUser = _cast(bool, isLdapUser)
        self.name = _cast(None, name)
        self.isEnabled = _cast(bool, isEnabled)
        self.deployedVMQuota = _cast(int, deployedVMQuota)
        self.storedVMQuota = _cast(int, storedVMQuota)
        self.numberOfStoredVMs = _cast(int, numberOfStoredVMs)
        self.numberOfDeployedVMs = _cast(int, numberOfDeployedVMs)
        self.identityProviderType = _cast(None, identityProviderType)
        self.fullName = _cast(None, fullName)
    def factory(*args_, **kwargs_):
        if QueryResultUserRecordType.subclass:
            return QueryResultUserRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultUserRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isLdapUser(self): return self.isLdapUser
    def set_isLdapUser(self, isLdapUser): self.isLdapUser = isLdapUser
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_deployedVMQuota(self): return self.deployedVMQuota
    def set_deployedVMQuota(self, deployedVMQuota): self.deployedVMQuota = deployedVMQuota
    def get_storedVMQuota(self): return self.storedVMQuota
    def set_storedVMQuota(self, storedVMQuota): self.storedVMQuota = storedVMQuota
    def get_numberOfStoredVMs(self): return self.numberOfStoredVMs
    def set_numberOfStoredVMs(self, numberOfStoredVMs): self.numberOfStoredVMs = numberOfStoredVMs
    def get_numberOfDeployedVMs(self): return self.numberOfDeployedVMs
    def set_numberOfDeployedVMs(self, numberOfDeployedVMs): self.numberOfDeployedVMs = numberOfDeployedVMs
    def get_identityProviderType(self): return self.identityProviderType
    def set_identityProviderType(self, identityProviderType): self.identityProviderType = identityProviderType
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def hasContent_(self):
        if (
            super(QueryResultUserRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultUserRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultUserRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultUserRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultUserRecordType'):
        super(QueryResultUserRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultUserRecordType')
        if self.isLdapUser is not None and 'isLdapUser' not in already_processed:
            already_processed.add('isLdapUser')
            outfile.write(' isLdapUser="%s"' % self.gds_format_boolean(self.isLdapUser, input_name='isLdapUser'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.deployedVMQuota is not None and 'deployedVMQuota' not in already_processed:
            already_processed.add('deployedVMQuota')
            outfile.write(' deployedVMQuota="%s"' % self.gds_format_integer(self.deployedVMQuota, input_name='deployedVMQuota'))
        if self.storedVMQuota is not None and 'storedVMQuota' not in already_processed:
            already_processed.add('storedVMQuota')
            outfile.write(' storedVMQuota="%s"' % self.gds_format_integer(self.storedVMQuota, input_name='storedVMQuota'))
        if self.numberOfStoredVMs is not None and 'numberOfStoredVMs' not in already_processed:
            already_processed.add('numberOfStoredVMs')
            outfile.write(' numberOfStoredVMs="%s"' % self.gds_format_integer(self.numberOfStoredVMs, input_name='numberOfStoredVMs'))
        if self.numberOfDeployedVMs is not None and 'numberOfDeployedVMs' not in already_processed:
            already_processed.add('numberOfDeployedVMs')
            outfile.write(' numberOfDeployedVMs="%s"' % self.gds_format_integer(self.numberOfDeployedVMs, input_name='numberOfDeployedVMs'))
        if self.identityProviderType is not None and 'identityProviderType' not in already_processed:
            already_processed.add('identityProviderType')
            outfile.write(' identityProviderType=%s' % (self.gds_format_string(quote_attrib(self.identityProviderType).encode(ExternalEncoding), input_name='identityProviderType'), ))
        if self.fullName is not None and 'fullName' not in already_processed:
            already_processed.add('fullName')
            outfile.write(' fullName=%s' % (self.gds_format_string(quote_attrib(self.fullName).encode(ExternalEncoding), input_name='fullName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultUserRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultUserRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultUserRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isLdapUser is not None and 'isLdapUser' not in already_processed:
            already_processed.add('isLdapUser')
            showIndent(outfile, level)
            outfile.write('isLdapUser=%s,\n' % (self.isLdapUser,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.deployedVMQuota is not None and 'deployedVMQuota' not in already_processed:
            already_processed.add('deployedVMQuota')
            showIndent(outfile, level)
            outfile.write('deployedVMQuota=%d,\n' % (self.deployedVMQuota,))
        if self.storedVMQuota is not None and 'storedVMQuota' not in already_processed:
            already_processed.add('storedVMQuota')
            showIndent(outfile, level)
            outfile.write('storedVMQuota=%d,\n' % (self.storedVMQuota,))
        if self.numberOfStoredVMs is not None and 'numberOfStoredVMs' not in already_processed:
            already_processed.add('numberOfStoredVMs')
            showIndent(outfile, level)
            outfile.write('numberOfStoredVMs=%d,\n' % (self.numberOfStoredVMs,))
        if self.numberOfDeployedVMs is not None and 'numberOfDeployedVMs' not in already_processed:
            already_processed.add('numberOfDeployedVMs')
            showIndent(outfile, level)
            outfile.write('numberOfDeployedVMs=%d,\n' % (self.numberOfDeployedVMs,))
        if self.identityProviderType is not None and 'identityProviderType' not in already_processed:
            already_processed.add('identityProviderType')
            showIndent(outfile, level)
            outfile.write('identityProviderType="%s",\n' % (self.identityProviderType,))
        if self.fullName is not None and 'fullName' not in already_processed:
            already_processed.add('fullName')
            showIndent(outfile, level)
            outfile.write('fullName="%s",\n' % (self.fullName,))
        super(QueryResultUserRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultUserRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isLdapUser', node)
        if value is not None and 'isLdapUser' not in already_processed:
            already_processed.add('isLdapUser')
            if value in ('true', '1'):
                self.isLdapUser = True
            elif value in ('false', '0'):
                self.isLdapUser = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('deployedVMQuota', node)
        if value is not None and 'deployedVMQuota' not in already_processed:
            already_processed.add('deployedVMQuota')
            try:
                self.deployedVMQuota = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storedVMQuota', node)
        if value is not None and 'storedVMQuota' not in already_processed:
            already_processed.add('storedVMQuota')
            try:
                self.storedVMQuota = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfStoredVMs', node)
        if value is not None and 'numberOfStoredVMs' not in already_processed:
            already_processed.add('numberOfStoredVMs')
            try:
                self.numberOfStoredVMs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfDeployedVMs', node)
        if value is not None and 'numberOfDeployedVMs' not in already_processed:
            already_processed.add('numberOfDeployedVMs')
            try:
                self.numberOfDeployedVMs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('identityProviderType', node)
        if value is not None and 'identityProviderType' not in already_processed:
            already_processed.add('identityProviderType')
            self.identityProviderType = value
        value = find_attr_value_('fullName', node)
        if value is not None and 'fullName' not in already_processed:
            already_processed.add('fullName')
            self.fullName = value
        super(QueryResultUserRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultUserRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultUserRecordType


class QueryResultStrandedUserRecordType(QueryResultRecordType):
    """1.5 Type for a single strandedUser query result in records format.
    1.5none The name of a stranded user. 1.5none The full name of
    this user. 1.5none True if this list is up to date. 1.5none
    Number of deployed VMs 1.5none Number of stored VMs 5.1none
    Organization reference or id"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, name=None, numberOfStoredVMs=None, numberOfDeployedVMs=None, isInSync=None, org=None, fullName=None):
        self.original_tagname_ = None
        super(QueryResultStrandedUserRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.name = _cast(None, name)
        self.numberOfStoredVMs = _cast(int, numberOfStoredVMs)
        self.numberOfDeployedVMs = _cast(int, numberOfDeployedVMs)
        self.isInSync = _cast(bool, isInSync)
        self.org = _cast(None, org)
        self.fullName = _cast(None, fullName)
    def factory(*args_, **kwargs_):
        if QueryResultStrandedUserRecordType.subclass:
            return QueryResultStrandedUserRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultStrandedUserRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_numberOfStoredVMs(self): return self.numberOfStoredVMs
    def set_numberOfStoredVMs(self, numberOfStoredVMs): self.numberOfStoredVMs = numberOfStoredVMs
    def get_numberOfDeployedVMs(self): return self.numberOfDeployedVMs
    def set_numberOfDeployedVMs(self, numberOfDeployedVMs): self.numberOfDeployedVMs = numberOfDeployedVMs
    def get_isInSync(self): return self.isInSync
    def set_isInSync(self, isInSync): self.isInSync = isInSync
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def hasContent_(self):
        if (
            super(QueryResultStrandedUserRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultStrandedUserRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultStrandedUserRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultStrandedUserRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultStrandedUserRecordType'):
        super(QueryResultStrandedUserRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultStrandedUserRecordType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.numberOfStoredVMs is not None and 'numberOfStoredVMs' not in already_processed:
            already_processed.add('numberOfStoredVMs')
            outfile.write(' numberOfStoredVMs="%s"' % self.gds_format_integer(self.numberOfStoredVMs, input_name='numberOfStoredVMs'))
        if self.numberOfDeployedVMs is not None and 'numberOfDeployedVMs' not in already_processed:
            already_processed.add('numberOfDeployedVMs')
            outfile.write(' numberOfDeployedVMs="%s"' % self.gds_format_integer(self.numberOfDeployedVMs, input_name='numberOfDeployedVMs'))
        if self.isInSync is not None and 'isInSync' not in already_processed:
            already_processed.add('isInSync')
            outfile.write(' isInSync="%s"' % self.gds_format_boolean(self.isInSync, input_name='isInSync'))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.fullName is not None and 'fullName' not in already_processed:
            already_processed.add('fullName')
            outfile.write(' fullName=%s' % (self.gds_format_string(quote_attrib(self.fullName).encode(ExternalEncoding), input_name='fullName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultStrandedUserRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultStrandedUserRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultStrandedUserRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.numberOfStoredVMs is not None and 'numberOfStoredVMs' not in already_processed:
            already_processed.add('numberOfStoredVMs')
            showIndent(outfile, level)
            outfile.write('numberOfStoredVMs=%d,\n' % (self.numberOfStoredVMs,))
        if self.numberOfDeployedVMs is not None and 'numberOfDeployedVMs' not in already_processed:
            already_processed.add('numberOfDeployedVMs')
            showIndent(outfile, level)
            outfile.write('numberOfDeployedVMs=%d,\n' % (self.numberOfDeployedVMs,))
        if self.isInSync is not None and 'isInSync' not in already_processed:
            already_processed.add('isInSync')
            showIndent(outfile, level)
            outfile.write('isInSync=%s,\n' % (self.isInSync,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.fullName is not None and 'fullName' not in already_processed:
            already_processed.add('fullName')
            showIndent(outfile, level)
            outfile.write('fullName="%s",\n' % (self.fullName,))
        super(QueryResultStrandedUserRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultStrandedUserRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('numberOfStoredVMs', node)
        if value is not None and 'numberOfStoredVMs' not in already_processed:
            already_processed.add('numberOfStoredVMs')
            try:
                self.numberOfStoredVMs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfDeployedVMs', node)
        if value is not None and 'numberOfDeployedVMs' not in already_processed:
            already_processed.add('numberOfDeployedVMs')
            try:
                self.numberOfDeployedVMs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isInSync', node)
        if value is not None and 'isInSync' not in already_processed:
            already_processed.add('isInSync')
            if value in ('true', '1'):
                self.isInSync = True
            elif value in ('false', '0'):
                self.isInSync = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('fullName', node)
        if value is not None and 'fullName' not in already_processed:
            already_processed.add('fullName')
            self.fullName = value
        super(QueryResultStrandedUserRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultStrandedUserRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultStrandedUserRecordType


class QueryResultRoleRecordType(QueryResultRecordType):
    """1.5 Type for a single role query result in records format. 1.5none
    The name of this role. 1.5none True if this entity is read-only."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, isReadOnly=None, name=None):
        self.original_tagname_ = None
        super(QueryResultRoleRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.isReadOnly = _cast(bool, isReadOnly)
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if QueryResultRoleRecordType.subclass:
            return QueryResultRoleRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultRoleRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isReadOnly(self): return self.isReadOnly
    def set_isReadOnly(self, isReadOnly): self.isReadOnly = isReadOnly
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            super(QueryResultRoleRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultRoleRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultRoleRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultRoleRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultRoleRecordType'):
        super(QueryResultRoleRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultRoleRecordType')
        if self.isReadOnly is not None and 'isReadOnly' not in already_processed:
            already_processed.add('isReadOnly')
            outfile.write(' isReadOnly="%s"' % self.gds_format_boolean(self.isReadOnly, input_name='isReadOnly'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultRoleRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultRoleRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultRoleRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isReadOnly is not None and 'isReadOnly' not in already_processed:
            already_processed.add('isReadOnly')
            showIndent(outfile, level)
            outfile.write('isReadOnly=%s,\n' % (self.isReadOnly,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(QueryResultRoleRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultRoleRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isReadOnly', node)
        if value is not None and 'isReadOnly' not in already_processed:
            already_processed.add('isReadOnly')
            if value in ('true', '1'):
                self.isReadOnly = True
            elif value in ('false', '0'):
                self.isReadOnly = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(QueryResultRoleRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultRoleRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultRoleRecordType


class QueryResultAllocatedExternalAddressRecordType(QueryResultRecordType):
    """1.55.1 Type for a single allocatedExternalAddress query result in
    records format. 1.5none Network reference or id 1.5none
    Allocated IP address 1.5none Linked network reference or id"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, ipAddress=None, network=None, linkedNetwork=None):
        self.original_tagname_ = None
        super(QueryResultAllocatedExternalAddressRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.ipAddress = _cast(None, ipAddress)
        self.network = _cast(None, network)
        self.linkedNetwork = _cast(None, linkedNetwork)
    def factory(*args_, **kwargs_):
        if QueryResultAllocatedExternalAddressRecordType.subclass:
            return QueryResultAllocatedExternalAddressRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAllocatedExternalAddressRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ipAddress(self): return self.ipAddress
    def set_ipAddress(self, ipAddress): self.ipAddress = ipAddress
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def get_linkedNetwork(self): return self.linkedNetwork
    def set_linkedNetwork(self, linkedNetwork): self.linkedNetwork = linkedNetwork
    def hasContent_(self):
        if (
            super(QueryResultAllocatedExternalAddressRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAllocatedExternalAddressRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAllocatedExternalAddressRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAllocatedExternalAddressRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAllocatedExternalAddressRecordType'):
        super(QueryResultAllocatedExternalAddressRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAllocatedExternalAddressRecordType')
        if self.ipAddress is not None and 'ipAddress' not in already_processed:
            already_processed.add('ipAddress')
            outfile.write(' ipAddress=%s' % (self.gds_format_string(quote_attrib(self.ipAddress).encode(ExternalEncoding), input_name='ipAddress'), ))
        if self.network is not None and 'network' not in already_processed:
            already_processed.add('network')
            outfile.write(' network=%s' % (self.gds_format_string(quote_attrib(self.network).encode(ExternalEncoding), input_name='network'), ))
        if self.linkedNetwork is not None and 'linkedNetwork' not in already_processed:
            already_processed.add('linkedNetwork')
            outfile.write(' linkedNetwork=%s' % (self.gds_format_string(quote_attrib(self.linkedNetwork).encode(ExternalEncoding), input_name='linkedNetwork'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAllocatedExternalAddressRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAllocatedExternalAddressRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAllocatedExternalAddressRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ipAddress is not None and 'ipAddress' not in already_processed:
            already_processed.add('ipAddress')
            showIndent(outfile, level)
            outfile.write('ipAddress="%s",\n' % (self.ipAddress,))
        if self.network is not None and 'network' not in already_processed:
            already_processed.add('network')
            showIndent(outfile, level)
            outfile.write('network="%s",\n' % (self.network,))
        if self.linkedNetwork is not None and 'linkedNetwork' not in already_processed:
            already_processed.add('linkedNetwork')
            showIndent(outfile, level)
            outfile.write('linkedNetwork="%s",\n' % (self.linkedNetwork,))
        super(QueryResultAllocatedExternalAddressRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAllocatedExternalAddressRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ipAddress', node)
        if value is not None and 'ipAddress' not in already_processed:
            already_processed.add('ipAddress')
            self.ipAddress = value
        value = find_attr_value_('network', node)
        if value is not None and 'network' not in already_processed:
            already_processed.add('network')
            self.network = value
        value = find_attr_value_('linkedNetwork', node)
        if value is not None and 'linkedNetwork' not in already_processed:
            already_processed.add('linkedNetwork')
            self.linkedNetwork = value
        super(QueryResultAllocatedExternalAddressRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAllocatedExternalAddressRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAllocatedExternalAddressRecordType


class QueryResultEventRecordType(QueryResultRecordType):
    """1.5 Type for a single event query result in records format. 1.5none
    Event type 1.5none Time stamp 1.5none Event status 1.5none User
    name 1.5none Organization name 1.5none Entity type 1.5none
    Entity name 5.1none Service name space 1.5none Entity reference
    or id"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, userName=None, orgName=None, eventType=None, entityName=None, entityType=None, entity=None, eventStatus=None, timeStamp=None, serviceNamespace=None):
        self.original_tagname_ = None
        super(QueryResultEventRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.userName = _cast(None, userName)
        self.orgName = _cast(None, orgName)
        self.eventType = _cast(None, eventType)
        self.entityName = _cast(None, entityName)
        self.entityType = _cast(None, entityType)
        self.entity = _cast(None, entity)
        self.eventStatus = _cast(int, eventStatus)
        if isinstance(timeStamp, basestring):
            initvalue_ = datetime_.datetime.strptime(timeStamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timeStamp
        self.timeStamp = initvalue_
        self.serviceNamespace = _cast(None, serviceNamespace)
    def factory(*args_, **kwargs_):
        if QueryResultEventRecordType.subclass:
            return QueryResultEventRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultEventRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_userName(self): return self.userName
    def set_userName(self, userName): self.userName = userName
    def get_orgName(self): return self.orgName
    def set_orgName(self, orgName): self.orgName = orgName
    def get_eventType(self): return self.eventType
    def set_eventType(self, eventType): self.eventType = eventType
    def get_entityName(self): return self.entityName
    def set_entityName(self, entityName): self.entityName = entityName
    def get_entityType(self): return self.entityType
    def set_entityType(self, entityType): self.entityType = entityType
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def get_eventStatus(self): return self.eventStatus
    def set_eventStatus(self, eventStatus): self.eventStatus = eventStatus
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def get_serviceNamespace(self): return self.serviceNamespace
    def set_serviceNamespace(self, serviceNamespace): self.serviceNamespace = serviceNamespace
    def hasContent_(self):
        if (
            super(QueryResultEventRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultEventRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultEventRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultEventRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultEventRecordType'):
        super(QueryResultEventRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultEventRecordType')
        if self.userName is not None and 'userName' not in already_processed:
            already_processed.add('userName')
            outfile.write(' userName=%s' % (self.gds_format_string(quote_attrib(self.userName).encode(ExternalEncoding), input_name='userName'), ))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            outfile.write(' orgName=%s' % (self.gds_format_string(quote_attrib(self.orgName).encode(ExternalEncoding), input_name='orgName'), ))
        if self.eventType is not None and 'eventType' not in already_processed:
            already_processed.add('eventType')
            outfile.write(' eventType=%s' % (self.gds_format_string(quote_attrib(self.eventType).encode(ExternalEncoding), input_name='eventType'), ))
        if self.entityName is not None and 'entityName' not in already_processed:
            already_processed.add('entityName')
            outfile.write(' entityName=%s' % (self.gds_format_string(quote_attrib(self.entityName).encode(ExternalEncoding), input_name='entityName'), ))
        if self.entityType is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            outfile.write(' entityType=%s' % (self.gds_format_string(quote_attrib(self.entityType).encode(ExternalEncoding), input_name='entityType'), ))
        if self.entity is not None and 'entity' not in already_processed:
            already_processed.add('entity')
            outfile.write(' entity=%s' % (self.gds_format_string(quote_attrib(self.entity).encode(ExternalEncoding), input_name='entity'), ))
        if self.eventStatus is not None and 'eventStatus' not in already_processed:
            already_processed.add('eventStatus')
            outfile.write(' eventStatus="%s"' % self.gds_format_integer(self.eventStatus, input_name='eventStatus'))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.add('timeStamp')
            outfile.write(' timeStamp="%s"' % self.gds_format_datetime(self.timeStamp, input_name='timeStamp'))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            outfile.write(' serviceNamespace=%s' % (self.gds_format_string(quote_attrib(self.serviceNamespace).encode(ExternalEncoding), input_name='serviceNamespace'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultEventRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultEventRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultEventRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.userName is not None and 'userName' not in already_processed:
            already_processed.add('userName')
            showIndent(outfile, level)
            outfile.write('userName="%s",\n' % (self.userName,))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            showIndent(outfile, level)
            outfile.write('orgName="%s",\n' % (self.orgName,))
        if self.eventType is not None and 'eventType' not in already_processed:
            already_processed.add('eventType')
            showIndent(outfile, level)
            outfile.write('eventType="%s",\n' % (self.eventType,))
        if self.entityName is not None and 'entityName' not in already_processed:
            already_processed.add('entityName')
            showIndent(outfile, level)
            outfile.write('entityName="%s",\n' % (self.entityName,))
        if self.entityType is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            showIndent(outfile, level)
            outfile.write('entityType="%s",\n' % (self.entityType,))
        if self.entity is not None and 'entity' not in already_processed:
            already_processed.add('entity')
            showIndent(outfile, level)
            outfile.write('entity="%s",\n' % (self.entity,))
        if self.eventStatus is not None and 'eventStatus' not in already_processed:
            already_processed.add('eventStatus')
            showIndent(outfile, level)
            outfile.write('eventStatus=%d,\n' % (self.eventStatus,))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.add('timeStamp')
            showIndent(outfile, level)
            outfile.write('timeStamp=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.timeStamp, input_name='timeStamp'))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            showIndent(outfile, level)
            outfile.write('serviceNamespace="%s",\n' % (self.serviceNamespace,))
        super(QueryResultEventRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultEventRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('userName', node)
        if value is not None and 'userName' not in already_processed:
            already_processed.add('userName')
            self.userName = value
        value = find_attr_value_('orgName', node)
        if value is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            self.orgName = value
        value = find_attr_value_('eventType', node)
        if value is not None and 'eventType' not in already_processed:
            already_processed.add('eventType')
            self.eventType = value
        value = find_attr_value_('entityName', node)
        if value is not None and 'entityName' not in already_processed:
            already_processed.add('entityName')
            self.entityName = value
        value = find_attr_value_('entityType', node)
        if value is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            self.entityType = value
        value = find_attr_value_('entity', node)
        if value is not None and 'entity' not in already_processed:
            already_processed.add('entity')
            self.entity = value
        value = find_attr_value_('eventStatus', node)
        if value is not None and 'eventStatus' not in already_processed:
            already_processed.add('eventStatus')
            try:
                self.eventStatus = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('timeStamp', node)
        if value is not None and 'timeStamp' not in already_processed:
            already_processed.add('timeStamp')
            try:
                self.timeStamp = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timeStamp): %s' % exp)
        value = find_attr_value_('serviceNamespace', node)
        if value is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            self.serviceNamespace = value
        super(QueryResultEventRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultEventRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultEventRecordType


class QueryResultResourcePoolRecordType(QueryResultRecordType):
    """1.5 Type for a single resourcePool query result in records format.
    1.5none The name of this resource pool. 1.5none Managed object
    reference 1.5none True if this entity is deleted 1.5none Virtual
    center reference or id 1.5none Vitual center name"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, moref=None, vc=None, vcName=None, name=None, isDeleted=None):
        self.original_tagname_ = None
        super(QueryResultResourcePoolRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.moref = _cast(None, moref)
        self.vc = _cast(None, vc)
        self.vcName = _cast(None, vcName)
        self.name = _cast(None, name)
        self.isDeleted = _cast(bool, isDeleted)
    def factory(*args_, **kwargs_):
        if QueryResultResourcePoolRecordType.subclass:
            return QueryResultResourcePoolRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultResourcePoolRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_moref(self): return self.moref
    def set_moref(self, moref): self.moref = moref
    def get_vc(self): return self.vc
    def set_vc(self, vc): self.vc = vc
    def get_vcName(self): return self.vcName
    def set_vcName(self, vcName): self.vcName = vcName
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_isDeleted(self): return self.isDeleted
    def set_isDeleted(self, isDeleted): self.isDeleted = isDeleted
    def hasContent_(self):
        if (
            super(QueryResultResourcePoolRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultResourcePoolRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultResourcePoolRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultResourcePoolRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultResourcePoolRecordType'):
        super(QueryResultResourcePoolRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultResourcePoolRecordType')
        if self.moref is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            outfile.write(' moref=%s' % (self.gds_format_string(quote_attrib(self.moref).encode(ExternalEncoding), input_name='moref'), ))
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            outfile.write(' vc=%s' % (self.gds_format_string(quote_attrib(self.vc).encode(ExternalEncoding), input_name='vc'), ))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            outfile.write(' vcName=%s' % (self.gds_format_string(quote_attrib(self.vcName).encode(ExternalEncoding), input_name='vcName'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            outfile.write(' isDeleted="%s"' % self.gds_format_boolean(self.isDeleted, input_name='isDeleted'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultResourcePoolRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultResourcePoolRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultResourcePoolRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.moref is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            showIndent(outfile, level)
            outfile.write('moref="%s",\n' % (self.moref,))
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            showIndent(outfile, level)
            outfile.write('vc="%s",\n' % (self.vc,))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            showIndent(outfile, level)
            outfile.write('vcName="%s",\n' % (self.vcName,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            showIndent(outfile, level)
            outfile.write('isDeleted=%s,\n' % (self.isDeleted,))
        super(QueryResultResourcePoolRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultResourcePoolRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('moref', node)
        if value is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            self.moref = value
        value = find_attr_value_('vc', node)
        if value is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            self.vc = value
        value = find_attr_value_('vcName', node)
        if value is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            self.vcName = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('isDeleted', node)
        if value is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            if value in ('true', '1'):
                self.isDeleted = True
            elif value in ('false', '0'):
                self.isDeleted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(QueryResultResourcePoolRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultResourcePoolRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultResourcePoolRecordType


class QueryResultDatastoreRecordType(QueryResultRecordType):
    """1.5 Type for a single datastore query result in records format.
    1.5none The name of this datastore. 1.5none Datastore type
    1.5none True if this entity is enabled 1.5none True if this
    entity is deleted 1.5none Storage used in MB 1.5none Storage in
    MB 1.5none Provisioned storage in MB 1.5none Requested storage
    in MB 1.5none Virtual center reference or id 1.5none Vitual
    center name 1.5none Managed object reference 1.5none Number of
    provider vDCs"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, vc=None, storageUsedMB=None, name=None, isEnabled=None, requestedStorageMB=None, storageMB=None, moref=None, vcName=None, datastoreType=None, numberOfProviderVdcs=None, provisionedStorageMB=None, isDeleted=None):
        self.original_tagname_ = None
        super(QueryResultDatastoreRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.vc = _cast(None, vc)
        self.storageUsedMB = _cast(int, storageUsedMB)
        self.name = _cast(None, name)
        self.isEnabled = _cast(bool, isEnabled)
        self.requestedStorageMB = _cast(int, requestedStorageMB)
        self.storageMB = _cast(int, storageMB)
        self.moref = _cast(None, moref)
        self.vcName = _cast(None, vcName)
        self.datastoreType = _cast(None, datastoreType)
        self.numberOfProviderVdcs = _cast(int, numberOfProviderVdcs)
        self.provisionedStorageMB = _cast(int, provisionedStorageMB)
        self.isDeleted = _cast(bool, isDeleted)
    def factory(*args_, **kwargs_):
        if QueryResultDatastoreRecordType.subclass:
            return QueryResultDatastoreRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultDatastoreRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vc(self): return self.vc
    def set_vc(self, vc): self.vc = vc
    def get_storageUsedMB(self): return self.storageUsedMB
    def set_storageUsedMB(self, storageUsedMB): self.storageUsedMB = storageUsedMB
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_requestedStorageMB(self): return self.requestedStorageMB
    def set_requestedStorageMB(self, requestedStorageMB): self.requestedStorageMB = requestedStorageMB
    def get_storageMB(self): return self.storageMB
    def set_storageMB(self, storageMB): self.storageMB = storageMB
    def get_moref(self): return self.moref
    def set_moref(self, moref): self.moref = moref
    def get_vcName(self): return self.vcName
    def set_vcName(self, vcName): self.vcName = vcName
    def get_datastoreType(self): return self.datastoreType
    def set_datastoreType(self, datastoreType): self.datastoreType = datastoreType
    def get_numberOfProviderVdcs(self): return self.numberOfProviderVdcs
    def set_numberOfProviderVdcs(self, numberOfProviderVdcs): self.numberOfProviderVdcs = numberOfProviderVdcs
    def get_provisionedStorageMB(self): return self.provisionedStorageMB
    def set_provisionedStorageMB(self, provisionedStorageMB): self.provisionedStorageMB = provisionedStorageMB
    def get_isDeleted(self): return self.isDeleted
    def set_isDeleted(self, isDeleted): self.isDeleted = isDeleted
    def hasContent_(self):
        if (
            super(QueryResultDatastoreRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultDatastoreRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultDatastoreRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultDatastoreRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultDatastoreRecordType'):
        super(QueryResultDatastoreRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultDatastoreRecordType')
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            outfile.write(' vc=%s' % (self.gds_format_string(quote_attrib(self.vc).encode(ExternalEncoding), input_name='vc'), ))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            outfile.write(' storageUsedMB="%s"' % self.gds_format_integer(self.storageUsedMB, input_name='storageUsedMB'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.requestedStorageMB is not None and 'requestedStorageMB' not in already_processed:
            already_processed.add('requestedStorageMB')
            outfile.write(' requestedStorageMB="%s"' % self.gds_format_integer(self.requestedStorageMB, input_name='requestedStorageMB'))
        if self.storageMB is not None and 'storageMB' not in already_processed:
            already_processed.add('storageMB')
            outfile.write(' storageMB="%s"' % self.gds_format_integer(self.storageMB, input_name='storageMB'))
        if self.moref is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            outfile.write(' moref=%s' % (self.gds_format_string(quote_attrib(self.moref).encode(ExternalEncoding), input_name='moref'), ))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            outfile.write(' vcName=%s' % (self.gds_format_string(quote_attrib(self.vcName).encode(ExternalEncoding), input_name='vcName'), ))
        if self.datastoreType is not None and 'datastoreType' not in already_processed:
            already_processed.add('datastoreType')
            outfile.write(' datastoreType=%s' % (self.gds_format_string(quote_attrib(self.datastoreType).encode(ExternalEncoding), input_name='datastoreType'), ))
        if self.numberOfProviderVdcs is not None and 'numberOfProviderVdcs' not in already_processed:
            already_processed.add('numberOfProviderVdcs')
            outfile.write(' numberOfProviderVdcs="%s"' % self.gds_format_integer(self.numberOfProviderVdcs, input_name='numberOfProviderVdcs'))
        if self.provisionedStorageMB is not None and 'provisionedStorageMB' not in already_processed:
            already_processed.add('provisionedStorageMB')
            outfile.write(' provisionedStorageMB="%s"' % self.gds_format_integer(self.provisionedStorageMB, input_name='provisionedStorageMB'))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            outfile.write(' isDeleted="%s"' % self.gds_format_boolean(self.isDeleted, input_name='isDeleted'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultDatastoreRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultDatastoreRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultDatastoreRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            showIndent(outfile, level)
            outfile.write('vc="%s",\n' % (self.vc,))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            showIndent(outfile, level)
            outfile.write('storageUsedMB=%d,\n' % (self.storageUsedMB,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.requestedStorageMB is not None and 'requestedStorageMB' not in already_processed:
            already_processed.add('requestedStorageMB')
            showIndent(outfile, level)
            outfile.write('requestedStorageMB=%d,\n' % (self.requestedStorageMB,))
        if self.storageMB is not None and 'storageMB' not in already_processed:
            already_processed.add('storageMB')
            showIndent(outfile, level)
            outfile.write('storageMB=%d,\n' % (self.storageMB,))
        if self.moref is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            showIndent(outfile, level)
            outfile.write('moref="%s",\n' % (self.moref,))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            showIndent(outfile, level)
            outfile.write('vcName="%s",\n' % (self.vcName,))
        if self.datastoreType is not None and 'datastoreType' not in already_processed:
            already_processed.add('datastoreType')
            showIndent(outfile, level)
            outfile.write('datastoreType="%s",\n' % (self.datastoreType,))
        if self.numberOfProviderVdcs is not None and 'numberOfProviderVdcs' not in already_processed:
            already_processed.add('numberOfProviderVdcs')
            showIndent(outfile, level)
            outfile.write('numberOfProviderVdcs=%d,\n' % (self.numberOfProviderVdcs,))
        if self.provisionedStorageMB is not None and 'provisionedStorageMB' not in already_processed:
            already_processed.add('provisionedStorageMB')
            showIndent(outfile, level)
            outfile.write('provisionedStorageMB=%d,\n' % (self.provisionedStorageMB,))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            showIndent(outfile, level)
            outfile.write('isDeleted=%s,\n' % (self.isDeleted,))
        super(QueryResultDatastoreRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultDatastoreRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vc', node)
        if value is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            self.vc = value
        value = find_attr_value_('storageUsedMB', node)
        if value is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            try:
                self.storageUsedMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('requestedStorageMB', node)
        if value is not None and 'requestedStorageMB' not in already_processed:
            already_processed.add('requestedStorageMB')
            try:
                self.requestedStorageMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storageMB', node)
        if value is not None and 'storageMB' not in already_processed:
            already_processed.add('storageMB')
            try:
                self.storageMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('moref', node)
        if value is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            self.moref = value
        value = find_attr_value_('vcName', node)
        if value is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            self.vcName = value
        value = find_attr_value_('datastoreType', node)
        if value is not None and 'datastoreType' not in already_processed:
            already_processed.add('datastoreType')
            self.datastoreType = value
        value = find_attr_value_('numberOfProviderVdcs', node)
        if value is not None and 'numberOfProviderVdcs' not in already_processed:
            already_processed.add('numberOfProviderVdcs')
            try:
                self.numberOfProviderVdcs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('provisionedStorageMB', node)
        if value is not None and 'provisionedStorageMB' not in already_processed:
            already_processed.add('provisionedStorageMB')
            try:
                self.provisionedStorageMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isDeleted', node)
        if value is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            if value in ('true', '1'):
                self.isDeleted = True
            elif value in ('false', '0'):
                self.isDeleted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(QueryResultDatastoreRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultDatastoreRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultDatastoreRecordType


class QueryResultNetworkPoolRecordType(QueryResultRecordType):
    """1.5 Type for a single networkPool query result in records format.
    1.5none Network pool name 1.5none Type of networkpool (0=Vlan
    backed network pool; 1=vNI backed network pool;2=Portgroup
    backed network pool) 1.5none True if this entity is busy"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, isBusy=None, networkPoolType=None, name=None):
        self.original_tagname_ = None
        super(QueryResultNetworkPoolRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.isBusy = _cast(bool, isBusy)
        self.networkPoolType = _cast(int, networkPoolType)
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if QueryResultNetworkPoolRecordType.subclass:
            return QueryResultNetworkPoolRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultNetworkPoolRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_networkPoolType(self): return self.networkPoolType
    def set_networkPoolType(self, networkPoolType): self.networkPoolType = networkPoolType
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            super(QueryResultNetworkPoolRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultNetworkPoolRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultNetworkPoolRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultNetworkPoolRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultNetworkPoolRecordType'):
        super(QueryResultNetworkPoolRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultNetworkPoolRecordType')
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.networkPoolType is not None and 'networkPoolType' not in already_processed:
            already_processed.add('networkPoolType')
            outfile.write(' networkPoolType="%s"' % self.gds_format_integer(self.networkPoolType, input_name='networkPoolType'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultNetworkPoolRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultNetworkPoolRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultNetworkPoolRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.networkPoolType is not None and 'networkPoolType' not in already_processed:
            already_processed.add('networkPoolType')
            showIndent(outfile, level)
            outfile.write('networkPoolType=%d,\n' % (self.networkPoolType,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(QueryResultNetworkPoolRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultNetworkPoolRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('networkPoolType', node)
        if value is not None and 'networkPoolType' not in already_processed:
            already_processed.add('networkPoolType')
            try:
                self.networkPoolType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(QueryResultNetworkPoolRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultNetworkPoolRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultNetworkPoolRecordType


class QueryResultPortgroupRecordType(QueryResultRecordType):
    """1.5 Type for a single portgroup query result in records format.
    1.5none Managed object reference of the portgroup 1.5none
    Portgroup name 1.5none Portgroup type 1.5none Virtual center
    reference or id 1.5none Vitual center name associated with the
    portgroup 1.5none True if the associated vCenter is enabled.
    1.5none Network reference or id 1.5none Name of the network that
    uses the portgroup 1.5none Scope of network using the
    portgroup(1=Global, 2=Organization, 3=vApp)"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, portgroupType=None, name=None, moref=None, vc=None, isVCEnabled=None, networkName=None, scopeType=None, vcName=None, network=None):
        self.original_tagname_ = None
        super(QueryResultPortgroupRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.portgroupType = _cast(None, portgroupType)
        self.name = _cast(None, name)
        self.moref = _cast(None, moref)
        self.vc = _cast(None, vc)
        self.isVCEnabled = _cast(bool, isVCEnabled)
        self.networkName = _cast(None, networkName)
        self.scopeType = _cast(int, scopeType)
        self.vcName = _cast(None, vcName)
        self.network = _cast(None, network)
    def factory(*args_, **kwargs_):
        if QueryResultPortgroupRecordType.subclass:
            return QueryResultPortgroupRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultPortgroupRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_portgroupType(self): return self.portgroupType
    def set_portgroupType(self, portgroupType): self.portgroupType = portgroupType
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_moref(self): return self.moref
    def set_moref(self, moref): self.moref = moref
    def get_vc(self): return self.vc
    def set_vc(self, vc): self.vc = vc
    def get_isVCEnabled(self): return self.isVCEnabled
    def set_isVCEnabled(self, isVCEnabled): self.isVCEnabled = isVCEnabled
    def get_networkName(self): return self.networkName
    def set_networkName(self, networkName): self.networkName = networkName
    def get_scopeType(self): return self.scopeType
    def set_scopeType(self, scopeType): self.scopeType = scopeType
    def get_vcName(self): return self.vcName
    def set_vcName(self, vcName): self.vcName = vcName
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def hasContent_(self):
        if (
            super(QueryResultPortgroupRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultPortgroupRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultPortgroupRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultPortgroupRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultPortgroupRecordType'):
        super(QueryResultPortgroupRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultPortgroupRecordType')
        if self.portgroupType is not None and 'portgroupType' not in already_processed:
            already_processed.add('portgroupType')
            outfile.write(' portgroupType=%s' % (self.gds_format_string(quote_attrib(self.portgroupType).encode(ExternalEncoding), input_name='portgroupType'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.moref is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            outfile.write(' moref=%s' % (self.gds_format_string(quote_attrib(self.moref).encode(ExternalEncoding), input_name='moref'), ))
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            outfile.write(' vc=%s' % (self.gds_format_string(quote_attrib(self.vc).encode(ExternalEncoding), input_name='vc'), ))
        if self.isVCEnabled is not None and 'isVCEnabled' not in already_processed:
            already_processed.add('isVCEnabled')
            outfile.write(' isVCEnabled="%s"' % self.gds_format_boolean(self.isVCEnabled, input_name='isVCEnabled'))
        if self.networkName is not None and 'networkName' not in already_processed:
            already_processed.add('networkName')
            outfile.write(' networkName=%s' % (self.gds_format_string(quote_attrib(self.networkName).encode(ExternalEncoding), input_name='networkName'), ))
        if self.scopeType is not None and 'scopeType' not in already_processed:
            already_processed.add('scopeType')
            outfile.write(' scopeType="%s"' % self.gds_format_integer(self.scopeType, input_name='scopeType'))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            outfile.write(' vcName=%s' % (self.gds_format_string(quote_attrib(self.vcName).encode(ExternalEncoding), input_name='vcName'), ))
        if self.network is not None and 'network' not in already_processed:
            already_processed.add('network')
            outfile.write(' network=%s' % (self.gds_format_string(quote_attrib(self.network).encode(ExternalEncoding), input_name='network'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultPortgroupRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultPortgroupRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultPortgroupRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.portgroupType is not None and 'portgroupType' not in already_processed:
            already_processed.add('portgroupType')
            showIndent(outfile, level)
            outfile.write('portgroupType="%s",\n' % (self.portgroupType,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.moref is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            showIndent(outfile, level)
            outfile.write('moref="%s",\n' % (self.moref,))
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            showIndent(outfile, level)
            outfile.write('vc="%s",\n' % (self.vc,))
        if self.isVCEnabled is not None and 'isVCEnabled' not in already_processed:
            already_processed.add('isVCEnabled')
            showIndent(outfile, level)
            outfile.write('isVCEnabled=%s,\n' % (self.isVCEnabled,))
        if self.networkName is not None and 'networkName' not in already_processed:
            already_processed.add('networkName')
            showIndent(outfile, level)
            outfile.write('networkName="%s",\n' % (self.networkName,))
        if self.scopeType is not None and 'scopeType' not in already_processed:
            already_processed.add('scopeType')
            showIndent(outfile, level)
            outfile.write('scopeType=%d,\n' % (self.scopeType,))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            showIndent(outfile, level)
            outfile.write('vcName="%s",\n' % (self.vcName,))
        if self.network is not None and 'network' not in already_processed:
            already_processed.add('network')
            showIndent(outfile, level)
            outfile.write('network="%s",\n' % (self.network,))
        super(QueryResultPortgroupRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultPortgroupRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('portgroupType', node)
        if value is not None and 'portgroupType' not in already_processed:
            already_processed.add('portgroupType')
            self.portgroupType = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('moref', node)
        if value is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            self.moref = value
        value = find_attr_value_('vc', node)
        if value is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            self.vc = value
        value = find_attr_value_('isVCEnabled', node)
        if value is not None and 'isVCEnabled' not in already_processed:
            already_processed.add('isVCEnabled')
            if value in ('true', '1'):
                self.isVCEnabled = True
            elif value in ('false', '0'):
                self.isVCEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('networkName', node)
        if value is not None and 'networkName' not in already_processed:
            already_processed.add('networkName')
            self.networkName = value
        value = find_attr_value_('scopeType', node)
        if value is not None and 'scopeType' not in already_processed:
            already_processed.add('scopeType')
            try:
                self.scopeType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('vcName', node)
        if value is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            self.vcName = value
        value = find_attr_value_('network', node)
        if value is not None and 'network' not in already_processed:
            already_processed.add('network')
            self.network = value
        super(QueryResultPortgroupRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultPortgroupRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultPortgroupRecordType


class QueryResultDvSwitchRecordType(QueryResultRecordType):
    """1.5 Type for a single dvSwitch query result in records format.
    1.5none Managed object reference of DV Switch 1.5none Virtual
    center name 1.5none Virtual center reference or id 1.5none
    Vitual center name 1.5none True if the associated vCenter is
    enabled."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, isVCEnabled=None, moref=None, vc=None, name=None, vcName=None):
        self.original_tagname_ = None
        super(QueryResultDvSwitchRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.isVCEnabled = _cast(bool, isVCEnabled)
        self.moref = _cast(None, moref)
        self.vc = _cast(None, vc)
        self.name = _cast(None, name)
        self.vcName = _cast(None, vcName)
    def factory(*args_, **kwargs_):
        if QueryResultDvSwitchRecordType.subclass:
            return QueryResultDvSwitchRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultDvSwitchRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isVCEnabled(self): return self.isVCEnabled
    def set_isVCEnabled(self, isVCEnabled): self.isVCEnabled = isVCEnabled
    def get_moref(self): return self.moref
    def set_moref(self, moref): self.moref = moref
    def get_vc(self): return self.vc
    def set_vc(self, vc): self.vc = vc
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_vcName(self): return self.vcName
    def set_vcName(self, vcName): self.vcName = vcName
    def hasContent_(self):
        if (
            super(QueryResultDvSwitchRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultDvSwitchRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultDvSwitchRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultDvSwitchRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultDvSwitchRecordType'):
        super(QueryResultDvSwitchRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultDvSwitchRecordType')
        if self.isVCEnabled is not None and 'isVCEnabled' not in already_processed:
            already_processed.add('isVCEnabled')
            outfile.write(' isVCEnabled="%s"' % self.gds_format_boolean(self.isVCEnabled, input_name='isVCEnabled'))
        if self.moref is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            outfile.write(' moref=%s' % (self.gds_format_string(quote_attrib(self.moref).encode(ExternalEncoding), input_name='moref'), ))
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            outfile.write(' vc=%s' % (self.gds_format_string(quote_attrib(self.vc).encode(ExternalEncoding), input_name='vc'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            outfile.write(' vcName=%s' % (self.gds_format_string(quote_attrib(self.vcName).encode(ExternalEncoding), input_name='vcName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultDvSwitchRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultDvSwitchRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultDvSwitchRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isVCEnabled is not None and 'isVCEnabled' not in already_processed:
            already_processed.add('isVCEnabled')
            showIndent(outfile, level)
            outfile.write('isVCEnabled=%s,\n' % (self.isVCEnabled,))
        if self.moref is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            showIndent(outfile, level)
            outfile.write('moref="%s",\n' % (self.moref,))
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            showIndent(outfile, level)
            outfile.write('vc="%s",\n' % (self.vc,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            showIndent(outfile, level)
            outfile.write('vcName="%s",\n' % (self.vcName,))
        super(QueryResultDvSwitchRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultDvSwitchRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isVCEnabled', node)
        if value is not None and 'isVCEnabled' not in already_processed:
            already_processed.add('isVCEnabled')
            if value in ('true', '1'):
                self.isVCEnabled = True
            elif value in ('false', '0'):
                self.isVCEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('moref', node)
        if value is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            self.moref = value
        value = find_attr_value_('vc', node)
        if value is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            self.vc = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('vcName', node)
        if value is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            self.vcName = value
        super(QueryResultDvSwitchRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultDvSwitchRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultDvSwitchRecordType


class QueryResultCellRecordType(QueryResultRecordType):
    """1.5 Type for a single cell query result in records format. 1.5none
    Primary IP 1.5none The Cell name 1.5none True if the cell is
    active 1.5none True if the cell is in vCenter inventory. 1.5none
    Build date 1.5none Version"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, name=None, version=None, isVMwareVc=None, primaryIp=None, isActive=None, buildDate=None):
        self.original_tagname_ = None
        super(QueryResultCellRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.name = _cast(None, name)
        self.version = _cast(None, version)
        self.isVMwareVc = _cast(int, isVMwareVc)
        self.primaryIp = _cast(None, primaryIp)
        self.isActive = _cast(int, isActive)
        if isinstance(buildDate, basestring):
            initvalue_ = datetime_.datetime.strptime(buildDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = buildDate
        self.buildDate = initvalue_
    def factory(*args_, **kwargs_):
        if QueryResultCellRecordType.subclass:
            return QueryResultCellRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultCellRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isVMwareVc(self): return self.isVMwareVc
    def set_isVMwareVc(self, isVMwareVc): self.isVMwareVc = isVMwareVc
    def get_primaryIp(self): return self.primaryIp
    def set_primaryIp(self, primaryIp): self.primaryIp = primaryIp
    def get_isActive(self): return self.isActive
    def set_isActive(self, isActive): self.isActive = isActive
    def get_buildDate(self): return self.buildDate
    def set_buildDate(self, buildDate): self.buildDate = buildDate
    def hasContent_(self):
        if (
            super(QueryResultCellRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultCellRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultCellRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultCellRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultCellRecordType'):
        super(QueryResultCellRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultCellRecordType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isVMwareVc is not None and 'isVMwareVc' not in already_processed:
            already_processed.add('isVMwareVc')
            outfile.write(' isVMwareVc="%s"' % self.gds_format_integer(self.isVMwareVc, input_name='isVMwareVc'))
        if self.primaryIp is not None and 'primaryIp' not in already_processed:
            already_processed.add('primaryIp')
            outfile.write(' primaryIp=%s' % (self.gds_format_string(quote_attrib(self.primaryIp).encode(ExternalEncoding), input_name='primaryIp'), ))
        if self.isActive is not None and 'isActive' not in already_processed:
            already_processed.add('isActive')
            outfile.write(' isActive="%s"' % self.gds_format_integer(self.isActive, input_name='isActive'))
        if self.buildDate is not None and 'buildDate' not in already_processed:
            already_processed.add('buildDate')
            outfile.write(' buildDate="%s"' % self.gds_format_datetime(self.buildDate, input_name='buildDate'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultCellRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultCellRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultCellRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.isVMwareVc is not None and 'isVMwareVc' not in already_processed:
            already_processed.add('isVMwareVc')
            showIndent(outfile, level)
            outfile.write('isVMwareVc=%d,\n' % (self.isVMwareVc,))
        if self.primaryIp is not None and 'primaryIp' not in already_processed:
            already_processed.add('primaryIp')
            showIndent(outfile, level)
            outfile.write('primaryIp="%s",\n' % (self.primaryIp,))
        if self.isActive is not None and 'isActive' not in already_processed:
            already_processed.add('isActive')
            showIndent(outfile, level)
            outfile.write('isActive=%d,\n' % (self.isActive,))
        if self.buildDate is not None and 'buildDate' not in already_processed:
            already_processed.add('buildDate')
            showIndent(outfile, level)
            outfile.write('buildDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.buildDate, input_name='buildDate'))
        super(QueryResultCellRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultCellRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('isVMwareVc', node)
        if value is not None and 'isVMwareVc' not in already_processed:
            already_processed.add('isVMwareVc')
            try:
                self.isVMwareVc = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('primaryIp', node)
        if value is not None and 'primaryIp' not in already_processed:
            already_processed.add('primaryIp')
            self.primaryIp = value
        value = find_attr_value_('isActive', node)
        if value is not None and 'isActive' not in already_processed:
            already_processed.add('isActive')
            try:
                self.isActive = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('buildDate', node)
        if value is not None and 'buildDate' not in already_processed:
            already_processed.add('buildDate')
            try:
                self.buildDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (buildDate): %s' % exp)
        super(QueryResultCellRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultCellRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultCellRecordType


class QueryResultVirtualCenterRecordType(QueryResultRecordType):
    """1.5 Type for a single virtualCenter query result in records format.
    1.5none The name of this vCenter. 1.5none Url 1.5none User name
    1.5none True if this entity is enabled 1.5none Virtual center
    version 1.5none Status 1.5none vShield IP address 1.5none True
    if this entity is busy 1.5none Uuid 5.1none True if this vCenter
    version is supported by this release of vCloud Director."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, userName=None, status=None, name=None, isSupported=None, url=None, isEnabled=None, vsmIP=None, vcVersion=None, isBusy=None, uuid=None):
        self.original_tagname_ = None
        super(QueryResultVirtualCenterRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.userName = _cast(None, userName)
        self.status = _cast(None, status)
        self.name = _cast(None, name)
        self.isSupported = _cast(bool, isSupported)
        self.url = _cast(None, url)
        self.isEnabled = _cast(bool, isEnabled)
        self.vsmIP = _cast(None, vsmIP)
        self.vcVersion = _cast(None, vcVersion)
        self.isBusy = _cast(bool, isBusy)
        self.uuid = _cast(None, uuid)
    def factory(*args_, **kwargs_):
        if QueryResultVirtualCenterRecordType.subclass:
            return QueryResultVirtualCenterRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultVirtualCenterRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_userName(self): return self.userName
    def set_userName(self, userName): self.userName = userName
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_isSupported(self): return self.isSupported
    def set_isSupported(self, isSupported): self.isSupported = isSupported
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_vsmIP(self): return self.vsmIP
    def set_vsmIP(self, vsmIP): self.vsmIP = vsmIP
    def get_vcVersion(self): return self.vcVersion
    def set_vcVersion(self, vcVersion): self.vcVersion = vcVersion
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_uuid(self): return self.uuid
    def set_uuid(self, uuid): self.uuid = uuid
    def hasContent_(self):
        if (
            super(QueryResultVirtualCenterRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultVirtualCenterRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVirtualCenterRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultVirtualCenterRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultVirtualCenterRecordType'):
        super(QueryResultVirtualCenterRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVirtualCenterRecordType')
        if self.userName is not None and 'userName' not in already_processed:
            already_processed.add('userName')
            outfile.write(' userName=%s' % (self.gds_format_string(quote_attrib(self.userName).encode(ExternalEncoding), input_name='userName'), ))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.isSupported is not None and 'isSupported' not in already_processed:
            already_processed.add('isSupported')
            outfile.write(' isSupported="%s"' % self.gds_format_boolean(self.isSupported, input_name='isSupported'))
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            outfile.write(' url=%s' % (self.gds_format_string(quote_attrib(self.url).encode(ExternalEncoding), input_name='url'), ))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.vsmIP is not None and 'vsmIP' not in already_processed:
            already_processed.add('vsmIP')
            outfile.write(' vsmIP=%s' % (self.gds_format_string(quote_attrib(self.vsmIP).encode(ExternalEncoding), input_name='vsmIP'), ))
        if self.vcVersion is not None and 'vcVersion' not in already_processed:
            already_processed.add('vcVersion')
            outfile.write(' vcVersion=%s' % (self.gds_format_string(quote_attrib(self.vcVersion).encode(ExternalEncoding), input_name='vcVersion'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.uuid is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            outfile.write(' uuid=%s' % (self.gds_format_string(quote_attrib(self.uuid).encode(ExternalEncoding), input_name='uuid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultVirtualCenterRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultVirtualCenterRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultVirtualCenterRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.userName is not None and 'userName' not in already_processed:
            already_processed.add('userName')
            showIndent(outfile, level)
            outfile.write('userName="%s",\n' % (self.userName,))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.isSupported is not None and 'isSupported' not in already_processed:
            already_processed.add('isSupported')
            showIndent(outfile, level)
            outfile.write('isSupported=%s,\n' % (self.isSupported,))
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            showIndent(outfile, level)
            outfile.write('url="%s",\n' % (self.url,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.vsmIP is not None and 'vsmIP' not in already_processed:
            already_processed.add('vsmIP')
            showIndent(outfile, level)
            outfile.write('vsmIP="%s",\n' % (self.vsmIP,))
        if self.vcVersion is not None and 'vcVersion' not in already_processed:
            already_processed.add('vcVersion')
            showIndent(outfile, level)
            outfile.write('vcVersion="%s",\n' % (self.vcVersion,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.uuid is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            showIndent(outfile, level)
            outfile.write('uuid="%s",\n' % (self.uuid,))
        super(QueryResultVirtualCenterRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultVirtualCenterRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('userName', node)
        if value is not None and 'userName' not in already_processed:
            already_processed.add('userName')
            self.userName = value
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('isSupported', node)
        if value is not None and 'isSupported' not in already_processed:
            already_processed.add('isSupported')
            if value in ('true', '1'):
                self.isSupported = True
            elif value in ('false', '0'):
                self.isSupported = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.add('url')
            self.url = value
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vsmIP', node)
        if value is not None and 'vsmIP' not in already_processed:
            already_processed.add('vsmIP')
            self.vsmIP = value
        value = find_attr_value_('vcVersion', node)
        if value is not None and 'vcVersion' not in already_processed:
            already_processed.add('vcVersion')
            self.vcVersion = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('uuid', node)
        if value is not None and 'uuid' not in already_processed:
            already_processed.add('uuid')
            self.uuid = value
        super(QueryResultVirtualCenterRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultVirtualCenterRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultVirtualCenterRecordType


class QueryResultHostRecordType(QueryResultRecordType):
    """1.5 Type for a single host query result in records format. 1.5none
    The name of this host. 1.5none True if this entity is enabled
    1.5none True if this entity is deleted 1.5none True if this host
    has tasks in progress 1.5none True if this host is prepared
    1.5none True if this host's ESXi version is supported by this
    release of vCloud Director. 1.5none True if this host is hung.
    1.5none True if this host has an upgrade pending. 1.5none State
    1.5none Operating system version 1.5none True if this host is
    cross-host enabled. 1.5none Number of VMs 1.5none True if this
    host is in maintenance mode. 1.5none Virtual center reference or
    id 1.5none Vitual center name"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, isSupported=None, isHung=None, vc=None, isInMaintenanceMode=None, name=None, isCrossHostEnabled=None, numberOfVMs=None, isEnabled=None, state=None, isPendingUpgrade=None, vcName=None, isBusy=None, osVersion=None, isDeleted=None, isPrepared=None):
        self.original_tagname_ = None
        super(QueryResultHostRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.isSupported = _cast(bool, isSupported)
        self.isHung = _cast(bool, isHung)
        self.vc = _cast(None, vc)
        self.isInMaintenanceMode = _cast(bool, isInMaintenanceMode)
        self.name = _cast(None, name)
        self.isCrossHostEnabled = _cast(bool, isCrossHostEnabled)
        self.numberOfVMs = _cast(int, numberOfVMs)
        self.isEnabled = _cast(bool, isEnabled)
        self.state = _cast(int, state)
        self.isPendingUpgrade = _cast(bool, isPendingUpgrade)
        self.vcName = _cast(None, vcName)
        self.isBusy = _cast(bool, isBusy)
        self.osVersion = _cast(None, osVersion)
        self.isDeleted = _cast(bool, isDeleted)
        self.isPrepared = _cast(bool, isPrepared)
    def factory(*args_, **kwargs_):
        if QueryResultHostRecordType.subclass:
            return QueryResultHostRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultHostRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isSupported(self): return self.isSupported
    def set_isSupported(self, isSupported): self.isSupported = isSupported
    def get_isHung(self): return self.isHung
    def set_isHung(self, isHung): self.isHung = isHung
    def get_vc(self): return self.vc
    def set_vc(self, vc): self.vc = vc
    def get_isInMaintenanceMode(self): return self.isInMaintenanceMode
    def set_isInMaintenanceMode(self, isInMaintenanceMode): self.isInMaintenanceMode = isInMaintenanceMode
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_isCrossHostEnabled(self): return self.isCrossHostEnabled
    def set_isCrossHostEnabled(self, isCrossHostEnabled): self.isCrossHostEnabled = isCrossHostEnabled
    def get_numberOfVMs(self): return self.numberOfVMs
    def set_numberOfVMs(self, numberOfVMs): self.numberOfVMs = numberOfVMs
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_state(self): return self.state
    def set_state(self, state): self.state = state
    def get_isPendingUpgrade(self): return self.isPendingUpgrade
    def set_isPendingUpgrade(self, isPendingUpgrade): self.isPendingUpgrade = isPendingUpgrade
    def get_vcName(self): return self.vcName
    def set_vcName(self, vcName): self.vcName = vcName
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_osVersion(self): return self.osVersion
    def set_osVersion(self, osVersion): self.osVersion = osVersion
    def get_isDeleted(self): return self.isDeleted
    def set_isDeleted(self, isDeleted): self.isDeleted = isDeleted
    def get_isPrepared(self): return self.isPrepared
    def set_isPrepared(self, isPrepared): self.isPrepared = isPrepared
    def hasContent_(self):
        if (
            super(QueryResultHostRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultHostRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultHostRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultHostRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultHostRecordType'):
        super(QueryResultHostRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultHostRecordType')
        if self.isSupported is not None and 'isSupported' not in already_processed:
            already_processed.add('isSupported')
            outfile.write(' isSupported="%s"' % self.gds_format_boolean(self.isSupported, input_name='isSupported'))
        if self.isHung is not None and 'isHung' not in already_processed:
            already_processed.add('isHung')
            outfile.write(' isHung="%s"' % self.gds_format_boolean(self.isHung, input_name='isHung'))
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            outfile.write(' vc=%s' % (self.gds_format_string(quote_attrib(self.vc).encode(ExternalEncoding), input_name='vc'), ))
        if self.isInMaintenanceMode is not None and 'isInMaintenanceMode' not in already_processed:
            already_processed.add('isInMaintenanceMode')
            outfile.write(' isInMaintenanceMode="%s"' % self.gds_format_boolean(self.isInMaintenanceMode, input_name='isInMaintenanceMode'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.isCrossHostEnabled is not None and 'isCrossHostEnabled' not in already_processed:
            already_processed.add('isCrossHostEnabled')
            outfile.write(' isCrossHostEnabled="%s"' % self.gds_format_boolean(self.isCrossHostEnabled, input_name='isCrossHostEnabled'))
        if self.numberOfVMs is not None and 'numberOfVMs' not in already_processed:
            already_processed.add('numberOfVMs')
            outfile.write(' numberOfVMs="%s"' % self.gds_format_integer(self.numberOfVMs, input_name='numberOfVMs'))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            outfile.write(' state="%s"' % self.gds_format_integer(self.state, input_name='state'))
        if self.isPendingUpgrade is not None and 'isPendingUpgrade' not in already_processed:
            already_processed.add('isPendingUpgrade')
            outfile.write(' isPendingUpgrade="%s"' % self.gds_format_boolean(self.isPendingUpgrade, input_name='isPendingUpgrade'))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            outfile.write(' vcName=%s' % (self.gds_format_string(quote_attrib(self.vcName).encode(ExternalEncoding), input_name='vcName'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.osVersion is not None and 'osVersion' not in already_processed:
            already_processed.add('osVersion')
            outfile.write(' osVersion=%s' % (self.gds_format_string(quote_attrib(self.osVersion).encode(ExternalEncoding), input_name='osVersion'), ))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            outfile.write(' isDeleted="%s"' % self.gds_format_boolean(self.isDeleted, input_name='isDeleted'))
        if self.isPrepared is not None and 'isPrepared' not in already_processed:
            already_processed.add('isPrepared')
            outfile.write(' isPrepared="%s"' % self.gds_format_boolean(self.isPrepared, input_name='isPrepared'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultHostRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultHostRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultHostRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isSupported is not None and 'isSupported' not in already_processed:
            already_processed.add('isSupported')
            showIndent(outfile, level)
            outfile.write('isSupported=%s,\n' % (self.isSupported,))
        if self.isHung is not None and 'isHung' not in already_processed:
            already_processed.add('isHung')
            showIndent(outfile, level)
            outfile.write('isHung=%s,\n' % (self.isHung,))
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            showIndent(outfile, level)
            outfile.write('vc="%s",\n' % (self.vc,))
        if self.isInMaintenanceMode is not None and 'isInMaintenanceMode' not in already_processed:
            already_processed.add('isInMaintenanceMode')
            showIndent(outfile, level)
            outfile.write('isInMaintenanceMode=%s,\n' % (self.isInMaintenanceMode,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.isCrossHostEnabled is not None and 'isCrossHostEnabled' not in already_processed:
            already_processed.add('isCrossHostEnabled')
            showIndent(outfile, level)
            outfile.write('isCrossHostEnabled=%s,\n' % (self.isCrossHostEnabled,))
        if self.numberOfVMs is not None and 'numberOfVMs' not in already_processed:
            already_processed.add('numberOfVMs')
            showIndent(outfile, level)
            outfile.write('numberOfVMs=%d,\n' % (self.numberOfVMs,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.state is not None and 'state' not in already_processed:
            already_processed.add('state')
            showIndent(outfile, level)
            outfile.write('state=%d,\n' % (self.state,))
        if self.isPendingUpgrade is not None and 'isPendingUpgrade' not in already_processed:
            already_processed.add('isPendingUpgrade')
            showIndent(outfile, level)
            outfile.write('isPendingUpgrade=%s,\n' % (self.isPendingUpgrade,))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            showIndent(outfile, level)
            outfile.write('vcName="%s",\n' % (self.vcName,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.osVersion is not None and 'osVersion' not in already_processed:
            already_processed.add('osVersion')
            showIndent(outfile, level)
            outfile.write('osVersion="%s",\n' % (self.osVersion,))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            showIndent(outfile, level)
            outfile.write('isDeleted=%s,\n' % (self.isDeleted,))
        if self.isPrepared is not None and 'isPrepared' not in already_processed:
            already_processed.add('isPrepared')
            showIndent(outfile, level)
            outfile.write('isPrepared=%s,\n' % (self.isPrepared,))
        super(QueryResultHostRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultHostRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isSupported', node)
        if value is not None and 'isSupported' not in already_processed:
            already_processed.add('isSupported')
            if value in ('true', '1'):
                self.isSupported = True
            elif value in ('false', '0'):
                self.isSupported = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isHung', node)
        if value is not None and 'isHung' not in already_processed:
            already_processed.add('isHung')
            if value in ('true', '1'):
                self.isHung = True
            elif value in ('false', '0'):
                self.isHung = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vc', node)
        if value is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            self.vc = value
        value = find_attr_value_('isInMaintenanceMode', node)
        if value is not None and 'isInMaintenanceMode' not in already_processed:
            already_processed.add('isInMaintenanceMode')
            if value in ('true', '1'):
                self.isInMaintenanceMode = True
            elif value in ('false', '0'):
                self.isInMaintenanceMode = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('isCrossHostEnabled', node)
        if value is not None and 'isCrossHostEnabled' not in already_processed:
            already_processed.add('isCrossHostEnabled')
            if value in ('true', '1'):
                self.isCrossHostEnabled = True
            elif value in ('false', '0'):
                self.isCrossHostEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('numberOfVMs', node)
        if value is not None and 'numberOfVMs' not in already_processed:
            already_processed.add('numberOfVMs')
            try:
                self.numberOfVMs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('state', node)
        if value is not None and 'state' not in already_processed:
            already_processed.add('state')
            try:
                self.state = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isPendingUpgrade', node)
        if value is not None and 'isPendingUpgrade' not in already_processed:
            already_processed.add('isPendingUpgrade')
            if value in ('true', '1'):
                self.isPendingUpgrade = True
            elif value in ('false', '0'):
                self.isPendingUpgrade = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vcName', node)
        if value is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            self.vcName = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('osVersion', node)
        if value is not None and 'osVersion' not in already_processed:
            already_processed.add('osVersion')
            self.osVersion = value
        value = find_attr_value_('isDeleted', node)
        if value is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            if value in ('true', '1'):
                self.isDeleted = True
            elif value in ('false', '0'):
                self.isDeleted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isPrepared', node)
        if value is not None and 'isPrepared' not in already_processed:
            already_processed.add('isPrepared')
            if value in ('true', '1'):
                self.isPrepared = True
            elif value in ('false', '0'):
                self.isPrepared = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(QueryResultHostRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultHostRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultHostRecordType


class QueryResultAdminVAppRecordType(QueryResultRecordType):
    """1.5 Type for a single adminVApp query result in records format.
    1.5none The name of this vApp. 1.5none Organization reference or
    id 1.5none VDC reference or id 1.5none VDC name 1.5none True if
    the containing VDC is enabled. 1.5none True if this entity is
    enabled 1.5none True if this entity is busy 1.5none Creation
    date 1.5none Status 1.5none Owner name 1.5none Storage in KB
    1.5none Number of VMs 1.55.1none CPU allocation in Mhz 1.5none
    Memory allocation in MB 1.5none True if the vApp is deployed.
    1.5none True if the vApp is in maintenance mode. 5.1none True if
    the vApp is expired."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, isDeployed=None, name=None, numberOfVMs=None, isEnabled=None, cpuAllocationMhz=None, vdcName=None, vdc=None, ownerName=None, isBusy=None, memoryAllocationMB=None, org=None, isInMaintenanceMode=None, creationDate=None, isVdcEnabled=None, isExpired=None, storageKB=None):
        self.original_tagname_ = None
        super(QueryResultAdminVAppRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        self.isDeployed = _cast(bool, isDeployed)
        self.name = _cast(None, name)
        self.numberOfVMs = _cast(int, numberOfVMs)
        self.isEnabled = _cast(bool, isEnabled)
        self.cpuAllocationMhz = _cast(int, cpuAllocationMhz)
        self.vdcName = _cast(None, vdcName)
        self.vdc = _cast(None, vdc)
        self.ownerName = _cast(None, ownerName)
        self.isBusy = _cast(bool, isBusy)
        self.memoryAllocationMB = _cast(int, memoryAllocationMB)
        self.org = _cast(None, org)
        self.isInMaintenanceMode = _cast(bool, isInMaintenanceMode)
        if isinstance(creationDate, basestring):
            initvalue_ = datetime_.datetime.strptime(creationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationDate
        self.creationDate = initvalue_
        self.isVdcEnabled = _cast(bool, isVdcEnabled)
        self.isExpired = _cast(bool, isExpired)
        self.storageKB = _cast(int, storageKB)
    def factory(*args_, **kwargs_):
        if QueryResultAdminVAppRecordType.subclass:
            return QueryResultAdminVAppRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminVAppRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_isDeployed(self): return self.isDeployed
    def set_isDeployed(self, isDeployed): self.isDeployed = isDeployed
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_numberOfVMs(self): return self.numberOfVMs
    def set_numberOfVMs(self, numberOfVMs): self.numberOfVMs = numberOfVMs
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_cpuAllocationMhz(self): return self.cpuAllocationMhz
    def set_cpuAllocationMhz(self, cpuAllocationMhz): self.cpuAllocationMhz = cpuAllocationMhz
    def get_vdcName(self): return self.vdcName
    def set_vdcName(self, vdcName): self.vdcName = vdcName
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_memoryAllocationMB(self): return self.memoryAllocationMB
    def set_memoryAllocationMB(self, memoryAllocationMB): self.memoryAllocationMB = memoryAllocationMB
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_isInMaintenanceMode(self): return self.isInMaintenanceMode
    def set_isInMaintenanceMode(self, isInMaintenanceMode): self.isInMaintenanceMode = isInMaintenanceMode
    def get_creationDate(self): return self.creationDate
    def set_creationDate(self, creationDate): self.creationDate = creationDate
    def get_isVdcEnabled(self): return self.isVdcEnabled
    def set_isVdcEnabled(self, isVdcEnabled): self.isVdcEnabled = isVdcEnabled
    def get_isExpired(self): return self.isExpired
    def set_isExpired(self, isExpired): self.isExpired = isExpired
    def get_storageKB(self): return self.storageKB
    def set_storageKB(self, storageKB): self.storageKB = storageKB
    def hasContent_(self):
        if (
            super(QueryResultAdminVAppRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminVAppRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminVAppRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminVAppRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminVAppRecordType'):
        super(QueryResultAdminVAppRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminVAppRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            outfile.write(' isDeployed="%s"' % self.gds_format_boolean(self.isDeployed, input_name='isDeployed'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.numberOfVMs is not None and 'numberOfVMs' not in already_processed:
            already_processed.add('numberOfVMs')
            outfile.write(' numberOfVMs="%s"' % self.gds_format_integer(self.numberOfVMs, input_name='numberOfVMs'))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.cpuAllocationMhz is not None and 'cpuAllocationMhz' not in already_processed:
            already_processed.add('cpuAllocationMhz')
            outfile.write(' cpuAllocationMhz="%s"' % self.gds_format_integer(self.cpuAllocationMhz, input_name='cpuAllocationMhz'))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            outfile.write(' vdcName=%s' % (self.gds_format_string(quote_attrib(self.vdcName).encode(ExternalEncoding), input_name='vdcName'), ))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.memoryAllocationMB is not None and 'memoryAllocationMB' not in already_processed:
            already_processed.add('memoryAllocationMB')
            outfile.write(' memoryAllocationMB="%s"' % self.gds_format_integer(self.memoryAllocationMB, input_name='memoryAllocationMB'))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.isInMaintenanceMode is not None and 'isInMaintenanceMode' not in already_processed:
            already_processed.add('isInMaintenanceMode')
            outfile.write(' isInMaintenanceMode="%s"' % self.gds_format_boolean(self.isInMaintenanceMode, input_name='isInMaintenanceMode'))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            outfile.write(' creationDate="%s"' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.isVdcEnabled is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            outfile.write(' isVdcEnabled="%s"' % self.gds_format_boolean(self.isVdcEnabled, input_name='isVdcEnabled'))
        if self.isExpired is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            outfile.write(' isExpired="%s"' % self.gds_format_boolean(self.isExpired, input_name='isExpired'))
        if self.storageKB is not None and 'storageKB' not in already_processed:
            already_processed.add('storageKB')
            outfile.write(' storageKB="%s"' % self.gds_format_integer(self.storageKB, input_name='storageKB'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminVAppRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminVAppRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminVAppRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            showIndent(outfile, level)
            outfile.write('isDeployed=%s,\n' % (self.isDeployed,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.numberOfVMs is not None and 'numberOfVMs' not in already_processed:
            already_processed.add('numberOfVMs')
            showIndent(outfile, level)
            outfile.write('numberOfVMs=%d,\n' % (self.numberOfVMs,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.cpuAllocationMhz is not None and 'cpuAllocationMhz' not in already_processed:
            already_processed.add('cpuAllocationMhz')
            showIndent(outfile, level)
            outfile.write('cpuAllocationMhz=%d,\n' % (self.cpuAllocationMhz,))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            showIndent(outfile, level)
            outfile.write('vdcName="%s",\n' % (self.vdcName,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.memoryAllocationMB is not None and 'memoryAllocationMB' not in already_processed:
            already_processed.add('memoryAllocationMB')
            showIndent(outfile, level)
            outfile.write('memoryAllocationMB=%d,\n' % (self.memoryAllocationMB,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.isInMaintenanceMode is not None and 'isInMaintenanceMode' not in already_processed:
            already_processed.add('isInMaintenanceMode')
            showIndent(outfile, level)
            outfile.write('isInMaintenanceMode=%s,\n' % (self.isInMaintenanceMode,))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            showIndent(outfile, level)
            outfile.write('creationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.isVdcEnabled is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            showIndent(outfile, level)
            outfile.write('isVdcEnabled=%s,\n' % (self.isVdcEnabled,))
        if self.isExpired is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            showIndent(outfile, level)
            outfile.write('isExpired=%s,\n' % (self.isExpired,))
        if self.storageKB is not None and 'storageKB' not in already_processed:
            already_processed.add('storageKB')
            showIndent(outfile, level)
            outfile.write('storageKB=%d,\n' % (self.storageKB,))
        super(QueryResultAdminVAppRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminVAppRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('isDeployed', node)
        if value is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            if value in ('true', '1'):
                self.isDeployed = True
            elif value in ('false', '0'):
                self.isDeployed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('numberOfVMs', node)
        if value is not None and 'numberOfVMs' not in already_processed:
            already_processed.add('numberOfVMs')
            try:
                self.numberOfVMs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('cpuAllocationMhz', node)
        if value is not None and 'cpuAllocationMhz' not in already_processed:
            already_processed.add('cpuAllocationMhz')
            try:
                self.cpuAllocationMhz = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('vdcName', node)
        if value is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            self.vdcName = value
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('memoryAllocationMB', node)
        if value is not None and 'memoryAllocationMB' not in already_processed:
            already_processed.add('memoryAllocationMB')
            try:
                self.memoryAllocationMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('isInMaintenanceMode', node)
        if value is not None and 'isInMaintenanceMode' not in already_processed:
            already_processed.add('isInMaintenanceMode')
            if value in ('true', '1'):
                self.isInMaintenanceMode = True
            elif value in ('false', '0'):
                self.isInMaintenanceMode = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('creationDate', node)
        if value is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            try:
                self.creationDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (creationDate): %s' % exp)
        value = find_attr_value_('isVdcEnabled', node)
        if value is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            if value in ('true', '1'):
                self.isVdcEnabled = True
            elif value in ('false', '0'):
                self.isVdcEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isExpired', node)
        if value is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            if value in ('true', '1'):
                self.isExpired = True
            elif value in ('false', '0'):
                self.isExpired = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('storageKB', node)
        if value is not None and 'storageKB' not in already_processed:
            already_processed.add('storageKB')
            try:
                self.storageKB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(QueryResultAdminVAppRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminVAppRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminVAppRecordType


class QueryResultRightRecordType(QueryResultRecordType):
    """1.5 Type for a single right query result in records format. 1.5none
    The name of this right. 1.5none Category"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, category=None, name=None):
        self.original_tagname_ = None
        super(QueryResultRightRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.category = _cast(None, category)
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if QueryResultRightRecordType.subclass:
            return QueryResultRightRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultRightRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            super(QueryResultRightRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultRightRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultRightRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultRightRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultRightRecordType'):
        super(QueryResultRightRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultRightRecordType')
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            outfile.write(' category=%s' % (self.gds_format_string(quote_attrib(self.category).encode(ExternalEncoding), input_name='category'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultRightRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultRightRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultRightRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.category is not None and 'category' not in already_processed:
            already_processed.add('category')
            showIndent(outfile, level)
            outfile.write('category="%s",\n' % (self.category,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(QueryResultRightRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultRightRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('category', node)
        if value is not None and 'category' not in already_processed:
            already_processed.add('category')
            self.category = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(QueryResultRightRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultRightRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultRightRecordType


class QueryResultAdminVMRecordType(QueryResultRecordType):
    """1.5 Type for a single adminVM query result in records format.
    1.5none The name of this VM. 1.5none The name of the containing
    vApp or vApp template. 1.5none Vapp or Vapp template 1.5none
    Status 1.5none VDC reference or id 1.5none ESXi host for this VM
    1.5none True if the VM belongs to a vApp template. 1.5none True
    if this entity is deleted 1.5none Guest operating system 1.5none
    Number of CPUs 1.5none Memory in MB 1.5none Network name 1.5none
    True if this entity is deployed 1.5none True if this entity is
    in a published catalog 1.5none Catalog name 1.5none True if the
    containing VDC is enabled 1.5none Hardware version 1.5none VM
    tools version 1.5none Datastore name 1.5none Virtual center
    reference or id 1.5none Managed object reference 1.5none
    Organization reference or id 5.1none Storage profile name"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, vc=None, vmToolsVersion=None, datastoreName=None, memoryMB=None, moref=None, hardwareVersion=None, org=None, isVAppTemplate=None, isDeleted=None, catalogName=None, isDeployed=None, guestOs=None, isVdcEnabled=None, status=None, storageProfileName=None, hostName=None, container=None, networkName=None, containerName=None, name=None, isPublished=None, numberOfCpus=None, vdc=None):
        self.original_tagname_ = None
        super(QueryResultAdminVMRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.vc = _cast(None, vc)
        self.vmToolsVersion = _cast(int, vmToolsVersion)
        self.datastoreName = _cast(None, datastoreName)
        self.memoryMB = _cast(int, memoryMB)
        self.moref = _cast(None, moref)
        self.hardwareVersion = _cast(int, hardwareVersion)
        self.org = _cast(None, org)
        self.isVAppTemplate = _cast(bool, isVAppTemplate)
        self.isDeleted = _cast(bool, isDeleted)
        self.catalogName = _cast(None, catalogName)
        self.isDeployed = _cast(bool, isDeployed)
        self.guestOs = _cast(None, guestOs)
        self.isVdcEnabled = _cast(bool, isVdcEnabled)
        self.status = _cast(None, status)
        self.storageProfileName = _cast(None, storageProfileName)
        self.hostName = _cast(None, hostName)
        self.container = _cast(None, container)
        self.networkName = _cast(None, networkName)
        self.containerName = _cast(None, containerName)
        self.name = _cast(None, name)
        self.isPublished = _cast(bool, isPublished)
        self.numberOfCpus = _cast(int, numberOfCpus)
        self.vdc = _cast(None, vdc)
    def factory(*args_, **kwargs_):
        if QueryResultAdminVMRecordType.subclass:
            return QueryResultAdminVMRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminVMRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vc(self): return self.vc
    def set_vc(self, vc): self.vc = vc
    def get_vmToolsVersion(self): return self.vmToolsVersion
    def set_vmToolsVersion(self, vmToolsVersion): self.vmToolsVersion = vmToolsVersion
    def get_datastoreName(self): return self.datastoreName
    def set_datastoreName(self, datastoreName): self.datastoreName = datastoreName
    def get_memoryMB(self): return self.memoryMB
    def set_memoryMB(self, memoryMB): self.memoryMB = memoryMB
    def get_moref(self): return self.moref
    def set_moref(self, moref): self.moref = moref
    def get_hardwareVersion(self): return self.hardwareVersion
    def set_hardwareVersion(self, hardwareVersion): self.hardwareVersion = hardwareVersion
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_isVAppTemplate(self): return self.isVAppTemplate
    def set_isVAppTemplate(self, isVAppTemplate): self.isVAppTemplate = isVAppTemplate
    def get_isDeleted(self): return self.isDeleted
    def set_isDeleted(self, isDeleted): self.isDeleted = isDeleted
    def get_catalogName(self): return self.catalogName
    def set_catalogName(self, catalogName): self.catalogName = catalogName
    def get_isDeployed(self): return self.isDeployed
    def set_isDeployed(self, isDeployed): self.isDeployed = isDeployed
    def get_guestOs(self): return self.guestOs
    def set_guestOs(self, guestOs): self.guestOs = guestOs
    def get_isVdcEnabled(self): return self.isVdcEnabled
    def set_isVdcEnabled(self, isVdcEnabled): self.isVdcEnabled = isVdcEnabled
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_storageProfileName(self): return self.storageProfileName
    def set_storageProfileName(self, storageProfileName): self.storageProfileName = storageProfileName
    def get_hostName(self): return self.hostName
    def set_hostName(self, hostName): self.hostName = hostName
    def get_container(self): return self.container
    def set_container(self, container): self.container = container
    def get_networkName(self): return self.networkName
    def set_networkName(self, networkName): self.networkName = networkName
    def get_containerName(self): return self.containerName
    def set_containerName(self, containerName): self.containerName = containerName
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_isPublished(self): return self.isPublished
    def set_isPublished(self, isPublished): self.isPublished = isPublished
    def get_numberOfCpus(self): return self.numberOfCpus
    def set_numberOfCpus(self, numberOfCpus): self.numberOfCpus = numberOfCpus
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def hasContent_(self):
        if (
            super(QueryResultAdminVMRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminVMRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminVMRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminVMRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminVMRecordType'):
        super(QueryResultAdminVMRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminVMRecordType')
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            outfile.write(' vc=%s' % (self.gds_format_string(quote_attrib(self.vc).encode(ExternalEncoding), input_name='vc'), ))
        if self.vmToolsVersion is not None and 'vmToolsVersion' not in already_processed:
            already_processed.add('vmToolsVersion')
            outfile.write(' vmToolsVersion="%s"' % self.gds_format_integer(self.vmToolsVersion, input_name='vmToolsVersion'))
        if self.datastoreName is not None and 'datastoreName' not in already_processed:
            already_processed.add('datastoreName')
            outfile.write(' datastoreName=%s' % (self.gds_format_string(quote_attrib(self.datastoreName).encode(ExternalEncoding), input_name='datastoreName'), ))
        if self.memoryMB is not None and 'memoryMB' not in already_processed:
            already_processed.add('memoryMB')
            outfile.write(' memoryMB="%s"' % self.gds_format_integer(self.memoryMB, input_name='memoryMB'))
        if self.moref is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            outfile.write(' moref=%s' % (self.gds_format_string(quote_attrib(self.moref).encode(ExternalEncoding), input_name='moref'), ))
        if self.hardwareVersion is not None and 'hardwareVersion' not in already_processed:
            already_processed.add('hardwareVersion')
            outfile.write(' hardwareVersion="%s"' % self.gds_format_integer(self.hardwareVersion, input_name='hardwareVersion'))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.isVAppTemplate is not None and 'isVAppTemplate' not in already_processed:
            already_processed.add('isVAppTemplate')
            outfile.write(' isVAppTemplate="%s"' % self.gds_format_boolean(self.isVAppTemplate, input_name='isVAppTemplate'))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            outfile.write(' isDeleted="%s"' % self.gds_format_boolean(self.isDeleted, input_name='isDeleted'))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            outfile.write(' catalogName=%s' % (self.gds_format_string(quote_attrib(self.catalogName).encode(ExternalEncoding), input_name='catalogName'), ))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            outfile.write(' isDeployed="%s"' % self.gds_format_boolean(self.isDeployed, input_name='isDeployed'))
        if self.guestOs is not None and 'guestOs' not in already_processed:
            already_processed.add('guestOs')
            outfile.write(' guestOs=%s' % (self.gds_format_string(quote_attrib(self.guestOs).encode(ExternalEncoding), input_name='guestOs'), ))
        if self.isVdcEnabled is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            outfile.write(' isVdcEnabled="%s"' % self.gds_format_boolean(self.isVdcEnabled, input_name='isVdcEnabled'))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            outfile.write(' storageProfileName=%s' % (self.gds_format_string(quote_attrib(self.storageProfileName).encode(ExternalEncoding), input_name='storageProfileName'), ))
        if self.hostName is not None and 'hostName' not in already_processed:
            already_processed.add('hostName')
            outfile.write(' hostName=%s' % (self.gds_format_string(quote_attrib(self.hostName).encode(ExternalEncoding), input_name='hostName'), ))
        if self.container is not None and 'container' not in already_processed:
            already_processed.add('container')
            outfile.write(' container=%s' % (self.gds_format_string(quote_attrib(self.container).encode(ExternalEncoding), input_name='container'), ))
        if self.networkName is not None and 'networkName' not in already_processed:
            already_processed.add('networkName')
            outfile.write(' networkName=%s' % (self.gds_format_string(quote_attrib(self.networkName).encode(ExternalEncoding), input_name='networkName'), ))
        if self.containerName is not None and 'containerName' not in already_processed:
            already_processed.add('containerName')
            outfile.write(' containerName=%s' % (self.gds_format_string(quote_attrib(self.containerName).encode(ExternalEncoding), input_name='containerName'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            outfile.write(' isPublished="%s"' % self.gds_format_boolean(self.isPublished, input_name='isPublished'))
        if self.numberOfCpus is not None and 'numberOfCpus' not in already_processed:
            already_processed.add('numberOfCpus')
            outfile.write(' numberOfCpus="%s"' % self.gds_format_integer(self.numberOfCpus, input_name='numberOfCpus'))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminVMRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminVMRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminVMRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            showIndent(outfile, level)
            outfile.write('vc="%s",\n' % (self.vc,))
        if self.vmToolsVersion is not None and 'vmToolsVersion' not in already_processed:
            already_processed.add('vmToolsVersion')
            showIndent(outfile, level)
            outfile.write('vmToolsVersion=%d,\n' % (self.vmToolsVersion,))
        if self.datastoreName is not None and 'datastoreName' not in already_processed:
            already_processed.add('datastoreName')
            showIndent(outfile, level)
            outfile.write('datastoreName="%s",\n' % (self.datastoreName,))
        if self.memoryMB is not None and 'memoryMB' not in already_processed:
            already_processed.add('memoryMB')
            showIndent(outfile, level)
            outfile.write('memoryMB=%d,\n' % (self.memoryMB,))
        if self.moref is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            showIndent(outfile, level)
            outfile.write('moref="%s",\n' % (self.moref,))
        if self.hardwareVersion is not None and 'hardwareVersion' not in already_processed:
            already_processed.add('hardwareVersion')
            showIndent(outfile, level)
            outfile.write('hardwareVersion=%d,\n' % (self.hardwareVersion,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.isVAppTemplate is not None and 'isVAppTemplate' not in already_processed:
            already_processed.add('isVAppTemplate')
            showIndent(outfile, level)
            outfile.write('isVAppTemplate=%s,\n' % (self.isVAppTemplate,))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            showIndent(outfile, level)
            outfile.write('isDeleted=%s,\n' % (self.isDeleted,))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            showIndent(outfile, level)
            outfile.write('catalogName="%s",\n' % (self.catalogName,))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            showIndent(outfile, level)
            outfile.write('isDeployed=%s,\n' % (self.isDeployed,))
        if self.guestOs is not None and 'guestOs' not in already_processed:
            already_processed.add('guestOs')
            showIndent(outfile, level)
            outfile.write('guestOs="%s",\n' % (self.guestOs,))
        if self.isVdcEnabled is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            showIndent(outfile, level)
            outfile.write('isVdcEnabled=%s,\n' % (self.isVdcEnabled,))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            showIndent(outfile, level)
            outfile.write('storageProfileName="%s",\n' % (self.storageProfileName,))
        if self.hostName is not None and 'hostName' not in already_processed:
            already_processed.add('hostName')
            showIndent(outfile, level)
            outfile.write('hostName="%s",\n' % (self.hostName,))
        if self.container is not None and 'container' not in already_processed:
            already_processed.add('container')
            showIndent(outfile, level)
            outfile.write('container="%s",\n' % (self.container,))
        if self.networkName is not None and 'networkName' not in already_processed:
            already_processed.add('networkName')
            showIndent(outfile, level)
            outfile.write('networkName="%s",\n' % (self.networkName,))
        if self.containerName is not None and 'containerName' not in already_processed:
            already_processed.add('containerName')
            showIndent(outfile, level)
            outfile.write('containerName="%s",\n' % (self.containerName,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            showIndent(outfile, level)
            outfile.write('isPublished=%s,\n' % (self.isPublished,))
        if self.numberOfCpus is not None and 'numberOfCpus' not in already_processed:
            already_processed.add('numberOfCpus')
            showIndent(outfile, level)
            outfile.write('numberOfCpus=%d,\n' % (self.numberOfCpus,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        super(QueryResultAdminVMRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminVMRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vc', node)
        if value is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            self.vc = value
        value = find_attr_value_('vmToolsVersion', node)
        if value is not None and 'vmToolsVersion' not in already_processed:
            already_processed.add('vmToolsVersion')
            try:
                self.vmToolsVersion = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('datastoreName', node)
        if value is not None and 'datastoreName' not in already_processed:
            already_processed.add('datastoreName')
            self.datastoreName = value
        value = find_attr_value_('memoryMB', node)
        if value is not None and 'memoryMB' not in already_processed:
            already_processed.add('memoryMB')
            try:
                self.memoryMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('moref', node)
        if value is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            self.moref = value
        value = find_attr_value_('hardwareVersion', node)
        if value is not None and 'hardwareVersion' not in already_processed:
            already_processed.add('hardwareVersion')
            try:
                self.hardwareVersion = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('isVAppTemplate', node)
        if value is not None and 'isVAppTemplate' not in already_processed:
            already_processed.add('isVAppTemplate')
            if value in ('true', '1'):
                self.isVAppTemplate = True
            elif value in ('false', '0'):
                self.isVAppTemplate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isDeleted', node)
        if value is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            if value in ('true', '1'):
                self.isDeleted = True
            elif value in ('false', '0'):
                self.isDeleted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('catalogName', node)
        if value is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            self.catalogName = value
        value = find_attr_value_('isDeployed', node)
        if value is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            if value in ('true', '1'):
                self.isDeployed = True
            elif value in ('false', '0'):
                self.isDeployed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('guestOs', node)
        if value is not None and 'guestOs' not in already_processed:
            already_processed.add('guestOs')
            self.guestOs = value
        value = find_attr_value_('isVdcEnabled', node)
        if value is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            if value in ('true', '1'):
                self.isVdcEnabled = True
            elif value in ('false', '0'):
                self.isVdcEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('storageProfileName', node)
        if value is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            self.storageProfileName = value
        value = find_attr_value_('hostName', node)
        if value is not None and 'hostName' not in already_processed:
            already_processed.add('hostName')
            self.hostName = value
        value = find_attr_value_('container', node)
        if value is not None and 'container' not in already_processed:
            already_processed.add('container')
            self.container = value
        value = find_attr_value_('networkName', node)
        if value is not None and 'networkName' not in already_processed:
            already_processed.add('networkName')
            self.networkName = value
        value = find_attr_value_('containerName', node)
        if value is not None and 'containerName' not in already_processed:
            already_processed.add('containerName')
            self.containerName = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('isPublished', node)
        if value is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            if value in ('true', '1'):
                self.isPublished = True
            elif value in ('false', '0'):
                self.isPublished = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('numberOfCpus', node)
        if value is not None and 'numberOfCpus' not in already_processed:
            already_processed.add('numberOfCpus')
            try:
                self.numberOfCpus = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        super(QueryResultAdminVMRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminVMRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminVMRecordType


class QueryResultAdminAllocatedExternalAddressRecordType(QueryResultRecordType):
    """1.55.1 Type for a single adminAllocatedExternalAddress query result
    in records format. 1.5none Network reference or id 1.5none
    Allocated IP address 1.5none Linked network reference or id
    1.5none Organization reference or id"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, org=None, ipAddress=None, network=None, linkedNetwork=None):
        self.original_tagname_ = None
        super(QueryResultAdminAllocatedExternalAddressRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.org = _cast(None, org)
        self.ipAddress = _cast(None, ipAddress)
        self.network = _cast(None, network)
        self.linkedNetwork = _cast(None, linkedNetwork)
    def factory(*args_, **kwargs_):
        if QueryResultAdminAllocatedExternalAddressRecordType.subclass:
            return QueryResultAdminAllocatedExternalAddressRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminAllocatedExternalAddressRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_ipAddress(self): return self.ipAddress
    def set_ipAddress(self, ipAddress): self.ipAddress = ipAddress
    def get_network(self): return self.network
    def set_network(self, network): self.network = network
    def get_linkedNetwork(self): return self.linkedNetwork
    def set_linkedNetwork(self, linkedNetwork): self.linkedNetwork = linkedNetwork
    def hasContent_(self):
        if (
            super(QueryResultAdminAllocatedExternalAddressRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminAllocatedExternalAddressRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminAllocatedExternalAddressRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminAllocatedExternalAddressRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminAllocatedExternalAddressRecordType'):
        super(QueryResultAdminAllocatedExternalAddressRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminAllocatedExternalAddressRecordType')
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.ipAddress is not None and 'ipAddress' not in already_processed:
            already_processed.add('ipAddress')
            outfile.write(' ipAddress=%s' % (self.gds_format_string(quote_attrib(self.ipAddress).encode(ExternalEncoding), input_name='ipAddress'), ))
        if self.network is not None and 'network' not in already_processed:
            already_processed.add('network')
            outfile.write(' network=%s' % (self.gds_format_string(quote_attrib(self.network).encode(ExternalEncoding), input_name='network'), ))
        if self.linkedNetwork is not None and 'linkedNetwork' not in already_processed:
            already_processed.add('linkedNetwork')
            outfile.write(' linkedNetwork=%s' % (self.gds_format_string(quote_attrib(self.linkedNetwork).encode(ExternalEncoding), input_name='linkedNetwork'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminAllocatedExternalAddressRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminAllocatedExternalAddressRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminAllocatedExternalAddressRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.ipAddress is not None and 'ipAddress' not in already_processed:
            already_processed.add('ipAddress')
            showIndent(outfile, level)
            outfile.write('ipAddress="%s",\n' % (self.ipAddress,))
        if self.network is not None and 'network' not in already_processed:
            already_processed.add('network')
            showIndent(outfile, level)
            outfile.write('network="%s",\n' % (self.network,))
        if self.linkedNetwork is not None and 'linkedNetwork' not in already_processed:
            already_processed.add('linkedNetwork')
            showIndent(outfile, level)
            outfile.write('linkedNetwork="%s",\n' % (self.linkedNetwork,))
        super(QueryResultAdminAllocatedExternalAddressRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminAllocatedExternalAddressRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('ipAddress', node)
        if value is not None and 'ipAddress' not in already_processed:
            already_processed.add('ipAddress')
            self.ipAddress = value
        value = find_attr_value_('network', node)
        if value is not None and 'network' not in already_processed:
            already_processed.add('network')
            self.network = value
        value = find_attr_value_('linkedNetwork', node)
        if value is not None and 'linkedNetwork' not in already_processed:
            already_processed.add('linkedNetwork')
            self.linkedNetwork = value
        super(QueryResultAdminAllocatedExternalAddressRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminAllocatedExternalAddressRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminAllocatedExternalAddressRecordType


class QueryResultVAppOrgNetworkRelationRecordType(QueryResultRecordType):
    """1.55.1 Type for a single vAppOrgNetworkRelation query result in
    records format. 1.5none Entity name 1.5none Organization
    reference or id 1.5none Network reference or id 1.5none Network
    name 1.5none Configuration Type 1.5none Status 1.5none Owner
    name"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, orgNetworkName=None, name=None, orgNetwork=None, ownerName=None, configurationType=None, org=None):
        self.original_tagname_ = None
        super(QueryResultVAppOrgNetworkRelationRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        self.orgNetworkName = _cast(None, orgNetworkName)
        self.name = _cast(None, name)
        self.orgNetwork = _cast(None, orgNetwork)
        self.ownerName = _cast(None, ownerName)
        self.configurationType = _cast(None, configurationType)
        self.org = _cast(None, org)
    def factory(*args_, **kwargs_):
        if QueryResultVAppOrgNetworkRelationRecordType.subclass:
            return QueryResultVAppOrgNetworkRelationRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultVAppOrgNetworkRelationRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_orgNetworkName(self): return self.orgNetworkName
    def set_orgNetworkName(self, orgNetworkName): self.orgNetworkName = orgNetworkName
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_orgNetwork(self): return self.orgNetwork
    def set_orgNetwork(self, orgNetwork): self.orgNetwork = orgNetwork
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_configurationType(self): return self.configurationType
    def set_configurationType(self, configurationType): self.configurationType = configurationType
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def hasContent_(self):
        if (
            super(QueryResultVAppOrgNetworkRelationRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultVAppOrgNetworkRelationRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVAppOrgNetworkRelationRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultVAppOrgNetworkRelationRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultVAppOrgNetworkRelationRecordType'):
        super(QueryResultVAppOrgNetworkRelationRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVAppOrgNetworkRelationRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.orgNetworkName is not None and 'orgNetworkName' not in already_processed:
            already_processed.add('orgNetworkName')
            outfile.write(' orgNetworkName=%s' % (self.gds_format_string(quote_attrib(self.orgNetworkName).encode(ExternalEncoding), input_name='orgNetworkName'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.orgNetwork is not None and 'orgNetwork' not in already_processed:
            already_processed.add('orgNetwork')
            outfile.write(' orgNetwork=%s' % (self.gds_format_string(quote_attrib(self.orgNetwork).encode(ExternalEncoding), input_name='orgNetwork'), ))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.configurationType is not None and 'configurationType' not in already_processed:
            already_processed.add('configurationType')
            outfile.write(' configurationType=%s' % (self.gds_format_string(quote_attrib(self.configurationType).encode(ExternalEncoding), input_name='configurationType'), ))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultVAppOrgNetworkRelationRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultVAppOrgNetworkRelationRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultVAppOrgNetworkRelationRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.orgNetworkName is not None and 'orgNetworkName' not in already_processed:
            already_processed.add('orgNetworkName')
            showIndent(outfile, level)
            outfile.write('orgNetworkName="%s",\n' % (self.orgNetworkName,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.orgNetwork is not None and 'orgNetwork' not in already_processed:
            already_processed.add('orgNetwork')
            showIndent(outfile, level)
            outfile.write('orgNetwork="%s",\n' % (self.orgNetwork,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.configurationType is not None and 'configurationType' not in already_processed:
            already_processed.add('configurationType')
            showIndent(outfile, level)
            outfile.write('configurationType="%s",\n' % (self.configurationType,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        super(QueryResultVAppOrgNetworkRelationRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultVAppOrgNetworkRelationRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('orgNetworkName', node)
        if value is not None and 'orgNetworkName' not in already_processed:
            already_processed.add('orgNetworkName')
            self.orgNetworkName = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('orgNetwork', node)
        if value is not None and 'orgNetwork' not in already_processed:
            already_processed.add('orgNetwork')
            self.orgNetwork = value
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('configurationType', node)
        if value is not None and 'configurationType' not in already_processed:
            already_processed.add('configurationType')
            self.configurationType = value
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        super(QueryResultVAppOrgNetworkRelationRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultVAppOrgNetworkRelationRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultVAppOrgNetworkRelationRecordType


class QueryResultOrgVdcResourcePoolRelationRecordType(QueryResultRecordType):
    """1.5 Type for a single orgVdcResourcePoolRelation query result in
    records format. 1.5none VDC reference or id 1.5none Virtual
    center reference or id 1.5none Resource pool managed object
    reference"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, vdc=None, vc=None, resourcePoolMoref=None):
        self.original_tagname_ = None
        super(QueryResultOrgVdcResourcePoolRelationRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.vdc = _cast(None, vdc)
        self.vc = _cast(None, vc)
        self.resourcePoolMoref = _cast(None, resourcePoolMoref)
    def factory(*args_, **kwargs_):
        if QueryResultOrgVdcResourcePoolRelationRecordType.subclass:
            return QueryResultOrgVdcResourcePoolRelationRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultOrgVdcResourcePoolRelationRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_vc(self): return self.vc
    def set_vc(self, vc): self.vc = vc
    def get_resourcePoolMoref(self): return self.resourcePoolMoref
    def set_resourcePoolMoref(self, resourcePoolMoref): self.resourcePoolMoref = resourcePoolMoref
    def hasContent_(self):
        if (
            super(QueryResultOrgVdcResourcePoolRelationRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultOrgVdcResourcePoolRelationRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultOrgVdcResourcePoolRelationRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultOrgVdcResourcePoolRelationRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultOrgVdcResourcePoolRelationRecordType'):
        super(QueryResultOrgVdcResourcePoolRelationRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultOrgVdcResourcePoolRelationRecordType')
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            outfile.write(' vc=%s' % (self.gds_format_string(quote_attrib(self.vc).encode(ExternalEncoding), input_name='vc'), ))
        if self.resourcePoolMoref is not None and 'resourcePoolMoref' not in already_processed:
            already_processed.add('resourcePoolMoref')
            outfile.write(' resourcePoolMoref=%s' % (self.gds_format_string(quote_attrib(self.resourcePoolMoref).encode(ExternalEncoding), input_name='resourcePoolMoref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultOrgVdcResourcePoolRelationRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultOrgVdcResourcePoolRelationRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultOrgVdcResourcePoolRelationRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            showIndent(outfile, level)
            outfile.write('vc="%s",\n' % (self.vc,))
        if self.resourcePoolMoref is not None and 'resourcePoolMoref' not in already_processed:
            already_processed.add('resourcePoolMoref')
            showIndent(outfile, level)
            outfile.write('resourcePoolMoref="%s",\n' % (self.resourcePoolMoref,))
        super(QueryResultOrgVdcResourcePoolRelationRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultOrgVdcResourcePoolRelationRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('vc', node)
        if value is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            self.vc = value
        value = find_attr_value_('resourcePoolMoref', node)
        if value is not None and 'resourcePoolMoref' not in already_processed:
            already_processed.add('resourcePoolMoref')
            self.resourcePoolMoref = value
        super(QueryResultOrgVdcResourcePoolRelationRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultOrgVdcResourcePoolRelationRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultOrgVdcResourcePoolRelationRecordType


class QueryResultProviderVdcResourcePoolRelationRecordType(QueryResultRecordType):
    """1.5 Type for a single providerVdcResourcePoolRelation query result
    in records format. 1.5none The name of this resource pool.
    1.5none Resource pool managed object reference 1.5none CPU
    reservation limit in Mhz 1.5none CPU reservation allocation in
    Mhz 1.5none True if this entity is enabled 1.5none Memory
    reservation limit in MB 1.5none Memory reservation allocation in
    MB 1.5none True if this is the primary resource pool for this
    Provider VDC. 1.5none Provider VDC reference or id 1.5none
    Virtual center reference or id 1.5none Vitual center name
    1.5none Number of VMs"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, vc=None, resourcePoolMoref=None, name=None, cpuReservationLimitMhz=None, providerVdc=None, numberOfVMs=None, isEnabled=None, cpuReservationAllocationMhz=None, memoryReservationLimitMB=None, memoryReservationAllocationMB=None, isPrimary=None, vcName=None):
        self.original_tagname_ = None
        super(QueryResultProviderVdcResourcePoolRelationRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.vc = _cast(None, vc)
        self.resourcePoolMoref = _cast(None, resourcePoolMoref)
        self.name = _cast(None, name)
        self.cpuReservationLimitMhz = _cast(int, cpuReservationLimitMhz)
        self.providerVdc = _cast(None, providerVdc)
        self.numberOfVMs = _cast(int, numberOfVMs)
        self.isEnabled = _cast(bool, isEnabled)
        self.cpuReservationAllocationMhz = _cast(int, cpuReservationAllocationMhz)
        self.memoryReservationLimitMB = _cast(int, memoryReservationLimitMB)
        self.memoryReservationAllocationMB = _cast(int, memoryReservationAllocationMB)
        self.isPrimary = _cast(bool, isPrimary)
        self.vcName = _cast(None, vcName)
    def factory(*args_, **kwargs_):
        if QueryResultProviderVdcResourcePoolRelationRecordType.subclass:
            return QueryResultProviderVdcResourcePoolRelationRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultProviderVdcResourcePoolRelationRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vc(self): return self.vc
    def set_vc(self, vc): self.vc = vc
    def get_resourcePoolMoref(self): return self.resourcePoolMoref
    def set_resourcePoolMoref(self, resourcePoolMoref): self.resourcePoolMoref = resourcePoolMoref
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_cpuReservationLimitMhz(self): return self.cpuReservationLimitMhz
    def set_cpuReservationLimitMhz(self, cpuReservationLimitMhz): self.cpuReservationLimitMhz = cpuReservationLimitMhz
    def get_providerVdc(self): return self.providerVdc
    def set_providerVdc(self, providerVdc): self.providerVdc = providerVdc
    def get_numberOfVMs(self): return self.numberOfVMs
    def set_numberOfVMs(self, numberOfVMs): self.numberOfVMs = numberOfVMs
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_cpuReservationAllocationMhz(self): return self.cpuReservationAllocationMhz
    def set_cpuReservationAllocationMhz(self, cpuReservationAllocationMhz): self.cpuReservationAllocationMhz = cpuReservationAllocationMhz
    def get_memoryReservationLimitMB(self): return self.memoryReservationLimitMB
    def set_memoryReservationLimitMB(self, memoryReservationLimitMB): self.memoryReservationLimitMB = memoryReservationLimitMB
    def get_memoryReservationAllocationMB(self): return self.memoryReservationAllocationMB
    def set_memoryReservationAllocationMB(self, memoryReservationAllocationMB): self.memoryReservationAllocationMB = memoryReservationAllocationMB
    def get_isPrimary(self): return self.isPrimary
    def set_isPrimary(self, isPrimary): self.isPrimary = isPrimary
    def get_vcName(self): return self.vcName
    def set_vcName(self, vcName): self.vcName = vcName
    def hasContent_(self):
        if (
            super(QueryResultProviderVdcResourcePoolRelationRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultProviderVdcResourcePoolRelationRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultProviderVdcResourcePoolRelationRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultProviderVdcResourcePoolRelationRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultProviderVdcResourcePoolRelationRecordType'):
        super(QueryResultProviderVdcResourcePoolRelationRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultProviderVdcResourcePoolRelationRecordType')
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            outfile.write(' vc=%s' % (self.gds_format_string(quote_attrib(self.vc).encode(ExternalEncoding), input_name='vc'), ))
        if self.resourcePoolMoref is not None and 'resourcePoolMoref' not in already_processed:
            already_processed.add('resourcePoolMoref')
            outfile.write(' resourcePoolMoref=%s' % (self.gds_format_string(quote_attrib(self.resourcePoolMoref).encode(ExternalEncoding), input_name='resourcePoolMoref'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.cpuReservationLimitMhz is not None and 'cpuReservationLimitMhz' not in already_processed:
            already_processed.add('cpuReservationLimitMhz')
            outfile.write(' cpuReservationLimitMhz="%s"' % self.gds_format_integer(self.cpuReservationLimitMhz, input_name='cpuReservationLimitMhz'))
        if self.providerVdc is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            outfile.write(' providerVdc=%s' % (self.gds_format_string(quote_attrib(self.providerVdc).encode(ExternalEncoding), input_name='providerVdc'), ))
        if self.numberOfVMs is not None and 'numberOfVMs' not in already_processed:
            already_processed.add('numberOfVMs')
            outfile.write(' numberOfVMs="%s"' % self.gds_format_integer(self.numberOfVMs, input_name='numberOfVMs'))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.cpuReservationAllocationMhz is not None and 'cpuReservationAllocationMhz' not in already_processed:
            already_processed.add('cpuReservationAllocationMhz')
            outfile.write(' cpuReservationAllocationMhz="%s"' % self.gds_format_integer(self.cpuReservationAllocationMhz, input_name='cpuReservationAllocationMhz'))
        if self.memoryReservationLimitMB is not None and 'memoryReservationLimitMB' not in already_processed:
            already_processed.add('memoryReservationLimitMB')
            outfile.write(' memoryReservationLimitMB="%s"' % self.gds_format_integer(self.memoryReservationLimitMB, input_name='memoryReservationLimitMB'))
        if self.memoryReservationAllocationMB is not None and 'memoryReservationAllocationMB' not in already_processed:
            already_processed.add('memoryReservationAllocationMB')
            outfile.write(' memoryReservationAllocationMB="%s"' % self.gds_format_integer(self.memoryReservationAllocationMB, input_name='memoryReservationAllocationMB'))
        if self.isPrimary is not None and 'isPrimary' not in already_processed:
            already_processed.add('isPrimary')
            outfile.write(' isPrimary="%s"' % self.gds_format_boolean(self.isPrimary, input_name='isPrimary'))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            outfile.write(' vcName=%s' % (self.gds_format_string(quote_attrib(self.vcName).encode(ExternalEncoding), input_name='vcName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultProviderVdcResourcePoolRelationRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultProviderVdcResourcePoolRelationRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultProviderVdcResourcePoolRelationRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            showIndent(outfile, level)
            outfile.write('vc="%s",\n' % (self.vc,))
        if self.resourcePoolMoref is not None and 'resourcePoolMoref' not in already_processed:
            already_processed.add('resourcePoolMoref')
            showIndent(outfile, level)
            outfile.write('resourcePoolMoref="%s",\n' % (self.resourcePoolMoref,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.cpuReservationLimitMhz is not None and 'cpuReservationLimitMhz' not in already_processed:
            already_processed.add('cpuReservationLimitMhz')
            showIndent(outfile, level)
            outfile.write('cpuReservationLimitMhz=%d,\n' % (self.cpuReservationLimitMhz,))
        if self.providerVdc is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            showIndent(outfile, level)
            outfile.write('providerVdc="%s",\n' % (self.providerVdc,))
        if self.numberOfVMs is not None and 'numberOfVMs' not in already_processed:
            already_processed.add('numberOfVMs')
            showIndent(outfile, level)
            outfile.write('numberOfVMs=%d,\n' % (self.numberOfVMs,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.cpuReservationAllocationMhz is not None and 'cpuReservationAllocationMhz' not in already_processed:
            already_processed.add('cpuReservationAllocationMhz')
            showIndent(outfile, level)
            outfile.write('cpuReservationAllocationMhz=%d,\n' % (self.cpuReservationAllocationMhz,))
        if self.memoryReservationLimitMB is not None and 'memoryReservationLimitMB' not in already_processed:
            already_processed.add('memoryReservationLimitMB')
            showIndent(outfile, level)
            outfile.write('memoryReservationLimitMB=%d,\n' % (self.memoryReservationLimitMB,))
        if self.memoryReservationAllocationMB is not None and 'memoryReservationAllocationMB' not in already_processed:
            already_processed.add('memoryReservationAllocationMB')
            showIndent(outfile, level)
            outfile.write('memoryReservationAllocationMB=%d,\n' % (self.memoryReservationAllocationMB,))
        if self.isPrimary is not None and 'isPrimary' not in already_processed:
            already_processed.add('isPrimary')
            showIndent(outfile, level)
            outfile.write('isPrimary=%s,\n' % (self.isPrimary,))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            showIndent(outfile, level)
            outfile.write('vcName="%s",\n' % (self.vcName,))
        super(QueryResultProviderVdcResourcePoolRelationRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultProviderVdcResourcePoolRelationRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vc', node)
        if value is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            self.vc = value
        value = find_attr_value_('resourcePoolMoref', node)
        if value is not None and 'resourcePoolMoref' not in already_processed:
            already_processed.add('resourcePoolMoref')
            self.resourcePoolMoref = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('cpuReservationLimitMhz', node)
        if value is not None and 'cpuReservationLimitMhz' not in already_processed:
            already_processed.add('cpuReservationLimitMhz')
            try:
                self.cpuReservationLimitMhz = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('providerVdc', node)
        if value is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            self.providerVdc = value
        value = find_attr_value_('numberOfVMs', node)
        if value is not None and 'numberOfVMs' not in already_processed:
            already_processed.add('numberOfVMs')
            try:
                self.numberOfVMs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('cpuReservationAllocationMhz', node)
        if value is not None and 'cpuReservationAllocationMhz' not in already_processed:
            already_processed.add('cpuReservationAllocationMhz')
            try:
                self.cpuReservationAllocationMhz = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('memoryReservationLimitMB', node)
        if value is not None and 'memoryReservationLimitMB' not in already_processed:
            already_processed.add('memoryReservationLimitMB')
            try:
                self.memoryReservationLimitMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('memoryReservationAllocationMB', node)
        if value is not None and 'memoryReservationAllocationMB' not in already_processed:
            already_processed.add('memoryReservationAllocationMB')
            try:
                self.memoryReservationAllocationMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isPrimary', node)
        if value is not None and 'isPrimary' not in already_processed:
            already_processed.add('isPrimary')
            if value in ('true', '1'):
                self.isPrimary = True
            elif value in ('false', '0'):
                self.isPrimary = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vcName', node)
        if value is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            self.vcName = value
        super(QueryResultProviderVdcResourcePoolRelationRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultProviderVdcResourcePoolRelationRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultProviderVdcResourcePoolRelationRecordType


class QueryResultDatastoreProviderVdcRelationRecordType(QueryResultRecordType):
    """1.5 Type for a single datastoreProviderVdcRelation query result in
    records format. 1.5none The name of this datastore. 1.5none
    Datastore type 1.5none True if this entity is enabled 1.5none
    True if this entity is deleted 1.5none Storage used in MB
    1.5none Storage in MB 1.5none Provisioned storage in MB 1.5none
    Requested storage in MB 1.5none Virtual center reference or id
    1.5none Vitual center name 1.5none Managed object reference
    1.5none Provider VDC reference or id 1.5none Datastore reference
    or id"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, vc=None, storageUsedMB=None, name=None, providerVdc=None, isEnabled=None, requestedStorageMB=None, storageMB=None, moref=None, vcName=None, datastoreType=None, provisionedStorageMB=None, datastore=None, isDeleted=None):
        self.original_tagname_ = None
        super(QueryResultDatastoreProviderVdcRelationRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.vc = _cast(None, vc)
        self.storageUsedMB = _cast(float, storageUsedMB)
        self.name = _cast(None, name)
        self.providerVdc = _cast(None, providerVdc)
        self.isEnabled = _cast(bool, isEnabled)
        self.requestedStorageMB = _cast(float, requestedStorageMB)
        self.storageMB = _cast(float, storageMB)
        self.moref = _cast(None, moref)
        self.vcName = _cast(None, vcName)
        self.datastoreType = _cast(None, datastoreType)
        self.provisionedStorageMB = _cast(float, provisionedStorageMB)
        self.datastore = _cast(None, datastore)
        self.isDeleted = _cast(bool, isDeleted)
    def factory(*args_, **kwargs_):
        if QueryResultDatastoreProviderVdcRelationRecordType.subclass:
            return QueryResultDatastoreProviderVdcRelationRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultDatastoreProviderVdcRelationRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vc(self): return self.vc
    def set_vc(self, vc): self.vc = vc
    def get_storageUsedMB(self): return self.storageUsedMB
    def set_storageUsedMB(self, storageUsedMB): self.storageUsedMB = storageUsedMB
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_providerVdc(self): return self.providerVdc
    def set_providerVdc(self, providerVdc): self.providerVdc = providerVdc
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_requestedStorageMB(self): return self.requestedStorageMB
    def set_requestedStorageMB(self, requestedStorageMB): self.requestedStorageMB = requestedStorageMB
    def get_storageMB(self): return self.storageMB
    def set_storageMB(self, storageMB): self.storageMB = storageMB
    def get_moref(self): return self.moref
    def set_moref(self, moref): self.moref = moref
    def get_vcName(self): return self.vcName
    def set_vcName(self, vcName): self.vcName = vcName
    def get_datastoreType(self): return self.datastoreType
    def set_datastoreType(self, datastoreType): self.datastoreType = datastoreType
    def get_provisionedStorageMB(self): return self.provisionedStorageMB
    def set_provisionedStorageMB(self, provisionedStorageMB): self.provisionedStorageMB = provisionedStorageMB
    def get_datastore(self): return self.datastore
    def set_datastore(self, datastore): self.datastore = datastore
    def get_isDeleted(self): return self.isDeleted
    def set_isDeleted(self, isDeleted): self.isDeleted = isDeleted
    def hasContent_(self):
        if (
            super(QueryResultDatastoreProviderVdcRelationRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultDatastoreProviderVdcRelationRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultDatastoreProviderVdcRelationRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultDatastoreProviderVdcRelationRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultDatastoreProviderVdcRelationRecordType'):
        super(QueryResultDatastoreProviderVdcRelationRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultDatastoreProviderVdcRelationRecordType')
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            outfile.write(' vc=%s' % (self.gds_format_string(quote_attrib(self.vc).encode(ExternalEncoding), input_name='vc'), ))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            outfile.write(' storageUsedMB="%s"' % self.gds_format_float(self.storageUsedMB, input_name='storageUsedMB'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.providerVdc is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            outfile.write(' providerVdc=%s' % (self.gds_format_string(quote_attrib(self.providerVdc).encode(ExternalEncoding), input_name='providerVdc'), ))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.requestedStorageMB is not None and 'requestedStorageMB' not in already_processed:
            already_processed.add('requestedStorageMB')
            outfile.write(' requestedStorageMB="%s"' % self.gds_format_float(self.requestedStorageMB, input_name='requestedStorageMB'))
        if self.storageMB is not None and 'storageMB' not in already_processed:
            already_processed.add('storageMB')
            outfile.write(' storageMB="%s"' % self.gds_format_float(self.storageMB, input_name='storageMB'))
        if self.moref is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            outfile.write(' moref=%s' % (self.gds_format_string(quote_attrib(self.moref).encode(ExternalEncoding), input_name='moref'), ))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            outfile.write(' vcName=%s' % (self.gds_format_string(quote_attrib(self.vcName).encode(ExternalEncoding), input_name='vcName'), ))
        if self.datastoreType is not None and 'datastoreType' not in already_processed:
            already_processed.add('datastoreType')
            outfile.write(' datastoreType=%s' % (self.gds_format_string(quote_attrib(self.datastoreType).encode(ExternalEncoding), input_name='datastoreType'), ))
        if self.provisionedStorageMB is not None and 'provisionedStorageMB' not in already_processed:
            already_processed.add('provisionedStorageMB')
            outfile.write(' provisionedStorageMB="%s"' % self.gds_format_float(self.provisionedStorageMB, input_name='provisionedStorageMB'))
        if self.datastore is not None and 'datastore' not in already_processed:
            already_processed.add('datastore')
            outfile.write(' datastore=%s' % (self.gds_format_string(quote_attrib(self.datastore).encode(ExternalEncoding), input_name='datastore'), ))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            outfile.write(' isDeleted="%s"' % self.gds_format_boolean(self.isDeleted, input_name='isDeleted'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultDatastoreProviderVdcRelationRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultDatastoreProviderVdcRelationRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultDatastoreProviderVdcRelationRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            showIndent(outfile, level)
            outfile.write('vc="%s",\n' % (self.vc,))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            showIndent(outfile, level)
            outfile.write('storageUsedMB=%f,\n' % (self.storageUsedMB,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.providerVdc is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            showIndent(outfile, level)
            outfile.write('providerVdc="%s",\n' % (self.providerVdc,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.requestedStorageMB is not None and 'requestedStorageMB' not in already_processed:
            already_processed.add('requestedStorageMB')
            showIndent(outfile, level)
            outfile.write('requestedStorageMB=%f,\n' % (self.requestedStorageMB,))
        if self.storageMB is not None and 'storageMB' not in already_processed:
            already_processed.add('storageMB')
            showIndent(outfile, level)
            outfile.write('storageMB=%f,\n' % (self.storageMB,))
        if self.moref is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            showIndent(outfile, level)
            outfile.write('moref="%s",\n' % (self.moref,))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            showIndent(outfile, level)
            outfile.write('vcName="%s",\n' % (self.vcName,))
        if self.datastoreType is not None and 'datastoreType' not in already_processed:
            already_processed.add('datastoreType')
            showIndent(outfile, level)
            outfile.write('datastoreType="%s",\n' % (self.datastoreType,))
        if self.provisionedStorageMB is not None and 'provisionedStorageMB' not in already_processed:
            already_processed.add('provisionedStorageMB')
            showIndent(outfile, level)
            outfile.write('provisionedStorageMB=%f,\n' % (self.provisionedStorageMB,))
        if self.datastore is not None and 'datastore' not in already_processed:
            already_processed.add('datastore')
            showIndent(outfile, level)
            outfile.write('datastore="%s",\n' % (self.datastore,))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            showIndent(outfile, level)
            outfile.write('isDeleted=%s,\n' % (self.isDeleted,))
        super(QueryResultDatastoreProviderVdcRelationRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultDatastoreProviderVdcRelationRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vc', node)
        if value is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            self.vc = value
        value = find_attr_value_('storageUsedMB', node)
        if value is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            try:
                self.storageUsedMB = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (storageUsedMB): %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('providerVdc', node)
        if value is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            self.providerVdc = value
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('requestedStorageMB', node)
        if value is not None and 'requestedStorageMB' not in already_processed:
            already_processed.add('requestedStorageMB')
            try:
                self.requestedStorageMB = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (requestedStorageMB): %s' % exp)
        value = find_attr_value_('storageMB', node)
        if value is not None and 'storageMB' not in already_processed:
            already_processed.add('storageMB')
            try:
                self.storageMB = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (storageMB): %s' % exp)
        value = find_attr_value_('moref', node)
        if value is not None and 'moref' not in already_processed:
            already_processed.add('moref')
            self.moref = value
        value = find_attr_value_('vcName', node)
        if value is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            self.vcName = value
        value = find_attr_value_('datastoreType', node)
        if value is not None and 'datastoreType' not in already_processed:
            already_processed.add('datastoreType')
            self.datastoreType = value
        value = find_attr_value_('provisionedStorageMB', node)
        if value is not None and 'provisionedStorageMB' not in already_processed:
            already_processed.add('provisionedStorageMB')
            try:
                self.provisionedStorageMB = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (provisionedStorageMB): %s' % exp)
        value = find_attr_value_('datastore', node)
        if value is not None and 'datastore' not in already_processed:
            already_processed.add('datastore')
            self.datastore = value
        value = find_attr_value_('isDeleted', node)
        if value is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            if value in ('true', '1'):
                self.isDeleted = True
            elif value in ('false', '0'):
                self.isDeleted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(QueryResultDatastoreProviderVdcRelationRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultDatastoreProviderVdcRelationRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultDatastoreProviderVdcRelationRecordType


class QueryResultAdminUserRecordType(QueryResultRecordType):
    """1.5 Type for a single adminUser query result in records format.
    1.5none The name of this user. 1.5none Organization reference or
    id 1.5none The full name of this user. 1.5none True if this
    entity is enabled 1.5none Number of deployed VMs 1.5none
    Deployed VM quota 1.5none Number of stored VMs 1.5none Stored VM
    Quota 1.5none If the identity provider type is INTEGRATED, shows
    whether the user was imported from LDAP 1.5none Deployed VM
    quota rank 1.5none Stored VM Quota rank 5.1none Shows the
    identity provider type of the user"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, isLdapUser=None, deployedVMQuotaRank=None, name=None, isEnabled=None, deployedVMQuota=None, identityProviderType=None, storedVMQuota=None, numberOfStoredVMs=None, storedVMQuotaRank=None, numberOfDeployedVMs=None, org=None, fullName=None):
        self.original_tagname_ = None
        super(QueryResultAdminUserRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.isLdapUser = _cast(bool, isLdapUser)
        self.deployedVMQuotaRank = _cast(int, deployedVMQuotaRank)
        self.name = _cast(None, name)
        self.isEnabled = _cast(bool, isEnabled)
        self.deployedVMQuota = _cast(int, deployedVMQuota)
        self.identityProviderType = _cast(None, identityProviderType)
        self.storedVMQuota = _cast(int, storedVMQuota)
        self.numberOfStoredVMs = _cast(int, numberOfStoredVMs)
        self.storedVMQuotaRank = _cast(int, storedVMQuotaRank)
        self.numberOfDeployedVMs = _cast(int, numberOfDeployedVMs)
        self.org = _cast(None, org)
        self.fullName = _cast(None, fullName)
    def factory(*args_, **kwargs_):
        if QueryResultAdminUserRecordType.subclass:
            return QueryResultAdminUserRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminUserRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isLdapUser(self): return self.isLdapUser
    def set_isLdapUser(self, isLdapUser): self.isLdapUser = isLdapUser
    def get_deployedVMQuotaRank(self): return self.deployedVMQuotaRank
    def set_deployedVMQuotaRank(self, deployedVMQuotaRank): self.deployedVMQuotaRank = deployedVMQuotaRank
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_deployedVMQuota(self): return self.deployedVMQuota
    def set_deployedVMQuota(self, deployedVMQuota): self.deployedVMQuota = deployedVMQuota
    def get_identityProviderType(self): return self.identityProviderType
    def set_identityProviderType(self, identityProviderType): self.identityProviderType = identityProviderType
    def get_storedVMQuota(self): return self.storedVMQuota
    def set_storedVMQuota(self, storedVMQuota): self.storedVMQuota = storedVMQuota
    def get_numberOfStoredVMs(self): return self.numberOfStoredVMs
    def set_numberOfStoredVMs(self, numberOfStoredVMs): self.numberOfStoredVMs = numberOfStoredVMs
    def get_storedVMQuotaRank(self): return self.storedVMQuotaRank
    def set_storedVMQuotaRank(self, storedVMQuotaRank): self.storedVMQuotaRank = storedVMQuotaRank
    def get_numberOfDeployedVMs(self): return self.numberOfDeployedVMs
    def set_numberOfDeployedVMs(self, numberOfDeployedVMs): self.numberOfDeployedVMs = numberOfDeployedVMs
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_fullName(self): return self.fullName
    def set_fullName(self, fullName): self.fullName = fullName
    def hasContent_(self):
        if (
            super(QueryResultAdminUserRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminUserRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminUserRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminUserRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminUserRecordType'):
        super(QueryResultAdminUserRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminUserRecordType')
        if self.isLdapUser is not None and 'isLdapUser' not in already_processed:
            already_processed.add('isLdapUser')
            outfile.write(' isLdapUser="%s"' % self.gds_format_boolean(self.isLdapUser, input_name='isLdapUser'))
        if self.deployedVMQuotaRank is not None and 'deployedVMQuotaRank' not in already_processed:
            already_processed.add('deployedVMQuotaRank')
            outfile.write(' deployedVMQuotaRank="%s"' % self.gds_format_integer(self.deployedVMQuotaRank, input_name='deployedVMQuotaRank'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.deployedVMQuota is not None and 'deployedVMQuota' not in already_processed:
            already_processed.add('deployedVMQuota')
            outfile.write(' deployedVMQuota="%s"' % self.gds_format_integer(self.deployedVMQuota, input_name='deployedVMQuota'))
        if self.identityProviderType is not None and 'identityProviderType' not in already_processed:
            already_processed.add('identityProviderType')
            outfile.write(' identityProviderType=%s' % (self.gds_format_string(quote_attrib(self.identityProviderType).encode(ExternalEncoding), input_name='identityProviderType'), ))
        if self.storedVMQuota is not None and 'storedVMQuota' not in already_processed:
            already_processed.add('storedVMQuota')
            outfile.write(' storedVMQuota="%s"' % self.gds_format_integer(self.storedVMQuota, input_name='storedVMQuota'))
        if self.numberOfStoredVMs is not None and 'numberOfStoredVMs' not in already_processed:
            already_processed.add('numberOfStoredVMs')
            outfile.write(' numberOfStoredVMs="%s"' % self.gds_format_integer(self.numberOfStoredVMs, input_name='numberOfStoredVMs'))
        if self.storedVMQuotaRank is not None and 'storedVMQuotaRank' not in already_processed:
            already_processed.add('storedVMQuotaRank')
            outfile.write(' storedVMQuotaRank="%s"' % self.gds_format_integer(self.storedVMQuotaRank, input_name='storedVMQuotaRank'))
        if self.numberOfDeployedVMs is not None and 'numberOfDeployedVMs' not in already_processed:
            already_processed.add('numberOfDeployedVMs')
            outfile.write(' numberOfDeployedVMs="%s"' % self.gds_format_integer(self.numberOfDeployedVMs, input_name='numberOfDeployedVMs'))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.fullName is not None and 'fullName' not in already_processed:
            already_processed.add('fullName')
            outfile.write(' fullName=%s' % (self.gds_format_string(quote_attrib(self.fullName).encode(ExternalEncoding), input_name='fullName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminUserRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminUserRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminUserRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isLdapUser is not None and 'isLdapUser' not in already_processed:
            already_processed.add('isLdapUser')
            showIndent(outfile, level)
            outfile.write('isLdapUser=%s,\n' % (self.isLdapUser,))
        if self.deployedVMQuotaRank is not None and 'deployedVMQuotaRank' not in already_processed:
            already_processed.add('deployedVMQuotaRank')
            showIndent(outfile, level)
            outfile.write('deployedVMQuotaRank=%d,\n' % (self.deployedVMQuotaRank,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.deployedVMQuota is not None and 'deployedVMQuota' not in already_processed:
            already_processed.add('deployedVMQuota')
            showIndent(outfile, level)
            outfile.write('deployedVMQuota=%d,\n' % (self.deployedVMQuota,))
        if self.identityProviderType is not None and 'identityProviderType' not in already_processed:
            already_processed.add('identityProviderType')
            showIndent(outfile, level)
            outfile.write('identityProviderType="%s",\n' % (self.identityProviderType,))
        if self.storedVMQuota is not None and 'storedVMQuota' not in already_processed:
            already_processed.add('storedVMQuota')
            showIndent(outfile, level)
            outfile.write('storedVMQuota=%d,\n' % (self.storedVMQuota,))
        if self.numberOfStoredVMs is not None and 'numberOfStoredVMs' not in already_processed:
            already_processed.add('numberOfStoredVMs')
            showIndent(outfile, level)
            outfile.write('numberOfStoredVMs=%d,\n' % (self.numberOfStoredVMs,))
        if self.storedVMQuotaRank is not None and 'storedVMQuotaRank' not in already_processed:
            already_processed.add('storedVMQuotaRank')
            showIndent(outfile, level)
            outfile.write('storedVMQuotaRank=%d,\n' % (self.storedVMQuotaRank,))
        if self.numberOfDeployedVMs is not None and 'numberOfDeployedVMs' not in already_processed:
            already_processed.add('numberOfDeployedVMs')
            showIndent(outfile, level)
            outfile.write('numberOfDeployedVMs=%d,\n' % (self.numberOfDeployedVMs,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.fullName is not None and 'fullName' not in already_processed:
            already_processed.add('fullName')
            showIndent(outfile, level)
            outfile.write('fullName="%s",\n' % (self.fullName,))
        super(QueryResultAdminUserRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminUserRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isLdapUser', node)
        if value is not None and 'isLdapUser' not in already_processed:
            already_processed.add('isLdapUser')
            if value in ('true', '1'):
                self.isLdapUser = True
            elif value in ('false', '0'):
                self.isLdapUser = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('deployedVMQuotaRank', node)
        if value is not None and 'deployedVMQuotaRank' not in already_processed:
            already_processed.add('deployedVMQuotaRank')
            try:
                self.deployedVMQuotaRank = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('deployedVMQuota', node)
        if value is not None and 'deployedVMQuota' not in already_processed:
            already_processed.add('deployedVMQuota')
            try:
                self.deployedVMQuota = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('identityProviderType', node)
        if value is not None and 'identityProviderType' not in already_processed:
            already_processed.add('identityProviderType')
            self.identityProviderType = value
        value = find_attr_value_('storedVMQuota', node)
        if value is not None and 'storedVMQuota' not in already_processed:
            already_processed.add('storedVMQuota')
            try:
                self.storedVMQuota = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfStoredVMs', node)
        if value is not None and 'numberOfStoredVMs' not in already_processed:
            already_processed.add('numberOfStoredVMs')
            try:
                self.numberOfStoredVMs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storedVMQuotaRank', node)
        if value is not None and 'storedVMQuotaRank' not in already_processed:
            already_processed.add('storedVMQuotaRank')
            try:
                self.storedVMQuotaRank = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfDeployedVMs', node)
        if value is not None and 'numberOfDeployedVMs' not in already_processed:
            already_processed.add('numberOfDeployedVMs')
            try:
                self.numberOfDeployedVMs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('fullName', node)
        if value is not None and 'fullName' not in already_processed:
            already_processed.add('fullName')
            self.fullName = value
        super(QueryResultAdminUserRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminUserRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminUserRecordType


class QueryResultAdminGroupRecordType(QueryResultRecordType):
    """1.5 Type for a single adminGroup query result in records format.
    1.5none The name of this group. 1.5none Organization reference
    or id 1.5none Role name 1.5none True if this entity is read-only
    5.1none Shows the identity provider type of the group"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, isReadOnly=None, org=None, identityProviderType=None, name=None, roleName=None):
        self.original_tagname_ = None
        super(QueryResultAdminGroupRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.isReadOnly = _cast(bool, isReadOnly)
        self.org = _cast(None, org)
        self.identityProviderType = _cast(None, identityProviderType)
        self.name = _cast(None, name)
        self.roleName = _cast(None, roleName)
    def factory(*args_, **kwargs_):
        if QueryResultAdminGroupRecordType.subclass:
            return QueryResultAdminGroupRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminGroupRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isReadOnly(self): return self.isReadOnly
    def set_isReadOnly(self, isReadOnly): self.isReadOnly = isReadOnly
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_identityProviderType(self): return self.identityProviderType
    def set_identityProviderType(self, identityProviderType): self.identityProviderType = identityProviderType
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_roleName(self): return self.roleName
    def set_roleName(self, roleName): self.roleName = roleName
    def hasContent_(self):
        if (
            super(QueryResultAdminGroupRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminGroupRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminGroupRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminGroupRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminGroupRecordType'):
        super(QueryResultAdminGroupRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminGroupRecordType')
        if self.isReadOnly is not None and 'isReadOnly' not in already_processed:
            already_processed.add('isReadOnly')
            outfile.write(' isReadOnly="%s"' % self.gds_format_boolean(self.isReadOnly, input_name='isReadOnly'))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.identityProviderType is not None and 'identityProviderType' not in already_processed:
            already_processed.add('identityProviderType')
            outfile.write(' identityProviderType=%s' % (self.gds_format_string(quote_attrib(self.identityProviderType).encode(ExternalEncoding), input_name='identityProviderType'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.roleName is not None and 'roleName' not in already_processed:
            already_processed.add('roleName')
            outfile.write(' roleName=%s' % (self.gds_format_string(quote_attrib(self.roleName).encode(ExternalEncoding), input_name='roleName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminGroupRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminGroupRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminGroupRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isReadOnly is not None and 'isReadOnly' not in already_processed:
            already_processed.add('isReadOnly')
            showIndent(outfile, level)
            outfile.write('isReadOnly=%s,\n' % (self.isReadOnly,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.identityProviderType is not None and 'identityProviderType' not in already_processed:
            already_processed.add('identityProviderType')
            showIndent(outfile, level)
            outfile.write('identityProviderType="%s",\n' % (self.identityProviderType,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.roleName is not None and 'roleName' not in already_processed:
            already_processed.add('roleName')
            showIndent(outfile, level)
            outfile.write('roleName="%s",\n' % (self.roleName,))
        super(QueryResultAdminGroupRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminGroupRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isReadOnly', node)
        if value is not None and 'isReadOnly' not in already_processed:
            already_processed.add('isReadOnly')
            if value in ('true', '1'):
                self.isReadOnly = True
            elif value in ('false', '0'):
                self.isReadOnly = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('identityProviderType', node)
        if value is not None and 'identityProviderType' not in already_processed:
            already_processed.add('identityProviderType')
            self.identityProviderType = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('roleName', node)
        if value is not None and 'roleName' not in already_processed:
            already_processed.add('roleName')
            self.roleName = value
        super(QueryResultAdminGroupRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminGroupRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminGroupRecordType


class QueryResultAdminVAppNetworkRecordType(QueryResultRecordType):
    """1.5 Type for a single adminVAppNetwork query result in records
    format. 1.5none The name of this network. 1.5none Organization
    reference or id 1.5none True if this network's IP scope is
    inherited. 1.5none Gateway 1.5none Netmask 1.5none Primary DNS
    1.5none Secondary DNS 1.5none DNS suffix 1.5none VApp reference
    or id 1.5none Vapp name 1.5none True if this entity is busy"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, name=None, vappName=None, isBusy=None, dns2=None, dns1=None, isIpScopeInherited=None, netmask=None, dnsSuffix=None, org=None, gateway=None, vApp=None):
        self.original_tagname_ = None
        super(QueryResultAdminVAppNetworkRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.name = _cast(None, name)
        self.vappName = _cast(None, vappName)
        self.isBusy = _cast(bool, isBusy)
        self.dns2 = _cast(None, dns2)
        self.dns1 = _cast(None, dns1)
        self.isIpScopeInherited = _cast(bool, isIpScopeInherited)
        self.netmask = _cast(None, netmask)
        self.dnsSuffix = _cast(None, dnsSuffix)
        self.org = _cast(None, org)
        self.gateway = _cast(None, gateway)
        self.vApp = _cast(None, vApp)
    def factory(*args_, **kwargs_):
        if QueryResultAdminVAppNetworkRecordType.subclass:
            return QueryResultAdminVAppNetworkRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminVAppNetworkRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_vappName(self): return self.vappName
    def set_vappName(self, vappName): self.vappName = vappName
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_dns2(self): return self.dns2
    def set_dns2(self, dns2): self.dns2 = dns2
    def get_dns1(self): return self.dns1
    def set_dns1(self, dns1): self.dns1 = dns1
    def get_isIpScopeInherited(self): return self.isIpScopeInherited
    def set_isIpScopeInherited(self, isIpScopeInherited): self.isIpScopeInherited = isIpScopeInherited
    def get_netmask(self): return self.netmask
    def set_netmask(self, netmask): self.netmask = netmask
    def get_dnsSuffix(self): return self.dnsSuffix
    def set_dnsSuffix(self, dnsSuffix): self.dnsSuffix = dnsSuffix
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_gateway(self): return self.gateway
    def set_gateway(self, gateway): self.gateway = gateway
    def get_vApp(self): return self.vApp
    def set_vApp(self, vApp): self.vApp = vApp
    def hasContent_(self):
        if (
            super(QueryResultAdminVAppNetworkRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminVAppNetworkRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminVAppNetworkRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminVAppNetworkRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminVAppNetworkRecordType'):
        super(QueryResultAdminVAppNetworkRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminVAppNetworkRecordType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.vappName is not None and 'vappName' not in already_processed:
            already_processed.add('vappName')
            outfile.write(' vappName=%s' % (self.gds_format_string(quote_attrib(self.vappName).encode(ExternalEncoding), input_name='vappName'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.dns2 is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            outfile.write(' dns2=%s' % (self.gds_format_string(quote_attrib(self.dns2).encode(ExternalEncoding), input_name='dns2'), ))
        if self.dns1 is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            outfile.write(' dns1=%s' % (self.gds_format_string(quote_attrib(self.dns1).encode(ExternalEncoding), input_name='dns1'), ))
        if self.isIpScopeInherited is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            outfile.write(' isIpScopeInherited="%s"' % self.gds_format_boolean(self.isIpScopeInherited, input_name='isIpScopeInherited'))
        if self.netmask is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            outfile.write(' netmask=%s' % (self.gds_format_string(quote_attrib(self.netmask).encode(ExternalEncoding), input_name='netmask'), ))
        if self.dnsSuffix is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            outfile.write(' dnsSuffix=%s' % (self.gds_format_string(quote_attrib(self.dnsSuffix).encode(ExternalEncoding), input_name='dnsSuffix'), ))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.gateway is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            outfile.write(' gateway=%s' % (self.gds_format_string(quote_attrib(self.gateway).encode(ExternalEncoding), input_name='gateway'), ))
        if self.vApp is not None and 'vApp' not in already_processed:
            already_processed.add('vApp')
            outfile.write(' vApp=%s' % (self.gds_format_string(quote_attrib(self.vApp).encode(ExternalEncoding), input_name='vApp'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminVAppNetworkRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminVAppNetworkRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminVAppNetworkRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.vappName is not None and 'vappName' not in already_processed:
            already_processed.add('vappName')
            showIndent(outfile, level)
            outfile.write('vappName="%s",\n' % (self.vappName,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.dns2 is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            showIndent(outfile, level)
            outfile.write('dns2="%s",\n' % (self.dns2,))
        if self.dns1 is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            showIndent(outfile, level)
            outfile.write('dns1="%s",\n' % (self.dns1,))
        if self.isIpScopeInherited is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            showIndent(outfile, level)
            outfile.write('isIpScopeInherited=%s,\n' % (self.isIpScopeInherited,))
        if self.netmask is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            showIndent(outfile, level)
            outfile.write('netmask="%s",\n' % (self.netmask,))
        if self.dnsSuffix is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            showIndent(outfile, level)
            outfile.write('dnsSuffix="%s",\n' % (self.dnsSuffix,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.gateway is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            showIndent(outfile, level)
            outfile.write('gateway="%s",\n' % (self.gateway,))
        if self.vApp is not None and 'vApp' not in already_processed:
            already_processed.add('vApp')
            showIndent(outfile, level)
            outfile.write('vApp="%s",\n' % (self.vApp,))
        super(QueryResultAdminVAppNetworkRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminVAppNetworkRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('vappName', node)
        if value is not None and 'vappName' not in already_processed:
            already_processed.add('vappName')
            self.vappName = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('dns2', node)
        if value is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            self.dns2 = value
        value = find_attr_value_('dns1', node)
        if value is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            self.dns1 = value
        value = find_attr_value_('isIpScopeInherited', node)
        if value is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            if value in ('true', '1'):
                self.isIpScopeInherited = True
            elif value in ('false', '0'):
                self.isIpScopeInherited = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('netmask', node)
        if value is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            self.netmask = value
        value = find_attr_value_('dnsSuffix', node)
        if value is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            self.dnsSuffix = value
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('gateway', node)
        if value is not None and 'gateway' not in already_processed:
            already_processed.add('gateway')
            self.gateway = value
        value = find_attr_value_('vApp', node)
        if value is not None and 'vApp' not in already_processed:
            already_processed.add('vApp')
            self.vApp = value
        super(QueryResultAdminVAppNetworkRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminVAppNetworkRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminVAppNetworkRecordType


class QueryResultAdminCatalogRecordType(QueryResultRecordType):
    """1.5 Type for a single adminCatalog query result in records format.
    1.5none Organization reference or id 1.5none The name of this
    catalog. 1.5none True if this entity is in a published catalog
    1.5none True if this entity is shared 1.5none Creation date
    1.5none Organization name 1.5none Owner name 1.5none Number of
    vApp templates 1.5none Number of media 1.5none Owner reference
    or id"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, name=None, orgName=None, isPublished=None, ownerName=None, numberOfMedia=None, owner=None, org=None, creationDate=None, numberOfTemplates=None, isShared=None):
        self.original_tagname_ = None
        super(QueryResultAdminCatalogRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.name = _cast(None, name)
        self.orgName = _cast(None, orgName)
        self.isPublished = _cast(bool, isPublished)
        self.ownerName = _cast(None, ownerName)
        self.numberOfMedia = _cast(int, numberOfMedia)
        self.owner = _cast(None, owner)
        self.org = _cast(None, org)
        if isinstance(creationDate, basestring):
            initvalue_ = datetime_.datetime.strptime(creationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationDate
        self.creationDate = initvalue_
        self.numberOfTemplates = _cast(int, numberOfTemplates)
        self.isShared = _cast(bool, isShared)
    def factory(*args_, **kwargs_):
        if QueryResultAdminCatalogRecordType.subclass:
            return QueryResultAdminCatalogRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminCatalogRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_orgName(self): return self.orgName
    def set_orgName(self, orgName): self.orgName = orgName
    def get_isPublished(self): return self.isPublished
    def set_isPublished(self, isPublished): self.isPublished = isPublished
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_numberOfMedia(self): return self.numberOfMedia
    def set_numberOfMedia(self, numberOfMedia): self.numberOfMedia = numberOfMedia
    def get_owner(self): return self.owner
    def set_owner(self, owner): self.owner = owner
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_creationDate(self): return self.creationDate
    def set_creationDate(self, creationDate): self.creationDate = creationDate
    def get_numberOfTemplates(self): return self.numberOfTemplates
    def set_numberOfTemplates(self, numberOfTemplates): self.numberOfTemplates = numberOfTemplates
    def get_isShared(self): return self.isShared
    def set_isShared(self, isShared): self.isShared = isShared
    def hasContent_(self):
        if (
            super(QueryResultAdminCatalogRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminCatalogRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminCatalogRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminCatalogRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminCatalogRecordType'):
        super(QueryResultAdminCatalogRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminCatalogRecordType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            outfile.write(' orgName=%s' % (self.gds_format_string(quote_attrib(self.orgName).encode(ExternalEncoding), input_name='orgName'), ))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            outfile.write(' isPublished="%s"' % self.gds_format_boolean(self.isPublished, input_name='isPublished'))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.numberOfMedia is not None and 'numberOfMedia' not in already_processed:
            already_processed.add('numberOfMedia')
            outfile.write(' numberOfMedia="%s"' % self.gds_format_integer(self.numberOfMedia, input_name='numberOfMedia'))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            outfile.write(' owner=%s' % (self.gds_format_string(quote_attrib(self.owner).encode(ExternalEncoding), input_name='owner'), ))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            outfile.write(' creationDate="%s"' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.numberOfTemplates is not None and 'numberOfTemplates' not in already_processed:
            already_processed.add('numberOfTemplates')
            outfile.write(' numberOfTemplates="%s"' % self.gds_format_integer(self.numberOfTemplates, input_name='numberOfTemplates'))
        if self.isShared is not None and 'isShared' not in already_processed:
            already_processed.add('isShared')
            outfile.write(' isShared="%s"' % self.gds_format_boolean(self.isShared, input_name='isShared'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminCatalogRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminCatalogRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminCatalogRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            showIndent(outfile, level)
            outfile.write('orgName="%s",\n' % (self.orgName,))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            showIndent(outfile, level)
            outfile.write('isPublished=%s,\n' % (self.isPublished,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.numberOfMedia is not None and 'numberOfMedia' not in already_processed:
            already_processed.add('numberOfMedia')
            showIndent(outfile, level)
            outfile.write('numberOfMedia=%d,\n' % (self.numberOfMedia,))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            showIndent(outfile, level)
            outfile.write('owner="%s",\n' % (self.owner,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            showIndent(outfile, level)
            outfile.write('creationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.numberOfTemplates is not None and 'numberOfTemplates' not in already_processed:
            already_processed.add('numberOfTemplates')
            showIndent(outfile, level)
            outfile.write('numberOfTemplates=%d,\n' % (self.numberOfTemplates,))
        if self.isShared is not None and 'isShared' not in already_processed:
            already_processed.add('isShared')
            showIndent(outfile, level)
            outfile.write('isShared=%s,\n' % (self.isShared,))
        super(QueryResultAdminCatalogRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminCatalogRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('orgName', node)
        if value is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            self.orgName = value
        value = find_attr_value_('isPublished', node)
        if value is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            if value in ('true', '1'):
                self.isPublished = True
            elif value in ('false', '0'):
                self.isPublished = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('numberOfMedia', node)
        if value is not None and 'numberOfMedia' not in already_processed:
            already_processed.add('numberOfMedia')
            try:
                self.numberOfMedia = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('owner', node)
        if value is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            self.owner = value
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('creationDate', node)
        if value is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            try:
                self.creationDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (creationDate): %s' % exp)
        value = find_attr_value_('numberOfTemplates', node)
        if value is not None and 'numberOfTemplates' not in already_processed:
            already_processed.add('numberOfTemplates')
            try:
                self.numberOfTemplates = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isShared', node)
        if value is not None and 'isShared' not in already_processed:
            already_processed.add('isShared')
            if value in ('true', '1'):
                self.isShared = True
            elif value in ('false', '0'):
                self.isShared = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(QueryResultAdminCatalogRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminCatalogRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminCatalogRecordType


class QueryResultAdminCatalogItemRecordType(QueryResultRecordType):
    """1.5 Type for a single adminCatalogItem query result in records
    format. 1.5none Entity reference or id 1.5none Entity name
    1.5none Entity type 1.5none Catalog reference or id 1.5none
    Catalog name 1.5none Owner name 1.5none Owner reference or id
    1.5none True if this entity is in a published catalog 1.5none
    VDC reference or id 1.5none VDC name 1.5none True if the
    containing VDC is enabled. 1.5none Organization reference or id
    1.5none Creation date 1.5none True if this entity is expired
    1.5none Status 1.5none The name of this catalog item."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, vdcName=None, creationDate=None, name=None, entityName=None, entityType=None, isPublished=None, entity=None, catalog=None, ownerName=None, owner=None, org=None, isExpired=None, vdc=None, isVdcEnabled=None, catalogName=None):
        self.original_tagname_ = None
        super(QueryResultAdminCatalogItemRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        self.vdcName = _cast(None, vdcName)
        if isinstance(creationDate, basestring):
            initvalue_ = datetime_.datetime.strptime(creationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationDate
        self.creationDate = initvalue_
        self.name = _cast(None, name)
        self.entityName = _cast(None, entityName)
        self.entityType = _cast(None, entityType)
        self.isPublished = _cast(bool, isPublished)
        self.entity = _cast(None, entity)
        self.catalog = _cast(None, catalog)
        self.ownerName = _cast(None, ownerName)
        self.owner = _cast(None, owner)
        self.org = _cast(None, org)
        self.isExpired = _cast(bool, isExpired)
        self.vdc = _cast(None, vdc)
        self.isVdcEnabled = _cast(bool, isVdcEnabled)
        self.catalogName = _cast(None, catalogName)
    def factory(*args_, **kwargs_):
        if QueryResultAdminCatalogItemRecordType.subclass:
            return QueryResultAdminCatalogItemRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminCatalogItemRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_vdcName(self): return self.vdcName
    def set_vdcName(self, vdcName): self.vdcName = vdcName
    def get_creationDate(self): return self.creationDate
    def set_creationDate(self, creationDate): self.creationDate = creationDate
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_entityName(self): return self.entityName
    def set_entityName(self, entityName): self.entityName = entityName
    def get_entityType(self): return self.entityType
    def set_entityType(self, entityType): self.entityType = entityType
    def get_isPublished(self): return self.isPublished
    def set_isPublished(self, isPublished): self.isPublished = isPublished
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def get_catalog(self): return self.catalog
    def set_catalog(self, catalog): self.catalog = catalog
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_owner(self): return self.owner
    def set_owner(self, owner): self.owner = owner
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_isExpired(self): return self.isExpired
    def set_isExpired(self, isExpired): self.isExpired = isExpired
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_isVdcEnabled(self): return self.isVdcEnabled
    def set_isVdcEnabled(self, isVdcEnabled): self.isVdcEnabled = isVdcEnabled
    def get_catalogName(self): return self.catalogName
    def set_catalogName(self, catalogName): self.catalogName = catalogName
    def hasContent_(self):
        if (
            super(QueryResultAdminCatalogItemRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminCatalogItemRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminCatalogItemRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminCatalogItemRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminCatalogItemRecordType'):
        super(QueryResultAdminCatalogItemRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminCatalogItemRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            outfile.write(' vdcName=%s' % (self.gds_format_string(quote_attrib(self.vdcName).encode(ExternalEncoding), input_name='vdcName'), ))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            outfile.write(' creationDate="%s"' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.entityName is not None and 'entityName' not in already_processed:
            already_processed.add('entityName')
            outfile.write(' entityName=%s' % (self.gds_format_string(quote_attrib(self.entityName).encode(ExternalEncoding), input_name='entityName'), ))
        if self.entityType is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            outfile.write(' entityType=%s' % (self.gds_format_string(quote_attrib(self.entityType).encode(ExternalEncoding), input_name='entityType'), ))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            outfile.write(' isPublished="%s"' % self.gds_format_boolean(self.isPublished, input_name='isPublished'))
        if self.entity is not None and 'entity' not in already_processed:
            already_processed.add('entity')
            outfile.write(' entity=%s' % (self.gds_format_string(quote_attrib(self.entity).encode(ExternalEncoding), input_name='entity'), ))
        if self.catalog is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            outfile.write(' catalog=%s' % (self.gds_format_string(quote_attrib(self.catalog).encode(ExternalEncoding), input_name='catalog'), ))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            outfile.write(' owner=%s' % (self.gds_format_string(quote_attrib(self.owner).encode(ExternalEncoding), input_name='owner'), ))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.isExpired is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            outfile.write(' isExpired="%s"' % self.gds_format_boolean(self.isExpired, input_name='isExpired'))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.isVdcEnabled is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            outfile.write(' isVdcEnabled="%s"' % self.gds_format_boolean(self.isVdcEnabled, input_name='isVdcEnabled'))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            outfile.write(' catalogName=%s' % (self.gds_format_string(quote_attrib(self.catalogName).encode(ExternalEncoding), input_name='catalogName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminCatalogItemRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminCatalogItemRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminCatalogItemRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            showIndent(outfile, level)
            outfile.write('vdcName="%s",\n' % (self.vdcName,))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            showIndent(outfile, level)
            outfile.write('creationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.entityName is not None and 'entityName' not in already_processed:
            already_processed.add('entityName')
            showIndent(outfile, level)
            outfile.write('entityName="%s",\n' % (self.entityName,))
        if self.entityType is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            showIndent(outfile, level)
            outfile.write('entityType="%s",\n' % (self.entityType,))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            showIndent(outfile, level)
            outfile.write('isPublished=%s,\n' % (self.isPublished,))
        if self.entity is not None and 'entity' not in already_processed:
            already_processed.add('entity')
            showIndent(outfile, level)
            outfile.write('entity="%s",\n' % (self.entity,))
        if self.catalog is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            showIndent(outfile, level)
            outfile.write('catalog="%s",\n' % (self.catalog,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            showIndent(outfile, level)
            outfile.write('owner="%s",\n' % (self.owner,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.isExpired is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            showIndent(outfile, level)
            outfile.write('isExpired=%s,\n' % (self.isExpired,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.isVdcEnabled is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            showIndent(outfile, level)
            outfile.write('isVdcEnabled=%s,\n' % (self.isVdcEnabled,))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            showIndent(outfile, level)
            outfile.write('catalogName="%s",\n' % (self.catalogName,))
        super(QueryResultAdminCatalogItemRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminCatalogItemRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('vdcName', node)
        if value is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            self.vdcName = value
        value = find_attr_value_('creationDate', node)
        if value is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            try:
                self.creationDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (creationDate): %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('entityName', node)
        if value is not None and 'entityName' not in already_processed:
            already_processed.add('entityName')
            self.entityName = value
        value = find_attr_value_('entityType', node)
        if value is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            self.entityType = value
        value = find_attr_value_('isPublished', node)
        if value is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            if value in ('true', '1'):
                self.isPublished = True
            elif value in ('false', '0'):
                self.isPublished = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('entity', node)
        if value is not None and 'entity' not in already_processed:
            already_processed.add('entity')
            self.entity = value
        value = find_attr_value_('catalog', node)
        if value is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            self.catalog = value
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('owner', node)
        if value is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            self.owner = value
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('isExpired', node)
        if value is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            if value in ('true', '1'):
                self.isExpired = True
            elif value in ('false', '0'):
                self.isExpired = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('isVdcEnabled', node)
        if value is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            if value in ('true', '1'):
                self.isVdcEnabled = True
            elif value in ('false', '0'):
                self.isVdcEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('catalogName', node)
        if value is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            self.catalogName = value
        super(QueryResultAdminCatalogItemRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminCatalogItemRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminCatalogItemRecordType


class QueryResultCatalogItemRecordType(QueryResultRecordType):
    """1.5 Type for a single catalogItem query result in records format.
    1.5none Entity reference or id 1.5none Entity name 1.5none
    Entity type 1.5none Catalog reference or id 1.5none Catalog name
    1.5none Owner name 1.5none Owner reference or id 1.5none True if
    this entity is in a published catalog 1.5none VDC reference or
    id 1.5none VDC name 1.5none True if the containing VDC is
    enabled. 1.5none Creation date 1.5none True if this entity is
    expired 1.5none Status 1.5none The name of this catalog item."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, vdcName=None, creationDate=None, name=None, entityName=None, entityType=None, isPublished=None, entity=None, catalog=None, ownerName=None, owner=None, isExpired=None, vdc=None, isVdcEnabled=None, catalogName=None):
        self.original_tagname_ = None
        super(QueryResultCatalogItemRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        self.vdcName = _cast(None, vdcName)
        if isinstance(creationDate, basestring):
            initvalue_ = datetime_.datetime.strptime(creationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationDate
        self.creationDate = initvalue_
        self.name = _cast(None, name)
        self.entityName = _cast(None, entityName)
        self.entityType = _cast(None, entityType)
        self.isPublished = _cast(bool, isPublished)
        self.entity = _cast(None, entity)
        self.catalog = _cast(None, catalog)
        self.ownerName = _cast(None, ownerName)
        self.owner = _cast(None, owner)
        self.isExpired = _cast(bool, isExpired)
        self.vdc = _cast(None, vdc)
        self.isVdcEnabled = _cast(bool, isVdcEnabled)
        self.catalogName = _cast(None, catalogName)
    def factory(*args_, **kwargs_):
        if QueryResultCatalogItemRecordType.subclass:
            return QueryResultCatalogItemRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultCatalogItemRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_vdcName(self): return self.vdcName
    def set_vdcName(self, vdcName): self.vdcName = vdcName
    def get_creationDate(self): return self.creationDate
    def set_creationDate(self, creationDate): self.creationDate = creationDate
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_entityName(self): return self.entityName
    def set_entityName(self, entityName): self.entityName = entityName
    def get_entityType(self): return self.entityType
    def set_entityType(self, entityType): self.entityType = entityType
    def get_isPublished(self): return self.isPublished
    def set_isPublished(self, isPublished): self.isPublished = isPublished
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def get_catalog(self): return self.catalog
    def set_catalog(self, catalog): self.catalog = catalog
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_owner(self): return self.owner
    def set_owner(self, owner): self.owner = owner
    def get_isExpired(self): return self.isExpired
    def set_isExpired(self, isExpired): self.isExpired = isExpired
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_isVdcEnabled(self): return self.isVdcEnabled
    def set_isVdcEnabled(self, isVdcEnabled): self.isVdcEnabled = isVdcEnabled
    def get_catalogName(self): return self.catalogName
    def set_catalogName(self, catalogName): self.catalogName = catalogName
    def hasContent_(self):
        if (
            super(QueryResultCatalogItemRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultCatalogItemRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultCatalogItemRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultCatalogItemRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultCatalogItemRecordType'):
        super(QueryResultCatalogItemRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultCatalogItemRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            outfile.write(' vdcName=%s' % (self.gds_format_string(quote_attrib(self.vdcName).encode(ExternalEncoding), input_name='vdcName'), ))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            outfile.write(' creationDate="%s"' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.entityName is not None and 'entityName' not in already_processed:
            already_processed.add('entityName')
            outfile.write(' entityName=%s' % (self.gds_format_string(quote_attrib(self.entityName).encode(ExternalEncoding), input_name='entityName'), ))
        if self.entityType is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            outfile.write(' entityType=%s' % (self.gds_format_string(quote_attrib(self.entityType).encode(ExternalEncoding), input_name='entityType'), ))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            outfile.write(' isPublished="%s"' % self.gds_format_boolean(self.isPublished, input_name='isPublished'))
        if self.entity is not None and 'entity' not in already_processed:
            already_processed.add('entity')
            outfile.write(' entity=%s' % (self.gds_format_string(quote_attrib(self.entity).encode(ExternalEncoding), input_name='entity'), ))
        if self.catalog is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            outfile.write(' catalog=%s' % (self.gds_format_string(quote_attrib(self.catalog).encode(ExternalEncoding), input_name='catalog'), ))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            outfile.write(' owner=%s' % (self.gds_format_string(quote_attrib(self.owner).encode(ExternalEncoding), input_name='owner'), ))
        if self.isExpired is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            outfile.write(' isExpired="%s"' % self.gds_format_boolean(self.isExpired, input_name='isExpired'))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.isVdcEnabled is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            outfile.write(' isVdcEnabled="%s"' % self.gds_format_boolean(self.isVdcEnabled, input_name='isVdcEnabled'))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            outfile.write(' catalogName=%s' % (self.gds_format_string(quote_attrib(self.catalogName).encode(ExternalEncoding), input_name='catalogName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultCatalogItemRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultCatalogItemRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultCatalogItemRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            showIndent(outfile, level)
            outfile.write('vdcName="%s",\n' % (self.vdcName,))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            showIndent(outfile, level)
            outfile.write('creationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.entityName is not None and 'entityName' not in already_processed:
            already_processed.add('entityName')
            showIndent(outfile, level)
            outfile.write('entityName="%s",\n' % (self.entityName,))
        if self.entityType is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            showIndent(outfile, level)
            outfile.write('entityType="%s",\n' % (self.entityType,))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            showIndent(outfile, level)
            outfile.write('isPublished=%s,\n' % (self.isPublished,))
        if self.entity is not None and 'entity' not in already_processed:
            already_processed.add('entity')
            showIndent(outfile, level)
            outfile.write('entity="%s",\n' % (self.entity,))
        if self.catalog is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            showIndent(outfile, level)
            outfile.write('catalog="%s",\n' % (self.catalog,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            showIndent(outfile, level)
            outfile.write('owner="%s",\n' % (self.owner,))
        if self.isExpired is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            showIndent(outfile, level)
            outfile.write('isExpired=%s,\n' % (self.isExpired,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.isVdcEnabled is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            showIndent(outfile, level)
            outfile.write('isVdcEnabled=%s,\n' % (self.isVdcEnabled,))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            showIndent(outfile, level)
            outfile.write('catalogName="%s",\n' % (self.catalogName,))
        super(QueryResultCatalogItemRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultCatalogItemRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('vdcName', node)
        if value is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            self.vdcName = value
        value = find_attr_value_('creationDate', node)
        if value is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            try:
                self.creationDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (creationDate): %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('entityName', node)
        if value is not None and 'entityName' not in already_processed:
            already_processed.add('entityName')
            self.entityName = value
        value = find_attr_value_('entityType', node)
        if value is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            self.entityType = value
        value = find_attr_value_('isPublished', node)
        if value is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            if value in ('true', '1'):
                self.isPublished = True
            elif value in ('false', '0'):
                self.isPublished = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('entity', node)
        if value is not None and 'entity' not in already_processed:
            already_processed.add('entity')
            self.entity = value
        value = find_attr_value_('catalog', node)
        if value is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            self.catalog = value
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('owner', node)
        if value is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            self.owner = value
        value = find_attr_value_('isExpired', node)
        if value is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            if value in ('true', '1'):
                self.isExpired = True
            elif value in ('false', '0'):
                self.isExpired = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('isVdcEnabled', node)
        if value is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            if value in ('true', '1'):
                self.isVdcEnabled = True
            elif value in ('false', '0'):
                self.isVdcEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('catalogName', node)
        if value is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            self.catalogName = value
        super(QueryResultCatalogItemRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultCatalogItemRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultCatalogItemRecordType


class QueryResultAdminMediaRecordType(QueryResultRecordType):
    """1.5 Type for a single adminMedia query result in records format.
    1.5none Organization reference or id 1.5none Owner name 1.5none
    Owner reference or id 1.5none True if this entity is in a
    published catalog 1.5none The name of this media object. 1.5none
    Storage in Bytes 1.5none VDC reference or id 1.5none VDC name
    1.5none True if the containing VDC is enabled. 1.5none Catalog
    reference or id 1.5none Catalog name 1.5none Catalog item
    reference or id 1.5none Creation date 1.5none True if this
    entity is busy 1.5none Status 5.1none Storage profile name"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, storageProfileName=None, name=None, storageB=None, isPublished=None, vdcName=None, catalog=None, vdc=None, catalogItem=None, ownerName=None, isBusy=None, owner=None, org=None, creationDate=None, isVdcEnabled=None, catalogName=None):
        self.original_tagname_ = None
        super(QueryResultAdminMediaRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        self.storageProfileName = _cast(None, storageProfileName)
        self.name = _cast(None, name)
        self.storageB = _cast(int, storageB)
        self.isPublished = _cast(bool, isPublished)
        self.vdcName = _cast(None, vdcName)
        self.catalog = _cast(None, catalog)
        self.vdc = _cast(None, vdc)
        self.catalogItem = _cast(None, catalogItem)
        self.ownerName = _cast(None, ownerName)
        self.isBusy = _cast(bool, isBusy)
        self.owner = _cast(None, owner)
        self.org = _cast(None, org)
        if isinstance(creationDate, basestring):
            initvalue_ = datetime_.datetime.strptime(creationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationDate
        self.creationDate = initvalue_
        self.isVdcEnabled = _cast(bool, isVdcEnabled)
        self.catalogName = _cast(None, catalogName)
    def factory(*args_, **kwargs_):
        if QueryResultAdminMediaRecordType.subclass:
            return QueryResultAdminMediaRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminMediaRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_storageProfileName(self): return self.storageProfileName
    def set_storageProfileName(self, storageProfileName): self.storageProfileName = storageProfileName
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_storageB(self): return self.storageB
    def set_storageB(self, storageB): self.storageB = storageB
    def get_isPublished(self): return self.isPublished
    def set_isPublished(self, isPublished): self.isPublished = isPublished
    def get_vdcName(self): return self.vdcName
    def set_vdcName(self, vdcName): self.vdcName = vdcName
    def get_catalog(self): return self.catalog
    def set_catalog(self, catalog): self.catalog = catalog
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_catalogItem(self): return self.catalogItem
    def set_catalogItem(self, catalogItem): self.catalogItem = catalogItem
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_owner(self): return self.owner
    def set_owner(self, owner): self.owner = owner
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_creationDate(self): return self.creationDate
    def set_creationDate(self, creationDate): self.creationDate = creationDate
    def get_isVdcEnabled(self): return self.isVdcEnabled
    def set_isVdcEnabled(self, isVdcEnabled): self.isVdcEnabled = isVdcEnabled
    def get_catalogName(self): return self.catalogName
    def set_catalogName(self, catalogName): self.catalogName = catalogName
    def hasContent_(self):
        if (
            super(QueryResultAdminMediaRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminMediaRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminMediaRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminMediaRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminMediaRecordType'):
        super(QueryResultAdminMediaRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminMediaRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            outfile.write(' storageProfileName=%s' % (self.gds_format_string(quote_attrib(self.storageProfileName).encode(ExternalEncoding), input_name='storageProfileName'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.storageB is not None and 'storageB' not in already_processed:
            already_processed.add('storageB')
            outfile.write(' storageB="%s"' % self.gds_format_integer(self.storageB, input_name='storageB'))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            outfile.write(' isPublished="%s"' % self.gds_format_boolean(self.isPublished, input_name='isPublished'))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            outfile.write(' vdcName=%s' % (self.gds_format_string(quote_attrib(self.vdcName).encode(ExternalEncoding), input_name='vdcName'), ))
        if self.catalog is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            outfile.write(' catalog=%s' % (self.gds_format_string(quote_attrib(self.catalog).encode(ExternalEncoding), input_name='catalog'), ))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.catalogItem is not None and 'catalogItem' not in already_processed:
            already_processed.add('catalogItem')
            outfile.write(' catalogItem=%s' % (self.gds_format_string(quote_attrib(self.catalogItem).encode(ExternalEncoding), input_name='catalogItem'), ))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            outfile.write(' owner=%s' % (self.gds_format_string(quote_attrib(self.owner).encode(ExternalEncoding), input_name='owner'), ))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            outfile.write(' creationDate="%s"' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.isVdcEnabled is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            outfile.write(' isVdcEnabled="%s"' % self.gds_format_boolean(self.isVdcEnabled, input_name='isVdcEnabled'))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            outfile.write(' catalogName=%s' % (self.gds_format_string(quote_attrib(self.catalogName).encode(ExternalEncoding), input_name='catalogName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminMediaRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminMediaRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminMediaRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            showIndent(outfile, level)
            outfile.write('storageProfileName="%s",\n' % (self.storageProfileName,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.storageB is not None and 'storageB' not in already_processed:
            already_processed.add('storageB')
            showIndent(outfile, level)
            outfile.write('storageB=%d,\n' % (self.storageB,))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            showIndent(outfile, level)
            outfile.write('isPublished=%s,\n' % (self.isPublished,))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            showIndent(outfile, level)
            outfile.write('vdcName="%s",\n' % (self.vdcName,))
        if self.catalog is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            showIndent(outfile, level)
            outfile.write('catalog="%s",\n' % (self.catalog,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.catalogItem is not None and 'catalogItem' not in already_processed:
            already_processed.add('catalogItem')
            showIndent(outfile, level)
            outfile.write('catalogItem="%s",\n' % (self.catalogItem,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            showIndent(outfile, level)
            outfile.write('owner="%s",\n' % (self.owner,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            showIndent(outfile, level)
            outfile.write('creationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.isVdcEnabled is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            showIndent(outfile, level)
            outfile.write('isVdcEnabled=%s,\n' % (self.isVdcEnabled,))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            showIndent(outfile, level)
            outfile.write('catalogName="%s",\n' % (self.catalogName,))
        super(QueryResultAdminMediaRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminMediaRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('storageProfileName', node)
        if value is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            self.storageProfileName = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('storageB', node)
        if value is not None and 'storageB' not in already_processed:
            already_processed.add('storageB')
            try:
                self.storageB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isPublished', node)
        if value is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            if value in ('true', '1'):
                self.isPublished = True
            elif value in ('false', '0'):
                self.isPublished = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vdcName', node)
        if value is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            self.vdcName = value
        value = find_attr_value_('catalog', node)
        if value is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            self.catalog = value
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('catalogItem', node)
        if value is not None and 'catalogItem' not in already_processed:
            already_processed.add('catalogItem')
            self.catalogItem = value
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('owner', node)
        if value is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            self.owner = value
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('creationDate', node)
        if value is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            try:
                self.creationDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (creationDate): %s' % exp)
        value = find_attr_value_('isVdcEnabled', node)
        if value is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            if value in ('true', '1'):
                self.isVdcEnabled = True
            elif value in ('false', '0'):
                self.isVdcEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('catalogName', node)
        if value is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            self.catalogName = value
        super(QueryResultAdminMediaRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminMediaRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminMediaRecordType


class QueryResultAdminVAppTemplateRecordType(QueryResultRecordType):
    """1.5 Type for a single adminVAppTemplate query result in records
    format. 1.5none Organization reference or id 1.5none Owner name
    1.5none Owner reference or id 1.5none True if this entity is in
    a published catalog. 1.5none The name of this vApp template.
    1.5none VDC reference or id 1.5none VDC name 1.5none True if the
    containing VDC is enabled. 1.5none Catalog reference or id
    1.5none Catalog name 1.5none Catalog item reference or id
    1.5none Creation date 1.5none True if this entity is busy
    1.5none True if this template is marked as a gold master 1.5none
    True if this entity is enabled 1.5none True if this entity is
    expired 1.5none True if this entity is deployed 1.5none Status
    5.1none Storage profile name"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, isGoldMaster=None, status=None, isDeployed=None, name=None, storageProfileName=None, isEnabled=None, isPublished=None, vdcName=None, catalog=None, vdc=None, catalogItem=None, ownerName=None, isBusy=None, owner=None, org=None, isExpired=None, creationDate=None, isVdcEnabled=None, catalogName=None):
        self.original_tagname_ = None
        super(QueryResultAdminVAppTemplateRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.isGoldMaster = _cast(bool, isGoldMaster)
        self.status = _cast(None, status)
        self.isDeployed = _cast(bool, isDeployed)
        self.name = _cast(None, name)
        self.storageProfileName = _cast(None, storageProfileName)
        self.isEnabled = _cast(bool, isEnabled)
        self.isPublished = _cast(bool, isPublished)
        self.vdcName = _cast(None, vdcName)
        self.catalog = _cast(None, catalog)
        self.vdc = _cast(None, vdc)
        self.catalogItem = _cast(None, catalogItem)
        self.ownerName = _cast(None, ownerName)
        self.isBusy = _cast(bool, isBusy)
        self.owner = _cast(None, owner)
        self.org = _cast(None, org)
        self.isExpired = _cast(bool, isExpired)
        if isinstance(creationDate, basestring):
            initvalue_ = datetime_.datetime.strptime(creationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationDate
        self.creationDate = initvalue_
        self.isVdcEnabled = _cast(bool, isVdcEnabled)
        self.catalogName = _cast(None, catalogName)
    def factory(*args_, **kwargs_):
        if QueryResultAdminVAppTemplateRecordType.subclass:
            return QueryResultAdminVAppTemplateRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminVAppTemplateRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isGoldMaster(self): return self.isGoldMaster
    def set_isGoldMaster(self, isGoldMaster): self.isGoldMaster = isGoldMaster
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_isDeployed(self): return self.isDeployed
    def set_isDeployed(self, isDeployed): self.isDeployed = isDeployed
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_storageProfileName(self): return self.storageProfileName
    def set_storageProfileName(self, storageProfileName): self.storageProfileName = storageProfileName
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_isPublished(self): return self.isPublished
    def set_isPublished(self, isPublished): self.isPublished = isPublished
    def get_vdcName(self): return self.vdcName
    def set_vdcName(self, vdcName): self.vdcName = vdcName
    def get_catalog(self): return self.catalog
    def set_catalog(self, catalog): self.catalog = catalog
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_catalogItem(self): return self.catalogItem
    def set_catalogItem(self, catalogItem): self.catalogItem = catalogItem
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_owner(self): return self.owner
    def set_owner(self, owner): self.owner = owner
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_isExpired(self): return self.isExpired
    def set_isExpired(self, isExpired): self.isExpired = isExpired
    def get_creationDate(self): return self.creationDate
    def set_creationDate(self, creationDate): self.creationDate = creationDate
    def get_isVdcEnabled(self): return self.isVdcEnabled
    def set_isVdcEnabled(self, isVdcEnabled): self.isVdcEnabled = isVdcEnabled
    def get_catalogName(self): return self.catalogName
    def set_catalogName(self, catalogName): self.catalogName = catalogName
    def hasContent_(self):
        if (
            super(QueryResultAdminVAppTemplateRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminVAppTemplateRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminVAppTemplateRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminVAppTemplateRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminVAppTemplateRecordType'):
        super(QueryResultAdminVAppTemplateRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminVAppTemplateRecordType')
        if self.isGoldMaster is not None and 'isGoldMaster' not in already_processed:
            already_processed.add('isGoldMaster')
            outfile.write(' isGoldMaster="%s"' % self.gds_format_boolean(self.isGoldMaster, input_name='isGoldMaster'))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            outfile.write(' isDeployed="%s"' % self.gds_format_boolean(self.isDeployed, input_name='isDeployed'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            outfile.write(' storageProfileName=%s' % (self.gds_format_string(quote_attrib(self.storageProfileName).encode(ExternalEncoding), input_name='storageProfileName'), ))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            outfile.write(' isPublished="%s"' % self.gds_format_boolean(self.isPublished, input_name='isPublished'))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            outfile.write(' vdcName=%s' % (self.gds_format_string(quote_attrib(self.vdcName).encode(ExternalEncoding), input_name='vdcName'), ))
        if self.catalog is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            outfile.write(' catalog=%s' % (self.gds_format_string(quote_attrib(self.catalog).encode(ExternalEncoding), input_name='catalog'), ))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.catalogItem is not None and 'catalogItem' not in already_processed:
            already_processed.add('catalogItem')
            outfile.write(' catalogItem=%s' % (self.gds_format_string(quote_attrib(self.catalogItem).encode(ExternalEncoding), input_name='catalogItem'), ))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            outfile.write(' owner=%s' % (self.gds_format_string(quote_attrib(self.owner).encode(ExternalEncoding), input_name='owner'), ))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.isExpired is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            outfile.write(' isExpired="%s"' % self.gds_format_boolean(self.isExpired, input_name='isExpired'))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            outfile.write(' creationDate="%s"' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.isVdcEnabled is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            outfile.write(' isVdcEnabled="%s"' % self.gds_format_boolean(self.isVdcEnabled, input_name='isVdcEnabled'))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            outfile.write(' catalogName=%s' % (self.gds_format_string(quote_attrib(self.catalogName).encode(ExternalEncoding), input_name='catalogName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminVAppTemplateRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminVAppTemplateRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminVAppTemplateRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isGoldMaster is not None and 'isGoldMaster' not in already_processed:
            already_processed.add('isGoldMaster')
            showIndent(outfile, level)
            outfile.write('isGoldMaster=%s,\n' % (self.isGoldMaster,))
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            showIndent(outfile, level)
            outfile.write('isDeployed=%s,\n' % (self.isDeployed,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            showIndent(outfile, level)
            outfile.write('storageProfileName="%s",\n' % (self.storageProfileName,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            showIndent(outfile, level)
            outfile.write('isPublished=%s,\n' % (self.isPublished,))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            showIndent(outfile, level)
            outfile.write('vdcName="%s",\n' % (self.vdcName,))
        if self.catalog is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            showIndent(outfile, level)
            outfile.write('catalog="%s",\n' % (self.catalog,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.catalogItem is not None and 'catalogItem' not in already_processed:
            already_processed.add('catalogItem')
            showIndent(outfile, level)
            outfile.write('catalogItem="%s",\n' % (self.catalogItem,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            showIndent(outfile, level)
            outfile.write('owner="%s",\n' % (self.owner,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.isExpired is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            showIndent(outfile, level)
            outfile.write('isExpired=%s,\n' % (self.isExpired,))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            showIndent(outfile, level)
            outfile.write('creationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        if self.isVdcEnabled is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            showIndent(outfile, level)
            outfile.write('isVdcEnabled=%s,\n' % (self.isVdcEnabled,))
        if self.catalogName is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            showIndent(outfile, level)
            outfile.write('catalogName="%s",\n' % (self.catalogName,))
        super(QueryResultAdminVAppTemplateRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminVAppTemplateRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isGoldMaster', node)
        if value is not None and 'isGoldMaster' not in already_processed:
            already_processed.add('isGoldMaster')
            if value in ('true', '1'):
                self.isGoldMaster = True
            elif value in ('false', '0'):
                self.isGoldMaster = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('isDeployed', node)
        if value is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            if value in ('true', '1'):
                self.isDeployed = True
            elif value in ('false', '0'):
                self.isDeployed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('storageProfileName', node)
        if value is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            self.storageProfileName = value
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isPublished', node)
        if value is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            if value in ('true', '1'):
                self.isPublished = True
            elif value in ('false', '0'):
                self.isPublished = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vdcName', node)
        if value is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            self.vdcName = value
        value = find_attr_value_('catalog', node)
        if value is not None and 'catalog' not in already_processed:
            already_processed.add('catalog')
            self.catalog = value
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('catalogItem', node)
        if value is not None and 'catalogItem' not in already_processed:
            already_processed.add('catalogItem')
            self.catalogItem = value
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('owner', node)
        if value is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            self.owner = value
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('isExpired', node)
        if value is not None and 'isExpired' not in already_processed:
            already_processed.add('isExpired')
            if value in ('true', '1'):
                self.isExpired = True
            elif value in ('false', '0'):
                self.isExpired = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('creationDate', node)
        if value is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            try:
                self.creationDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (creationDate): %s' % exp)
        value = find_attr_value_('isVdcEnabled', node)
        if value is not None and 'isVdcEnabled' not in already_processed:
            already_processed.add('isVdcEnabled')
            if value in ('true', '1'):
                self.isVdcEnabled = True
            elif value in ('false', '0'):
                self.isVdcEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('catalogName', node)
        if value is not None and 'catalogName' not in already_processed:
            already_processed.add('catalogName')
            self.catalogName = value
        super(QueryResultAdminVAppTemplateRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminVAppTemplateRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminVAppTemplateRecordType


class QueryResultAdminShadowVMRecordType(QueryResultRecordType):
    """1.5 Type for a single adminShadowVM query result in records format.
    1.5none True if this entity is in a published catalog 1.5none
    Entity name 1.5none Primary VM name 1.55.1none Shadow vApp
    reference or id 1.5none Primary vApp template reference or id
    1.5none Primary vApp name 1.5none Datastore name 1.5none Vitual
    center name 1.5none True if this entity is deleted 1.5none
    Status 1.5none True if this entity is busy 1.5none Primary VM
    owner reference or id 1.5none Primary VM refernce or id 1.5none
    Primary VM catalog reference or id 1.5none Organization
    reference or id"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, primaryVMOwner=None, name=None, isDeleted=None, datastoreName=None, org=None, isPublished=None, isBusy=None, shadowVApp=None, primaryVMCatalog=None, primaryVAppName=None, primaryVAppTemplate=None, primaryVmName=None, primaryVM=None, vcName=None):
        self.original_tagname_ = None
        super(QueryResultAdminShadowVMRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        self.primaryVMOwner = _cast(None, primaryVMOwner)
        self.name = _cast(None, name)
        self.isDeleted = _cast(bool, isDeleted)
        self.datastoreName = _cast(None, datastoreName)
        self.org = _cast(None, org)
        self.isPublished = _cast(bool, isPublished)
        self.isBusy = _cast(bool, isBusy)
        self.shadowVApp = _cast(None, shadowVApp)
        self.primaryVMCatalog = _cast(None, primaryVMCatalog)
        self.primaryVAppName = _cast(None, primaryVAppName)
        self.primaryVAppTemplate = _cast(None, primaryVAppTemplate)
        self.primaryVmName = _cast(None, primaryVmName)
        self.primaryVM = _cast(None, primaryVM)
        self.vcName = _cast(None, vcName)
    def factory(*args_, **kwargs_):
        if QueryResultAdminShadowVMRecordType.subclass:
            return QueryResultAdminShadowVMRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminShadowVMRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_primaryVMOwner(self): return self.primaryVMOwner
    def set_primaryVMOwner(self, primaryVMOwner): self.primaryVMOwner = primaryVMOwner
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_isDeleted(self): return self.isDeleted
    def set_isDeleted(self, isDeleted): self.isDeleted = isDeleted
    def get_datastoreName(self): return self.datastoreName
    def set_datastoreName(self, datastoreName): self.datastoreName = datastoreName
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_isPublished(self): return self.isPublished
    def set_isPublished(self, isPublished): self.isPublished = isPublished
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_shadowVApp(self): return self.shadowVApp
    def set_shadowVApp(self, shadowVApp): self.shadowVApp = shadowVApp
    def get_primaryVMCatalog(self): return self.primaryVMCatalog
    def set_primaryVMCatalog(self, primaryVMCatalog): self.primaryVMCatalog = primaryVMCatalog
    def get_primaryVAppName(self): return self.primaryVAppName
    def set_primaryVAppName(self, primaryVAppName): self.primaryVAppName = primaryVAppName
    def get_primaryVAppTemplate(self): return self.primaryVAppTemplate
    def set_primaryVAppTemplate(self, primaryVAppTemplate): self.primaryVAppTemplate = primaryVAppTemplate
    def get_primaryVmName(self): return self.primaryVmName
    def set_primaryVmName(self, primaryVmName): self.primaryVmName = primaryVmName
    def get_primaryVM(self): return self.primaryVM
    def set_primaryVM(self, primaryVM): self.primaryVM = primaryVM
    def get_vcName(self): return self.vcName
    def set_vcName(self, vcName): self.vcName = vcName
    def hasContent_(self):
        if (
            super(QueryResultAdminShadowVMRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminShadowVMRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminShadowVMRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminShadowVMRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminShadowVMRecordType'):
        super(QueryResultAdminShadowVMRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminShadowVMRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.primaryVMOwner is not None and 'primaryVMOwner' not in already_processed:
            already_processed.add('primaryVMOwner')
            outfile.write(' primaryVMOwner=%s' % (self.gds_format_string(quote_attrib(self.primaryVMOwner).encode(ExternalEncoding), input_name='primaryVMOwner'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            outfile.write(' isDeleted="%s"' % self.gds_format_boolean(self.isDeleted, input_name='isDeleted'))
        if self.datastoreName is not None and 'datastoreName' not in already_processed:
            already_processed.add('datastoreName')
            outfile.write(' datastoreName=%s' % (self.gds_format_string(quote_attrib(self.datastoreName).encode(ExternalEncoding), input_name='datastoreName'), ))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            outfile.write(' isPublished="%s"' % self.gds_format_boolean(self.isPublished, input_name='isPublished'))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.shadowVApp is not None and 'shadowVApp' not in already_processed:
            already_processed.add('shadowVApp')
            outfile.write(' shadowVApp=%s' % (self.gds_format_string(quote_attrib(self.shadowVApp).encode(ExternalEncoding), input_name='shadowVApp'), ))
        if self.primaryVMCatalog is not None and 'primaryVMCatalog' not in already_processed:
            already_processed.add('primaryVMCatalog')
            outfile.write(' primaryVMCatalog=%s' % (self.gds_format_string(quote_attrib(self.primaryVMCatalog).encode(ExternalEncoding), input_name='primaryVMCatalog'), ))
        if self.primaryVAppName is not None and 'primaryVAppName' not in already_processed:
            already_processed.add('primaryVAppName')
            outfile.write(' primaryVAppName=%s' % (self.gds_format_string(quote_attrib(self.primaryVAppName).encode(ExternalEncoding), input_name='primaryVAppName'), ))
        if self.primaryVAppTemplate is not None and 'primaryVAppTemplate' not in already_processed:
            already_processed.add('primaryVAppTemplate')
            outfile.write(' primaryVAppTemplate=%s' % (self.gds_format_string(quote_attrib(self.primaryVAppTemplate).encode(ExternalEncoding), input_name='primaryVAppTemplate'), ))
        if self.primaryVmName is not None and 'primaryVmName' not in already_processed:
            already_processed.add('primaryVmName')
            outfile.write(' primaryVmName=%s' % (self.gds_format_string(quote_attrib(self.primaryVmName).encode(ExternalEncoding), input_name='primaryVmName'), ))
        if self.primaryVM is not None and 'primaryVM' not in already_processed:
            already_processed.add('primaryVM')
            outfile.write(' primaryVM=%s' % (self.gds_format_string(quote_attrib(self.primaryVM).encode(ExternalEncoding), input_name='primaryVM'), ))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            outfile.write(' vcName=%s' % (self.gds_format_string(quote_attrib(self.vcName).encode(ExternalEncoding), input_name='vcName'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminShadowVMRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminShadowVMRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminShadowVMRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.primaryVMOwner is not None and 'primaryVMOwner' not in already_processed:
            already_processed.add('primaryVMOwner')
            showIndent(outfile, level)
            outfile.write('primaryVMOwner="%s",\n' % (self.primaryVMOwner,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.isDeleted is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            showIndent(outfile, level)
            outfile.write('isDeleted=%s,\n' % (self.isDeleted,))
        if self.datastoreName is not None and 'datastoreName' not in already_processed:
            already_processed.add('datastoreName')
            showIndent(outfile, level)
            outfile.write('datastoreName="%s",\n' % (self.datastoreName,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.isPublished is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            showIndent(outfile, level)
            outfile.write('isPublished=%s,\n' % (self.isPublished,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.shadowVApp is not None and 'shadowVApp' not in already_processed:
            already_processed.add('shadowVApp')
            showIndent(outfile, level)
            outfile.write('shadowVApp="%s",\n' % (self.shadowVApp,))
        if self.primaryVMCatalog is not None and 'primaryVMCatalog' not in already_processed:
            already_processed.add('primaryVMCatalog')
            showIndent(outfile, level)
            outfile.write('primaryVMCatalog="%s",\n' % (self.primaryVMCatalog,))
        if self.primaryVAppName is not None and 'primaryVAppName' not in already_processed:
            already_processed.add('primaryVAppName')
            showIndent(outfile, level)
            outfile.write('primaryVAppName="%s",\n' % (self.primaryVAppName,))
        if self.primaryVAppTemplate is not None and 'primaryVAppTemplate' not in already_processed:
            already_processed.add('primaryVAppTemplate')
            showIndent(outfile, level)
            outfile.write('primaryVAppTemplate="%s",\n' % (self.primaryVAppTemplate,))
        if self.primaryVmName is not None and 'primaryVmName' not in already_processed:
            already_processed.add('primaryVmName')
            showIndent(outfile, level)
            outfile.write('primaryVmName="%s",\n' % (self.primaryVmName,))
        if self.primaryVM is not None and 'primaryVM' not in already_processed:
            already_processed.add('primaryVM')
            showIndent(outfile, level)
            outfile.write('primaryVM="%s",\n' % (self.primaryVM,))
        if self.vcName is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            showIndent(outfile, level)
            outfile.write('vcName="%s",\n' % (self.vcName,))
        super(QueryResultAdminShadowVMRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminShadowVMRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('primaryVMOwner', node)
        if value is not None and 'primaryVMOwner' not in already_processed:
            already_processed.add('primaryVMOwner')
            self.primaryVMOwner = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('isDeleted', node)
        if value is not None and 'isDeleted' not in already_processed:
            already_processed.add('isDeleted')
            if value in ('true', '1'):
                self.isDeleted = True
            elif value in ('false', '0'):
                self.isDeleted = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('datastoreName', node)
        if value is not None and 'datastoreName' not in already_processed:
            already_processed.add('datastoreName')
            self.datastoreName = value
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('isPublished', node)
        if value is not None and 'isPublished' not in already_processed:
            already_processed.add('isPublished')
            if value in ('true', '1'):
                self.isPublished = True
            elif value in ('false', '0'):
                self.isPublished = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('shadowVApp', node)
        if value is not None and 'shadowVApp' not in already_processed:
            already_processed.add('shadowVApp')
            self.shadowVApp = value
        value = find_attr_value_('primaryVMCatalog', node)
        if value is not None and 'primaryVMCatalog' not in already_processed:
            already_processed.add('primaryVMCatalog')
            self.primaryVMCatalog = value
        value = find_attr_value_('primaryVAppName', node)
        if value is not None and 'primaryVAppName' not in already_processed:
            already_processed.add('primaryVAppName')
            self.primaryVAppName = value
        value = find_attr_value_('primaryVAppTemplate', node)
        if value is not None and 'primaryVAppTemplate' not in already_processed:
            already_processed.add('primaryVAppTemplate')
            self.primaryVAppTemplate = value
        value = find_attr_value_('primaryVmName', node)
        if value is not None and 'primaryVmName' not in already_processed:
            already_processed.add('primaryVmName')
            self.primaryVmName = value
        value = find_attr_value_('primaryVM', node)
        if value is not None and 'primaryVM' not in already_processed:
            already_processed.add('primaryVM')
            self.primaryVM = value
        value = find_attr_value_('vcName', node)
        if value is not None and 'vcName' not in already_processed:
            already_processed.add('vcName')
            self.vcName = value
        super(QueryResultAdminShadowVMRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminShadowVMRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminShadowVMRecordType


class QueryResultTaskRecordType(QueryResultRecordType):
    """1.5 Type for a single task query result in records format. 1.5none
    Organization reference or id 1.5none Organization name 1.5none
    The name of this task. 1.5none Start date 1.5none End date
    1.5none Status 1.5none Owner name 1.5none Object 1.5none Object
    type 1.5none Object name 5.1none Service name space"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, startDate=None, endDate=None, name=None, objectName=None, orgName=None, object=None, ownerName=None, org=None, serviceNamespace=None, objectType=None):
        self.original_tagname_ = None
        super(QueryResultTaskRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        if isinstance(startDate, basestring):
            initvalue_ = datetime_.datetime.strptime(startDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = startDate
        self.startDate = initvalue_
        if isinstance(endDate, basestring):
            initvalue_ = datetime_.datetime.strptime(endDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = endDate
        self.endDate = initvalue_
        self.name = _cast(None, name)
        self.objectName = _cast(None, objectName)
        self.orgName = _cast(None, orgName)
        self.object = _cast(None, object)
        self.ownerName = _cast(None, ownerName)
        self.org = _cast(None, org)
        self.serviceNamespace = _cast(None, serviceNamespace)
        self.objectType = _cast(None, objectType)
    def factory(*args_, **kwargs_):
        if QueryResultTaskRecordType.subclass:
            return QueryResultTaskRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultTaskRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_startDate(self): return self.startDate
    def set_startDate(self, startDate): self.startDate = startDate
    def get_endDate(self): return self.endDate
    def set_endDate(self, endDate): self.endDate = endDate
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_objectName(self): return self.objectName
    def set_objectName(self, objectName): self.objectName = objectName
    def get_orgName(self): return self.orgName
    def set_orgName(self, orgName): self.orgName = orgName
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_serviceNamespace(self): return self.serviceNamespace
    def set_serviceNamespace(self, serviceNamespace): self.serviceNamespace = serviceNamespace
    def get_objectType(self): return self.objectType
    def set_objectType(self, objectType): self.objectType = objectType
    def hasContent_(self):
        if (
            super(QueryResultTaskRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultTaskRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultTaskRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultTaskRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultTaskRecordType'):
        super(QueryResultTaskRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultTaskRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.startDate is not None and 'startDate' not in already_processed:
            already_processed.add('startDate')
            outfile.write(' startDate="%s"' % self.gds_format_datetime(self.startDate, input_name='startDate'))
        if self.endDate is not None and 'endDate' not in already_processed:
            already_processed.add('endDate')
            outfile.write(' endDate="%s"' % self.gds_format_datetime(self.endDate, input_name='endDate'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.objectName is not None and 'objectName' not in already_processed:
            already_processed.add('objectName')
            outfile.write(' objectName=%s' % (self.gds_format_string(quote_attrib(self.objectName).encode(ExternalEncoding), input_name='objectName'), ))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            outfile.write(' orgName=%s' % (self.gds_format_string(quote_attrib(self.orgName).encode(ExternalEncoding), input_name='orgName'), ))
        if self.object is not None and 'object' not in already_processed:
            already_processed.add('object')
            outfile.write(' object=%s' % (self.gds_format_string(quote_attrib(self.object).encode(ExternalEncoding), input_name='object'), ))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            outfile.write(' serviceNamespace=%s' % (self.gds_format_string(quote_attrib(self.serviceNamespace).encode(ExternalEncoding), input_name='serviceNamespace'), ))
        if self.objectType is not None and 'objectType' not in already_processed:
            already_processed.add('objectType')
            outfile.write(' objectType=%s' % (self.gds_format_string(quote_attrib(self.objectType).encode(ExternalEncoding), input_name='objectType'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultTaskRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultTaskRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultTaskRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.startDate is not None and 'startDate' not in already_processed:
            already_processed.add('startDate')
            showIndent(outfile, level)
            outfile.write('startDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.startDate, input_name='startDate'))
        if self.endDate is not None and 'endDate' not in already_processed:
            already_processed.add('endDate')
            showIndent(outfile, level)
            outfile.write('endDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.endDate, input_name='endDate'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.objectName is not None and 'objectName' not in already_processed:
            already_processed.add('objectName')
            showIndent(outfile, level)
            outfile.write('objectName="%s",\n' % (self.objectName,))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            showIndent(outfile, level)
            outfile.write('orgName="%s",\n' % (self.orgName,))
        if self.object is not None and 'object' not in already_processed:
            already_processed.add('object')
            showIndent(outfile, level)
            outfile.write('object="%s",\n' % (self.object,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            showIndent(outfile, level)
            outfile.write('serviceNamespace="%s",\n' % (self.serviceNamespace,))
        if self.objectType is not None and 'objectType' not in already_processed:
            already_processed.add('objectType')
            showIndent(outfile, level)
            outfile.write('objectType="%s",\n' % (self.objectType,))
        super(QueryResultTaskRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultTaskRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('startDate', node)
        if value is not None and 'startDate' not in already_processed:
            already_processed.add('startDate')
            try:
                self.startDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (startDate): %s' % exp)
        value = find_attr_value_('endDate', node)
        if value is not None and 'endDate' not in already_processed:
            already_processed.add('endDate')
            try:
                self.endDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (endDate): %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('objectName', node)
        if value is not None and 'objectName' not in already_processed:
            already_processed.add('objectName')
            self.objectName = value
        value = find_attr_value_('orgName', node)
        if value is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            self.orgName = value
        value = find_attr_value_('object', node)
        if value is not None and 'object' not in already_processed:
            already_processed.add('object')
            self.object = value
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('serviceNamespace', node)
        if value is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            self.serviceNamespace = value
        value = find_attr_value_('objectType', node)
        if value is not None and 'objectType' not in already_processed:
            already_processed.add('objectType')
            self.objectType = value
        super(QueryResultTaskRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultTaskRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultTaskRecordType


class QueryResultAdminTaskRecordType(QueryResultRecordType):
    """1.5 Type for a single adminTask query result in records format.
    1.5none Organization reference or id 1.5none Organization name
    1.5none The name of this task. 1.5none Start date 1.5none End
    date 1.5none Status 1.5none Owner reference or id 1.5none Owner
    name 1.5none Object 1.5none Object type 1.5none Object name
    1.5none Cell name 5.1none Service name space 5.1none True if
    this task has an owner."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, startDate=None, endDate=None, name=None, objectName=None, orgName=None, cellName=None, object=None, hasOwner=None, ownerName=None, owner=None, org=None, serviceNamespace=None, objectType=None):
        self.original_tagname_ = None
        super(QueryResultAdminTaskRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        if isinstance(startDate, basestring):
            initvalue_ = datetime_.datetime.strptime(startDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = startDate
        self.startDate = initvalue_
        if isinstance(endDate, basestring):
            initvalue_ = datetime_.datetime.strptime(endDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = endDate
        self.endDate = initvalue_
        self.name = _cast(None, name)
        self.objectName = _cast(None, objectName)
        self.orgName = _cast(None, orgName)
        self.cellName = _cast(None, cellName)
        self.object = _cast(None, object)
        self.hasOwner = _cast(bool, hasOwner)
        self.ownerName = _cast(None, ownerName)
        self.owner = _cast(None, owner)
        self.org = _cast(None, org)
        self.serviceNamespace = _cast(None, serviceNamespace)
        self.objectType = _cast(None, objectType)
    def factory(*args_, **kwargs_):
        if QueryResultAdminTaskRecordType.subclass:
            return QueryResultAdminTaskRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminTaskRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_startDate(self): return self.startDate
    def set_startDate(self, startDate): self.startDate = startDate
    def get_endDate(self): return self.endDate
    def set_endDate(self, endDate): self.endDate = endDate
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_objectName(self): return self.objectName
    def set_objectName(self, objectName): self.objectName = objectName
    def get_orgName(self): return self.orgName
    def set_orgName(self, orgName): self.orgName = orgName
    def get_cellName(self): return self.cellName
    def set_cellName(self, cellName): self.cellName = cellName
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_hasOwner(self): return self.hasOwner
    def set_hasOwner(self, hasOwner): self.hasOwner = hasOwner
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_owner(self): return self.owner
    def set_owner(self, owner): self.owner = owner
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_serviceNamespace(self): return self.serviceNamespace
    def set_serviceNamespace(self, serviceNamespace): self.serviceNamespace = serviceNamespace
    def get_objectType(self): return self.objectType
    def set_objectType(self, objectType): self.objectType = objectType
    def hasContent_(self):
        if (
            super(QueryResultAdminTaskRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminTaskRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminTaskRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminTaskRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminTaskRecordType'):
        super(QueryResultAdminTaskRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminTaskRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.startDate is not None and 'startDate' not in already_processed:
            already_processed.add('startDate')
            outfile.write(' startDate="%s"' % self.gds_format_datetime(self.startDate, input_name='startDate'))
        if self.endDate is not None and 'endDate' not in already_processed:
            already_processed.add('endDate')
            outfile.write(' endDate="%s"' % self.gds_format_datetime(self.endDate, input_name='endDate'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.objectName is not None and 'objectName' not in already_processed:
            already_processed.add('objectName')
            outfile.write(' objectName=%s' % (self.gds_format_string(quote_attrib(self.objectName).encode(ExternalEncoding), input_name='objectName'), ))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            outfile.write(' orgName=%s' % (self.gds_format_string(quote_attrib(self.orgName).encode(ExternalEncoding), input_name='orgName'), ))
        if self.cellName is not None and 'cellName' not in already_processed:
            already_processed.add('cellName')
            outfile.write(' cellName=%s' % (self.gds_format_string(quote_attrib(self.cellName).encode(ExternalEncoding), input_name='cellName'), ))
        if self.object is not None and 'object' not in already_processed:
            already_processed.add('object')
            outfile.write(' object=%s' % (self.gds_format_string(quote_attrib(self.object).encode(ExternalEncoding), input_name='object'), ))
        if self.hasOwner is not None and 'hasOwner' not in already_processed:
            already_processed.add('hasOwner')
            outfile.write(' hasOwner="%s"' % self.gds_format_boolean(self.hasOwner, input_name='hasOwner'))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            outfile.write(' owner=%s' % (self.gds_format_string(quote_attrib(self.owner).encode(ExternalEncoding), input_name='owner'), ))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            outfile.write(' serviceNamespace=%s' % (self.gds_format_string(quote_attrib(self.serviceNamespace).encode(ExternalEncoding), input_name='serviceNamespace'), ))
        if self.objectType is not None and 'objectType' not in already_processed:
            already_processed.add('objectType')
            outfile.write(' objectType=%s' % (self.gds_format_string(quote_attrib(self.objectType).encode(ExternalEncoding), input_name='objectType'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminTaskRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminTaskRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminTaskRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.startDate is not None and 'startDate' not in already_processed:
            already_processed.add('startDate')
            showIndent(outfile, level)
            outfile.write('startDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.startDate, input_name='startDate'))
        if self.endDate is not None and 'endDate' not in already_processed:
            already_processed.add('endDate')
            showIndent(outfile, level)
            outfile.write('endDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.endDate, input_name='endDate'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.objectName is not None and 'objectName' not in already_processed:
            already_processed.add('objectName')
            showIndent(outfile, level)
            outfile.write('objectName="%s",\n' % (self.objectName,))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            showIndent(outfile, level)
            outfile.write('orgName="%s",\n' % (self.orgName,))
        if self.cellName is not None and 'cellName' not in already_processed:
            already_processed.add('cellName')
            showIndent(outfile, level)
            outfile.write('cellName="%s",\n' % (self.cellName,))
        if self.object is not None and 'object' not in already_processed:
            already_processed.add('object')
            showIndent(outfile, level)
            outfile.write('object="%s",\n' % (self.object,))
        if self.hasOwner is not None and 'hasOwner' not in already_processed:
            already_processed.add('hasOwner')
            showIndent(outfile, level)
            outfile.write('hasOwner=%s,\n' % (self.hasOwner,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            showIndent(outfile, level)
            outfile.write('owner="%s",\n' % (self.owner,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            showIndent(outfile, level)
            outfile.write('serviceNamespace="%s",\n' % (self.serviceNamespace,))
        if self.objectType is not None and 'objectType' not in already_processed:
            already_processed.add('objectType')
            showIndent(outfile, level)
            outfile.write('objectType="%s",\n' % (self.objectType,))
        super(QueryResultAdminTaskRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminTaskRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('startDate', node)
        if value is not None and 'startDate' not in already_processed:
            already_processed.add('startDate')
            try:
                self.startDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (startDate): %s' % exp)
        value = find_attr_value_('endDate', node)
        if value is not None and 'endDate' not in already_processed:
            already_processed.add('endDate')
            try:
                self.endDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (endDate): %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('objectName', node)
        if value is not None and 'objectName' not in already_processed:
            already_processed.add('objectName')
            self.objectName = value
        value = find_attr_value_('orgName', node)
        if value is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            self.orgName = value
        value = find_attr_value_('cellName', node)
        if value is not None and 'cellName' not in already_processed:
            already_processed.add('cellName')
            self.cellName = value
        value = find_attr_value_('object', node)
        if value is not None and 'object' not in already_processed:
            already_processed.add('object')
            self.object = value
        value = find_attr_value_('hasOwner', node)
        if value is not None and 'hasOwner' not in already_processed:
            already_processed.add('hasOwner')
            if value in ('true', '1'):
                self.hasOwner = True
            elif value in ('false', '0'):
                self.hasOwner = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('owner', node)
        if value is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            self.owner = value
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('serviceNamespace', node)
        if value is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            self.serviceNamespace = value
        value = find_attr_value_('objectType', node)
        if value is not None and 'objectType' not in already_processed:
            already_processed.add('objectType')
            self.objectType = value
        super(QueryResultAdminTaskRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminTaskRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminTaskRecordType


class QueryResultBlockingTaskRecordType(QueryResultRecordType):
    """1.5 Type for a single blockingTask query result in records format.
    1.5none Status 1.5none Operation name 1.5none Owner reference or
    id 1.5none Owner name 1.5none Originating organization name
    1.5none Organization reference or id 1.5none Creation date
    1.5none Expiration time 1.5none Time action 1.5none task
    reference or id 1.5none Job status 5.1none True if this blocking
    task has an owner."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, originatingOrg=None, task=None, timeoutAction=None, originatingOrgName=None, operationName=None, hasOwner=None, jobStatus=None, ownerName=None, owner=None, expirationTime=None, creationDate=None):
        self.original_tagname_ = None
        super(QueryResultBlockingTaskRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        self.originatingOrg = _cast(None, originatingOrg)
        self.task = _cast(None, task)
        self.timeoutAction = _cast(None, timeoutAction)
        self.originatingOrgName = _cast(None, originatingOrgName)
        self.operationName = _cast(None, operationName)
        self.hasOwner = _cast(bool, hasOwner)
        self.jobStatus = _cast(None, jobStatus)
        self.ownerName = _cast(None, ownerName)
        self.owner = _cast(None, owner)
        if isinstance(expirationTime, basestring):
            initvalue_ = datetime_.datetime.strptime(expirationTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expirationTime
        self.expirationTime = initvalue_
        if isinstance(creationDate, basestring):
            initvalue_ = datetime_.datetime.strptime(creationDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creationDate
        self.creationDate = initvalue_
    def factory(*args_, **kwargs_):
        if QueryResultBlockingTaskRecordType.subclass:
            return QueryResultBlockingTaskRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultBlockingTaskRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_originatingOrg(self): return self.originatingOrg
    def set_originatingOrg(self, originatingOrg): self.originatingOrg = originatingOrg
    def get_task(self): return self.task
    def set_task(self, task): self.task = task
    def get_timeoutAction(self): return self.timeoutAction
    def set_timeoutAction(self, timeoutAction): self.timeoutAction = timeoutAction
    def get_originatingOrgName(self): return self.originatingOrgName
    def set_originatingOrgName(self, originatingOrgName): self.originatingOrgName = originatingOrgName
    def get_operationName(self): return self.operationName
    def set_operationName(self, operationName): self.operationName = operationName
    def get_hasOwner(self): return self.hasOwner
    def set_hasOwner(self, hasOwner): self.hasOwner = hasOwner
    def get_jobStatus(self): return self.jobStatus
    def set_jobStatus(self, jobStatus): self.jobStatus = jobStatus
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_owner(self): return self.owner
    def set_owner(self, owner): self.owner = owner
    def get_expirationTime(self): return self.expirationTime
    def set_expirationTime(self, expirationTime): self.expirationTime = expirationTime
    def get_creationDate(self): return self.creationDate
    def set_creationDate(self, creationDate): self.creationDate = creationDate
    def hasContent_(self):
        if (
            super(QueryResultBlockingTaskRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultBlockingTaskRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultBlockingTaskRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultBlockingTaskRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultBlockingTaskRecordType'):
        super(QueryResultBlockingTaskRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultBlockingTaskRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.originatingOrg is not None and 'originatingOrg' not in already_processed:
            already_processed.add('originatingOrg')
            outfile.write(' originatingOrg=%s' % (self.gds_format_string(quote_attrib(self.originatingOrg).encode(ExternalEncoding), input_name='originatingOrg'), ))
        if self.task is not None and 'task' not in already_processed:
            already_processed.add('task')
            outfile.write(' task=%s' % (self.gds_format_string(quote_attrib(self.task).encode(ExternalEncoding), input_name='task'), ))
        if self.timeoutAction is not None and 'timeoutAction' not in already_processed:
            already_processed.add('timeoutAction')
            outfile.write(' timeoutAction=%s' % (self.gds_format_string(quote_attrib(self.timeoutAction).encode(ExternalEncoding), input_name='timeoutAction'), ))
        if self.originatingOrgName is not None and 'originatingOrgName' not in already_processed:
            already_processed.add('originatingOrgName')
            outfile.write(' originatingOrgName=%s' % (self.gds_format_string(quote_attrib(self.originatingOrgName).encode(ExternalEncoding), input_name='originatingOrgName'), ))
        if self.operationName is not None and 'operationName' not in already_processed:
            already_processed.add('operationName')
            outfile.write(' operationName=%s' % (self.gds_format_string(quote_attrib(self.operationName).encode(ExternalEncoding), input_name='operationName'), ))
        if self.hasOwner is not None and 'hasOwner' not in already_processed:
            already_processed.add('hasOwner')
            outfile.write(' hasOwner="%s"' % self.gds_format_boolean(self.hasOwner, input_name='hasOwner'))
        if self.jobStatus is not None and 'jobStatus' not in already_processed:
            already_processed.add('jobStatus')
            outfile.write(' jobStatus=%s' % (self.gds_format_string(quote_attrib(self.jobStatus).encode(ExternalEncoding), input_name='jobStatus'), ))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            outfile.write(' owner=%s' % (self.gds_format_string(quote_attrib(self.owner).encode(ExternalEncoding), input_name='owner'), ))
        if self.expirationTime is not None and 'expirationTime' not in already_processed:
            already_processed.add('expirationTime')
            outfile.write(' expirationTime="%s"' % self.gds_format_datetime(self.expirationTime, input_name='expirationTime'))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            outfile.write(' creationDate="%s"' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultBlockingTaskRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultBlockingTaskRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultBlockingTaskRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.originatingOrg is not None and 'originatingOrg' not in already_processed:
            already_processed.add('originatingOrg')
            showIndent(outfile, level)
            outfile.write('originatingOrg="%s",\n' % (self.originatingOrg,))
        if self.task is not None and 'task' not in already_processed:
            already_processed.add('task')
            showIndent(outfile, level)
            outfile.write('task="%s",\n' % (self.task,))
        if self.timeoutAction is not None and 'timeoutAction' not in already_processed:
            already_processed.add('timeoutAction')
            showIndent(outfile, level)
            outfile.write('timeoutAction="%s",\n' % (self.timeoutAction,))
        if self.originatingOrgName is not None and 'originatingOrgName' not in already_processed:
            already_processed.add('originatingOrgName')
            showIndent(outfile, level)
            outfile.write('originatingOrgName="%s",\n' % (self.originatingOrgName,))
        if self.operationName is not None and 'operationName' not in already_processed:
            already_processed.add('operationName')
            showIndent(outfile, level)
            outfile.write('operationName="%s",\n' % (self.operationName,))
        if self.hasOwner is not None and 'hasOwner' not in already_processed:
            already_processed.add('hasOwner')
            showIndent(outfile, level)
            outfile.write('hasOwner=%s,\n' % (self.hasOwner,))
        if self.jobStatus is not None and 'jobStatus' not in already_processed:
            already_processed.add('jobStatus')
            showIndent(outfile, level)
            outfile.write('jobStatus="%s",\n' % (self.jobStatus,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            showIndent(outfile, level)
            outfile.write('owner="%s",\n' % (self.owner,))
        if self.expirationTime is not None and 'expirationTime' not in already_processed:
            already_processed.add('expirationTime')
            showIndent(outfile, level)
            outfile.write('expirationTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.expirationTime, input_name='expirationTime'))
        if self.creationDate is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            showIndent(outfile, level)
            outfile.write('creationDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.creationDate, input_name='creationDate'))
        super(QueryResultBlockingTaskRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultBlockingTaskRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('originatingOrg', node)
        if value is not None and 'originatingOrg' not in already_processed:
            already_processed.add('originatingOrg')
            self.originatingOrg = value
        value = find_attr_value_('task', node)
        if value is not None and 'task' not in already_processed:
            already_processed.add('task')
            self.task = value
        value = find_attr_value_('timeoutAction', node)
        if value is not None and 'timeoutAction' not in already_processed:
            already_processed.add('timeoutAction')
            self.timeoutAction = value
        value = find_attr_value_('originatingOrgName', node)
        if value is not None and 'originatingOrgName' not in already_processed:
            already_processed.add('originatingOrgName')
            self.originatingOrgName = value
        value = find_attr_value_('operationName', node)
        if value is not None and 'operationName' not in already_processed:
            already_processed.add('operationName')
            self.operationName = value
        value = find_attr_value_('hasOwner', node)
        if value is not None and 'hasOwner' not in already_processed:
            already_processed.add('hasOwner')
            if value in ('true', '1'):
                self.hasOwner = True
            elif value in ('false', '0'):
                self.hasOwner = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('jobStatus', node)
        if value is not None and 'jobStatus' not in already_processed:
            already_processed.add('jobStatus')
            self.jobStatus = value
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('owner', node)
        if value is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            self.owner = value
        value = find_attr_value_('expirationTime', node)
        if value is not None and 'expirationTime' not in already_processed:
            already_processed.add('expirationTime')
            try:
                self.expirationTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (expirationTime): %s' % exp)
        value = find_attr_value_('creationDate', node)
        if value is not None and 'creationDate' not in already_processed:
            already_processed.add('creationDate')
            try:
                self.creationDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (creationDate): %s' % exp)
        super(QueryResultBlockingTaskRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultBlockingTaskRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultBlockingTaskRecordType


class QueryResultDiskRecordType(QueryResultRecordType):
    """5.1 Type for a single disk query result in records format. 5.1none
    Disk name 5.1none VDC reference or id 5.1none Size of the disk
    in bytes 5.1none Datastore reference or id 5.1none Datastore
    name 5.1none Owner name 5.1none VDC name 5.1none In-progress
    task reference or id 5.1none Storage profile reference or id
    5.1none Storage profile name 5.1none Disk status 5.1none Disk
    controller type 5.1none Disk controller type description 5.1none
    Disk controller subtype 5.1none True if the disk is already
    attached."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, storageProfileName=None, task=None, name=None, storageProfile=None, datastoreName=None, busType=None, vdcName=None, vdc=None, busSubType=None, ownerName=None, sizeB=None, isAttached=None, datastore=None, busTypeDesc=None):
        self.original_tagname_ = None
        super(QueryResultDiskRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        self.storageProfileName = _cast(None, storageProfileName)
        self.task = _cast(None, task)
        self.name = _cast(None, name)
        self.storageProfile = _cast(None, storageProfile)
        self.datastoreName = _cast(None, datastoreName)
        self.busType = _cast(None, busType)
        self.vdcName = _cast(None, vdcName)
        self.vdc = _cast(None, vdc)
        self.busSubType = _cast(None, busSubType)
        self.ownerName = _cast(None, ownerName)
        self.sizeB = _cast(int, sizeB)
        self.isAttached = _cast(bool, isAttached)
        self.datastore = _cast(None, datastore)
        self.busTypeDesc = _cast(None, busTypeDesc)
    def factory(*args_, **kwargs_):
        if QueryResultDiskRecordType.subclass:
            return QueryResultDiskRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultDiskRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_storageProfileName(self): return self.storageProfileName
    def set_storageProfileName(self, storageProfileName): self.storageProfileName = storageProfileName
    def get_task(self): return self.task
    def set_task(self, task): self.task = task
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_storageProfile(self): return self.storageProfile
    def set_storageProfile(self, storageProfile): self.storageProfile = storageProfile
    def get_datastoreName(self): return self.datastoreName
    def set_datastoreName(self, datastoreName): self.datastoreName = datastoreName
    def get_busType(self): return self.busType
    def set_busType(self, busType): self.busType = busType
    def get_vdcName(self): return self.vdcName
    def set_vdcName(self, vdcName): self.vdcName = vdcName
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_busSubType(self): return self.busSubType
    def set_busSubType(self, busSubType): self.busSubType = busSubType
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_sizeB(self): return self.sizeB
    def set_sizeB(self, sizeB): self.sizeB = sizeB
    def get_isAttached(self): return self.isAttached
    def set_isAttached(self, isAttached): self.isAttached = isAttached
    def get_datastore(self): return self.datastore
    def set_datastore(self, datastore): self.datastore = datastore
    def get_busTypeDesc(self): return self.busTypeDesc
    def set_busTypeDesc(self, busTypeDesc): self.busTypeDesc = busTypeDesc
    def hasContent_(self):
        if (
            super(QueryResultDiskRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultDiskRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultDiskRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultDiskRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultDiskRecordType'):
        super(QueryResultDiskRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultDiskRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            outfile.write(' storageProfileName=%s' % (self.gds_format_string(quote_attrib(self.storageProfileName).encode(ExternalEncoding), input_name='storageProfileName'), ))
        if self.task is not None and 'task' not in already_processed:
            already_processed.add('task')
            outfile.write(' task=%s' % (self.gds_format_string(quote_attrib(self.task).encode(ExternalEncoding), input_name='task'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.storageProfile is not None and 'storageProfile' not in already_processed:
            already_processed.add('storageProfile')
            outfile.write(' storageProfile=%s' % (self.gds_format_string(quote_attrib(self.storageProfile).encode(ExternalEncoding), input_name='storageProfile'), ))
        if self.datastoreName is not None and 'datastoreName' not in already_processed:
            already_processed.add('datastoreName')
            outfile.write(' datastoreName=%s' % (self.gds_format_string(quote_attrib(self.datastoreName).encode(ExternalEncoding), input_name='datastoreName'), ))
        if self.busType is not None and 'busType' not in already_processed:
            already_processed.add('busType')
            outfile.write(' busType=%s' % (self.gds_format_string(quote_attrib(self.busType).encode(ExternalEncoding), input_name='busType'), ))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            outfile.write(' vdcName=%s' % (self.gds_format_string(quote_attrib(self.vdcName).encode(ExternalEncoding), input_name='vdcName'), ))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.busSubType is not None and 'busSubType' not in already_processed:
            already_processed.add('busSubType')
            outfile.write(' busSubType=%s' % (self.gds_format_string(quote_attrib(self.busSubType).encode(ExternalEncoding), input_name='busSubType'), ))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.sizeB is not None and 'sizeB' not in already_processed:
            already_processed.add('sizeB')
            outfile.write(' sizeB="%s"' % self.gds_format_integer(self.sizeB, input_name='sizeB'))
        if self.isAttached is not None and 'isAttached' not in already_processed:
            already_processed.add('isAttached')
            outfile.write(' isAttached="%s"' % self.gds_format_boolean(self.isAttached, input_name='isAttached'))
        if self.datastore is not None and 'datastore' not in already_processed:
            already_processed.add('datastore')
            outfile.write(' datastore=%s' % (self.gds_format_string(quote_attrib(self.datastore).encode(ExternalEncoding), input_name='datastore'), ))
        if self.busTypeDesc is not None and 'busTypeDesc' not in already_processed:
            already_processed.add('busTypeDesc')
            outfile.write(' busTypeDesc=%s' % (self.gds_format_string(quote_attrib(self.busTypeDesc).encode(ExternalEncoding), input_name='busTypeDesc'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultDiskRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultDiskRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultDiskRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            showIndent(outfile, level)
            outfile.write('storageProfileName="%s",\n' % (self.storageProfileName,))
        if self.task is not None and 'task' not in already_processed:
            already_processed.add('task')
            showIndent(outfile, level)
            outfile.write('task="%s",\n' % (self.task,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.storageProfile is not None and 'storageProfile' not in already_processed:
            already_processed.add('storageProfile')
            showIndent(outfile, level)
            outfile.write('storageProfile="%s",\n' % (self.storageProfile,))
        if self.datastoreName is not None and 'datastoreName' not in already_processed:
            already_processed.add('datastoreName')
            showIndent(outfile, level)
            outfile.write('datastoreName="%s",\n' % (self.datastoreName,))
        if self.busType is not None and 'busType' not in already_processed:
            already_processed.add('busType')
            showIndent(outfile, level)
            outfile.write('busType="%s",\n' % (self.busType,))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            showIndent(outfile, level)
            outfile.write('vdcName="%s",\n' % (self.vdcName,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.busSubType is not None and 'busSubType' not in already_processed:
            already_processed.add('busSubType')
            showIndent(outfile, level)
            outfile.write('busSubType="%s",\n' % (self.busSubType,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.sizeB is not None and 'sizeB' not in already_processed:
            already_processed.add('sizeB')
            showIndent(outfile, level)
            outfile.write('sizeB=%d,\n' % (self.sizeB,))
        if self.isAttached is not None and 'isAttached' not in already_processed:
            already_processed.add('isAttached')
            showIndent(outfile, level)
            outfile.write('isAttached=%s,\n' % (self.isAttached,))
        if self.datastore is not None and 'datastore' not in already_processed:
            already_processed.add('datastore')
            showIndent(outfile, level)
            outfile.write('datastore="%s",\n' % (self.datastore,))
        if self.busTypeDesc is not None and 'busTypeDesc' not in already_processed:
            already_processed.add('busTypeDesc')
            showIndent(outfile, level)
            outfile.write('busTypeDesc="%s",\n' % (self.busTypeDesc,))
        super(QueryResultDiskRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultDiskRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('storageProfileName', node)
        if value is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            self.storageProfileName = value
        value = find_attr_value_('task', node)
        if value is not None and 'task' not in already_processed:
            already_processed.add('task')
            self.task = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('storageProfile', node)
        if value is not None and 'storageProfile' not in already_processed:
            already_processed.add('storageProfile')
            self.storageProfile = value
        value = find_attr_value_('datastoreName', node)
        if value is not None and 'datastoreName' not in already_processed:
            already_processed.add('datastoreName')
            self.datastoreName = value
        value = find_attr_value_('busType', node)
        if value is not None and 'busType' not in already_processed:
            already_processed.add('busType')
            self.busType = value
        value = find_attr_value_('vdcName', node)
        if value is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            self.vdcName = value
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('busSubType', node)
        if value is not None and 'busSubType' not in already_processed:
            already_processed.add('busSubType')
            self.busSubType = value
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('sizeB', node)
        if value is not None and 'sizeB' not in already_processed:
            already_processed.add('sizeB')
            try:
                self.sizeB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isAttached', node)
        if value is not None and 'isAttached' not in already_processed:
            already_processed.add('isAttached')
            if value in ('true', '1'):
                self.isAttached = True
            elif value in ('false', '0'):
                self.isAttached = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('datastore', node)
        if value is not None and 'datastore' not in already_processed:
            already_processed.add('datastore')
            self.datastore = value
        value = find_attr_value_('busTypeDesc', node)
        if value is not None and 'busTypeDesc' not in already_processed:
            already_processed.add('busTypeDesc')
            self.busTypeDesc = value
        super(QueryResultDiskRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultDiskRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultDiskRecordType


class QueryResultVmDiskRelationRecordType(QueryResultRecordType):
    """5.1 Type for a single vmDiskRelation query result in records format.
    5.1none vDc reference or id 5.1none Disk reference or id 5.1none
    Virtual machine reference or id"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, vdc=None, disk=None, vm=None):
        self.original_tagname_ = None
        super(QueryResultVmDiskRelationRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.vdc = _cast(None, vdc)
        self.disk = _cast(None, disk)
        self.vm = _cast(None, vm)
    def factory(*args_, **kwargs_):
        if QueryResultVmDiskRelationRecordType.subclass:
            return QueryResultVmDiskRelationRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultVmDiskRelationRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_disk(self): return self.disk
    def set_disk(self, disk): self.disk = disk
    def get_vm(self): return self.vm
    def set_vm(self, vm): self.vm = vm
    def hasContent_(self):
        if (
            super(QueryResultVmDiskRelationRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultVmDiskRelationRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVmDiskRelationRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultVmDiskRelationRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultVmDiskRelationRecordType'):
        super(QueryResultVmDiskRelationRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVmDiskRelationRecordType')
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.disk is not None and 'disk' not in already_processed:
            already_processed.add('disk')
            outfile.write(' disk=%s' % (self.gds_format_string(quote_attrib(self.disk).encode(ExternalEncoding), input_name='disk'), ))
        if self.vm is not None and 'vm' not in already_processed:
            already_processed.add('vm')
            outfile.write(' vm=%s' % (self.gds_format_string(quote_attrib(self.vm).encode(ExternalEncoding), input_name='vm'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultVmDiskRelationRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultVmDiskRelationRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultVmDiskRelationRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.disk is not None and 'disk' not in already_processed:
            already_processed.add('disk')
            showIndent(outfile, level)
            outfile.write('disk="%s",\n' % (self.disk,))
        if self.vm is not None and 'vm' not in already_processed:
            already_processed.add('vm')
            showIndent(outfile, level)
            outfile.write('vm="%s",\n' % (self.vm,))
        super(QueryResultVmDiskRelationRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultVmDiskRelationRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('disk', node)
        if value is not None and 'disk' not in already_processed:
            already_processed.add('disk')
            self.disk = value
        value = find_attr_value_('vm', node)
        if value is not None and 'vm' not in already_processed:
            already_processed.add('vm')
            self.vm = value
        super(QueryResultVmDiskRelationRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultVmDiskRelationRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultVmDiskRelationRecordType


class QueryResultAdminDiskRecordType(QueryResultRecordType):
    """5.1 Type for a single adminDisk query result in records format.
    5.1none 5.1none VDC reference or id 5.1none Size of disk in
    bytes 5.1none Virtual center reference or id 5.1none Datastore
    reference or id 5.1none Datastore name 5.1none Owner name
    5.1none VDC name 5.1none Organization reference or id 5.1none
    In-progress task reference or id 5.1none Storage profile
    reference or id 5.1none Storage profile reference or id 5.1none
    Disk status 5.1none Disk controller type 5.1none Disk controller
    type description 5.1none Disk controller subtype 5.1none True if
    the disk is already attached."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, storageProfileName=None, vc=None, name=None, storageProfile=None, datastoreName=None, busType=None, vdcName=None, vdc=None, task=None, ownerName=None, sizeB=None, isAttached=None, org=None, datastore=None, busSubType=None, busTypeDesc=None):
        self.original_tagname_ = None
        super(QueryResultAdminDiskRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        self.storageProfileName = _cast(None, storageProfileName)
        self.vc = _cast(None, vc)
        self.name = _cast(None, name)
        self.storageProfile = _cast(None, storageProfile)
        self.datastoreName = _cast(None, datastoreName)
        self.busType = _cast(None, busType)
        self.vdcName = _cast(None, vdcName)
        self.vdc = _cast(None, vdc)
        self.task = _cast(None, task)
        self.ownerName = _cast(None, ownerName)
        self.sizeB = _cast(int, sizeB)
        self.isAttached = _cast(bool, isAttached)
        self.org = _cast(None, org)
        self.datastore = _cast(None, datastore)
        self.busSubType = _cast(None, busSubType)
        self.busTypeDesc = _cast(None, busTypeDesc)
    def factory(*args_, **kwargs_):
        if QueryResultAdminDiskRecordType.subclass:
            return QueryResultAdminDiskRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminDiskRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_storageProfileName(self): return self.storageProfileName
    def set_storageProfileName(self, storageProfileName): self.storageProfileName = storageProfileName
    def get_vc(self): return self.vc
    def set_vc(self, vc): self.vc = vc
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_storageProfile(self): return self.storageProfile
    def set_storageProfile(self, storageProfile): self.storageProfile = storageProfile
    def get_datastoreName(self): return self.datastoreName
    def set_datastoreName(self, datastoreName): self.datastoreName = datastoreName
    def get_busType(self): return self.busType
    def set_busType(self, busType): self.busType = busType
    def get_vdcName(self): return self.vdcName
    def set_vdcName(self, vdcName): self.vdcName = vdcName
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_task(self): return self.task
    def set_task(self, task): self.task = task
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_sizeB(self): return self.sizeB
    def set_sizeB(self, sizeB): self.sizeB = sizeB
    def get_isAttached(self): return self.isAttached
    def set_isAttached(self, isAttached): self.isAttached = isAttached
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_datastore(self): return self.datastore
    def set_datastore(self, datastore): self.datastore = datastore
    def get_busSubType(self): return self.busSubType
    def set_busSubType(self, busSubType): self.busSubType = busSubType
    def get_busTypeDesc(self): return self.busTypeDesc
    def set_busTypeDesc(self, busTypeDesc): self.busTypeDesc = busTypeDesc
    def hasContent_(self):
        if (
            super(QueryResultAdminDiskRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminDiskRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminDiskRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminDiskRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminDiskRecordType'):
        super(QueryResultAdminDiskRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminDiskRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            outfile.write(' storageProfileName=%s' % (self.gds_format_string(quote_attrib(self.storageProfileName).encode(ExternalEncoding), input_name='storageProfileName'), ))
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            outfile.write(' vc=%s' % (self.gds_format_string(quote_attrib(self.vc).encode(ExternalEncoding), input_name='vc'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.storageProfile is not None and 'storageProfile' not in already_processed:
            already_processed.add('storageProfile')
            outfile.write(' storageProfile=%s' % (self.gds_format_string(quote_attrib(self.storageProfile).encode(ExternalEncoding), input_name='storageProfile'), ))
        if self.datastoreName is not None and 'datastoreName' not in already_processed:
            already_processed.add('datastoreName')
            outfile.write(' datastoreName=%s' % (self.gds_format_string(quote_attrib(self.datastoreName).encode(ExternalEncoding), input_name='datastoreName'), ))
        if self.busType is not None and 'busType' not in already_processed:
            already_processed.add('busType')
            outfile.write(' busType=%s' % (self.gds_format_string(quote_attrib(self.busType).encode(ExternalEncoding), input_name='busType'), ))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            outfile.write(' vdcName=%s' % (self.gds_format_string(quote_attrib(self.vdcName).encode(ExternalEncoding), input_name='vdcName'), ))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.task is not None and 'task' not in already_processed:
            already_processed.add('task')
            outfile.write(' task=%s' % (self.gds_format_string(quote_attrib(self.task).encode(ExternalEncoding), input_name='task'), ))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.sizeB is not None and 'sizeB' not in already_processed:
            already_processed.add('sizeB')
            outfile.write(' sizeB="%s"' % self.gds_format_integer(self.sizeB, input_name='sizeB'))
        if self.isAttached is not None and 'isAttached' not in already_processed:
            already_processed.add('isAttached')
            outfile.write(' isAttached="%s"' % self.gds_format_boolean(self.isAttached, input_name='isAttached'))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.datastore is not None and 'datastore' not in already_processed:
            already_processed.add('datastore')
            outfile.write(' datastore=%s' % (self.gds_format_string(quote_attrib(self.datastore).encode(ExternalEncoding), input_name='datastore'), ))
        if self.busSubType is not None and 'busSubType' not in already_processed:
            already_processed.add('busSubType')
            outfile.write(' busSubType=%s' % (self.gds_format_string(quote_attrib(self.busSubType).encode(ExternalEncoding), input_name='busSubType'), ))
        if self.busTypeDesc is not None and 'busTypeDesc' not in already_processed:
            already_processed.add('busTypeDesc')
            outfile.write(' busTypeDesc=%s' % (self.gds_format_string(quote_attrib(self.busTypeDesc).encode(ExternalEncoding), input_name='busTypeDesc'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminDiskRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminDiskRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminDiskRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.storageProfileName is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            showIndent(outfile, level)
            outfile.write('storageProfileName="%s",\n' % (self.storageProfileName,))
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            showIndent(outfile, level)
            outfile.write('vc="%s",\n' % (self.vc,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.storageProfile is not None and 'storageProfile' not in already_processed:
            already_processed.add('storageProfile')
            showIndent(outfile, level)
            outfile.write('storageProfile="%s",\n' % (self.storageProfile,))
        if self.datastoreName is not None and 'datastoreName' not in already_processed:
            already_processed.add('datastoreName')
            showIndent(outfile, level)
            outfile.write('datastoreName="%s",\n' % (self.datastoreName,))
        if self.busType is not None and 'busType' not in already_processed:
            already_processed.add('busType')
            showIndent(outfile, level)
            outfile.write('busType="%s",\n' % (self.busType,))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            showIndent(outfile, level)
            outfile.write('vdcName="%s",\n' % (self.vdcName,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.task is not None and 'task' not in already_processed:
            already_processed.add('task')
            showIndent(outfile, level)
            outfile.write('task="%s",\n' % (self.task,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.sizeB is not None and 'sizeB' not in already_processed:
            already_processed.add('sizeB')
            showIndent(outfile, level)
            outfile.write('sizeB=%d,\n' % (self.sizeB,))
        if self.isAttached is not None and 'isAttached' not in already_processed:
            already_processed.add('isAttached')
            showIndent(outfile, level)
            outfile.write('isAttached=%s,\n' % (self.isAttached,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.datastore is not None and 'datastore' not in already_processed:
            already_processed.add('datastore')
            showIndent(outfile, level)
            outfile.write('datastore="%s",\n' % (self.datastore,))
        if self.busSubType is not None and 'busSubType' not in already_processed:
            already_processed.add('busSubType')
            showIndent(outfile, level)
            outfile.write('busSubType="%s",\n' % (self.busSubType,))
        if self.busTypeDesc is not None and 'busTypeDesc' not in already_processed:
            already_processed.add('busTypeDesc')
            showIndent(outfile, level)
            outfile.write('busTypeDesc="%s",\n' % (self.busTypeDesc,))
        super(QueryResultAdminDiskRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminDiskRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('storageProfileName', node)
        if value is not None and 'storageProfileName' not in already_processed:
            already_processed.add('storageProfileName')
            self.storageProfileName = value
        value = find_attr_value_('vc', node)
        if value is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            self.vc = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('storageProfile', node)
        if value is not None and 'storageProfile' not in already_processed:
            already_processed.add('storageProfile')
            self.storageProfile = value
        value = find_attr_value_('datastoreName', node)
        if value is not None and 'datastoreName' not in already_processed:
            already_processed.add('datastoreName')
            self.datastoreName = value
        value = find_attr_value_('busType', node)
        if value is not None and 'busType' not in already_processed:
            already_processed.add('busType')
            self.busType = value
        value = find_attr_value_('vdcName', node)
        if value is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            self.vdcName = value
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('task', node)
        if value is not None and 'task' not in already_processed:
            already_processed.add('task')
            self.task = value
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('sizeB', node)
        if value is not None and 'sizeB' not in already_processed:
            already_processed.add('sizeB')
            try:
                self.sizeB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isAttached', node)
        if value is not None and 'isAttached' not in already_processed:
            already_processed.add('isAttached')
            if value in ('true', '1'):
                self.isAttached = True
            elif value in ('false', '0'):
                self.isAttached = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('datastore', node)
        if value is not None and 'datastore' not in already_processed:
            already_processed.add('datastore')
            self.datastore = value
        value = find_attr_value_('busSubType', node)
        if value is not None and 'busSubType' not in already_processed:
            already_processed.add('busSubType')
            self.busSubType = value
        value = find_attr_value_('busTypeDesc', node)
        if value is not None and 'busTypeDesc' not in already_processed:
            already_processed.add('busTypeDesc')
            self.busTypeDesc = value
        super(QueryResultAdminDiskRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminDiskRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminDiskRecordType


class QueryResultAdminVmDiskRelationRecordType(QueryResultRecordType):
    """5.1 Type for a single adminVMDiskRelation query result in records
    format. 5.1none VDC reference or id 5.1none Disk reference or id
    5.1none Virtual machine reference or id"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, vdc=None, disk=None, vm=None):
        self.original_tagname_ = None
        super(QueryResultAdminVmDiskRelationRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.vdc = _cast(None, vdc)
        self.disk = _cast(None, disk)
        self.vm = _cast(None, vm)
    def factory(*args_, **kwargs_):
        if QueryResultAdminVmDiskRelationRecordType.subclass:
            return QueryResultAdminVmDiskRelationRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminVmDiskRelationRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_disk(self): return self.disk
    def set_disk(self, disk): self.disk = disk
    def get_vm(self): return self.vm
    def set_vm(self, vm): self.vm = vm
    def hasContent_(self):
        if (
            super(QueryResultAdminVmDiskRelationRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminVmDiskRelationRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminVmDiskRelationRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminVmDiskRelationRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminVmDiskRelationRecordType'):
        super(QueryResultAdminVmDiskRelationRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminVmDiskRelationRecordType')
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.disk is not None and 'disk' not in already_processed:
            already_processed.add('disk')
            outfile.write(' disk=%s' % (self.gds_format_string(quote_attrib(self.disk).encode(ExternalEncoding), input_name='disk'), ))
        if self.vm is not None and 'vm' not in already_processed:
            already_processed.add('vm')
            outfile.write(' vm=%s' % (self.gds_format_string(quote_attrib(self.vm).encode(ExternalEncoding), input_name='vm'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminVmDiskRelationRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminVmDiskRelationRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminVmDiskRelationRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.disk is not None and 'disk' not in already_processed:
            already_processed.add('disk')
            showIndent(outfile, level)
            outfile.write('disk="%s",\n' % (self.disk,))
        if self.vm is not None and 'vm' not in already_processed:
            already_processed.add('vm')
            showIndent(outfile, level)
            outfile.write('vm="%s",\n' % (self.vm,))
        super(QueryResultAdminVmDiskRelationRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminVmDiskRelationRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('disk', node)
        if value is not None and 'disk' not in already_processed:
            already_processed.add('disk')
            self.disk = value
        value = find_attr_value_('vm', node)
        if value is not None and 'vm' not in already_processed:
            already_processed.add('vm')
            self.vm = value
        super(QueryResultAdminVmDiskRelationRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminVmDiskRelationRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminVmDiskRelationRecordType


class QueryResultConditionRecordType(QueryResultRecordType):
    """5.1 Type for a single condition query result in records format.
    5.1none Reference to the entity 5.1none The type of the object.
    5.1none The severity of the condition. One of RED:the integrity
    of the object has been compromised and the object may be
    inaccessible or inoperable. ORANGE: the integrity of the object
    has been compromised. YELLOW: the condition should be
    investigated when convenient. BLUE: object is in consistent
    state. 5.1none A summary of the condition. 5.1none Details of
    the condition. 5.1none Date and time when the condition
    occurred."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, severity=None, object=None, occurenceDate=None, summary=None, details=None, objectType=None):
        self.original_tagname_ = None
        super(QueryResultConditionRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.severity = _cast(None, severity)
        self.object = _cast(None, object)
        if isinstance(occurenceDate, basestring):
            initvalue_ = datetime_.datetime.strptime(occurenceDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = occurenceDate
        self.occurenceDate = initvalue_
        self.summary = _cast(None, summary)
        self.details = _cast(None, details)
        self.objectType = _cast(None, objectType)
    def factory(*args_, **kwargs_):
        if QueryResultConditionRecordType.subclass:
            return QueryResultConditionRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultConditionRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_severity(self): return self.severity
    def set_severity(self, severity): self.severity = severity
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_occurenceDate(self): return self.occurenceDate
    def set_occurenceDate(self, occurenceDate): self.occurenceDate = occurenceDate
    def get_summary(self): return self.summary
    def set_summary(self, summary): self.summary = summary
    def get_details(self): return self.details
    def set_details(self, details): self.details = details
    def get_objectType(self): return self.objectType
    def set_objectType(self, objectType): self.objectType = objectType
    def hasContent_(self):
        if (
            super(QueryResultConditionRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultConditionRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultConditionRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultConditionRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultConditionRecordType'):
        super(QueryResultConditionRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultConditionRecordType')
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.add('severity')
            outfile.write(' severity=%s' % (self.gds_format_string(quote_attrib(self.severity).encode(ExternalEncoding), input_name='severity'), ))
        if self.object is not None and 'object' not in already_processed:
            already_processed.add('object')
            outfile.write(' object=%s' % (self.gds_format_string(quote_attrib(self.object).encode(ExternalEncoding), input_name='object'), ))
        if self.occurenceDate is not None and 'occurenceDate' not in already_processed:
            already_processed.add('occurenceDate')
            outfile.write(' occurenceDate="%s"' % self.gds_format_datetime(self.occurenceDate, input_name='occurenceDate'))
        if self.summary is not None and 'summary' not in already_processed:
            already_processed.add('summary')
            outfile.write(' summary=%s' % (self.gds_format_string(quote_attrib(self.summary).encode(ExternalEncoding), input_name='summary'), ))
        if self.details is not None and 'details' not in already_processed:
            already_processed.add('details')
            outfile.write(' details=%s' % (self.gds_format_string(quote_attrib(self.details).encode(ExternalEncoding), input_name='details'), ))
        if self.objectType is not None and 'objectType' not in already_processed:
            already_processed.add('objectType')
            outfile.write(' objectType=%s' % (self.gds_format_string(quote_attrib(self.objectType).encode(ExternalEncoding), input_name='objectType'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultConditionRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultConditionRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultConditionRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.severity is not None and 'severity' not in already_processed:
            already_processed.add('severity')
            showIndent(outfile, level)
            outfile.write('severity="%s",\n' % (self.severity,))
        if self.object is not None and 'object' not in already_processed:
            already_processed.add('object')
            showIndent(outfile, level)
            outfile.write('object="%s",\n' % (self.object,))
        if self.occurenceDate is not None and 'occurenceDate' not in already_processed:
            already_processed.add('occurenceDate')
            showIndent(outfile, level)
            outfile.write('occurenceDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.occurenceDate, input_name='occurenceDate'))
        if self.summary is not None and 'summary' not in already_processed:
            already_processed.add('summary')
            showIndent(outfile, level)
            outfile.write('summary="%s",\n' % (self.summary,))
        if self.details is not None and 'details' not in already_processed:
            already_processed.add('details')
            showIndent(outfile, level)
            outfile.write('details="%s",\n' % (self.details,))
        if self.objectType is not None and 'objectType' not in already_processed:
            already_processed.add('objectType')
            showIndent(outfile, level)
            outfile.write('objectType="%s",\n' % (self.objectType,))
        super(QueryResultConditionRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultConditionRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('severity', node)
        if value is not None and 'severity' not in already_processed:
            already_processed.add('severity')
            self.severity = value
        value = find_attr_value_('object', node)
        if value is not None and 'object' not in already_processed:
            already_processed.add('object')
            self.object = value
        value = find_attr_value_('occurenceDate', node)
        if value is not None and 'occurenceDate' not in already_processed:
            already_processed.add('occurenceDate')
            try:
                self.occurenceDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (occurenceDate): %s' % exp)
        value = find_attr_value_('summary', node)
        if value is not None and 'summary' not in already_processed:
            already_processed.add('summary')
            self.summary = value
        value = find_attr_value_('details', node)
        if value is not None and 'details' not in already_processed:
            already_processed.add('details')
            self.details = value
        value = find_attr_value_('objectType', node)
        if value is not None and 'objectType' not in already_processed:
            already_processed.add('objectType')
            self.objectType = value
        super(QueryResultConditionRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultConditionRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultConditionRecordType


class QueryResultAdminEventRecordType(QueryResultRecordType):
    """5.1 Type for a single adminEvent query result in records format.
    5.1none Event ID. 5.1none Event type 5.1none Time stamp 5.1none
    Event status 5.1none User name 5.1none Organization name 5.1none
    Entity type 5.1none Entity name 5.1none Service namespace
    5.1none Version of the product 5.1none Entity reference or id
    5.1none Organization reference or id"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, eventId=None, userName=None, orgName=None, eventType=None, entityName=None, entityType=None, entity=None, eventStatus=None, timeStamp=None, org=None, serviceNamespace=None, productVersion=None):
        self.original_tagname_ = None
        super(QueryResultAdminEventRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.eventId = _cast(None, eventId)
        self.userName = _cast(None, userName)
        self.orgName = _cast(None, orgName)
        self.eventType = _cast(None, eventType)
        self.entityName = _cast(None, entityName)
        self.entityType = _cast(None, entityType)
        self.entity = _cast(None, entity)
        self.eventStatus = _cast(int, eventStatus)
        if isinstance(timeStamp, basestring):
            initvalue_ = datetime_.datetime.strptime(timeStamp, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = timeStamp
        self.timeStamp = initvalue_
        self.org = _cast(None, org)
        self.serviceNamespace = _cast(None, serviceNamespace)
        self.productVersion = _cast(None, productVersion)
    def factory(*args_, **kwargs_):
        if QueryResultAdminEventRecordType.subclass:
            return QueryResultAdminEventRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminEventRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_eventId(self): return self.eventId
    def set_eventId(self, eventId): self.eventId = eventId
    def get_userName(self): return self.userName
    def set_userName(self, userName): self.userName = userName
    def get_orgName(self): return self.orgName
    def set_orgName(self, orgName): self.orgName = orgName
    def get_eventType(self): return self.eventType
    def set_eventType(self, eventType): self.eventType = eventType
    def get_entityName(self): return self.entityName
    def set_entityName(self, entityName): self.entityName = entityName
    def get_entityType(self): return self.entityType
    def set_entityType(self, entityType): self.entityType = entityType
    def get_entity(self): return self.entity
    def set_entity(self, entity): self.entity = entity
    def get_eventStatus(self): return self.eventStatus
    def set_eventStatus(self, eventStatus): self.eventStatus = eventStatus
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_serviceNamespace(self): return self.serviceNamespace
    def set_serviceNamespace(self, serviceNamespace): self.serviceNamespace = serviceNamespace
    def get_productVersion(self): return self.productVersion
    def set_productVersion(self, productVersion): self.productVersion = productVersion
    def hasContent_(self):
        if (
            super(QueryResultAdminEventRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminEventRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminEventRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminEventRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminEventRecordType'):
        super(QueryResultAdminEventRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminEventRecordType')
        if self.eventId is not None and 'eventId' not in already_processed:
            already_processed.add('eventId')
            outfile.write(' eventId=%s' % (self.gds_format_string(quote_attrib(self.eventId).encode(ExternalEncoding), input_name='eventId'), ))
        if self.userName is not None and 'userName' not in already_processed:
            already_processed.add('userName')
            outfile.write(' userName=%s' % (self.gds_format_string(quote_attrib(self.userName).encode(ExternalEncoding), input_name='userName'), ))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            outfile.write(' orgName=%s' % (self.gds_format_string(quote_attrib(self.orgName).encode(ExternalEncoding), input_name='orgName'), ))
        if self.eventType is not None and 'eventType' not in already_processed:
            already_processed.add('eventType')
            outfile.write(' eventType=%s' % (self.gds_format_string(quote_attrib(self.eventType).encode(ExternalEncoding), input_name='eventType'), ))
        if self.entityName is not None and 'entityName' not in already_processed:
            already_processed.add('entityName')
            outfile.write(' entityName=%s' % (self.gds_format_string(quote_attrib(self.entityName).encode(ExternalEncoding), input_name='entityName'), ))
        if self.entityType is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            outfile.write(' entityType=%s' % (self.gds_format_string(quote_attrib(self.entityType).encode(ExternalEncoding), input_name='entityType'), ))
        if self.entity is not None and 'entity' not in already_processed:
            already_processed.add('entity')
            outfile.write(' entity=%s' % (self.gds_format_string(quote_attrib(self.entity).encode(ExternalEncoding), input_name='entity'), ))
        if self.eventStatus is not None and 'eventStatus' not in already_processed:
            already_processed.add('eventStatus')
            outfile.write(' eventStatus="%s"' % self.gds_format_integer(self.eventStatus, input_name='eventStatus'))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.add('timeStamp')
            outfile.write(' timeStamp="%s"' % self.gds_format_datetime(self.timeStamp, input_name='timeStamp'))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            outfile.write(' serviceNamespace=%s' % (self.gds_format_string(quote_attrib(self.serviceNamespace).encode(ExternalEncoding), input_name='serviceNamespace'), ))
        if self.productVersion is not None and 'productVersion' not in already_processed:
            already_processed.add('productVersion')
            outfile.write(' productVersion=%s' % (self.gds_format_string(quote_attrib(self.productVersion).encode(ExternalEncoding), input_name='productVersion'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminEventRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminEventRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminEventRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.eventId is not None and 'eventId' not in already_processed:
            already_processed.add('eventId')
            showIndent(outfile, level)
            outfile.write('eventId="%s",\n' % (self.eventId,))
        if self.userName is not None and 'userName' not in already_processed:
            already_processed.add('userName')
            showIndent(outfile, level)
            outfile.write('userName="%s",\n' % (self.userName,))
        if self.orgName is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            showIndent(outfile, level)
            outfile.write('orgName="%s",\n' % (self.orgName,))
        if self.eventType is not None and 'eventType' not in already_processed:
            already_processed.add('eventType')
            showIndent(outfile, level)
            outfile.write('eventType="%s",\n' % (self.eventType,))
        if self.entityName is not None and 'entityName' not in already_processed:
            already_processed.add('entityName')
            showIndent(outfile, level)
            outfile.write('entityName="%s",\n' % (self.entityName,))
        if self.entityType is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            showIndent(outfile, level)
            outfile.write('entityType="%s",\n' % (self.entityType,))
        if self.entity is not None and 'entity' not in already_processed:
            already_processed.add('entity')
            showIndent(outfile, level)
            outfile.write('entity="%s",\n' % (self.entity,))
        if self.eventStatus is not None and 'eventStatus' not in already_processed:
            already_processed.add('eventStatus')
            showIndent(outfile, level)
            outfile.write('eventStatus=%d,\n' % (self.eventStatus,))
        if self.timeStamp is not None and 'timeStamp' not in already_processed:
            already_processed.add('timeStamp')
            showIndent(outfile, level)
            outfile.write('timeStamp=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.timeStamp, input_name='timeStamp'))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            showIndent(outfile, level)
            outfile.write('serviceNamespace="%s",\n' % (self.serviceNamespace,))
        if self.productVersion is not None and 'productVersion' not in already_processed:
            already_processed.add('productVersion')
            showIndent(outfile, level)
            outfile.write('productVersion="%s",\n' % (self.productVersion,))
        super(QueryResultAdminEventRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminEventRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('eventId', node)
        if value is not None and 'eventId' not in already_processed:
            already_processed.add('eventId')
            self.eventId = value
        value = find_attr_value_('userName', node)
        if value is not None and 'userName' not in already_processed:
            already_processed.add('userName')
            self.userName = value
        value = find_attr_value_('orgName', node)
        if value is not None and 'orgName' not in already_processed:
            already_processed.add('orgName')
            self.orgName = value
        value = find_attr_value_('eventType', node)
        if value is not None and 'eventType' not in already_processed:
            already_processed.add('eventType')
            self.eventType = value
        value = find_attr_value_('entityName', node)
        if value is not None and 'entityName' not in already_processed:
            already_processed.add('entityName')
            self.entityName = value
        value = find_attr_value_('entityType', node)
        if value is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            self.entityType = value
        value = find_attr_value_('entity', node)
        if value is not None and 'entity' not in already_processed:
            already_processed.add('entity')
            self.entity = value
        value = find_attr_value_('eventStatus', node)
        if value is not None and 'eventStatus' not in already_processed:
            already_processed.add('eventStatus')
            try:
                self.eventStatus = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('timeStamp', node)
        if value is not None and 'timeStamp' not in already_processed:
            already_processed.add('timeStamp')
            try:
                self.timeStamp = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (timeStamp): %s' % exp)
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('serviceNamespace', node)
        if value is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            self.serviceNamespace = value
        value = find_attr_value_('productVersion', node)
        if value is not None and 'productVersion' not in already_processed:
            already_processed.add('productVersion')
            self.productVersion = value
        super(QueryResultAdminEventRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminEventRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminEventRecordType


class QueryResultStrandedItemRecordType(QueryResultRecordType):
    """5.1 Type for a single strandedItem query result in records format.
    5.1none The name of this stranded item. 5.1none Vim object type
    5.1none The name of the parent of the stranded item 5.1none Date
    when the vCD object is deleted 5.1none The href of the parent of
    the stranded item 5.1none Shows if purging of the item from a
    vCenter has failed"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, deletionDate=None, vimObjectType=None, name=None, parent=None, parentName=None, numberOfPurgeAttempts=None):
        self.original_tagname_ = None
        super(QueryResultStrandedItemRecordType, self).__init__(href, type_, id, Link, Metadata, )
        if isinstance(deletionDate, basestring):
            initvalue_ = datetime_.datetime.strptime(deletionDate, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = deletionDate
        self.deletionDate = initvalue_
        self.vimObjectType = _cast(None, vimObjectType)
        self.name = _cast(None, name)
        self.parent = _cast(None, parent)
        self.parentName = _cast(None, parentName)
        self.numberOfPurgeAttempts = _cast(int, numberOfPurgeAttempts)
    def factory(*args_, **kwargs_):
        if QueryResultStrandedItemRecordType.subclass:
            return QueryResultStrandedItemRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultStrandedItemRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deletionDate(self): return self.deletionDate
    def set_deletionDate(self, deletionDate): self.deletionDate = deletionDate
    def get_vimObjectType(self): return self.vimObjectType
    def set_vimObjectType(self, vimObjectType): self.vimObjectType = vimObjectType
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_parent(self): return self.parent
    def set_parent(self, parent): self.parent = parent
    def get_parentName(self): return self.parentName
    def set_parentName(self, parentName): self.parentName = parentName
    def get_numberOfPurgeAttempts(self): return self.numberOfPurgeAttempts
    def set_numberOfPurgeAttempts(self, numberOfPurgeAttempts): self.numberOfPurgeAttempts = numberOfPurgeAttempts
    def hasContent_(self):
        if (
            super(QueryResultStrandedItemRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultStrandedItemRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultStrandedItemRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultStrandedItemRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultStrandedItemRecordType'):
        super(QueryResultStrandedItemRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultStrandedItemRecordType')
        if self.deletionDate is not None and 'deletionDate' not in already_processed:
            already_processed.add('deletionDate')
            outfile.write(' deletionDate="%s"' % self.gds_format_datetime(self.deletionDate, input_name='deletionDate'))
        if self.vimObjectType is not None and 'vimObjectType' not in already_processed:
            already_processed.add('vimObjectType')
            outfile.write(' vimObjectType=%s' % (self.gds_format_string(quote_attrib(self.vimObjectType).encode(ExternalEncoding), input_name='vimObjectType'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.add('parent')
            outfile.write(' parent=%s' % (self.gds_format_string(quote_attrib(self.parent).encode(ExternalEncoding), input_name='parent'), ))
        if self.parentName is not None and 'parentName' not in already_processed:
            already_processed.add('parentName')
            outfile.write(' parentName=%s' % (self.gds_format_string(quote_attrib(self.parentName).encode(ExternalEncoding), input_name='parentName'), ))
        if self.numberOfPurgeAttempts is not None and 'numberOfPurgeAttempts' not in already_processed:
            already_processed.add('numberOfPurgeAttempts')
            outfile.write(' numberOfPurgeAttempts="%s"' % self.gds_format_integer(self.numberOfPurgeAttempts, input_name='numberOfPurgeAttempts'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultStrandedItemRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultStrandedItemRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultStrandedItemRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.deletionDate is not None and 'deletionDate' not in already_processed:
            already_processed.add('deletionDate')
            showIndent(outfile, level)
            outfile.write('deletionDate=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.deletionDate, input_name='deletionDate'))
        if self.vimObjectType is not None and 'vimObjectType' not in already_processed:
            already_processed.add('vimObjectType')
            showIndent(outfile, level)
            outfile.write('vimObjectType="%s",\n' % (self.vimObjectType,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.add('parent')
            showIndent(outfile, level)
            outfile.write('parent="%s",\n' % (self.parent,))
        if self.parentName is not None and 'parentName' not in already_processed:
            already_processed.add('parentName')
            showIndent(outfile, level)
            outfile.write('parentName="%s",\n' % (self.parentName,))
        if self.numberOfPurgeAttempts is not None and 'numberOfPurgeAttempts' not in already_processed:
            already_processed.add('numberOfPurgeAttempts')
            showIndent(outfile, level)
            outfile.write('numberOfPurgeAttempts=%d,\n' % (self.numberOfPurgeAttempts,))
        super(QueryResultStrandedItemRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultStrandedItemRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('deletionDate', node)
        if value is not None and 'deletionDate' not in already_processed:
            already_processed.add('deletionDate')
            try:
                self.deletionDate = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (deletionDate): %s' % exp)
        value = find_attr_value_('vimObjectType', node)
        if value is not None and 'vimObjectType' not in already_processed:
            already_processed.add('vimObjectType')
            self.vimObjectType = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('parent', node)
        if value is not None and 'parent' not in already_processed:
            already_processed.add('parent')
            self.parent = value
        value = find_attr_value_('parentName', node)
        if value is not None and 'parentName' not in already_processed:
            already_processed.add('parentName')
            self.parentName = value
        value = find_attr_value_('numberOfPurgeAttempts', node)
        if value is not None and 'numberOfPurgeAttempts' not in already_processed:
            already_processed.add('numberOfPurgeAttempts')
            try:
                self.numberOfPurgeAttempts = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(QueryResultStrandedItemRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultStrandedItemRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultStrandedItemRecordType


class QueryResultAdminServiceRecordType(QueryResultRecordType):
    """5.1 Type for a single adminService query result in records format.
    5.1none Name of the external service. 5.1none True if service is
    enabled. 5.1none The service exchange. 5.1none Service priority.
    5.1none The service routing key. 5.1none Service vendor. 5.1none
    Service namespace. 5.1none True if authorization is enabled."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, vendor=None, routingKey=None, exchange=None, namespace=None, enabled=None, priority=None, isAuthorizationEnabled=None, name=None):
        self.original_tagname_ = None
        super(QueryResultAdminServiceRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.vendor = _cast(None, vendor)
        self.routingKey = _cast(None, routingKey)
        self.exchange = _cast(None, exchange)
        self.namespace = _cast(None, namespace)
        self.enabled = _cast(bool, enabled)
        self.priority = _cast(int, priority)
        self.isAuthorizationEnabled = _cast(bool, isAuthorizationEnabled)
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if QueryResultAdminServiceRecordType.subclass:
            return QueryResultAdminServiceRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminServiceRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_routingKey(self): return self.routingKey
    def set_routingKey(self, routingKey): self.routingKey = routingKey
    def get_exchange(self): return self.exchange
    def set_exchange(self, exchange): self.exchange = exchange
    def get_namespace(self): return self.namespace
    def set_namespace(self, namespace): self.namespace = namespace
    def get_enabled(self): return self.enabled
    def set_enabled(self, enabled): self.enabled = enabled
    def get_priority(self): return self.priority
    def set_priority(self, priority): self.priority = priority
    def get_isAuthorizationEnabled(self): return self.isAuthorizationEnabled
    def set_isAuthorizationEnabled(self, isAuthorizationEnabled): self.isAuthorizationEnabled = isAuthorizationEnabled
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            super(QueryResultAdminServiceRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminServiceRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminServiceRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminServiceRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminServiceRecordType'):
        super(QueryResultAdminServiceRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminServiceRecordType')
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            outfile.write(' vendor=%s' % (self.gds_format_string(quote_attrib(self.vendor).encode(ExternalEncoding), input_name='vendor'), ))
        if self.routingKey is not None and 'routingKey' not in already_processed:
            already_processed.add('routingKey')
            outfile.write(' routingKey=%s' % (self.gds_format_string(quote_attrib(self.routingKey).encode(ExternalEncoding), input_name='routingKey'), ))
        if self.exchange is not None and 'exchange' not in already_processed:
            already_processed.add('exchange')
            outfile.write(' exchange=%s' % (self.gds_format_string(quote_attrib(self.exchange).encode(ExternalEncoding), input_name='exchange'), ))
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            outfile.write(' namespace=%s' % (self.gds_format_string(quote_attrib(self.namespace).encode(ExternalEncoding), input_name='namespace'), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            outfile.write(' priority="%s"' % self.gds_format_integer(self.priority, input_name='priority'))
        if self.isAuthorizationEnabled is not None and 'isAuthorizationEnabled' not in already_processed:
            already_processed.add('isAuthorizationEnabled')
            outfile.write(' isAuthorizationEnabled="%s"' % self.gds_format_boolean(self.isAuthorizationEnabled, input_name='isAuthorizationEnabled'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminServiceRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminServiceRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminServiceRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            showIndent(outfile, level)
            outfile.write('vendor="%s",\n' % (self.vendor,))
        if self.routingKey is not None and 'routingKey' not in already_processed:
            already_processed.add('routingKey')
            showIndent(outfile, level)
            outfile.write('routingKey="%s",\n' % (self.routingKey,))
        if self.exchange is not None and 'exchange' not in already_processed:
            already_processed.add('exchange')
            showIndent(outfile, level)
            outfile.write('exchange="%s",\n' % (self.exchange,))
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            showIndent(outfile, level)
            outfile.write('namespace="%s",\n' % (self.namespace,))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            showIndent(outfile, level)
            outfile.write('enabled=%s,\n' % (self.enabled,))
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            showIndent(outfile, level)
            outfile.write('priority=%d,\n' % (self.priority,))
        if self.isAuthorizationEnabled is not None and 'isAuthorizationEnabled' not in already_processed:
            already_processed.add('isAuthorizationEnabled')
            showIndent(outfile, level)
            outfile.write('isAuthorizationEnabled=%s,\n' % (self.isAuthorizationEnabled,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(QueryResultAdminServiceRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminServiceRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vendor', node)
        if value is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            self.vendor = value
        value = find_attr_value_('routingKey', node)
        if value is not None and 'routingKey' not in already_processed:
            already_processed.add('routingKey')
            self.routingKey = value
        value = find_attr_value_('exchange', node)
        if value is not None and 'exchange' not in already_processed:
            already_processed.add('exchange')
            self.exchange = value
        value = find_attr_value_('namespace', node)
        if value is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            self.namespace = value
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('priority', node)
        if value is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            try:
                self.priority = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isAuthorizationEnabled', node)
        if value is not None and 'isAuthorizationEnabled' not in already_processed:
            already_processed.add('isAuthorizationEnabled')
            if value in ('true', '1'):
                self.isAuthorizationEnabled = True
            elif value in ('false', '0'):
                self.isAuthorizationEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(QueryResultAdminServiceRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminServiceRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminServiceRecordType


class QueryResultServiceRecordType(QueryResultRecordType):
    """5.1 Type for a single service query result in records format.
    5.1none Name of the external service. 5.1none External service
    vendor. 5.1none Service namespace."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, namespace=None, vendor=None, name=None):
        self.original_tagname_ = None
        super(QueryResultServiceRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.namespace = _cast(None, namespace)
        self.vendor = _cast(None, vendor)
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if QueryResultServiceRecordType.subclass:
            return QueryResultServiceRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultServiceRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_namespace(self): return self.namespace
    def set_namespace(self, namespace): self.namespace = namespace
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            super(QueryResultServiceRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultServiceRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultServiceRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultServiceRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultServiceRecordType'):
        super(QueryResultServiceRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultServiceRecordType')
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            outfile.write(' namespace=%s' % (self.gds_format_string(quote_attrib(self.namespace).encode(ExternalEncoding), input_name='namespace'), ))
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            outfile.write(' vendor=%s' % (self.gds_format_string(quote_attrib(self.vendor).encode(ExternalEncoding), input_name='vendor'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultServiceRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultServiceRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultServiceRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            showIndent(outfile, level)
            outfile.write('namespace="%s",\n' % (self.namespace,))
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            showIndent(outfile, level)
            outfile.write('vendor="%s",\n' % (self.vendor,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(QueryResultServiceRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultServiceRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('namespace', node)
        if value is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            self.namespace = value
        value = find_attr_value_('vendor', node)
        if value is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            self.vendor = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(QueryResultServiceRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultServiceRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultServiceRecordType


class QueryResultServiceLinkRecordType(QueryResultRecordType):
    """5.1 Type for a single serviceLink query result in records format.
    5.1none Relation for the link. 5.1none Href for the link.
    5.1none Link's mime type. 5.1none Resource type the link is
    registered for. 5.1none Service reference or id 5.1none Resource
    id the link is registered for."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, mimeType=None, service=None, resourceType=None, resourceId=None, linkHref=None, rel=None):
        self.original_tagname_ = None
        super(QueryResultServiceLinkRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.mimeType = _cast(None, mimeType)
        self.service = _cast(None, service)
        self.resourceType = _cast(None, resourceType)
        self.resourceId = _cast(None, resourceId)
        self.linkHref = _cast(None, linkHref)
        self.rel = _cast(None, rel)
    def factory(*args_, **kwargs_):
        if QueryResultServiceLinkRecordType.subclass:
            return QueryResultServiceLinkRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultServiceLinkRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mimeType(self): return self.mimeType
    def set_mimeType(self, mimeType): self.mimeType = mimeType
    def get_service(self): return self.service
    def set_service(self, service): self.service = service
    def get_resourceType(self): return self.resourceType
    def set_resourceType(self, resourceType): self.resourceType = resourceType
    def get_resourceId(self): return self.resourceId
    def set_resourceId(self, resourceId): self.resourceId = resourceId
    def get_linkHref(self): return self.linkHref
    def set_linkHref(self, linkHref): self.linkHref = linkHref
    def get_rel(self): return self.rel
    def set_rel(self, rel): self.rel = rel
    def hasContent_(self):
        if (
            super(QueryResultServiceLinkRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultServiceLinkRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultServiceLinkRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultServiceLinkRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultServiceLinkRecordType'):
        super(QueryResultServiceLinkRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultServiceLinkRecordType')
        if self.mimeType is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            outfile.write(' mimeType=%s' % (self.gds_format_string(quote_attrib(self.mimeType).encode(ExternalEncoding), input_name='mimeType'), ))
        if self.service is not None and 'service' not in already_processed:
            already_processed.add('service')
            outfile.write(' service=%s' % (self.gds_format_string(quote_attrib(self.service).encode(ExternalEncoding), input_name='service'), ))
        if self.resourceType is not None and 'resourceType' not in already_processed:
            already_processed.add('resourceType')
            outfile.write(' resourceType=%s' % (self.gds_format_string(quote_attrib(self.resourceType).encode(ExternalEncoding), input_name='resourceType'), ))
        if self.resourceId is not None and 'resourceId' not in already_processed:
            already_processed.add('resourceId')
            outfile.write(' resourceId=%s' % (self.gds_format_string(quote_attrib(self.resourceId).encode(ExternalEncoding), input_name='resourceId'), ))
        if self.linkHref is not None and 'linkHref' not in already_processed:
            already_processed.add('linkHref')
            outfile.write(' linkHref=%s' % (self.gds_format_string(quote_attrib(self.linkHref).encode(ExternalEncoding), input_name='linkHref'), ))
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            outfile.write(' rel=%s' % (self.gds_format_string(quote_attrib(self.rel).encode(ExternalEncoding), input_name='rel'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultServiceLinkRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultServiceLinkRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultServiceLinkRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mimeType is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            showIndent(outfile, level)
            outfile.write('mimeType="%s",\n' % (self.mimeType,))
        if self.service is not None and 'service' not in already_processed:
            already_processed.add('service')
            showIndent(outfile, level)
            outfile.write('service="%s",\n' % (self.service,))
        if self.resourceType is not None and 'resourceType' not in already_processed:
            already_processed.add('resourceType')
            showIndent(outfile, level)
            outfile.write('resourceType="%s",\n' % (self.resourceType,))
        if self.resourceId is not None and 'resourceId' not in already_processed:
            already_processed.add('resourceId')
            showIndent(outfile, level)
            outfile.write('resourceId="%s",\n' % (self.resourceId,))
        if self.linkHref is not None and 'linkHref' not in already_processed:
            already_processed.add('linkHref')
            showIndent(outfile, level)
            outfile.write('linkHref="%s",\n' % (self.linkHref,))
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            showIndent(outfile, level)
            outfile.write('rel="%s",\n' % (self.rel,))
        super(QueryResultServiceLinkRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultServiceLinkRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mimeType', node)
        if value is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            self.mimeType = value
        value = find_attr_value_('service', node)
        if value is not None and 'service' not in already_processed:
            already_processed.add('service')
            self.service = value
        value = find_attr_value_('resourceType', node)
        if value is not None and 'resourceType' not in already_processed:
            already_processed.add('resourceType')
            self.resourceType = value
        value = find_attr_value_('resourceId', node)
        if value is not None and 'resourceId' not in already_processed:
            already_processed.add('resourceId')
            self.resourceId = value
        value = find_attr_value_('linkHref', node)
        if value is not None and 'linkHref' not in already_processed:
            already_processed.add('linkHref')
            self.linkHref = value
        value = find_attr_value_('rel', node)
        if value is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            self.rel = value
        super(QueryResultServiceLinkRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultServiceLinkRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultServiceLinkRecordType


class QueryResultOrgVdcStorageProfileRecordType(QueryResultRecordType):
    """5.1 Type for a single orgVdcStorageProfile query result in records
    format. 5.1none Name of the storage profile 5.1none True if this
    entity is enabled 5.1none True if this is the default storage
    profile. 5.1none Storage used in MB 5.1none Storage limit in MB
    5.1none Number of conditions on the storage profile 5.1none VDC
    reference or id 5.1none VDC name 5.1none True if the associated
    VDC is busy."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, isVdcBusy=None, storageUsedMB=None, name=None, isEnabled=None, storageLimitMB=None, isDefaultStorageProfile=None, vdcName=None, numberOfConditions=None, vdc=None):
        self.original_tagname_ = None
        super(QueryResultOrgVdcStorageProfileRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.isVdcBusy = _cast(bool, isVdcBusy)
        self.storageUsedMB = _cast(int, storageUsedMB)
        self.name = _cast(None, name)
        self.isEnabled = _cast(bool, isEnabled)
        self.storageLimitMB = _cast(int, storageLimitMB)
        self.isDefaultStorageProfile = _cast(bool, isDefaultStorageProfile)
        self.vdcName = _cast(None, vdcName)
        self.numberOfConditions = _cast(int, numberOfConditions)
        self.vdc = _cast(None, vdc)
    def factory(*args_, **kwargs_):
        if QueryResultOrgVdcStorageProfileRecordType.subclass:
            return QueryResultOrgVdcStorageProfileRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultOrgVdcStorageProfileRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isVdcBusy(self): return self.isVdcBusy
    def set_isVdcBusy(self, isVdcBusy): self.isVdcBusy = isVdcBusy
    def get_storageUsedMB(self): return self.storageUsedMB
    def set_storageUsedMB(self, storageUsedMB): self.storageUsedMB = storageUsedMB
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_storageLimitMB(self): return self.storageLimitMB
    def set_storageLimitMB(self, storageLimitMB): self.storageLimitMB = storageLimitMB
    def get_isDefaultStorageProfile(self): return self.isDefaultStorageProfile
    def set_isDefaultStorageProfile(self, isDefaultStorageProfile): self.isDefaultStorageProfile = isDefaultStorageProfile
    def get_vdcName(self): return self.vdcName
    def set_vdcName(self, vdcName): self.vdcName = vdcName
    def get_numberOfConditions(self): return self.numberOfConditions
    def set_numberOfConditions(self, numberOfConditions): self.numberOfConditions = numberOfConditions
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def hasContent_(self):
        if (
            super(QueryResultOrgVdcStorageProfileRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultOrgVdcStorageProfileRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultOrgVdcStorageProfileRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultOrgVdcStorageProfileRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultOrgVdcStorageProfileRecordType'):
        super(QueryResultOrgVdcStorageProfileRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultOrgVdcStorageProfileRecordType')
        if self.isVdcBusy is not None and 'isVdcBusy' not in already_processed:
            already_processed.add('isVdcBusy')
            outfile.write(' isVdcBusy="%s"' % self.gds_format_boolean(self.isVdcBusy, input_name='isVdcBusy'))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            outfile.write(' storageUsedMB="%s"' % self.gds_format_integer(self.storageUsedMB, input_name='storageUsedMB'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.storageLimitMB is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            outfile.write(' storageLimitMB="%s"' % self.gds_format_integer(self.storageLimitMB, input_name='storageLimitMB'))
        if self.isDefaultStorageProfile is not None and 'isDefaultStorageProfile' not in already_processed:
            already_processed.add('isDefaultStorageProfile')
            outfile.write(' isDefaultStorageProfile="%s"' % self.gds_format_boolean(self.isDefaultStorageProfile, input_name='isDefaultStorageProfile'))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            outfile.write(' vdcName=%s' % (self.gds_format_string(quote_attrib(self.vdcName).encode(ExternalEncoding), input_name='vdcName'), ))
        if self.numberOfConditions is not None and 'numberOfConditions' not in already_processed:
            already_processed.add('numberOfConditions')
            outfile.write(' numberOfConditions="%s"' % self.gds_format_integer(self.numberOfConditions, input_name='numberOfConditions'))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultOrgVdcStorageProfileRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultOrgVdcStorageProfileRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultOrgVdcStorageProfileRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isVdcBusy is not None and 'isVdcBusy' not in already_processed:
            already_processed.add('isVdcBusy')
            showIndent(outfile, level)
            outfile.write('isVdcBusy=%s,\n' % (self.isVdcBusy,))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            showIndent(outfile, level)
            outfile.write('storageUsedMB=%d,\n' % (self.storageUsedMB,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.storageLimitMB is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            showIndent(outfile, level)
            outfile.write('storageLimitMB=%d,\n' % (self.storageLimitMB,))
        if self.isDefaultStorageProfile is not None and 'isDefaultStorageProfile' not in already_processed:
            already_processed.add('isDefaultStorageProfile')
            showIndent(outfile, level)
            outfile.write('isDefaultStorageProfile=%s,\n' % (self.isDefaultStorageProfile,))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            showIndent(outfile, level)
            outfile.write('vdcName="%s",\n' % (self.vdcName,))
        if self.numberOfConditions is not None and 'numberOfConditions' not in already_processed:
            already_processed.add('numberOfConditions')
            showIndent(outfile, level)
            outfile.write('numberOfConditions=%d,\n' % (self.numberOfConditions,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        super(QueryResultOrgVdcStorageProfileRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultOrgVdcStorageProfileRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isVdcBusy', node)
        if value is not None and 'isVdcBusy' not in already_processed:
            already_processed.add('isVdcBusy')
            if value in ('true', '1'):
                self.isVdcBusy = True
            elif value in ('false', '0'):
                self.isVdcBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('storageUsedMB', node)
        if value is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            try:
                self.storageUsedMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('storageLimitMB', node)
        if value is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            try:
                self.storageLimitMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isDefaultStorageProfile', node)
        if value is not None and 'isDefaultStorageProfile' not in already_processed:
            already_processed.add('isDefaultStorageProfile')
            if value in ('true', '1'):
                self.isDefaultStorageProfile = True
            elif value in ('false', '0'):
                self.isDefaultStorageProfile = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vdcName', node)
        if value is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            self.vdcName = value
        value = find_attr_value_('numberOfConditions', node)
        if value is not None and 'numberOfConditions' not in already_processed:
            already_processed.add('numberOfConditions')
            try:
                self.numberOfConditions = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        super(QueryResultOrgVdcStorageProfileRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultOrgVdcStorageProfileRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultOrgVdcStorageProfileRecordType


class QueryResultAdminOrgVdcStorageProfileRecordType(QueryResultRecordType):
    """5.1 Type for a single adminOrgVdcStorageProfile query result in
    records format. 5.1none Name of the storage profile 5.1none True
    if this entity is enabled 5.1none True if this is the default
    storage profile for a VDC. 5.1none Storage used in MB 5.1none
    Storage limit in MB 5.1none Number of conditions on the storage
    profile 5.1none VDC reference or id 5.1none VDC name 5.1none
    Organization reference or id 5.1none Virtual center reference or
    id 5.1none Managed object reference of the storage profile"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, vc=None, storageUsedMB=None, name=None, isEnabled=None, storageLimitMB=None, isDefaultStorageProfile=None, vdcName=None, numberOfConditions=None, vdc=None, storageProfileMoref=None, org=None):
        self.original_tagname_ = None
        super(QueryResultAdminOrgVdcStorageProfileRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.vc = _cast(None, vc)
        self.storageUsedMB = _cast(int, storageUsedMB)
        self.name = _cast(None, name)
        self.isEnabled = _cast(bool, isEnabled)
        self.storageLimitMB = _cast(int, storageLimitMB)
        self.isDefaultStorageProfile = _cast(bool, isDefaultStorageProfile)
        self.vdcName = _cast(None, vdcName)
        self.numberOfConditions = _cast(int, numberOfConditions)
        self.vdc = _cast(None, vdc)
        self.storageProfileMoref = _cast(None, storageProfileMoref)
        self.org = _cast(None, org)
    def factory(*args_, **kwargs_):
        if QueryResultAdminOrgVdcStorageProfileRecordType.subclass:
            return QueryResultAdminOrgVdcStorageProfileRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminOrgVdcStorageProfileRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vc(self): return self.vc
    def set_vc(self, vc): self.vc = vc
    def get_storageUsedMB(self): return self.storageUsedMB
    def set_storageUsedMB(self, storageUsedMB): self.storageUsedMB = storageUsedMB
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_storageLimitMB(self): return self.storageLimitMB
    def set_storageLimitMB(self, storageLimitMB): self.storageLimitMB = storageLimitMB
    def get_isDefaultStorageProfile(self): return self.isDefaultStorageProfile
    def set_isDefaultStorageProfile(self, isDefaultStorageProfile): self.isDefaultStorageProfile = isDefaultStorageProfile
    def get_vdcName(self): return self.vdcName
    def set_vdcName(self, vdcName): self.vdcName = vdcName
    def get_numberOfConditions(self): return self.numberOfConditions
    def set_numberOfConditions(self, numberOfConditions): self.numberOfConditions = numberOfConditions
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_storageProfileMoref(self): return self.storageProfileMoref
    def set_storageProfileMoref(self, storageProfileMoref): self.storageProfileMoref = storageProfileMoref
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def hasContent_(self):
        if (
            super(QueryResultAdminOrgVdcStorageProfileRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminOrgVdcStorageProfileRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminOrgVdcStorageProfileRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminOrgVdcStorageProfileRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminOrgVdcStorageProfileRecordType'):
        super(QueryResultAdminOrgVdcStorageProfileRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminOrgVdcStorageProfileRecordType')
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            outfile.write(' vc=%s' % (self.gds_format_string(quote_attrib(self.vc).encode(ExternalEncoding), input_name='vc'), ))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            outfile.write(' storageUsedMB="%s"' % self.gds_format_integer(self.storageUsedMB, input_name='storageUsedMB'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.storageLimitMB is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            outfile.write(' storageLimitMB="%s"' % self.gds_format_integer(self.storageLimitMB, input_name='storageLimitMB'))
        if self.isDefaultStorageProfile is not None and 'isDefaultStorageProfile' not in already_processed:
            already_processed.add('isDefaultStorageProfile')
            outfile.write(' isDefaultStorageProfile="%s"' % self.gds_format_boolean(self.isDefaultStorageProfile, input_name='isDefaultStorageProfile'))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            outfile.write(' vdcName=%s' % (self.gds_format_string(quote_attrib(self.vdcName).encode(ExternalEncoding), input_name='vdcName'), ))
        if self.numberOfConditions is not None and 'numberOfConditions' not in already_processed:
            already_processed.add('numberOfConditions')
            outfile.write(' numberOfConditions="%s"' % self.gds_format_integer(self.numberOfConditions, input_name='numberOfConditions'))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.storageProfileMoref is not None and 'storageProfileMoref' not in already_processed:
            already_processed.add('storageProfileMoref')
            outfile.write(' storageProfileMoref=%s' % (self.gds_format_string(quote_attrib(self.storageProfileMoref).encode(ExternalEncoding), input_name='storageProfileMoref'), ))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminOrgVdcStorageProfileRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminOrgVdcStorageProfileRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminOrgVdcStorageProfileRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            showIndent(outfile, level)
            outfile.write('vc="%s",\n' % (self.vc,))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            showIndent(outfile, level)
            outfile.write('storageUsedMB=%d,\n' % (self.storageUsedMB,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.storageLimitMB is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            showIndent(outfile, level)
            outfile.write('storageLimitMB=%d,\n' % (self.storageLimitMB,))
        if self.isDefaultStorageProfile is not None and 'isDefaultStorageProfile' not in already_processed:
            already_processed.add('isDefaultStorageProfile')
            showIndent(outfile, level)
            outfile.write('isDefaultStorageProfile=%s,\n' % (self.isDefaultStorageProfile,))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            showIndent(outfile, level)
            outfile.write('vdcName="%s",\n' % (self.vdcName,))
        if self.numberOfConditions is not None and 'numberOfConditions' not in already_processed:
            already_processed.add('numberOfConditions')
            showIndent(outfile, level)
            outfile.write('numberOfConditions=%d,\n' % (self.numberOfConditions,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.storageProfileMoref is not None and 'storageProfileMoref' not in already_processed:
            already_processed.add('storageProfileMoref')
            showIndent(outfile, level)
            outfile.write('storageProfileMoref="%s",\n' % (self.storageProfileMoref,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        super(QueryResultAdminOrgVdcStorageProfileRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminOrgVdcStorageProfileRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vc', node)
        if value is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            self.vc = value
        value = find_attr_value_('storageUsedMB', node)
        if value is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            try:
                self.storageUsedMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('storageLimitMB', node)
        if value is not None and 'storageLimitMB' not in already_processed:
            already_processed.add('storageLimitMB')
            try:
                self.storageLimitMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isDefaultStorageProfile', node)
        if value is not None and 'isDefaultStorageProfile' not in already_processed:
            already_processed.add('isDefaultStorageProfile')
            if value in ('true', '1'):
                self.isDefaultStorageProfile = True
            elif value in ('false', '0'):
                self.isDefaultStorageProfile = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('vdcName', node)
        if value is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            self.vdcName = value
        value = find_attr_value_('numberOfConditions', node)
        if value is not None and 'numberOfConditions' not in already_processed:
            already_processed.add('numberOfConditions')
            try:
                self.numberOfConditions = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('storageProfileMoref', node)
        if value is not None and 'storageProfileMoref' not in already_processed:
            already_processed.add('storageProfileMoref')
            self.storageProfileMoref = value
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        super(QueryResultAdminOrgVdcStorageProfileRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminOrgVdcStorageProfileRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminOrgVdcStorageProfileRecordType


class QueryResultProviderVdcStorageProfileRecordType(QueryResultRecordType):
    """5.1 Type for a single providerVdcStorageProfile query result in
    records format. 5.1none True if this entity is enabled 5.1none
    Name of the Provider VDC storage profile 5.1none Total storage
    in MB 5.1none 5.1none 5.1none 5.1none Number of conditions on
    the provider storage profile 5.1none Provider VDC reference or
    id 5.1none Virtual center reference or id 5.1none Managed object
    reference of the storage profile"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, vc=None, storageUsedMB=None, name=None, providerVdc=None, storageTotalMB=None, isEnabled=None, storageProvisionedMB=None, numberOfConditions=None, storageRequestedMB=None, storageProfileMoref=None):
        self.original_tagname_ = None
        super(QueryResultProviderVdcStorageProfileRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.vc = _cast(None, vc)
        self.storageUsedMB = _cast(int, storageUsedMB)
        self.name = _cast(None, name)
        self.providerVdc = _cast(None, providerVdc)
        self.storageTotalMB = _cast(int, storageTotalMB)
        self.isEnabled = _cast(bool, isEnabled)
        self.storageProvisionedMB = _cast(int, storageProvisionedMB)
        self.numberOfConditions = _cast(int, numberOfConditions)
        self.storageRequestedMB = _cast(int, storageRequestedMB)
        self.storageProfileMoref = _cast(None, storageProfileMoref)
    def factory(*args_, **kwargs_):
        if QueryResultProviderVdcStorageProfileRecordType.subclass:
            return QueryResultProviderVdcStorageProfileRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultProviderVdcStorageProfileRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vc(self): return self.vc
    def set_vc(self, vc): self.vc = vc
    def get_storageUsedMB(self): return self.storageUsedMB
    def set_storageUsedMB(self, storageUsedMB): self.storageUsedMB = storageUsedMB
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_providerVdc(self): return self.providerVdc
    def set_providerVdc(self, providerVdc): self.providerVdc = providerVdc
    def get_storageTotalMB(self): return self.storageTotalMB
    def set_storageTotalMB(self, storageTotalMB): self.storageTotalMB = storageTotalMB
    def get_isEnabled(self): return self.isEnabled
    def set_isEnabled(self, isEnabled): self.isEnabled = isEnabled
    def get_storageProvisionedMB(self): return self.storageProvisionedMB
    def set_storageProvisionedMB(self, storageProvisionedMB): self.storageProvisionedMB = storageProvisionedMB
    def get_numberOfConditions(self): return self.numberOfConditions
    def set_numberOfConditions(self, numberOfConditions): self.numberOfConditions = numberOfConditions
    def get_storageRequestedMB(self): return self.storageRequestedMB
    def set_storageRequestedMB(self, storageRequestedMB): self.storageRequestedMB = storageRequestedMB
    def get_storageProfileMoref(self): return self.storageProfileMoref
    def set_storageProfileMoref(self, storageProfileMoref): self.storageProfileMoref = storageProfileMoref
    def hasContent_(self):
        if (
            super(QueryResultProviderVdcStorageProfileRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultProviderVdcStorageProfileRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultProviderVdcStorageProfileRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultProviderVdcStorageProfileRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultProviderVdcStorageProfileRecordType'):
        super(QueryResultProviderVdcStorageProfileRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultProviderVdcStorageProfileRecordType')
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            outfile.write(' vc=%s' % (self.gds_format_string(quote_attrib(self.vc).encode(ExternalEncoding), input_name='vc'), ))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            outfile.write(' storageUsedMB="%s"' % self.gds_format_integer(self.storageUsedMB, input_name='storageUsedMB'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.providerVdc is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            outfile.write(' providerVdc=%s' % (self.gds_format_string(quote_attrib(self.providerVdc).encode(ExternalEncoding), input_name='providerVdc'), ))
        if self.storageTotalMB is not None and 'storageTotalMB' not in already_processed:
            already_processed.add('storageTotalMB')
            outfile.write(' storageTotalMB="%s"' % self.gds_format_integer(self.storageTotalMB, input_name='storageTotalMB'))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            outfile.write(' isEnabled="%s"' % self.gds_format_boolean(self.isEnabled, input_name='isEnabled'))
        if self.storageProvisionedMB is not None and 'storageProvisionedMB' not in already_processed:
            already_processed.add('storageProvisionedMB')
            outfile.write(' storageProvisionedMB="%s"' % self.gds_format_integer(self.storageProvisionedMB, input_name='storageProvisionedMB'))
        if self.numberOfConditions is not None and 'numberOfConditions' not in already_processed:
            already_processed.add('numberOfConditions')
            outfile.write(' numberOfConditions="%s"' % self.gds_format_integer(self.numberOfConditions, input_name='numberOfConditions'))
        if self.storageRequestedMB is not None and 'storageRequestedMB' not in already_processed:
            already_processed.add('storageRequestedMB')
            outfile.write(' storageRequestedMB="%s"' % self.gds_format_integer(self.storageRequestedMB, input_name='storageRequestedMB'))
        if self.storageProfileMoref is not None and 'storageProfileMoref' not in already_processed:
            already_processed.add('storageProfileMoref')
            outfile.write(' storageProfileMoref=%s' % (self.gds_format_string(quote_attrib(self.storageProfileMoref).encode(ExternalEncoding), input_name='storageProfileMoref'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultProviderVdcStorageProfileRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultProviderVdcStorageProfileRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultProviderVdcStorageProfileRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vc is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            showIndent(outfile, level)
            outfile.write('vc="%s",\n' % (self.vc,))
        if self.storageUsedMB is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            showIndent(outfile, level)
            outfile.write('storageUsedMB=%d,\n' % (self.storageUsedMB,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.providerVdc is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            showIndent(outfile, level)
            outfile.write('providerVdc="%s",\n' % (self.providerVdc,))
        if self.storageTotalMB is not None and 'storageTotalMB' not in already_processed:
            already_processed.add('storageTotalMB')
            showIndent(outfile, level)
            outfile.write('storageTotalMB=%d,\n' % (self.storageTotalMB,))
        if self.isEnabled is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            showIndent(outfile, level)
            outfile.write('isEnabled=%s,\n' % (self.isEnabled,))
        if self.storageProvisionedMB is not None and 'storageProvisionedMB' not in already_processed:
            already_processed.add('storageProvisionedMB')
            showIndent(outfile, level)
            outfile.write('storageProvisionedMB=%d,\n' % (self.storageProvisionedMB,))
        if self.numberOfConditions is not None and 'numberOfConditions' not in already_processed:
            already_processed.add('numberOfConditions')
            showIndent(outfile, level)
            outfile.write('numberOfConditions=%d,\n' % (self.numberOfConditions,))
        if self.storageRequestedMB is not None and 'storageRequestedMB' not in already_processed:
            already_processed.add('storageRequestedMB')
            showIndent(outfile, level)
            outfile.write('storageRequestedMB=%d,\n' % (self.storageRequestedMB,))
        if self.storageProfileMoref is not None and 'storageProfileMoref' not in already_processed:
            already_processed.add('storageProfileMoref')
            showIndent(outfile, level)
            outfile.write('storageProfileMoref="%s",\n' % (self.storageProfileMoref,))
        super(QueryResultProviderVdcStorageProfileRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultProviderVdcStorageProfileRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vc', node)
        if value is not None and 'vc' not in already_processed:
            already_processed.add('vc')
            self.vc = value
        value = find_attr_value_('storageUsedMB', node)
        if value is not None and 'storageUsedMB' not in already_processed:
            already_processed.add('storageUsedMB')
            try:
                self.storageUsedMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('providerVdc', node)
        if value is not None and 'providerVdc' not in already_processed:
            already_processed.add('providerVdc')
            self.providerVdc = value
        value = find_attr_value_('storageTotalMB', node)
        if value is not None and 'storageTotalMB' not in already_processed:
            already_processed.add('storageTotalMB')
            try:
                self.storageTotalMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isEnabled', node)
        if value is not None and 'isEnabled' not in already_processed:
            already_processed.add('isEnabled')
            if value in ('true', '1'):
                self.isEnabled = True
            elif value in ('false', '0'):
                self.isEnabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('storageProvisionedMB', node)
        if value is not None and 'storageProvisionedMB' not in already_processed:
            already_processed.add('storageProvisionedMB')
            try:
                self.storageProvisionedMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfConditions', node)
        if value is not None and 'numberOfConditions' not in already_processed:
            already_processed.add('numberOfConditions')
            try:
                self.numberOfConditions = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storageRequestedMB', node)
        if value is not None and 'storageRequestedMB' not in already_processed:
            already_processed.add('storageRequestedMB')
            try:
                self.storageRequestedMB = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('storageProfileMoref', node)
        if value is not None and 'storageProfileMoref' not in already_processed:
            already_processed.add('storageProfileMoref')
            self.storageProfileMoref = value
        super(QueryResultProviderVdcStorageProfileRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultProviderVdcStorageProfileRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultProviderVdcStorageProfileRecordType


class QueryResultApiFilterRecordType(QueryResultRecordType):
    """5.1 Type for a single apiFilter query result in records format.
    5.1none Url pattern on which the extension service is bind.
    5.1none Service reference or id"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, urlPattern=None, service=None):
        self.original_tagname_ = None
        super(QueryResultApiFilterRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.urlPattern = _cast(None, urlPattern)
        self.service = _cast(None, service)
    def factory(*args_, **kwargs_):
        if QueryResultApiFilterRecordType.subclass:
            return QueryResultApiFilterRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultApiFilterRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_urlPattern(self): return self.urlPattern
    def set_urlPattern(self, urlPattern): self.urlPattern = urlPattern
    def get_service(self): return self.service
    def set_service(self, service): self.service = service
    def hasContent_(self):
        if (
            super(QueryResultApiFilterRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultApiFilterRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultApiFilterRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultApiFilterRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultApiFilterRecordType'):
        super(QueryResultApiFilterRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultApiFilterRecordType')
        if self.urlPattern is not None and 'urlPattern' not in already_processed:
            already_processed.add('urlPattern')
            outfile.write(' urlPattern=%s' % (self.gds_format_string(quote_attrib(self.urlPattern).encode(ExternalEncoding), input_name='urlPattern'), ))
        if self.service is not None and 'service' not in already_processed:
            already_processed.add('service')
            outfile.write(' service=%s' % (self.gds_format_string(quote_attrib(self.service).encode(ExternalEncoding), input_name='service'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultApiFilterRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultApiFilterRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultApiFilterRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.urlPattern is not None and 'urlPattern' not in already_processed:
            already_processed.add('urlPattern')
            showIndent(outfile, level)
            outfile.write('urlPattern="%s",\n' % (self.urlPattern,))
        if self.service is not None and 'service' not in already_processed:
            already_processed.add('service')
            showIndent(outfile, level)
            outfile.write('service="%s",\n' % (self.service,))
        super(QueryResultApiFilterRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultApiFilterRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('urlPattern', node)
        if value is not None and 'urlPattern' not in already_processed:
            already_processed.add('urlPattern')
            self.urlPattern = value
        value = find_attr_value_('service', node)
        if value is not None and 'service' not in already_processed:
            already_processed.add('service')
            self.service = value
        super(QueryResultApiFilterRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultApiFilterRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultApiFilterRecordType


class QueryResultAdminApiDefinitionRecordType(QueryResultRecordType):
    """5.1 Type for a single adminApiDefinition query result in records
    format. 5.1none API definition name 5.1none API definition entry
    point 5.1none Service reference or id 5.1none API definition
    namespace. 5.1none API definition vendor. 5.1none Service name
    5.1none Service namespace 5.1none Service vendor"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, name=None, service=None, namespace=None, serviceName=None, entryPoint=None, serviceVendor=None, serviceNamespace=None, apiVendor=None):
        self.original_tagname_ = None
        super(QueryResultAdminApiDefinitionRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.name = _cast(None, name)
        self.service = _cast(None, service)
        self.namespace = _cast(None, namespace)
        self.serviceName = _cast(None, serviceName)
        self.entryPoint = _cast(None, entryPoint)
        self.serviceVendor = _cast(None, serviceVendor)
        self.serviceNamespace = _cast(None, serviceNamespace)
        self.apiVendor = _cast(None, apiVendor)
    def factory(*args_, **kwargs_):
        if QueryResultAdminApiDefinitionRecordType.subclass:
            return QueryResultAdminApiDefinitionRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminApiDefinitionRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_service(self): return self.service
    def set_service(self, service): self.service = service
    def get_namespace(self): return self.namespace
    def set_namespace(self, namespace): self.namespace = namespace
    def get_serviceName(self): return self.serviceName
    def set_serviceName(self, serviceName): self.serviceName = serviceName
    def get_entryPoint(self): return self.entryPoint
    def set_entryPoint(self, entryPoint): self.entryPoint = entryPoint
    def get_serviceVendor(self): return self.serviceVendor
    def set_serviceVendor(self, serviceVendor): self.serviceVendor = serviceVendor
    def get_serviceNamespace(self): return self.serviceNamespace
    def set_serviceNamespace(self, serviceNamespace): self.serviceNamespace = serviceNamespace
    def get_apiVendor(self): return self.apiVendor
    def set_apiVendor(self, apiVendor): self.apiVendor = apiVendor
    def hasContent_(self):
        if (
            super(QueryResultAdminApiDefinitionRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminApiDefinitionRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminApiDefinitionRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminApiDefinitionRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminApiDefinitionRecordType'):
        super(QueryResultAdminApiDefinitionRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminApiDefinitionRecordType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.service is not None and 'service' not in already_processed:
            already_processed.add('service')
            outfile.write(' service=%s' % (self.gds_format_string(quote_attrib(self.service).encode(ExternalEncoding), input_name='service'), ))
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            outfile.write(' namespace=%s' % (self.gds_format_string(quote_attrib(self.namespace).encode(ExternalEncoding), input_name='namespace'), ))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            outfile.write(' serviceName=%s' % (self.gds_format_string(quote_attrib(self.serviceName).encode(ExternalEncoding), input_name='serviceName'), ))
        if self.entryPoint is not None and 'entryPoint' not in already_processed:
            already_processed.add('entryPoint')
            outfile.write(' entryPoint=%s' % (self.gds_format_string(quote_attrib(self.entryPoint).encode(ExternalEncoding), input_name='entryPoint'), ))
        if self.serviceVendor is not None and 'serviceVendor' not in already_processed:
            already_processed.add('serviceVendor')
            outfile.write(' serviceVendor=%s' % (self.gds_format_string(quote_attrib(self.serviceVendor).encode(ExternalEncoding), input_name='serviceVendor'), ))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            outfile.write(' serviceNamespace=%s' % (self.gds_format_string(quote_attrib(self.serviceNamespace).encode(ExternalEncoding), input_name='serviceNamespace'), ))
        if self.apiVendor is not None and 'apiVendor' not in already_processed:
            already_processed.add('apiVendor')
            outfile.write(' apiVendor=%s' % (self.gds_format_string(quote_attrib(self.apiVendor).encode(ExternalEncoding), input_name='apiVendor'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminApiDefinitionRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminApiDefinitionRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminApiDefinitionRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.service is not None and 'service' not in already_processed:
            already_processed.add('service')
            showIndent(outfile, level)
            outfile.write('service="%s",\n' % (self.service,))
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            showIndent(outfile, level)
            outfile.write('namespace="%s",\n' % (self.namespace,))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            showIndent(outfile, level)
            outfile.write('serviceName="%s",\n' % (self.serviceName,))
        if self.entryPoint is not None and 'entryPoint' not in already_processed:
            already_processed.add('entryPoint')
            showIndent(outfile, level)
            outfile.write('entryPoint="%s",\n' % (self.entryPoint,))
        if self.serviceVendor is not None and 'serviceVendor' not in already_processed:
            already_processed.add('serviceVendor')
            showIndent(outfile, level)
            outfile.write('serviceVendor="%s",\n' % (self.serviceVendor,))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            showIndent(outfile, level)
            outfile.write('serviceNamespace="%s",\n' % (self.serviceNamespace,))
        if self.apiVendor is not None and 'apiVendor' not in already_processed:
            already_processed.add('apiVendor')
            showIndent(outfile, level)
            outfile.write('apiVendor="%s",\n' % (self.apiVendor,))
        super(QueryResultAdminApiDefinitionRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminApiDefinitionRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('service', node)
        if value is not None and 'service' not in already_processed:
            already_processed.add('service')
            self.service = value
        value = find_attr_value_('namespace', node)
        if value is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            self.namespace = value
        value = find_attr_value_('serviceName', node)
        if value is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            self.serviceName = value
        value = find_attr_value_('entryPoint', node)
        if value is not None and 'entryPoint' not in already_processed:
            already_processed.add('entryPoint')
            self.entryPoint = value
        value = find_attr_value_('serviceVendor', node)
        if value is not None and 'serviceVendor' not in already_processed:
            already_processed.add('serviceVendor')
            self.serviceVendor = value
        value = find_attr_value_('serviceNamespace', node)
        if value is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            self.serviceNamespace = value
        value = find_attr_value_('apiVendor', node)
        if value is not None and 'apiVendor' not in already_processed:
            already_processed.add('apiVendor')
            self.apiVendor = value
        super(QueryResultAdminApiDefinitionRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminApiDefinitionRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminApiDefinitionRecordType


class QueryResultApiDefinitionRecordType(QueryResultRecordType):
    """5.1 Type for a single apiDefinition query result in records format.
    5.1none API definition name 5.1none API definition entry point
    5.1none Service reference or id 5.1none API definition
    namespace. 5.1none API definition vendor. 5.1none Service name
    5.1none Service namespace 5.1none Service vendor"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, name=None, service=None, namespace=None, serviceName=None, entryPoint=None, serviceVendor=None, serviceNamespace=None, apiVendor=None):
        self.original_tagname_ = None
        super(QueryResultApiDefinitionRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.name = _cast(None, name)
        self.service = _cast(None, service)
        self.namespace = _cast(None, namespace)
        self.serviceName = _cast(None, serviceName)
        self.entryPoint = _cast(None, entryPoint)
        self.serviceVendor = _cast(None, serviceVendor)
        self.serviceNamespace = _cast(None, serviceNamespace)
        self.apiVendor = _cast(None, apiVendor)
    def factory(*args_, **kwargs_):
        if QueryResultApiDefinitionRecordType.subclass:
            return QueryResultApiDefinitionRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultApiDefinitionRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_service(self): return self.service
    def set_service(self, service): self.service = service
    def get_namespace(self): return self.namespace
    def set_namespace(self, namespace): self.namespace = namespace
    def get_serviceName(self): return self.serviceName
    def set_serviceName(self, serviceName): self.serviceName = serviceName
    def get_entryPoint(self): return self.entryPoint
    def set_entryPoint(self, entryPoint): self.entryPoint = entryPoint
    def get_serviceVendor(self): return self.serviceVendor
    def set_serviceVendor(self, serviceVendor): self.serviceVendor = serviceVendor
    def get_serviceNamespace(self): return self.serviceNamespace
    def set_serviceNamespace(self, serviceNamespace): self.serviceNamespace = serviceNamespace
    def get_apiVendor(self): return self.apiVendor
    def set_apiVendor(self, apiVendor): self.apiVendor = apiVendor
    def hasContent_(self):
        if (
            super(QueryResultApiDefinitionRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultApiDefinitionRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultApiDefinitionRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultApiDefinitionRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultApiDefinitionRecordType'):
        super(QueryResultApiDefinitionRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultApiDefinitionRecordType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.service is not None and 'service' not in already_processed:
            already_processed.add('service')
            outfile.write(' service=%s' % (self.gds_format_string(quote_attrib(self.service).encode(ExternalEncoding), input_name='service'), ))
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            outfile.write(' namespace=%s' % (self.gds_format_string(quote_attrib(self.namespace).encode(ExternalEncoding), input_name='namespace'), ))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            outfile.write(' serviceName=%s' % (self.gds_format_string(quote_attrib(self.serviceName).encode(ExternalEncoding), input_name='serviceName'), ))
        if self.entryPoint is not None and 'entryPoint' not in already_processed:
            already_processed.add('entryPoint')
            outfile.write(' entryPoint=%s' % (self.gds_format_string(quote_attrib(self.entryPoint).encode(ExternalEncoding), input_name='entryPoint'), ))
        if self.serviceVendor is not None and 'serviceVendor' not in already_processed:
            already_processed.add('serviceVendor')
            outfile.write(' serviceVendor=%s' % (self.gds_format_string(quote_attrib(self.serviceVendor).encode(ExternalEncoding), input_name='serviceVendor'), ))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            outfile.write(' serviceNamespace=%s' % (self.gds_format_string(quote_attrib(self.serviceNamespace).encode(ExternalEncoding), input_name='serviceNamespace'), ))
        if self.apiVendor is not None and 'apiVendor' not in already_processed:
            already_processed.add('apiVendor')
            outfile.write(' apiVendor=%s' % (self.gds_format_string(quote_attrib(self.apiVendor).encode(ExternalEncoding), input_name='apiVendor'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultApiDefinitionRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultApiDefinitionRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultApiDefinitionRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.service is not None and 'service' not in already_processed:
            already_processed.add('service')
            showIndent(outfile, level)
            outfile.write('service="%s",\n' % (self.service,))
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            showIndent(outfile, level)
            outfile.write('namespace="%s",\n' % (self.namespace,))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            showIndent(outfile, level)
            outfile.write('serviceName="%s",\n' % (self.serviceName,))
        if self.entryPoint is not None and 'entryPoint' not in already_processed:
            already_processed.add('entryPoint')
            showIndent(outfile, level)
            outfile.write('entryPoint="%s",\n' % (self.entryPoint,))
        if self.serviceVendor is not None and 'serviceVendor' not in already_processed:
            already_processed.add('serviceVendor')
            showIndent(outfile, level)
            outfile.write('serviceVendor="%s",\n' % (self.serviceVendor,))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            showIndent(outfile, level)
            outfile.write('serviceNamespace="%s",\n' % (self.serviceNamespace,))
        if self.apiVendor is not None and 'apiVendor' not in already_processed:
            already_processed.add('apiVendor')
            showIndent(outfile, level)
            outfile.write('apiVendor="%s",\n' % (self.apiVendor,))
        super(QueryResultApiDefinitionRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultApiDefinitionRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('service', node)
        if value is not None and 'service' not in already_processed:
            already_processed.add('service')
            self.service = value
        value = find_attr_value_('namespace', node)
        if value is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            self.namespace = value
        value = find_attr_value_('serviceName', node)
        if value is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            self.serviceName = value
        value = find_attr_value_('entryPoint', node)
        if value is not None and 'entryPoint' not in already_processed:
            already_processed.add('entryPoint')
            self.entryPoint = value
        value = find_attr_value_('serviceVendor', node)
        if value is not None and 'serviceVendor' not in already_processed:
            already_processed.add('serviceVendor')
            self.serviceVendor = value
        value = find_attr_value_('serviceNamespace', node)
        if value is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            self.serviceNamespace = value
        value = find_attr_value_('apiVendor', node)
        if value is not None and 'apiVendor' not in already_processed:
            already_processed.add('apiVendor')
            self.apiVendor = value
        super(QueryResultApiDefinitionRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultApiDefinitionRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultApiDefinitionRecordType


class QueryResultAdminFileDescriptorRecordType(QueryResultRecordType):
    """5.1 Type for a single adminFileDescriptor query result in records
    format. 5.1none File URL. 5.1none Reference to the API
    definition owner of the file descriptor 5.1none File mime type.
    5.1none File name. 5.1none API definition name 5.1none API
    definition namespace 5.1none API definition vendor 5.1none File
    descriptor owner service name 5.1none File descriptor owner
    service namespace 5.1none File descriptor owner service vendor
    5.1none Service reference or id"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, service=None, apiDefinition=None, fileMimeType=None, serviceName=None, serviceVendor=None, apiName=None, apiNamespace=None, fileUrl=None, apiVendor=None, serviceNamespace=None, name=None):
        self.original_tagname_ = None
        super(QueryResultAdminFileDescriptorRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.service = _cast(None, service)
        self.apiDefinition = _cast(None, apiDefinition)
        self.fileMimeType = _cast(None, fileMimeType)
        self.serviceName = _cast(None, serviceName)
        self.serviceVendor = _cast(None, serviceVendor)
        self.apiName = _cast(None, apiName)
        self.apiNamespace = _cast(None, apiNamespace)
        self.fileUrl = _cast(None, fileUrl)
        self.apiVendor = _cast(None, apiVendor)
        self.serviceNamespace = _cast(None, serviceNamespace)
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if QueryResultAdminFileDescriptorRecordType.subclass:
            return QueryResultAdminFileDescriptorRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAdminFileDescriptorRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_service(self): return self.service
    def set_service(self, service): self.service = service
    def get_apiDefinition(self): return self.apiDefinition
    def set_apiDefinition(self, apiDefinition): self.apiDefinition = apiDefinition
    def get_fileMimeType(self): return self.fileMimeType
    def set_fileMimeType(self, fileMimeType): self.fileMimeType = fileMimeType
    def get_serviceName(self): return self.serviceName
    def set_serviceName(self, serviceName): self.serviceName = serviceName
    def get_serviceVendor(self): return self.serviceVendor
    def set_serviceVendor(self, serviceVendor): self.serviceVendor = serviceVendor
    def get_apiName(self): return self.apiName
    def set_apiName(self, apiName): self.apiName = apiName
    def get_apiNamespace(self): return self.apiNamespace
    def set_apiNamespace(self, apiNamespace): self.apiNamespace = apiNamespace
    def get_fileUrl(self): return self.fileUrl
    def set_fileUrl(self, fileUrl): self.fileUrl = fileUrl
    def get_apiVendor(self): return self.apiVendor
    def set_apiVendor(self, apiVendor): self.apiVendor = apiVendor
    def get_serviceNamespace(self): return self.serviceNamespace
    def set_serviceNamespace(self, serviceNamespace): self.serviceNamespace = serviceNamespace
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            super(QueryResultAdminFileDescriptorRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAdminFileDescriptorRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminFileDescriptorRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAdminFileDescriptorRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAdminFileDescriptorRecordType'):
        super(QueryResultAdminFileDescriptorRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAdminFileDescriptorRecordType')
        if self.service is not None and 'service' not in already_processed:
            already_processed.add('service')
            outfile.write(' service=%s' % (self.gds_format_string(quote_attrib(self.service).encode(ExternalEncoding), input_name='service'), ))
        if self.apiDefinition is not None and 'apiDefinition' not in already_processed:
            already_processed.add('apiDefinition')
            outfile.write(' apiDefinition=%s' % (self.gds_format_string(quote_attrib(self.apiDefinition).encode(ExternalEncoding), input_name='apiDefinition'), ))
        if self.fileMimeType is not None and 'fileMimeType' not in already_processed:
            already_processed.add('fileMimeType')
            outfile.write(' fileMimeType=%s' % (self.gds_format_string(quote_attrib(self.fileMimeType).encode(ExternalEncoding), input_name='fileMimeType'), ))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            outfile.write(' serviceName=%s' % (self.gds_format_string(quote_attrib(self.serviceName).encode(ExternalEncoding), input_name='serviceName'), ))
        if self.serviceVendor is not None and 'serviceVendor' not in already_processed:
            already_processed.add('serviceVendor')
            outfile.write(' serviceVendor=%s' % (self.gds_format_string(quote_attrib(self.serviceVendor).encode(ExternalEncoding), input_name='serviceVendor'), ))
        if self.apiName is not None and 'apiName' not in already_processed:
            already_processed.add('apiName')
            outfile.write(' apiName=%s' % (self.gds_format_string(quote_attrib(self.apiName).encode(ExternalEncoding), input_name='apiName'), ))
        if self.apiNamespace is not None and 'apiNamespace' not in already_processed:
            already_processed.add('apiNamespace')
            outfile.write(' apiNamespace=%s' % (self.gds_format_string(quote_attrib(self.apiNamespace).encode(ExternalEncoding), input_name='apiNamespace'), ))
        if self.fileUrl is not None and 'fileUrl' not in already_processed:
            already_processed.add('fileUrl')
            outfile.write(' fileUrl=%s' % (self.gds_format_string(quote_attrib(self.fileUrl).encode(ExternalEncoding), input_name='fileUrl'), ))
        if self.apiVendor is not None and 'apiVendor' not in already_processed:
            already_processed.add('apiVendor')
            outfile.write(' apiVendor=%s' % (self.gds_format_string(quote_attrib(self.apiVendor).encode(ExternalEncoding), input_name='apiVendor'), ))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            outfile.write(' serviceNamespace=%s' % (self.gds_format_string(quote_attrib(self.serviceNamespace).encode(ExternalEncoding), input_name='serviceNamespace'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAdminFileDescriptorRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAdminFileDescriptorRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAdminFileDescriptorRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.service is not None and 'service' not in already_processed:
            already_processed.add('service')
            showIndent(outfile, level)
            outfile.write('service="%s",\n' % (self.service,))
        if self.apiDefinition is not None and 'apiDefinition' not in already_processed:
            already_processed.add('apiDefinition')
            showIndent(outfile, level)
            outfile.write('apiDefinition="%s",\n' % (self.apiDefinition,))
        if self.fileMimeType is not None and 'fileMimeType' not in already_processed:
            already_processed.add('fileMimeType')
            showIndent(outfile, level)
            outfile.write('fileMimeType="%s",\n' % (self.fileMimeType,))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            showIndent(outfile, level)
            outfile.write('serviceName="%s",\n' % (self.serviceName,))
        if self.serviceVendor is not None and 'serviceVendor' not in already_processed:
            already_processed.add('serviceVendor')
            showIndent(outfile, level)
            outfile.write('serviceVendor="%s",\n' % (self.serviceVendor,))
        if self.apiName is not None and 'apiName' not in already_processed:
            already_processed.add('apiName')
            showIndent(outfile, level)
            outfile.write('apiName="%s",\n' % (self.apiName,))
        if self.apiNamespace is not None and 'apiNamespace' not in already_processed:
            already_processed.add('apiNamespace')
            showIndent(outfile, level)
            outfile.write('apiNamespace="%s",\n' % (self.apiNamespace,))
        if self.fileUrl is not None and 'fileUrl' not in already_processed:
            already_processed.add('fileUrl')
            showIndent(outfile, level)
            outfile.write('fileUrl="%s",\n' % (self.fileUrl,))
        if self.apiVendor is not None and 'apiVendor' not in already_processed:
            already_processed.add('apiVendor')
            showIndent(outfile, level)
            outfile.write('apiVendor="%s",\n' % (self.apiVendor,))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            showIndent(outfile, level)
            outfile.write('serviceNamespace="%s",\n' % (self.serviceNamespace,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(QueryResultAdminFileDescriptorRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAdminFileDescriptorRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('service', node)
        if value is not None and 'service' not in already_processed:
            already_processed.add('service')
            self.service = value
        value = find_attr_value_('apiDefinition', node)
        if value is not None and 'apiDefinition' not in already_processed:
            already_processed.add('apiDefinition')
            self.apiDefinition = value
        value = find_attr_value_('fileMimeType', node)
        if value is not None and 'fileMimeType' not in already_processed:
            already_processed.add('fileMimeType')
            self.fileMimeType = value
        value = find_attr_value_('serviceName', node)
        if value is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            self.serviceName = value
        value = find_attr_value_('serviceVendor', node)
        if value is not None and 'serviceVendor' not in already_processed:
            already_processed.add('serviceVendor')
            self.serviceVendor = value
        value = find_attr_value_('apiName', node)
        if value is not None and 'apiName' not in already_processed:
            already_processed.add('apiName')
            self.apiName = value
        value = find_attr_value_('apiNamespace', node)
        if value is not None and 'apiNamespace' not in already_processed:
            already_processed.add('apiNamespace')
            self.apiNamespace = value
        value = find_attr_value_('fileUrl', node)
        if value is not None and 'fileUrl' not in already_processed:
            already_processed.add('fileUrl')
            self.fileUrl = value
        value = find_attr_value_('apiVendor', node)
        if value is not None and 'apiVendor' not in already_processed:
            already_processed.add('apiVendor')
            self.apiVendor = value
        value = find_attr_value_('serviceNamespace', node)
        if value is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            self.serviceNamespace = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(QueryResultAdminFileDescriptorRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAdminFileDescriptorRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAdminFileDescriptorRecordType


class QueryResultFileDescriptorRecordType(QueryResultRecordType):
    """5.1 Type for a single fileDescriptor query result in records format.
    5.1none File URL. 5.1none Reference to the API definition owner
    of the file descriptor 5.1none File mime type. 5.1none File
    name. 5.1none API definition name 5.1none API definition
    namespace 5.1none API definition vendor 5.1none File descriptor
    owner service name 5.1none File descriptor owner service
    namespace 5.1none File descriptor owner service vendor 5.1none
    Service reference or id"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, service=None, apiDefinition=None, fileMimeType=None, serviceName=None, serviceVendor=None, apiName=None, apiNamespace=None, fileUrl=None, apiVendor=None, serviceNamespace=None, name=None):
        self.original_tagname_ = None
        super(QueryResultFileDescriptorRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.service = _cast(None, service)
        self.apiDefinition = _cast(None, apiDefinition)
        self.fileMimeType = _cast(None, fileMimeType)
        self.serviceName = _cast(None, serviceName)
        self.serviceVendor = _cast(None, serviceVendor)
        self.apiName = _cast(None, apiName)
        self.apiNamespace = _cast(None, apiNamespace)
        self.fileUrl = _cast(None, fileUrl)
        self.apiVendor = _cast(None, apiVendor)
        self.serviceNamespace = _cast(None, serviceNamespace)
        self.name = _cast(None, name)
    def factory(*args_, **kwargs_):
        if QueryResultFileDescriptorRecordType.subclass:
            return QueryResultFileDescriptorRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultFileDescriptorRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_service(self): return self.service
    def set_service(self, service): self.service = service
    def get_apiDefinition(self): return self.apiDefinition
    def set_apiDefinition(self, apiDefinition): self.apiDefinition = apiDefinition
    def get_fileMimeType(self): return self.fileMimeType
    def set_fileMimeType(self, fileMimeType): self.fileMimeType = fileMimeType
    def get_serviceName(self): return self.serviceName
    def set_serviceName(self, serviceName): self.serviceName = serviceName
    def get_serviceVendor(self): return self.serviceVendor
    def set_serviceVendor(self, serviceVendor): self.serviceVendor = serviceVendor
    def get_apiName(self): return self.apiName
    def set_apiName(self, apiName): self.apiName = apiName
    def get_apiNamespace(self): return self.apiNamespace
    def set_apiNamespace(self, apiNamespace): self.apiNamespace = apiNamespace
    def get_fileUrl(self): return self.fileUrl
    def set_fileUrl(self, fileUrl): self.fileUrl = fileUrl
    def get_apiVendor(self): return self.apiVendor
    def set_apiVendor(self, apiVendor): self.apiVendor = apiVendor
    def get_serviceNamespace(self): return self.serviceNamespace
    def set_serviceNamespace(self, serviceNamespace): self.serviceNamespace = serviceNamespace
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def hasContent_(self):
        if (
            super(QueryResultFileDescriptorRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultFileDescriptorRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultFileDescriptorRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultFileDescriptorRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultFileDescriptorRecordType'):
        super(QueryResultFileDescriptorRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultFileDescriptorRecordType')
        if self.service is not None and 'service' not in already_processed:
            already_processed.add('service')
            outfile.write(' service=%s' % (self.gds_format_string(quote_attrib(self.service).encode(ExternalEncoding), input_name='service'), ))
        if self.apiDefinition is not None and 'apiDefinition' not in already_processed:
            already_processed.add('apiDefinition')
            outfile.write(' apiDefinition=%s' % (self.gds_format_string(quote_attrib(self.apiDefinition).encode(ExternalEncoding), input_name='apiDefinition'), ))
        if self.fileMimeType is not None and 'fileMimeType' not in already_processed:
            already_processed.add('fileMimeType')
            outfile.write(' fileMimeType=%s' % (self.gds_format_string(quote_attrib(self.fileMimeType).encode(ExternalEncoding), input_name='fileMimeType'), ))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            outfile.write(' serviceName=%s' % (self.gds_format_string(quote_attrib(self.serviceName).encode(ExternalEncoding), input_name='serviceName'), ))
        if self.serviceVendor is not None and 'serviceVendor' not in already_processed:
            already_processed.add('serviceVendor')
            outfile.write(' serviceVendor=%s' % (self.gds_format_string(quote_attrib(self.serviceVendor).encode(ExternalEncoding), input_name='serviceVendor'), ))
        if self.apiName is not None and 'apiName' not in already_processed:
            already_processed.add('apiName')
            outfile.write(' apiName=%s' % (self.gds_format_string(quote_attrib(self.apiName).encode(ExternalEncoding), input_name='apiName'), ))
        if self.apiNamespace is not None and 'apiNamespace' not in already_processed:
            already_processed.add('apiNamespace')
            outfile.write(' apiNamespace=%s' % (self.gds_format_string(quote_attrib(self.apiNamespace).encode(ExternalEncoding), input_name='apiNamespace'), ))
        if self.fileUrl is not None and 'fileUrl' not in already_processed:
            already_processed.add('fileUrl')
            outfile.write(' fileUrl=%s' % (self.gds_format_string(quote_attrib(self.fileUrl).encode(ExternalEncoding), input_name='fileUrl'), ))
        if self.apiVendor is not None and 'apiVendor' not in already_processed:
            already_processed.add('apiVendor')
            outfile.write(' apiVendor=%s' % (self.gds_format_string(quote_attrib(self.apiVendor).encode(ExternalEncoding), input_name='apiVendor'), ))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            outfile.write(' serviceNamespace=%s' % (self.gds_format_string(quote_attrib(self.serviceNamespace).encode(ExternalEncoding), input_name='serviceNamespace'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultFileDescriptorRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultFileDescriptorRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultFileDescriptorRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.service is not None and 'service' not in already_processed:
            already_processed.add('service')
            showIndent(outfile, level)
            outfile.write('service="%s",\n' % (self.service,))
        if self.apiDefinition is not None and 'apiDefinition' not in already_processed:
            already_processed.add('apiDefinition')
            showIndent(outfile, level)
            outfile.write('apiDefinition="%s",\n' % (self.apiDefinition,))
        if self.fileMimeType is not None and 'fileMimeType' not in already_processed:
            already_processed.add('fileMimeType')
            showIndent(outfile, level)
            outfile.write('fileMimeType="%s",\n' % (self.fileMimeType,))
        if self.serviceName is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            showIndent(outfile, level)
            outfile.write('serviceName="%s",\n' % (self.serviceName,))
        if self.serviceVendor is not None and 'serviceVendor' not in already_processed:
            already_processed.add('serviceVendor')
            showIndent(outfile, level)
            outfile.write('serviceVendor="%s",\n' % (self.serviceVendor,))
        if self.apiName is not None and 'apiName' not in already_processed:
            already_processed.add('apiName')
            showIndent(outfile, level)
            outfile.write('apiName="%s",\n' % (self.apiName,))
        if self.apiNamespace is not None and 'apiNamespace' not in already_processed:
            already_processed.add('apiNamespace')
            showIndent(outfile, level)
            outfile.write('apiNamespace="%s",\n' % (self.apiNamespace,))
        if self.fileUrl is not None and 'fileUrl' not in already_processed:
            already_processed.add('fileUrl')
            showIndent(outfile, level)
            outfile.write('fileUrl="%s",\n' % (self.fileUrl,))
        if self.apiVendor is not None and 'apiVendor' not in already_processed:
            already_processed.add('apiVendor')
            showIndent(outfile, level)
            outfile.write('apiVendor="%s",\n' % (self.apiVendor,))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            showIndent(outfile, level)
            outfile.write('serviceNamespace="%s",\n' % (self.serviceNamespace,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        super(QueryResultFileDescriptorRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultFileDescriptorRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('service', node)
        if value is not None and 'service' not in already_processed:
            already_processed.add('service')
            self.service = value
        value = find_attr_value_('apiDefinition', node)
        if value is not None and 'apiDefinition' not in already_processed:
            already_processed.add('apiDefinition')
            self.apiDefinition = value
        value = find_attr_value_('fileMimeType', node)
        if value is not None and 'fileMimeType' not in already_processed:
            already_processed.add('fileMimeType')
            self.fileMimeType = value
        value = find_attr_value_('serviceName', node)
        if value is not None and 'serviceName' not in already_processed:
            already_processed.add('serviceName')
            self.serviceName = value
        value = find_attr_value_('serviceVendor', node)
        if value is not None and 'serviceVendor' not in already_processed:
            already_processed.add('serviceVendor')
            self.serviceVendor = value
        value = find_attr_value_('apiName', node)
        if value is not None and 'apiName' not in already_processed:
            already_processed.add('apiName')
            self.apiName = value
        value = find_attr_value_('apiNamespace', node)
        if value is not None and 'apiNamespace' not in already_processed:
            already_processed.add('apiNamespace')
            self.apiNamespace = value
        value = find_attr_value_('fileUrl', node)
        if value is not None and 'fileUrl' not in already_processed:
            already_processed.add('fileUrl')
            self.fileUrl = value
        value = find_attr_value_('apiVendor', node)
        if value is not None and 'apiVendor' not in already_processed:
            already_processed.add('apiVendor')
            self.apiVendor = value
        value = find_attr_value_('serviceNamespace', node)
        if value is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            self.serviceNamespace = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        super(QueryResultFileDescriptorRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultFileDescriptorRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultFileDescriptorRecordType


class QueryResultResourceClassActionRecordType(QueryResultRecordType):
    """5.1 Type for a single resourceClassAction query result in records
    format. 5.1none The name of the action. 5.1none HTTP request
    method. One of GET, POST, PUT, DELETE. 5.1none HTTP URL regular
    expression pattern. 5.1none Reference to resource class."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, httpMethod=None, resourceClass=None, name=None, urlPattern=None):
        self.original_tagname_ = None
        super(QueryResultResourceClassActionRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.httpMethod = _cast(None, httpMethod)
        self.resourceClass = _cast(None, resourceClass)
        self.name = _cast(None, name)
        self.urlPattern = _cast(None, urlPattern)
    def factory(*args_, **kwargs_):
        if QueryResultResourceClassActionRecordType.subclass:
            return QueryResultResourceClassActionRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultResourceClassActionRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_httpMethod(self): return self.httpMethod
    def set_httpMethod(self, httpMethod): self.httpMethod = httpMethod
    def get_resourceClass(self): return self.resourceClass
    def set_resourceClass(self, resourceClass): self.resourceClass = resourceClass
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_urlPattern(self): return self.urlPattern
    def set_urlPattern(self, urlPattern): self.urlPattern = urlPattern
    def hasContent_(self):
        if (
            super(QueryResultResourceClassActionRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultResourceClassActionRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultResourceClassActionRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultResourceClassActionRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultResourceClassActionRecordType'):
        super(QueryResultResourceClassActionRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultResourceClassActionRecordType')
        if self.httpMethod is not None and 'httpMethod' not in already_processed:
            already_processed.add('httpMethod')
            outfile.write(' httpMethod=%s' % (self.gds_format_string(quote_attrib(self.httpMethod).encode(ExternalEncoding), input_name='httpMethod'), ))
        if self.resourceClass is not None and 'resourceClass' not in already_processed:
            already_processed.add('resourceClass')
            outfile.write(' resourceClass=%s' % (self.gds_format_string(quote_attrib(self.resourceClass).encode(ExternalEncoding), input_name='resourceClass'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.urlPattern is not None and 'urlPattern' not in already_processed:
            already_processed.add('urlPattern')
            outfile.write(' urlPattern=%s' % (self.gds_format_string(quote_attrib(self.urlPattern).encode(ExternalEncoding), input_name='urlPattern'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultResourceClassActionRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultResourceClassActionRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultResourceClassActionRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.httpMethod is not None and 'httpMethod' not in already_processed:
            already_processed.add('httpMethod')
            showIndent(outfile, level)
            outfile.write('httpMethod="%s",\n' % (self.httpMethod,))
        if self.resourceClass is not None and 'resourceClass' not in already_processed:
            already_processed.add('resourceClass')
            showIndent(outfile, level)
            outfile.write('resourceClass="%s",\n' % (self.resourceClass,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.urlPattern is not None and 'urlPattern' not in already_processed:
            already_processed.add('urlPattern')
            showIndent(outfile, level)
            outfile.write('urlPattern="%s",\n' % (self.urlPattern,))
        super(QueryResultResourceClassActionRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultResourceClassActionRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('httpMethod', node)
        if value is not None and 'httpMethod' not in already_processed:
            already_processed.add('httpMethod')
            self.httpMethod = value
        value = find_attr_value_('resourceClass', node)
        if value is not None and 'resourceClass' not in already_processed:
            already_processed.add('resourceClass')
            self.resourceClass = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('urlPattern', node)
        if value is not None and 'urlPattern' not in already_processed:
            already_processed.add('urlPattern')
            self.urlPattern = value
        super(QueryResultResourceClassActionRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultResourceClassActionRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultResourceClassActionRecordType


class QueryResultAclRuleRecordType(QueryResultRecordType):
    """5.1 Type for a single aclRule query result in records format.
    5.1none Organization reference or id. 5.1none Principal
    reference. 5.1none The name of the ACL rule. 5.1none
    ServiceResource reference or id. 5.1none Principal type - user
    or right. 5.1none Resource class action reference or id. 5.1none
    Organization Access - Entity, Shared or Published. 5.1none
    Service Resource Access - Entity or Shared . 5.1none Principal
    Access - Entity or Shared."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, orgAccess=None, name=None, resourceClassAction=None, serviceResourceAccess=None, principalType=None, principalAccess=None, org=None, serviceResource=None, principal=None):
        self.original_tagname_ = None
        super(QueryResultAclRuleRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.orgAccess = _cast(None, orgAccess)
        self.name = _cast(None, name)
        self.resourceClassAction = _cast(None, resourceClassAction)
        self.serviceResourceAccess = _cast(None, serviceResourceAccess)
        self.principalType = _cast(None, principalType)
        self.principalAccess = _cast(None, principalAccess)
        self.org = _cast(None, org)
        self.serviceResource = _cast(None, serviceResource)
        self.principal = _cast(None, principal)
    def factory(*args_, **kwargs_):
        if QueryResultAclRuleRecordType.subclass:
            return QueryResultAclRuleRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultAclRuleRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orgAccess(self): return self.orgAccess
    def set_orgAccess(self, orgAccess): self.orgAccess = orgAccess
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_resourceClassAction(self): return self.resourceClassAction
    def set_resourceClassAction(self, resourceClassAction): self.resourceClassAction = resourceClassAction
    def get_serviceResourceAccess(self): return self.serviceResourceAccess
    def set_serviceResourceAccess(self, serviceResourceAccess): self.serviceResourceAccess = serviceResourceAccess
    def get_principalType(self): return self.principalType
    def set_principalType(self, principalType): self.principalType = principalType
    def get_principalAccess(self): return self.principalAccess
    def set_principalAccess(self, principalAccess): self.principalAccess = principalAccess
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_serviceResource(self): return self.serviceResource
    def set_serviceResource(self, serviceResource): self.serviceResource = serviceResource
    def get_principal(self): return self.principal
    def set_principal(self, principal): self.principal = principal
    def hasContent_(self):
        if (
            super(QueryResultAclRuleRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultAclRuleRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAclRuleRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultAclRuleRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultAclRuleRecordType'):
        super(QueryResultAclRuleRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultAclRuleRecordType')
        if self.orgAccess is not None and 'orgAccess' not in already_processed:
            already_processed.add('orgAccess')
            outfile.write(' orgAccess=%s' % (self.gds_format_string(quote_attrib(self.orgAccess).encode(ExternalEncoding), input_name='orgAccess'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.resourceClassAction is not None and 'resourceClassAction' not in already_processed:
            already_processed.add('resourceClassAction')
            outfile.write(' resourceClassAction=%s' % (self.gds_format_string(quote_attrib(self.resourceClassAction).encode(ExternalEncoding), input_name='resourceClassAction'), ))
        if self.serviceResourceAccess is not None and 'serviceResourceAccess' not in already_processed:
            already_processed.add('serviceResourceAccess')
            outfile.write(' serviceResourceAccess=%s' % (self.gds_format_string(quote_attrib(self.serviceResourceAccess).encode(ExternalEncoding), input_name='serviceResourceAccess'), ))
        if self.principalType is not None and 'principalType' not in already_processed:
            already_processed.add('principalType')
            outfile.write(' principalType=%s' % (self.gds_format_string(quote_attrib(self.principalType).encode(ExternalEncoding), input_name='principalType'), ))
        if self.principalAccess is not None and 'principalAccess' not in already_processed:
            already_processed.add('principalAccess')
            outfile.write(' principalAccess=%s' % (self.gds_format_string(quote_attrib(self.principalAccess).encode(ExternalEncoding), input_name='principalAccess'), ))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.serviceResource is not None and 'serviceResource' not in already_processed:
            already_processed.add('serviceResource')
            outfile.write(' serviceResource=%s' % (self.gds_format_string(quote_attrib(self.serviceResource).encode(ExternalEncoding), input_name='serviceResource'), ))
        if self.principal is not None and 'principal' not in already_processed:
            already_processed.add('principal')
            outfile.write(' principal=%s' % (self.gds_format_string(quote_attrib(self.principal).encode(ExternalEncoding), input_name='principal'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultAclRuleRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultAclRuleRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultAclRuleRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.orgAccess is not None and 'orgAccess' not in already_processed:
            already_processed.add('orgAccess')
            showIndent(outfile, level)
            outfile.write('orgAccess="%s",\n' % (self.orgAccess,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.resourceClassAction is not None and 'resourceClassAction' not in already_processed:
            already_processed.add('resourceClassAction')
            showIndent(outfile, level)
            outfile.write('resourceClassAction="%s",\n' % (self.resourceClassAction,))
        if self.serviceResourceAccess is not None and 'serviceResourceAccess' not in already_processed:
            already_processed.add('serviceResourceAccess')
            showIndent(outfile, level)
            outfile.write('serviceResourceAccess="%s",\n' % (self.serviceResourceAccess,))
        if self.principalType is not None and 'principalType' not in already_processed:
            already_processed.add('principalType')
            showIndent(outfile, level)
            outfile.write('principalType="%s",\n' % (self.principalType,))
        if self.principalAccess is not None and 'principalAccess' not in already_processed:
            already_processed.add('principalAccess')
            showIndent(outfile, level)
            outfile.write('principalAccess="%s",\n' % (self.principalAccess,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.serviceResource is not None and 'serviceResource' not in already_processed:
            already_processed.add('serviceResource')
            showIndent(outfile, level)
            outfile.write('serviceResource="%s",\n' % (self.serviceResource,))
        if self.principal is not None and 'principal' not in already_processed:
            already_processed.add('principal')
            showIndent(outfile, level)
            outfile.write('principal="%s",\n' % (self.principal,))
        super(QueryResultAclRuleRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultAclRuleRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('orgAccess', node)
        if value is not None and 'orgAccess' not in already_processed:
            already_processed.add('orgAccess')
            self.orgAccess = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('resourceClassAction', node)
        if value is not None and 'resourceClassAction' not in already_processed:
            already_processed.add('resourceClassAction')
            self.resourceClassAction = value
        value = find_attr_value_('serviceResourceAccess', node)
        if value is not None and 'serviceResourceAccess' not in already_processed:
            already_processed.add('serviceResourceAccess')
            self.serviceResourceAccess = value
        value = find_attr_value_('principalType', node)
        if value is not None and 'principalType' not in already_processed:
            already_processed.add('principalType')
            self.principalType = value
        value = find_attr_value_('principalAccess', node)
        if value is not None and 'principalAccess' not in already_processed:
            already_processed.add('principalAccess')
            self.principalAccess = value
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('serviceResource', node)
        if value is not None and 'serviceResource' not in already_processed:
            already_processed.add('serviceResource')
            self.serviceResource = value
        value = find_attr_value_('principal', node)
        if value is not None and 'principal' not in already_processed:
            already_processed.add('principal')
            self.principal = value
        super(QueryResultAclRuleRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultAclRuleRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultAclRuleRecordType


class QueryResultResourceClassRecordType(QueryResultRecordType):
    """5.1 Type for a single resourceClass query result in records format.
    5.1none The name of the resource class. 5.1none Service
    reference or id 5.1none The MIME type of this resource class.
    5.1none Object's url template 5.1none NID part of a urn which in
    the resolving process will have link based on the url template
    5.1none String template that should match the NSS part of a urn"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, mimeType=None, name=None, service=None, urnPattern=None, nid=None, urlTemplate=None):
        self.original_tagname_ = None
        super(QueryResultResourceClassRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.mimeType = _cast(None, mimeType)
        self.name = _cast(None, name)
        self.service = _cast(None, service)
        self.urnPattern = _cast(None, urnPattern)
        self.nid = _cast(None, nid)
        self.urlTemplate = _cast(None, urlTemplate)
    def factory(*args_, **kwargs_):
        if QueryResultResourceClassRecordType.subclass:
            return QueryResultResourceClassRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultResourceClassRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mimeType(self): return self.mimeType
    def set_mimeType(self, mimeType): self.mimeType = mimeType
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_service(self): return self.service
    def set_service(self, service): self.service = service
    def get_urnPattern(self): return self.urnPattern
    def set_urnPattern(self, urnPattern): self.urnPattern = urnPattern
    def get_nid(self): return self.nid
    def set_nid(self, nid): self.nid = nid
    def get_urlTemplate(self): return self.urlTemplate
    def set_urlTemplate(self, urlTemplate): self.urlTemplate = urlTemplate
    def hasContent_(self):
        if (
            super(QueryResultResourceClassRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultResourceClassRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultResourceClassRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultResourceClassRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultResourceClassRecordType'):
        super(QueryResultResourceClassRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultResourceClassRecordType')
        if self.mimeType is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            outfile.write(' mimeType=%s' % (self.gds_format_string(quote_attrib(self.mimeType).encode(ExternalEncoding), input_name='mimeType'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.service is not None and 'service' not in already_processed:
            already_processed.add('service')
            outfile.write(' service=%s' % (self.gds_format_string(quote_attrib(self.service).encode(ExternalEncoding), input_name='service'), ))
        if self.urnPattern is not None and 'urnPattern' not in already_processed:
            already_processed.add('urnPattern')
            outfile.write(' urnPattern=%s' % (self.gds_format_string(quote_attrib(self.urnPattern).encode(ExternalEncoding), input_name='urnPattern'), ))
        if self.nid is not None and 'nid' not in already_processed:
            already_processed.add('nid')
            outfile.write(' nid=%s' % (self.gds_format_string(quote_attrib(self.nid).encode(ExternalEncoding), input_name='nid'), ))
        if self.urlTemplate is not None and 'urlTemplate' not in already_processed:
            already_processed.add('urlTemplate')
            outfile.write(' urlTemplate=%s' % (self.gds_format_string(quote_attrib(self.urlTemplate).encode(ExternalEncoding), input_name='urlTemplate'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultResourceClassRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultResourceClassRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultResourceClassRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mimeType is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            showIndent(outfile, level)
            outfile.write('mimeType="%s",\n' % (self.mimeType,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.service is not None and 'service' not in already_processed:
            already_processed.add('service')
            showIndent(outfile, level)
            outfile.write('service="%s",\n' % (self.service,))
        if self.urnPattern is not None and 'urnPattern' not in already_processed:
            already_processed.add('urnPattern')
            showIndent(outfile, level)
            outfile.write('urnPattern="%s",\n' % (self.urnPattern,))
        if self.nid is not None and 'nid' not in already_processed:
            already_processed.add('nid')
            showIndent(outfile, level)
            outfile.write('nid="%s",\n' % (self.nid,))
        if self.urlTemplate is not None and 'urlTemplate' not in already_processed:
            already_processed.add('urlTemplate')
            showIndent(outfile, level)
            outfile.write('urlTemplate="%s",\n' % (self.urlTemplate,))
        super(QueryResultResourceClassRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultResourceClassRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mimeType', node)
        if value is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            self.mimeType = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('service', node)
        if value is not None and 'service' not in already_processed:
            already_processed.add('service')
            self.service = value
        value = find_attr_value_('urnPattern', node)
        if value is not None and 'urnPattern' not in already_processed:
            already_processed.add('urnPattern')
            self.urnPattern = value
        value = find_attr_value_('nid', node)
        if value is not None and 'nid' not in already_processed:
            already_processed.add('nid')
            self.nid = value
        value = find_attr_value_('urlTemplate', node)
        if value is not None and 'urlTemplate' not in already_processed:
            already_processed.add('urlTemplate')
            self.urlTemplate = value
        super(QueryResultResourceClassRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultResourceClassRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultResourceClassRecordType


class QueryResultServiceResourceRecordType(QueryResultRecordType):
    """5.1 Type for a single serviceResource query result in records
    format. 5.1none The name of the service resource. 5.1none
    Reference to organization or id. 5.1none Reference to resource
    class. 5.1none The id of the external object."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, org=None, externalObjectId=None, name=None, resourceClass=None):
        self.original_tagname_ = None
        super(QueryResultServiceResourceRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.org = _cast(None, org)
        self.externalObjectId = _cast(None, externalObjectId)
        self.name = _cast(None, name)
        self.resourceClass = _cast(None, resourceClass)
    def factory(*args_, **kwargs_):
        if QueryResultServiceResourceRecordType.subclass:
            return QueryResultServiceResourceRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultServiceResourceRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_externalObjectId(self): return self.externalObjectId
    def set_externalObjectId(self, externalObjectId): self.externalObjectId = externalObjectId
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_resourceClass(self): return self.resourceClass
    def set_resourceClass(self, resourceClass): self.resourceClass = resourceClass
    def hasContent_(self):
        if (
            super(QueryResultServiceResourceRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultServiceResourceRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultServiceResourceRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultServiceResourceRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultServiceResourceRecordType'):
        super(QueryResultServiceResourceRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultServiceResourceRecordType')
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.externalObjectId is not None and 'externalObjectId' not in already_processed:
            already_processed.add('externalObjectId')
            outfile.write(' externalObjectId=%s' % (self.gds_format_string(quote_attrib(self.externalObjectId).encode(ExternalEncoding), input_name='externalObjectId'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.resourceClass is not None and 'resourceClass' not in already_processed:
            already_processed.add('resourceClass')
            outfile.write(' resourceClass=%s' % (self.gds_format_string(quote_attrib(self.resourceClass).encode(ExternalEncoding), input_name='resourceClass'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultServiceResourceRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultServiceResourceRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultServiceResourceRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.externalObjectId is not None and 'externalObjectId' not in already_processed:
            already_processed.add('externalObjectId')
            showIndent(outfile, level)
            outfile.write('externalObjectId="%s",\n' % (self.externalObjectId,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.resourceClass is not None and 'resourceClass' not in already_processed:
            already_processed.add('resourceClass')
            showIndent(outfile, level)
            outfile.write('resourceClass="%s",\n' % (self.resourceClass,))
        super(QueryResultServiceResourceRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultServiceResourceRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('externalObjectId', node)
        if value is not None and 'externalObjectId' not in already_processed:
            already_processed.add('externalObjectId')
            self.externalObjectId = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('resourceClass', node)
        if value is not None and 'resourceClass' not in already_processed:
            already_processed.add('resourceClass')
            self.resourceClass = value
        super(QueryResultServiceResourceRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultServiceResourceRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultServiceResourceRecordType


class QueryResultEdgeGatewayRecordType(QueryResultRecordType):
    """5.1 Type for a single edgeGateway query result in records format.
    5.1none EdgeGateway name. 5.1none VDC Reference or ID 5.1none
    Number of external networks connected to the edgeGateway.
    5.1none Number of org VDC networks connected to the edgeGateway
    5.1none True if this Edge Gateway is busy. 5.1none 5.1none High
    Availability Status of the edgeGateway"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, name=None, haStatus=None, gatewayStatus=None, vdc=None, numberOfExtNetworks=None, numberOfOrgNetworks=None, isBusy=None):
        self.original_tagname_ = None
        super(QueryResultEdgeGatewayRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.name = _cast(None, name)
        self.haStatus = _cast(None, haStatus)
        self.gatewayStatus = _cast(None, gatewayStatus)
        self.vdc = _cast(None, vdc)
        self.numberOfExtNetworks = _cast(int, numberOfExtNetworks)
        self.numberOfOrgNetworks = _cast(int, numberOfOrgNetworks)
        self.isBusy = _cast(bool, isBusy)
    def factory(*args_, **kwargs_):
        if QueryResultEdgeGatewayRecordType.subclass:
            return QueryResultEdgeGatewayRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultEdgeGatewayRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_haStatus(self): return self.haStatus
    def set_haStatus(self, haStatus): self.haStatus = haStatus
    def get_gatewayStatus(self): return self.gatewayStatus
    def set_gatewayStatus(self, gatewayStatus): self.gatewayStatus = gatewayStatus
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_numberOfExtNetworks(self): return self.numberOfExtNetworks
    def set_numberOfExtNetworks(self, numberOfExtNetworks): self.numberOfExtNetworks = numberOfExtNetworks
    def get_numberOfOrgNetworks(self): return self.numberOfOrgNetworks
    def set_numberOfOrgNetworks(self, numberOfOrgNetworks): self.numberOfOrgNetworks = numberOfOrgNetworks
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def hasContent_(self):
        if (
            super(QueryResultEdgeGatewayRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultEdgeGatewayRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultEdgeGatewayRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultEdgeGatewayRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultEdgeGatewayRecordType'):
        super(QueryResultEdgeGatewayRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultEdgeGatewayRecordType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.haStatus is not None and 'haStatus' not in already_processed:
            already_processed.add('haStatus')
            outfile.write(' haStatus=%s' % (self.gds_format_string(quote_attrib(self.haStatus).encode(ExternalEncoding), input_name='haStatus'), ))
        if self.gatewayStatus is not None and 'gatewayStatus' not in already_processed:
            already_processed.add('gatewayStatus')
            outfile.write(' gatewayStatus=%s' % (self.gds_format_string(quote_attrib(self.gatewayStatus).encode(ExternalEncoding), input_name='gatewayStatus'), ))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.numberOfExtNetworks is not None and 'numberOfExtNetworks' not in already_processed:
            already_processed.add('numberOfExtNetworks')
            outfile.write(' numberOfExtNetworks="%s"' % self.gds_format_integer(self.numberOfExtNetworks, input_name='numberOfExtNetworks'))
        if self.numberOfOrgNetworks is not None and 'numberOfOrgNetworks' not in already_processed:
            already_processed.add('numberOfOrgNetworks')
            outfile.write(' numberOfOrgNetworks="%s"' % self.gds_format_integer(self.numberOfOrgNetworks, input_name='numberOfOrgNetworks'))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultEdgeGatewayRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultEdgeGatewayRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultEdgeGatewayRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.haStatus is not None and 'haStatus' not in already_processed:
            already_processed.add('haStatus')
            showIndent(outfile, level)
            outfile.write('haStatus="%s",\n' % (self.haStatus,))
        if self.gatewayStatus is not None and 'gatewayStatus' not in already_processed:
            already_processed.add('gatewayStatus')
            showIndent(outfile, level)
            outfile.write('gatewayStatus="%s",\n' % (self.gatewayStatus,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.numberOfExtNetworks is not None and 'numberOfExtNetworks' not in already_processed:
            already_processed.add('numberOfExtNetworks')
            showIndent(outfile, level)
            outfile.write('numberOfExtNetworks=%d,\n' % (self.numberOfExtNetworks,))
        if self.numberOfOrgNetworks is not None and 'numberOfOrgNetworks' not in already_processed:
            already_processed.add('numberOfOrgNetworks')
            showIndent(outfile, level)
            outfile.write('numberOfOrgNetworks=%d,\n' % (self.numberOfOrgNetworks,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        super(QueryResultEdgeGatewayRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultEdgeGatewayRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('haStatus', node)
        if value is not None and 'haStatus' not in already_processed:
            already_processed.add('haStatus')
            self.haStatus = value
        value = find_attr_value_('gatewayStatus', node)
        if value is not None and 'gatewayStatus' not in already_processed:
            already_processed.add('gatewayStatus')
            self.gatewayStatus = value
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('numberOfExtNetworks', node)
        if value is not None and 'numberOfExtNetworks' not in already_processed:
            already_processed.add('numberOfExtNetworks')
            try:
                self.numberOfExtNetworks = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numberOfOrgNetworks', node)
        if value is not None and 'numberOfOrgNetworks' not in already_processed:
            already_processed.add('numberOfOrgNetworks')
            try:
                self.numberOfOrgNetworks = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(QueryResultEdgeGatewayRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultEdgeGatewayRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultEdgeGatewayRecordType


class QueryResultOrgVdcNetworkRecordType(QueryResultRecordType):
    """5.1 Type for a single orgVdcNetwork query result in records format.
    5.1none Network Name 5.1none Default Gateway 5.1none Netmask
    5.1none Primary DNS 5.1none Secondary DNS 5.1none DNS Suffix
    5.1none Link Type 5.1none Network or Gateway that it connects to
    5.1none VDC Reference or ID 5.1none True if this network is
    busy. 5.1none True if this network is shared. 5.1none VDC Name
    5.1none True if this network's IP scope is inherited."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, linkType=None, isIpScopeInherited=None, name=None, dns2=None, dns1=None, connectedTo=None, vdcName=None, netmask=None, vdc=None, dnsSuffix=None, isBusy=None, isShared=None, defaultGateway=None):
        self.original_tagname_ = None
        super(QueryResultOrgVdcNetworkRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.linkType = _cast(int, linkType)
        self.isIpScopeInherited = _cast(bool, isIpScopeInherited)
        self.name = _cast(None, name)
        self.dns2 = _cast(None, dns2)
        self.dns1 = _cast(None, dns1)
        self.connectedTo = _cast(None, connectedTo)
        self.vdcName = _cast(None, vdcName)
        self.netmask = _cast(None, netmask)
        self.vdc = _cast(None, vdc)
        self.dnsSuffix = _cast(None, dnsSuffix)
        self.isBusy = _cast(bool, isBusy)
        self.isShared = _cast(bool, isShared)
        self.defaultGateway = _cast(None, defaultGateway)
    def factory(*args_, **kwargs_):
        if QueryResultOrgVdcNetworkRecordType.subclass:
            return QueryResultOrgVdcNetworkRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultOrgVdcNetworkRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_linkType(self): return self.linkType
    def set_linkType(self, linkType): self.linkType = linkType
    def get_isIpScopeInherited(self): return self.isIpScopeInherited
    def set_isIpScopeInherited(self, isIpScopeInherited): self.isIpScopeInherited = isIpScopeInherited
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_dns2(self): return self.dns2
    def set_dns2(self, dns2): self.dns2 = dns2
    def get_dns1(self): return self.dns1
    def set_dns1(self, dns1): self.dns1 = dns1
    def get_connectedTo(self): return self.connectedTo
    def set_connectedTo(self, connectedTo): self.connectedTo = connectedTo
    def get_vdcName(self): return self.vdcName
    def set_vdcName(self, vdcName): self.vdcName = vdcName
    def get_netmask(self): return self.netmask
    def set_netmask(self, netmask): self.netmask = netmask
    def get_vdc(self): return self.vdc
    def set_vdc(self, vdc): self.vdc = vdc
    def get_dnsSuffix(self): return self.dnsSuffix
    def set_dnsSuffix(self, dnsSuffix): self.dnsSuffix = dnsSuffix
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def get_isShared(self): return self.isShared
    def set_isShared(self, isShared): self.isShared = isShared
    def get_defaultGateway(self): return self.defaultGateway
    def set_defaultGateway(self, defaultGateway): self.defaultGateway = defaultGateway
    def hasContent_(self):
        if (
            super(QueryResultOrgVdcNetworkRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultOrgVdcNetworkRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultOrgVdcNetworkRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultOrgVdcNetworkRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultOrgVdcNetworkRecordType'):
        super(QueryResultOrgVdcNetworkRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultOrgVdcNetworkRecordType')
        if self.linkType is not None and 'linkType' not in already_processed:
            already_processed.add('linkType')
            outfile.write(' linkType="%s"' % self.gds_format_integer(self.linkType, input_name='linkType'))
        if self.isIpScopeInherited is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            outfile.write(' isIpScopeInherited="%s"' % self.gds_format_boolean(self.isIpScopeInherited, input_name='isIpScopeInherited'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.dns2 is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            outfile.write(' dns2=%s' % (self.gds_format_string(quote_attrib(self.dns2).encode(ExternalEncoding), input_name='dns2'), ))
        if self.dns1 is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            outfile.write(' dns1=%s' % (self.gds_format_string(quote_attrib(self.dns1).encode(ExternalEncoding), input_name='dns1'), ))
        if self.connectedTo is not None and 'connectedTo' not in already_processed:
            already_processed.add('connectedTo')
            outfile.write(' connectedTo=%s' % (self.gds_format_string(quote_attrib(self.connectedTo).encode(ExternalEncoding), input_name='connectedTo'), ))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            outfile.write(' vdcName=%s' % (self.gds_format_string(quote_attrib(self.vdcName).encode(ExternalEncoding), input_name='vdcName'), ))
        if self.netmask is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            outfile.write(' netmask=%s' % (self.gds_format_string(quote_attrib(self.netmask).encode(ExternalEncoding), input_name='netmask'), ))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            outfile.write(' vdc=%s' % (self.gds_format_string(quote_attrib(self.vdc).encode(ExternalEncoding), input_name='vdc'), ))
        if self.dnsSuffix is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            outfile.write(' dnsSuffix=%s' % (self.gds_format_string(quote_attrib(self.dnsSuffix).encode(ExternalEncoding), input_name='dnsSuffix'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
        if self.isShared is not None and 'isShared' not in already_processed:
            already_processed.add('isShared')
            outfile.write(' isShared="%s"' % self.gds_format_boolean(self.isShared, input_name='isShared'))
        if self.defaultGateway is not None and 'defaultGateway' not in already_processed:
            already_processed.add('defaultGateway')
            outfile.write(' defaultGateway=%s' % (self.gds_format_string(quote_attrib(self.defaultGateway).encode(ExternalEncoding), input_name='defaultGateway'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultOrgVdcNetworkRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultOrgVdcNetworkRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultOrgVdcNetworkRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.linkType is not None and 'linkType' not in already_processed:
            already_processed.add('linkType')
            showIndent(outfile, level)
            outfile.write('linkType=%d,\n' % (self.linkType,))
        if self.isIpScopeInherited is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            showIndent(outfile, level)
            outfile.write('isIpScopeInherited=%s,\n' % (self.isIpScopeInherited,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.dns2 is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            showIndent(outfile, level)
            outfile.write('dns2="%s",\n' % (self.dns2,))
        if self.dns1 is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            showIndent(outfile, level)
            outfile.write('dns1="%s",\n' % (self.dns1,))
        if self.connectedTo is not None and 'connectedTo' not in already_processed:
            already_processed.add('connectedTo')
            showIndent(outfile, level)
            outfile.write('connectedTo="%s",\n' % (self.connectedTo,))
        if self.vdcName is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            showIndent(outfile, level)
            outfile.write('vdcName="%s",\n' % (self.vdcName,))
        if self.netmask is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            showIndent(outfile, level)
            outfile.write('netmask="%s",\n' % (self.netmask,))
        if self.vdc is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            showIndent(outfile, level)
            outfile.write('vdc="%s",\n' % (self.vdc,))
        if self.dnsSuffix is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            showIndent(outfile, level)
            outfile.write('dnsSuffix="%s",\n' % (self.dnsSuffix,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        if self.isShared is not None and 'isShared' not in already_processed:
            already_processed.add('isShared')
            showIndent(outfile, level)
            outfile.write('isShared=%s,\n' % (self.isShared,))
        if self.defaultGateway is not None and 'defaultGateway' not in already_processed:
            already_processed.add('defaultGateway')
            showIndent(outfile, level)
            outfile.write('defaultGateway="%s",\n' % (self.defaultGateway,))
        super(QueryResultOrgVdcNetworkRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultOrgVdcNetworkRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('linkType', node)
        if value is not None and 'linkType' not in already_processed:
            already_processed.add('linkType')
            try:
                self.linkType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isIpScopeInherited', node)
        if value is not None and 'isIpScopeInherited' not in already_processed:
            already_processed.add('isIpScopeInherited')
            if value in ('true', '1'):
                self.isIpScopeInherited = True
            elif value in ('false', '0'):
                self.isIpScopeInherited = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('dns2', node)
        if value is not None and 'dns2' not in already_processed:
            already_processed.add('dns2')
            self.dns2 = value
        value = find_attr_value_('dns1', node)
        if value is not None and 'dns1' not in already_processed:
            already_processed.add('dns1')
            self.dns1 = value
        value = find_attr_value_('connectedTo', node)
        if value is not None and 'connectedTo' not in already_processed:
            already_processed.add('connectedTo')
            self.connectedTo = value
        value = find_attr_value_('vdcName', node)
        if value is not None and 'vdcName' not in already_processed:
            already_processed.add('vdcName')
            self.vdcName = value
        value = find_attr_value_('netmask', node)
        if value is not None and 'netmask' not in already_processed:
            already_processed.add('netmask')
            self.netmask = value
        value = find_attr_value_('vdc', node)
        if value is not None and 'vdc' not in already_processed:
            already_processed.add('vdc')
            self.vdc = value
        value = find_attr_value_('dnsSuffix', node)
        if value is not None and 'dnsSuffix' not in already_processed:
            already_processed.add('dnsSuffix')
            self.dnsSuffix = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isShared', node)
        if value is not None and 'isShared' not in already_processed:
            already_processed.add('isShared')
            if value in ('true', '1'):
                self.isShared = True
            elif value in ('false', '0'):
                self.isShared = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('defaultGateway', node)
        if value is not None and 'defaultGateway' not in already_processed:
            already_processed.add('defaultGateway')
            self.defaultGateway = value
        super(QueryResultOrgVdcNetworkRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultOrgVdcNetworkRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultOrgVdcNetworkRecordType


class QueryResultVAppOrgVdcNetworkRelationRecordType(QueryResultRecordType):
    """5.1 Type for a single vAppOrgVdcNetworkRelation query result in
    records format. 5.1none Configuration Type 5.1none Entity name
    5.1none Organization reference or id 5.1none Network reference
    or id 5.1none Network name 5.1none Status 5.1none Owner name"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, name=None, entityType=None, orgVdcNetworkName=None, ownerName=None, org=None, orgVdcNetwork=None):
        self.original_tagname_ = None
        super(QueryResultVAppOrgVdcNetworkRelationRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        self.name = _cast(None, name)
        self.entityType = _cast(None, entityType)
        self.orgVdcNetworkName = _cast(None, orgVdcNetworkName)
        self.ownerName = _cast(None, ownerName)
        self.org = _cast(None, org)
        self.orgVdcNetwork = _cast(None, orgVdcNetwork)
    def factory(*args_, **kwargs_):
        if QueryResultVAppOrgVdcNetworkRelationRecordType.subclass:
            return QueryResultVAppOrgVdcNetworkRelationRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultVAppOrgVdcNetworkRelationRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_entityType(self): return self.entityType
    def set_entityType(self, entityType): self.entityType = entityType
    def get_orgVdcNetworkName(self): return self.orgVdcNetworkName
    def set_orgVdcNetworkName(self, orgVdcNetworkName): self.orgVdcNetworkName = orgVdcNetworkName
    def get_ownerName(self): return self.ownerName
    def set_ownerName(self, ownerName): self.ownerName = ownerName
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_orgVdcNetwork(self): return self.orgVdcNetwork
    def set_orgVdcNetwork(self, orgVdcNetwork): self.orgVdcNetwork = orgVdcNetwork
    def hasContent_(self):
        if (
            super(QueryResultVAppOrgVdcNetworkRelationRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultVAppOrgVdcNetworkRelationRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVAppOrgVdcNetworkRelationRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultVAppOrgVdcNetworkRelationRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultVAppOrgVdcNetworkRelationRecordType'):
        super(QueryResultVAppOrgVdcNetworkRelationRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultVAppOrgVdcNetworkRelationRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.entityType is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            outfile.write(' entityType=%s' % (self.gds_format_string(quote_attrib(self.entityType).encode(ExternalEncoding), input_name='entityType'), ))
        if self.orgVdcNetworkName is not None and 'orgVdcNetworkName' not in already_processed:
            already_processed.add('orgVdcNetworkName')
            outfile.write(' orgVdcNetworkName=%s' % (self.gds_format_string(quote_attrib(self.orgVdcNetworkName).encode(ExternalEncoding), input_name='orgVdcNetworkName'), ))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            outfile.write(' ownerName=%s' % (self.gds_format_string(quote_attrib(self.ownerName).encode(ExternalEncoding), input_name='ownerName'), ))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.orgVdcNetwork is not None and 'orgVdcNetwork' not in already_processed:
            already_processed.add('orgVdcNetwork')
            outfile.write(' orgVdcNetwork=%s' % (self.gds_format_string(quote_attrib(self.orgVdcNetwork).encode(ExternalEncoding), input_name='orgVdcNetwork'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultVAppOrgVdcNetworkRelationRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultVAppOrgVdcNetworkRelationRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultVAppOrgVdcNetworkRelationRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.entityType is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            showIndent(outfile, level)
            outfile.write('entityType="%s",\n' % (self.entityType,))
        if self.orgVdcNetworkName is not None and 'orgVdcNetworkName' not in already_processed:
            already_processed.add('orgVdcNetworkName')
            showIndent(outfile, level)
            outfile.write('orgVdcNetworkName="%s",\n' % (self.orgVdcNetworkName,))
        if self.ownerName is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            showIndent(outfile, level)
            outfile.write('ownerName="%s",\n' % (self.ownerName,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.orgVdcNetwork is not None and 'orgVdcNetwork' not in already_processed:
            already_processed.add('orgVdcNetwork')
            showIndent(outfile, level)
            outfile.write('orgVdcNetwork="%s",\n' % (self.orgVdcNetwork,))
        super(QueryResultVAppOrgVdcNetworkRelationRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultVAppOrgVdcNetworkRelationRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('entityType', node)
        if value is not None and 'entityType' not in already_processed:
            already_processed.add('entityType')
            self.entityType = value
        value = find_attr_value_('orgVdcNetworkName', node)
        if value is not None and 'orgVdcNetworkName' not in already_processed:
            already_processed.add('orgVdcNetworkName')
            self.orgVdcNetworkName = value
        value = find_attr_value_('ownerName', node)
        if value is not None and 'ownerName' not in already_processed:
            already_processed.add('ownerName')
            self.ownerName = value
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('orgVdcNetwork', node)
        if value is not None and 'orgVdcNetwork' not in already_processed:
            already_processed.add('orgVdcNetwork')
            self.orgVdcNetwork = value
        super(QueryResultVAppOrgVdcNetworkRelationRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultVAppOrgVdcNetworkRelationRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultVAppOrgVdcNetworkRelationRecordType


class QueryResultExternalLocalizationRecordType(QueryResultRecordType):
    """5.1 Type for a single externalLocalization query result in records
    format. 5.1none Service namespace 5.1none Locale 5.1none
    Localization template key 5.1none Localization template value"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, locale=None, serviceNamespace=None, value=None, key=None):
        self.original_tagname_ = None
        super(QueryResultExternalLocalizationRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.locale = _cast(None, locale)
        self.serviceNamespace = _cast(None, serviceNamespace)
        self.value = _cast(None, value)
        self.key = _cast(None, key)
    def factory(*args_, **kwargs_):
        if QueryResultExternalLocalizationRecordType.subclass:
            return QueryResultExternalLocalizationRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultExternalLocalizationRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_locale(self): return self.locale
    def set_locale(self, locale): self.locale = locale
    def get_serviceNamespace(self): return self.serviceNamespace
    def set_serviceNamespace(self, serviceNamespace): self.serviceNamespace = serviceNamespace
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def hasContent_(self):
        if (
            super(QueryResultExternalLocalizationRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultExternalLocalizationRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultExternalLocalizationRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultExternalLocalizationRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultExternalLocalizationRecordType'):
        super(QueryResultExternalLocalizationRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultExternalLocalizationRecordType')
        if self.locale is not None and 'locale' not in already_processed:
            already_processed.add('locale')
            outfile.write(' locale=%s' % (self.gds_format_string(quote_attrib(self.locale).encode(ExternalEncoding), input_name='locale'), ))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            outfile.write(' serviceNamespace=%s' % (self.gds_format_string(quote_attrib(self.serviceNamespace).encode(ExternalEncoding), input_name='serviceNamespace'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultExternalLocalizationRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultExternalLocalizationRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultExternalLocalizationRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.locale is not None and 'locale' not in already_processed:
            already_processed.add('locale')
            showIndent(outfile, level)
            outfile.write('locale="%s",\n' % (self.locale,))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            showIndent(outfile, level)
            outfile.write('serviceNamespace="%s",\n' % (self.serviceNamespace,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            showIndent(outfile, level)
            outfile.write('key="%s",\n' % (self.key,))
        super(QueryResultExternalLocalizationRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultExternalLocalizationRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('locale', node)
        if value is not None and 'locale' not in already_processed:
            already_processed.add('locale')
            self.locale = value
        value = find_attr_value_('serviceNamespace', node)
        if value is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            self.serviceNamespace = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            self.key = value
        super(QueryResultExternalLocalizationRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultExternalLocalizationRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultExternalLocalizationRecordType


class QueryResultResourcePoolVMRecordType(QueryResultRecordType):
    """5.1 Type for a single resourcePoolVmList query result in records
    format. 5.1none The name of this resource pool. 5.1none VM
    Status 5.1none Name of the vApp or vApp template that contains
    the VM 5.1none Guest operating system 5.1none True if this
    entity is deployed 5.1none True if this entity is busy 5.1none
    Hardware version"""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, status=None, containerName=None, hardwareVersion=None, isDeployed=None, name=None, guestOs=None, isBusy=None):
        self.original_tagname_ = None
        super(QueryResultResourcePoolVMRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.status = _cast(None, status)
        self.containerName = _cast(None, containerName)
        self.hardwareVersion = _cast(int, hardwareVersion)
        self.isDeployed = _cast(bool, isDeployed)
        self.name = _cast(None, name)
        self.guestOs = _cast(None, guestOs)
        self.isBusy = _cast(bool, isBusy)
    def factory(*args_, **kwargs_):
        if QueryResultResourcePoolVMRecordType.subclass:
            return QueryResultResourcePoolVMRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultResourcePoolVMRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_containerName(self): return self.containerName
    def set_containerName(self, containerName): self.containerName = containerName
    def get_hardwareVersion(self): return self.hardwareVersion
    def set_hardwareVersion(self, hardwareVersion): self.hardwareVersion = hardwareVersion
    def get_isDeployed(self): return self.isDeployed
    def set_isDeployed(self, isDeployed): self.isDeployed = isDeployed
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_guestOs(self): return self.guestOs
    def set_guestOs(self, guestOs): self.guestOs = guestOs
    def get_isBusy(self): return self.isBusy
    def set_isBusy(self, isBusy): self.isBusy = isBusy
    def hasContent_(self):
        if (
            super(QueryResultResourcePoolVMRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultResourcePoolVMRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultResourcePoolVMRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultResourcePoolVMRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultResourcePoolVMRecordType'):
        super(QueryResultResourcePoolVMRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultResourcePoolVMRecordType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.containerName is not None and 'containerName' not in already_processed:
            already_processed.add('containerName')
            outfile.write(' containerName=%s' % (self.gds_format_string(quote_attrib(self.containerName).encode(ExternalEncoding), input_name='containerName'), ))
        if self.hardwareVersion is not None and 'hardwareVersion' not in already_processed:
            already_processed.add('hardwareVersion')
            outfile.write(' hardwareVersion="%s"' % self.gds_format_integer(self.hardwareVersion, input_name='hardwareVersion'))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            outfile.write(' isDeployed="%s"' % self.gds_format_boolean(self.isDeployed, input_name='isDeployed'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.guestOs is not None and 'guestOs' not in already_processed:
            already_processed.add('guestOs')
            outfile.write(' guestOs=%s' % (self.gds_format_string(quote_attrib(self.guestOs).encode(ExternalEncoding), input_name='guestOs'), ))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            outfile.write(' isBusy="%s"' % self.gds_format_boolean(self.isBusy, input_name='isBusy'))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultResourcePoolVMRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultResourcePoolVMRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultResourcePoolVMRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.containerName is not None and 'containerName' not in already_processed:
            already_processed.add('containerName')
            showIndent(outfile, level)
            outfile.write('containerName="%s",\n' % (self.containerName,))
        if self.hardwareVersion is not None and 'hardwareVersion' not in already_processed:
            already_processed.add('hardwareVersion')
            showIndent(outfile, level)
            outfile.write('hardwareVersion=%d,\n' % (self.hardwareVersion,))
        if self.isDeployed is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            showIndent(outfile, level)
            outfile.write('isDeployed=%s,\n' % (self.isDeployed,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.guestOs is not None and 'guestOs' not in already_processed:
            already_processed.add('guestOs')
            showIndent(outfile, level)
            outfile.write('guestOs="%s",\n' % (self.guestOs,))
        if self.isBusy is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            showIndent(outfile, level)
            outfile.write('isBusy=%s,\n' % (self.isBusy,))
        super(QueryResultResourcePoolVMRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultResourcePoolVMRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('containerName', node)
        if value is not None and 'containerName' not in already_processed:
            already_processed.add('containerName')
            self.containerName = value
        value = find_attr_value_('hardwareVersion', node)
        if value is not None and 'hardwareVersion' not in already_processed:
            already_processed.add('hardwareVersion')
            try:
                self.hardwareVersion = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('isDeployed', node)
        if value is not None and 'isDeployed' not in already_processed:
            already_processed.add('isDeployed')
            if value in ('true', '1'):
                self.isDeployed = True
            elif value in ('false', '0'):
                self.isDeployed = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('guestOs', node)
        if value is not None and 'guestOs' not in already_processed:
            already_processed.add('guestOs')
            self.guestOs = value
        value = find_attr_value_('isBusy', node)
        if value is not None and 'isBusy' not in already_processed:
            already_processed.add('isBusy')
            if value in ('true', '1'):
                self.isBusy = True
            elif value in ('false', '0'):
                self.isBusy = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(QueryResultResourcePoolVMRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultResourcePoolVMRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultResourcePoolVMRecordType


class QueryResultToCloudTunnelRecordType(QueryResultRecordType):
    """5.6 Type for a single toCloudTunnel query result in records format.
    5.6none Opaque string indicating the type of traffic (for
    example, ""HBR"") 5.6none Opaque string identifying the
    destination server in the cloud 5.6none IP address of the
    destination server in the cloud. This property is visible only
    to sysadmins. 5.6none Port on the destination server in the
    cloud. This property is visible only to sysadmins. 5.6none
    Organization reference. This property is visible only to
    sysadmins."""
    subclass = None
    superclass = QueryResultRecordType
    def __init__(self, href=None, type_=None, id=None, Link=None, Metadata=None, trafficType=None, destinationHost=None, destinationId=None, destinationPort=None, org=None):
        self.original_tagname_ = None
        super(QueryResultToCloudTunnelRecordType, self).__init__(href, type_, id, Link, Metadata, )
        self.trafficType = _cast(None, trafficType)
        self.destinationHost = _cast(None, destinationHost)
        self.destinationId = _cast(None, destinationId)
        self.destinationPort = _cast(int, destinationPort)
        self.org = _cast(None, org)
    def factory(*args_, **kwargs_):
        if QueryResultToCloudTunnelRecordType.subclass:
            return QueryResultToCloudTunnelRecordType.subclass(*args_, **kwargs_)
        else:
            return QueryResultToCloudTunnelRecordType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_trafficType(self): return self.trafficType
    def set_trafficType(self, trafficType): self.trafficType = trafficType
    def get_destinationHost(self): return self.destinationHost
    def set_destinationHost(self, destinationHost): self.destinationHost = destinationHost
    def get_destinationId(self): return self.destinationId
    def set_destinationId(self, destinationId): self.destinationId = destinationId
    def get_destinationPort(self): return self.destinationPort
    def set_destinationPort(self, destinationPort): self.destinationPort = destinationPort
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def hasContent_(self):
        if (
            super(QueryResultToCloudTunnelRecordType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QueryResultToCloudTunnelRecordType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultToCloudTunnelRecordType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QueryResultToCloudTunnelRecordType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QueryResultToCloudTunnelRecordType'):
        super(QueryResultToCloudTunnelRecordType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultToCloudTunnelRecordType')
        if self.trafficType is not None and 'trafficType' not in already_processed:
            already_processed.add('trafficType')
            outfile.write(' trafficType=%s' % (self.gds_format_string(quote_attrib(self.trafficType).encode(ExternalEncoding), input_name='trafficType'), ))
        if self.destinationHost is not None and 'destinationHost' not in already_processed:
            already_processed.add('destinationHost')
            outfile.write(' destinationHost=%s' % (self.gds_format_string(quote_attrib(self.destinationHost).encode(ExternalEncoding), input_name='destinationHost'), ))
        if self.destinationId is not None and 'destinationId' not in already_processed:
            already_processed.add('destinationId')
            outfile.write(' destinationId=%s' % (self.gds_format_string(quote_attrib(self.destinationId).encode(ExternalEncoding), input_name='destinationId'), ))
        if self.destinationPort is not None and 'destinationPort' not in already_processed:
            already_processed.add('destinationPort')
            outfile.write(' destinationPort="%s"' % self.gds_format_integer(self.destinationPort, input_name='destinationPort'))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QueryResultToCloudTunnelRecordType', fromsubclass_=False, pretty_print=True):
        super(QueryResultToCloudTunnelRecordType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultToCloudTunnelRecordType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.trafficType is not None and 'trafficType' not in already_processed:
            already_processed.add('trafficType')
            showIndent(outfile, level)
            outfile.write('trafficType="%s",\n' % (self.trafficType,))
        if self.destinationHost is not None and 'destinationHost' not in already_processed:
            already_processed.add('destinationHost')
            showIndent(outfile, level)
            outfile.write('destinationHost="%s",\n' % (self.destinationHost,))
        if self.destinationId is not None and 'destinationId' not in already_processed:
            already_processed.add('destinationId')
            showIndent(outfile, level)
            outfile.write('destinationId="%s",\n' % (self.destinationId,))
        if self.destinationPort is not None and 'destinationPort' not in already_processed:
            already_processed.add('destinationPort')
            showIndent(outfile, level)
            outfile.write('destinationPort=%d,\n' % (self.destinationPort,))
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        super(QueryResultToCloudTunnelRecordType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryResultToCloudTunnelRecordType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('trafficType', node)
        if value is not None and 'trafficType' not in already_processed:
            already_processed.add('trafficType')
            self.trafficType = value
        value = find_attr_value_('destinationHost', node)
        if value is not None and 'destinationHost' not in already_processed:
            already_processed.add('destinationHost')
            self.destinationHost = value
        value = find_attr_value_('destinationId', node)
        if value is not None and 'destinationId' not in already_processed:
            already_processed.add('destinationId')
            self.destinationId = value
        value = find_attr_value_('destinationPort', node)
        if value is not None and 'destinationPort' not in already_processed:
            already_processed.add('destinationPort')
            try:
                self.destinationPort = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        super(QueryResultToCloudTunnelRecordType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(QueryResultToCloudTunnelRecordType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class QueryResultToCloudTunnelRecordType


class SessionType(ResourceType):
    """1.5 Represents a vCloud Session. none The name of the user that owns
    the session falsenone The name of the user's organization
    falsenone The URN of the user entity false"""
    subclass = None
    superclass = ResourceType
    def __init__(self, org=None, userId=None, user=None):
        self.original_tagname_ = None
        super(SessionType, self).__init__()
        self.org = _cast(None, org)
        self.userId = _cast(None, userId)
        self.user = _cast(None, user)
    def factory(*args_, **kwargs_):
        if SessionType.subclass:
            return SessionType.subclass(*args_, **kwargs_)
        else:
            return SessionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_org(self): return self.org
    def set_org(self, org): self.org = org
    def get_userId(self): return self.userId
    def set_userId(self, userId): self.userId = userId
    def get_user(self): return self.user
    def set_user(self, user): self.user = user
    def hasContent_(self):
        if (
            super(SessionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SessionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SessionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SessionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SessionType'):
        super(SessionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SessionType')
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            outfile.write(' org=%s' % (self.gds_format_string(quote_attrib(self.org).encode(ExternalEncoding), input_name='org'), ))
        if self.userId is not None and 'userId' not in already_processed:
            already_processed.add('userId')
            outfile.write(' userId=%s' % (self.gds_format_string(quote_attrib(self.userId).encode(ExternalEncoding), input_name='userId'), ))
        if self.user is not None and 'user' not in already_processed:
            already_processed.add('user')
            outfile.write(' user=%s' % (self.gds_format_string(quote_attrib(self.user).encode(ExternalEncoding), input_name='user'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SessionType', fromsubclass_=False, pretty_print=True):
        super(SessionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='SessionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.org is not None and 'org' not in already_processed:
            already_processed.add('org')
            showIndent(outfile, level)
            outfile.write('org="%s",\n' % (self.org,))
        if self.userId is not None and 'userId' not in already_processed:
            already_processed.add('userId')
            showIndent(outfile, level)
            outfile.write('userId="%s",\n' % (self.userId,))
        if self.user is not None and 'user' not in already_processed:
            already_processed.add('user')
            showIndent(outfile, level)
            outfile.write('user="%s",\n' % (self.user,))
        super(SessionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SessionType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('org', node)
        if value is not None and 'org' not in already_processed:
            already_processed.add('org')
            self.org = value
        value = find_attr_value_('userId', node)
        if value is not None and 'userId' not in already_processed:
            already_processed.add('userId')
            self.userId = value
        value = find_attr_value_('user', node)
        if value is not None and 'user' not in already_processed:
            already_processed.add('user')
            self.user = value
        super(SessionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SessionType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SessionType


class ApiExtensibilityType(ResourceType):
    """5.1 Lists links to API extensibility operations and entities."""
    subclass = None
    superclass = ResourceType
    def __init__(self):
        self.original_tagname_ = None
        super(ApiExtensibilityType, self).__init__()
    def factory(*args_, **kwargs_):
        if ApiExtensibilityType.subclass:
            return ApiExtensibilityType.subclass(*args_, **kwargs_)
        else:
            return ApiExtensibilityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ApiExtensibilityType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ApiExtensibilityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ApiExtensibilityType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ApiExtensibilityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ApiExtensibilityType'):
        super(ApiExtensibilityType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ApiExtensibilityType')
    def exportChildren(self, outfile, level, namespace_='', name_='ApiExtensibilityType', fromsubclass_=False, pretty_print=True):
        super(ApiExtensibilityType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ApiExtensibilityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ApiExtensibilityType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ApiExtensibilityType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ApiExtensibilityType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ApiExtensibilityType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ApiExtensibilityType


class ServiceType(EntityType):
    """5.1 Public representation of an external service."""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, Namespace=None, Vendor=None):
        self.original_tagname_ = None
        super(ServiceType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.Namespace = Namespace
        self.Vendor = Vendor
    def factory(*args_, **kwargs_):
        if ServiceType.subclass:
            return ServiceType.subclass(*args_, **kwargs_)
        else:
            return ServiceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Namespace(self): return self.Namespace
    def set_Namespace(self, Namespace): self.Namespace = Namespace
    def get_Vendor(self): return self.Vendor
    def set_Vendor(self, Vendor): self.Vendor = Vendor
    def hasContent_(self):
        if (
            self.Namespace is not None or
            self.Vendor is not None or
            super(ServiceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceType'):
        super(ServiceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceType')
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceType', fromsubclass_=False, pretty_print=True):
        super(ServiceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Namespace is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNamespace>%s</%sNamespace>%s' % (namespace_, self.gds_format_string(quote_xml(self.Namespace).encode(ExternalEncoding), input_name='Namespace'), namespace_, eol_))
        if self.Vendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVendor>%s</%sVendor>%s' % (namespace_, self.gds_format_string(quote_xml(self.Vendor).encode(ExternalEncoding), input_name='Vendor'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ServiceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ServiceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ServiceType, self).exportLiteralChildren(outfile, level, name_)
        if self.Namespace is not None:
            showIndent(outfile, level)
            outfile.write('Namespace=%s,\n' % quote_python(self.Namespace).encode(ExternalEncoding))
        if self.Vendor is not None:
            showIndent(outfile, level)
            outfile.write('Vendor=%s,\n' % quote_python(self.Vendor).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ServiceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Namespace':
            Namespace_ = child_.text
            Namespace_ = self.gds_validate_string(Namespace_, node, 'Namespace')
            self.Namespace = Namespace_
        elif nodeName_ == 'Vendor':
            Vendor_ = child_.text
            Vendor_ = self.gds_validate_string(Vendor_, node, 'Vendor')
            self.Vendor = Vendor_
        super(ServiceType, self).buildChildren(child_, node, nodeName_, True)
# end class ServiceType


class ApiDefinitionType(EntityType):
    """5.1 Representation of an API definition accessible by all
    authenticated users."""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, EntryPoint=None, Namespace=None, ApiVendor=None, SupportedApiVersions=None):
        self.original_tagname_ = None
        super(ApiDefinitionType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.EntryPoint = EntryPoint
        self.Namespace = Namespace
        self.ApiVendor = ApiVendor
        self.SupportedApiVersions = SupportedApiVersions
    def factory(*args_, **kwargs_):
        if ApiDefinitionType.subclass:
            return ApiDefinitionType.subclass(*args_, **kwargs_)
        else:
            return ApiDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EntryPoint(self): return self.EntryPoint
    def set_EntryPoint(self, EntryPoint): self.EntryPoint = EntryPoint
    def get_Namespace(self): return self.Namespace
    def set_Namespace(self, Namespace): self.Namespace = Namespace
    def get_ApiVendor(self): return self.ApiVendor
    def set_ApiVendor(self, ApiVendor): self.ApiVendor = ApiVendor
    def get_SupportedApiVersions(self): return self.SupportedApiVersions
    def set_SupportedApiVersions(self, SupportedApiVersions): self.SupportedApiVersions = SupportedApiVersions
    def hasContent_(self):
        if (
            self.EntryPoint is not None or
            self.Namespace is not None or
            self.ApiVendor is not None or
            self.SupportedApiVersions is not None or
            super(ApiDefinitionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ApiDefinitionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ApiDefinitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ApiDefinitionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ApiDefinitionType'):
        super(ApiDefinitionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ApiDefinitionType')
    def exportChildren(self, outfile, level, namespace_='', name_='ApiDefinitionType', fromsubclass_=False, pretty_print=True):
        super(ApiDefinitionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EntryPoint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEntryPoint>%s</%sEntryPoint>%s' % (namespace_, self.gds_format_string(quote_xml(self.EntryPoint).encode(ExternalEncoding), input_name='EntryPoint'), namespace_, eol_))
        if self.Namespace is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNamespace>%s</%sNamespace>%s' % (namespace_, self.gds_format_string(quote_xml(self.Namespace).encode(ExternalEncoding), input_name='Namespace'), namespace_, eol_))
        if self.ApiVendor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sApiVendor>%s</%sApiVendor>%s' % (namespace_, self.gds_format_string(quote_xml(self.ApiVendor).encode(ExternalEncoding), input_name='ApiVendor'), namespace_, eol_))
        if self.SupportedApiVersions is not None:
            self.SupportedApiVersions.export(outfile, level, namespace_, name_='SupportedApiVersions', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ApiDefinitionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ApiDefinitionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ApiDefinitionType, self).exportLiteralChildren(outfile, level, name_)
        if self.EntryPoint is not None:
            showIndent(outfile, level)
            outfile.write('EntryPoint=%s,\n' % quote_python(self.EntryPoint).encode(ExternalEncoding))
        if self.Namespace is not None:
            showIndent(outfile, level)
            outfile.write('Namespace=%s,\n' % quote_python(self.Namespace).encode(ExternalEncoding))
        if self.ApiVendor is not None:
            showIndent(outfile, level)
            outfile.write('ApiVendor=%s,\n' % quote_python(self.ApiVendor).encode(ExternalEncoding))
        if self.SupportedApiVersions is not None:
            showIndent(outfile, level)
            outfile.write('SupportedApiVersions=model_.VersionsType(\n')
            self.SupportedApiVersions.exportLiteral(outfile, level, name_='SupportedApiVersions')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ApiDefinitionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EntryPoint':
            EntryPoint_ = child_.text
            EntryPoint_ = self.gds_validate_string(EntryPoint_, node, 'EntryPoint')
            self.EntryPoint = EntryPoint_
        elif nodeName_ == 'Namespace':
            Namespace_ = child_.text
            Namespace_ = self.gds_validate_string(Namespace_, node, 'Namespace')
            self.Namespace = Namespace_
        elif nodeName_ == 'ApiVendor':
            ApiVendor_ = child_.text
            ApiVendor_ = self.gds_validate_string(ApiVendor_, node, 'ApiVendor')
            self.ApiVendor = ApiVendor_
        elif nodeName_ == 'SupportedApiVersions':
            obj_ = VersionsType.factory()
            obj_.build(child_)
            self.SupportedApiVersions = obj_
            obj_.original_tagname_ = 'SupportedApiVersions'
        super(ApiDefinitionType, self).buildChildren(child_, node, nodeName_, True)
# end class ApiDefinitionType


class VersionsType(VCloudExtensibleType):
    """5.1 Represents a list of API versions supported by an ApiVendor."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, Version=None):
        self.original_tagname_ = None
        super(VersionsType, self).__init__(VCloudExtension, )
        if Version is None:
            self.Version = []
        else:
            self.Version = Version
    def factory(*args_, **kwargs_):
        if VersionsType.subclass:
            return VersionsType.subclass(*args_, **kwargs_)
        else:
            return VersionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def add_Version(self, value): self.Version.append(value)
    def insert_Version_at(self, index, value): self.Version.insert(index, value)
    def replace_Version_at(self, index, value): self.Version[index] = value
    def hasContent_(self):
        if (
            self.Version or
            super(VersionsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VersionsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VersionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VersionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VersionsType'):
        super(VersionsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VersionsType')
    def exportChildren(self, outfile, level, namespace_='', name_='VersionsType', fromsubclass_=False, pretty_print=True):
        super(VersionsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Version_ in self.Version:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(Version_).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VersionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(VersionsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VersionsType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Version=[\n')
        level += 1
        for Version_ in self.Version:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Version_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(VersionsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version.append(Version_)
        super(VersionsType, self).buildChildren(child_, node, nodeName_, True)
# end class VersionsType


class FileDescriptorType(IdentifiableResourceType):
    """5.1 Represents a file required by an extension API definition."""
    subclass = None
    superclass = IdentifiableResourceType
    def __init__(self, operationKey=None, id=None, Description=None, File=None):
        self.original_tagname_ = None
        super(FileDescriptorType, self).__init__(operationKey, id, )
        self.Description = Description
        self.File = File
    def factory(*args_, **kwargs_):
        if FileDescriptorType.subclass:
            return FileDescriptorType.subclass(*args_, **kwargs_)
        else:
            return FileDescriptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_File(self): return self.File
    def set_File(self, File): self.File = File
    def hasContent_(self):
        if (
            self.Description is not None or
            self.File is not None or
            super(FileDescriptorType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FileDescriptorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FileDescriptorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FileDescriptorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FileDescriptorType'):
        super(FileDescriptorType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FileDescriptorType')
    def exportChildren(self, outfile, level, namespace_='', name_='FileDescriptorType', fromsubclass_=False, pretty_print=True):
        super(FileDescriptorType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDescription>%s</%sDescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.Description).encode(ExternalEncoding), input_name='Description'), namespace_, eol_))
        if self.File is not None:
            self.File.export(outfile, level, namespace_, name_='File', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FileDescriptorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FileDescriptorType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FileDescriptorType, self).exportLiteralChildren(outfile, level, name_)
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=%s,\n' % quote_python(self.Description).encode(ExternalEncoding))
        if self.File is not None:
            showIndent(outfile, level)
            outfile.write('File=model_.ReferenceType(\n')
            self.File.exportLiteral(outfile, level, name_='File')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FileDescriptorType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            Description_ = child_.text
            Description_ = self.gds_validate_string(Description_, node, 'Description')
            self.Description = Description_
        elif nodeName_ == 'File':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.File = obj_
            obj_.original_tagname_ = 'File'
        super(FileDescriptorType, self).buildChildren(child_, node, nodeName_, True)
# end class FileDescriptorType


class HybridOrgType(ResourceType):
    """5.6 Lists links to hybrid operations and entities in the context of
    an Org."""
    subclass = None
    superclass = ResourceType
    def __init__(self):
        self.original_tagname_ = None
        super(HybridOrgType, self).__init__()
    def factory(*args_, **kwargs_):
        if HybridOrgType.subclass:
            return HybridOrgType.subclass(*args_, **kwargs_)
        else:
            return HybridOrgType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(HybridOrgType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HybridOrgType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HybridOrgType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HybridOrgType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HybridOrgType'):
        super(HybridOrgType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HybridOrgType')
    def exportChildren(self, outfile, level, namespace_='', name_='HybridOrgType', fromsubclass_=False, pretty_print=True):
        super(HybridOrgType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='HybridOrgType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(HybridOrgType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HybridOrgType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HybridOrgType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(HybridOrgType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class HybridOrgType


class ToCloudTunnelCreateParamsType(VCloudExtensibleType):
    """5.6Parameters for creating to-the-cloud tunnel"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, TrafficType=None, DestinationId=None):
        self.original_tagname_ = None
        super(ToCloudTunnelCreateParamsType, self).__init__(VCloudExtension, )
        self.TrafficType = TrafficType
        self.DestinationId = DestinationId
    def factory(*args_, **kwargs_):
        if ToCloudTunnelCreateParamsType.subclass:
            return ToCloudTunnelCreateParamsType.subclass(*args_, **kwargs_)
        else:
            return ToCloudTunnelCreateParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TrafficType(self): return self.TrafficType
    def set_TrafficType(self, TrafficType): self.TrafficType = TrafficType
    def get_DestinationId(self): return self.DestinationId
    def set_DestinationId(self, DestinationId): self.DestinationId = DestinationId
    def hasContent_(self):
        if (
            self.TrafficType is not None or
            self.DestinationId is not None or
            super(ToCloudTunnelCreateParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ToCloudTunnelCreateParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ToCloudTunnelCreateParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ToCloudTunnelCreateParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ToCloudTunnelCreateParamsType'):
        super(ToCloudTunnelCreateParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ToCloudTunnelCreateParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='ToCloudTunnelCreateParamsType', fromsubclass_=False, pretty_print=True):
        super(ToCloudTunnelCreateParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TrafficType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTrafficType>%s</%sTrafficType>%s' % (namespace_, self.gds_format_string(quote_xml(self.TrafficType).encode(ExternalEncoding), input_name='TrafficType'), namespace_, eol_))
        if self.DestinationId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDestinationId>%s</%sDestinationId>%s' % (namespace_, self.gds_format_string(quote_xml(self.DestinationId).encode(ExternalEncoding), input_name='DestinationId'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ToCloudTunnelCreateParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ToCloudTunnelCreateParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ToCloudTunnelCreateParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.TrafficType is not None:
            showIndent(outfile, level)
            outfile.write('TrafficType=%s,\n' % quote_python(self.TrafficType).encode(ExternalEncoding))
        if self.DestinationId is not None:
            showIndent(outfile, level)
            outfile.write('DestinationId=%s,\n' % quote_python(self.DestinationId).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ToCloudTunnelCreateParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TrafficType':
            TrafficType_ = child_.text
            TrafficType_ = self.gds_validate_string(TrafficType_, node, 'TrafficType')
            self.TrafficType = TrafficType_
        elif nodeName_ == 'DestinationId':
            DestinationId_ = child_.text
            DestinationId_ = self.gds_validate_string(DestinationId_, node, 'DestinationId')
            self.DestinationId = DestinationId_
        super(ToCloudTunnelCreateParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class ToCloudTunnelCreateParamsType


class ToCloudTunnelType(EntityType):
    """5.6 Describes to-the-cloud tunnel"""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, TrafficType=None, DestinationId=None, extensiontype_=None):
        self.original_tagname_ = None
        super(ToCloudTunnelType, self).__init__(operationKey, id, name, Description, Tasks, extensiontype_, )
        self.TrafficType = TrafficType
        self.DestinationId = DestinationId
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ToCloudTunnelType.subclass:
            return ToCloudTunnelType.subclass(*args_, **kwargs_)
        else:
            return ToCloudTunnelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TrafficType(self): return self.TrafficType
    def set_TrafficType(self, TrafficType): self.TrafficType = TrafficType
    def get_DestinationId(self): return self.DestinationId
    def set_DestinationId(self, DestinationId): self.DestinationId = DestinationId
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.TrafficType is not None or
            self.DestinationId is not None or
            super(ToCloudTunnelType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ToCloudTunnelType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ToCloudTunnelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ToCloudTunnelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ToCloudTunnelType'):
        super(ToCloudTunnelType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ToCloudTunnelType')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ToCloudTunnelType', fromsubclass_=False, pretty_print=True):
        super(ToCloudTunnelType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TrafficType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTrafficType>%s</%sTrafficType>%s' % (namespace_, self.gds_format_string(quote_xml(self.TrafficType).encode(ExternalEncoding), input_name='TrafficType'), namespace_, eol_))
        if self.DestinationId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDestinationId>%s</%sDestinationId>%s' % (namespace_, self.gds_format_string(quote_xml(self.DestinationId).encode(ExternalEncoding), input_name='DestinationId'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ToCloudTunnelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ToCloudTunnelType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ToCloudTunnelType, self).exportLiteralChildren(outfile, level, name_)
        if self.TrafficType is not None:
            showIndent(outfile, level)
            outfile.write('TrafficType=%s,\n' % quote_python(self.TrafficType).encode(ExternalEncoding))
        if self.DestinationId is not None:
            showIndent(outfile, level)
            outfile.write('DestinationId=%s,\n' % quote_python(self.DestinationId).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(ToCloudTunnelType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TrafficType':
            TrafficType_ = child_.text
            TrafficType_ = self.gds_validate_string(TrafficType_, node, 'TrafficType')
            self.TrafficType = TrafficType_
        elif nodeName_ == 'DestinationId':
            DestinationId_ = child_.text
            DestinationId_ = self.gds_validate_string(DestinationId_, node, 'DestinationId')
            self.DestinationId = DestinationId_
        super(ToCloudTunnelType, self).buildChildren(child_, node, nodeName_, True)
# end class ToCloudTunnelType


class AdminToCloudTunnelType(ToCloudTunnelType):
    """5.6 Describes the administrator view of a to-the-cloud tunnel"""
    subclass = None
    superclass = ToCloudTunnelType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, TrafficType=None, DestinationId=None, DestinationIpAddress=None, DestinationPort=None):
        self.original_tagname_ = None
        super(AdminToCloudTunnelType, self).__init__(operationKey, id, name, Description, Tasks, TrafficType, DestinationId, )
        self.DestinationIpAddress = DestinationIpAddress
        self.DestinationPort = DestinationPort
    def factory(*args_, **kwargs_):
        if AdminToCloudTunnelType.subclass:
            return AdminToCloudTunnelType.subclass(*args_, **kwargs_)
        else:
            return AdminToCloudTunnelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DestinationIpAddress(self): return self.DestinationIpAddress
    def set_DestinationIpAddress(self, DestinationIpAddress): self.DestinationIpAddress = DestinationIpAddress
    def get_DestinationPort(self): return self.DestinationPort
    def set_DestinationPort(self, DestinationPort): self.DestinationPort = DestinationPort
    def hasContent_(self):
        if (
            self.DestinationIpAddress is not None or
            self.DestinationPort is not None or
            super(AdminToCloudTunnelType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AdminToCloudTunnelType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AdminToCloudTunnelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AdminToCloudTunnelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AdminToCloudTunnelType'):
        super(AdminToCloudTunnelType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AdminToCloudTunnelType')
    def exportChildren(self, outfile, level, namespace_='', name_='AdminToCloudTunnelType', fromsubclass_=False, pretty_print=True):
        super(AdminToCloudTunnelType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DestinationIpAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDestinationIpAddress>%s</%sDestinationIpAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.DestinationIpAddress).encode(ExternalEncoding), input_name='DestinationIpAddress'), namespace_, eol_))
        if self.DestinationPort is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDestinationPort>%s</%sDestinationPort>%s' % (namespace_, self.gds_format_integer(self.DestinationPort, input_name='DestinationPort'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AdminToCloudTunnelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AdminToCloudTunnelType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AdminToCloudTunnelType, self).exportLiteralChildren(outfile, level, name_)
        if self.DestinationIpAddress is not None:
            showIndent(outfile, level)
            outfile.write('DestinationIpAddress=%s,\n' % quote_python(self.DestinationIpAddress).encode(ExternalEncoding))
        if self.DestinationPort is not None:
            showIndent(outfile, level)
            outfile.write('DestinationPort=%d,\n' % self.DestinationPort)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AdminToCloudTunnelType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DestinationIpAddress':
            DestinationIpAddress_ = child_.text
            DestinationIpAddress_ = self.gds_validate_string(DestinationIpAddress_, node, 'DestinationIpAddress')
            self.DestinationIpAddress = DestinationIpAddress_
        elif nodeName_ == 'DestinationPort':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DestinationPort')
            self.DestinationPort = ival_
        super(AdminToCloudTunnelType, self).buildChildren(child_, node, nodeName_, True)
# end class AdminToCloudTunnelType


class HybridTicketType(GeneratedsSuper):
    """5.6 Ticket for establishing a connection to Cloud Proxy."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if HybridTicketType.subclass:
            return HybridTicketType.subclass(*args_, **kwargs_)
        else:
            return HybridTicketType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HybridTicketType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HybridTicketType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HybridTicketType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HybridTicketType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HybridTicketType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='HybridTicketType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class HybridTicketType


class TunnelingApplicationRegisterParamsType(VCloudExtensibleType):
    """5.6 Parameters for registering cloud part of the tunneling
    application."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, TrafficType=None, RoutingKey=None, Exchange=None):
        self.original_tagname_ = None
        super(TunnelingApplicationRegisterParamsType, self).__init__(VCloudExtension, )
        self.TrafficType = TrafficType
        self.RoutingKey = RoutingKey
        self.Exchange = Exchange
    def factory(*args_, **kwargs_):
        if TunnelingApplicationRegisterParamsType.subclass:
            return TunnelingApplicationRegisterParamsType.subclass(*args_, **kwargs_)
        else:
            return TunnelingApplicationRegisterParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TrafficType(self): return self.TrafficType
    def set_TrafficType(self, TrafficType): self.TrafficType = TrafficType
    def get_RoutingKey(self): return self.RoutingKey
    def set_RoutingKey(self, RoutingKey): self.RoutingKey = RoutingKey
    def get_Exchange(self): return self.Exchange
    def set_Exchange(self, Exchange): self.Exchange = Exchange
    def hasContent_(self):
        if (
            self.TrafficType is not None or
            self.RoutingKey is not None or
            self.Exchange is not None or
            super(TunnelingApplicationRegisterParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TunnelingApplicationRegisterParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TunnelingApplicationRegisterParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TunnelingApplicationRegisterParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TunnelingApplicationRegisterParamsType'):
        super(TunnelingApplicationRegisterParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TunnelingApplicationRegisterParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='TunnelingApplicationRegisterParamsType', fromsubclass_=False, pretty_print=True):
        super(TunnelingApplicationRegisterParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TrafficType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTrafficType>%s</%sTrafficType>%s' % (namespace_, self.gds_format_string(quote_xml(self.TrafficType).encode(ExternalEncoding), input_name='TrafficType'), namespace_, eol_))
        if self.RoutingKey is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRoutingKey>%s</%sRoutingKey>%s' % (namespace_, self.gds_format_string(quote_xml(self.RoutingKey).encode(ExternalEncoding), input_name='RoutingKey'), namespace_, eol_))
        if self.Exchange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExchange>%s</%sExchange>%s' % (namespace_, self.gds_format_string(quote_xml(self.Exchange).encode(ExternalEncoding), input_name='Exchange'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TunnelingApplicationRegisterParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TunnelingApplicationRegisterParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TunnelingApplicationRegisterParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.TrafficType is not None:
            showIndent(outfile, level)
            outfile.write('TrafficType=%s,\n' % quote_python(self.TrafficType).encode(ExternalEncoding))
        if self.RoutingKey is not None:
            showIndent(outfile, level)
            outfile.write('RoutingKey=%s,\n' % quote_python(self.RoutingKey).encode(ExternalEncoding))
        if self.Exchange is not None:
            showIndent(outfile, level)
            outfile.write('Exchange=%s,\n' % quote_python(self.Exchange).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TunnelingApplicationRegisterParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TrafficType':
            TrafficType_ = child_.text
            TrafficType_ = self.gds_validate_string(TrafficType_, node, 'TrafficType')
            self.TrafficType = TrafficType_
        elif nodeName_ == 'RoutingKey':
            RoutingKey_ = child_.text
            RoutingKey_ = self.gds_validate_string(RoutingKey_, node, 'RoutingKey')
            self.RoutingKey = RoutingKey_
        elif nodeName_ == 'Exchange':
            Exchange_ = child_.text
            Exchange_ = self.gds_validate_string(Exchange_, node, 'Exchange')
            self.Exchange = Exchange_
        super(TunnelingApplicationRegisterParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class TunnelingApplicationRegisterParamsType


class TunnelingApplicationType(EntityType):
    """5.6 Describes cloud part of a tunneling application registered with
    VCD."""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, TrafficType=None, RoutingKey=None, Exchange=None):
        self.original_tagname_ = None
        super(TunnelingApplicationType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.TrafficType = TrafficType
        self.RoutingKey = RoutingKey
        self.Exchange = Exchange
    def factory(*args_, **kwargs_):
        if TunnelingApplicationType.subclass:
            return TunnelingApplicationType.subclass(*args_, **kwargs_)
        else:
            return TunnelingApplicationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TrafficType(self): return self.TrafficType
    def set_TrafficType(self, TrafficType): self.TrafficType = TrafficType
    def get_RoutingKey(self): return self.RoutingKey
    def set_RoutingKey(self, RoutingKey): self.RoutingKey = RoutingKey
    def get_Exchange(self): return self.Exchange
    def set_Exchange(self, Exchange): self.Exchange = Exchange
    def hasContent_(self):
        if (
            self.TrafficType is not None or
            self.RoutingKey is not None or
            self.Exchange is not None or
            super(TunnelingApplicationType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TunnelingApplicationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TunnelingApplicationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TunnelingApplicationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TunnelingApplicationType'):
        super(TunnelingApplicationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TunnelingApplicationType')
    def exportChildren(self, outfile, level, namespace_='', name_='TunnelingApplicationType', fromsubclass_=False, pretty_print=True):
        super(TunnelingApplicationType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TrafficType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTrafficType>%s</%sTrafficType>%s' % (namespace_, self.gds_format_string(quote_xml(self.TrafficType).encode(ExternalEncoding), input_name='TrafficType'), namespace_, eol_))
        if self.RoutingKey is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRoutingKey>%s</%sRoutingKey>%s' % (namespace_, self.gds_format_string(quote_xml(self.RoutingKey).encode(ExternalEncoding), input_name='RoutingKey'), namespace_, eol_))
        if self.Exchange is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExchange>%s</%sExchange>%s' % (namespace_, self.gds_format_string(quote_xml(self.Exchange).encode(ExternalEncoding), input_name='Exchange'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TunnelingApplicationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TunnelingApplicationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TunnelingApplicationType, self).exportLiteralChildren(outfile, level, name_)
        if self.TrafficType is not None:
            showIndent(outfile, level)
            outfile.write('TrafficType=%s,\n' % quote_python(self.TrafficType).encode(ExternalEncoding))
        if self.RoutingKey is not None:
            showIndent(outfile, level)
            outfile.write('RoutingKey=%s,\n' % quote_python(self.RoutingKey).encode(ExternalEncoding))
        if self.Exchange is not None:
            showIndent(outfile, level)
            outfile.write('Exchange=%s,\n' % quote_python(self.Exchange).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TunnelingApplicationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TrafficType':
            TrafficType_ = child_.text
            TrafficType_ = self.gds_validate_string(TrafficType_, node, 'TrafficType')
            self.TrafficType = TrafficType_
        elif nodeName_ == 'RoutingKey':
            RoutingKey_ = child_.text
            RoutingKey_ = self.gds_validate_string(RoutingKey_, node, 'RoutingKey')
            self.RoutingKey = RoutingKey_
        elif nodeName_ == 'Exchange':
            Exchange_ = child_.text
            Exchange_ = self.gds_validate_string(Exchange_, node, 'Exchange')
            self.Exchange = Exchange_
        super(TunnelingApplicationType, self).buildChildren(child_, node, nodeName_, True)
# end class TunnelingApplicationType


class TunnelingApplicationListType(ContainerType):
    """5.6 A list of registered tunneling applications."""
    subclass = None
    superclass = ContainerType
    def __init__(self, total=None, name=None, pageSize=None, page=None, TunnelingApplication=None):
        self.original_tagname_ = None
        super(TunnelingApplicationListType, self).__init__(total, name, pageSize, page, )
        if TunnelingApplication is None:
            self.TunnelingApplication = []
        else:
            self.TunnelingApplication = TunnelingApplication
    def factory(*args_, **kwargs_):
        if TunnelingApplicationListType.subclass:
            return TunnelingApplicationListType.subclass(*args_, **kwargs_)
        else:
            return TunnelingApplicationListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TunnelingApplication(self): return self.TunnelingApplication
    def set_TunnelingApplication(self, TunnelingApplication): self.TunnelingApplication = TunnelingApplication
    def add_TunnelingApplication(self, value): self.TunnelingApplication.append(value)
    def insert_TunnelingApplication_at(self, index, value): self.TunnelingApplication.insert(index, value)
    def replace_TunnelingApplication_at(self, index, value): self.TunnelingApplication[index] = value
    def hasContent_(self):
        if (
            self.TunnelingApplication or
            super(TunnelingApplicationListType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TunnelingApplicationListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TunnelingApplicationListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TunnelingApplicationListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TunnelingApplicationListType'):
        super(TunnelingApplicationListType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TunnelingApplicationListType')
    def exportChildren(self, outfile, level, namespace_='', name_='TunnelingApplicationListType', fromsubclass_=False, pretty_print=True):
        super(TunnelingApplicationListType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TunnelingApplication_ in self.TunnelingApplication:
            TunnelingApplication_.export(outfile, level, namespace_, name_='TunnelingApplication', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TunnelingApplicationListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TunnelingApplicationListType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TunnelingApplicationListType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('TunnelingApplication=[\n')
        level += 1
        for TunnelingApplication_ in self.TunnelingApplication:
            showIndent(outfile, level)
            outfile.write('model_.TunnelingApplicationType(\n')
            TunnelingApplication_.exportLiteral(outfile, level, name_='TunnelingApplicationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TunnelingApplicationListType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TunnelingApplication':
            obj_ = TunnelingApplicationType.factory()
            obj_.build(child_)
            self.TunnelingApplication.append(obj_)
            obj_.original_tagname_ = 'TunnelingApplication'
        super(TunnelingApplicationListType, self).buildChildren(child_, node, nodeName_, True)
# end class TunnelingApplicationListType


class HybridSettingsType(ResourceType):
    """5.6 Public URL and certificate of the Cloud Proxy end point."""
    subclass = None
    superclass = ResourceType
    def __init__(self, CloudProxyBaseUri=None, CloudProxyBaseUriPublicCertChain=None, CloudProxyBaseUriOverride=None, CloudProxyBaseUriPublicCertChainOverride=None):
        self.original_tagname_ = None
        super(HybridSettingsType, self).__init__()
        self.CloudProxyBaseUri = CloudProxyBaseUri
        self.CloudProxyBaseUriPublicCertChain = CloudProxyBaseUriPublicCertChain
        self.CloudProxyBaseUriOverride = CloudProxyBaseUriOverride
        self.CloudProxyBaseUriPublicCertChainOverride = CloudProxyBaseUriPublicCertChainOverride
    def factory(*args_, **kwargs_):
        if HybridSettingsType.subclass:
            return HybridSettingsType.subclass(*args_, **kwargs_)
        else:
            return HybridSettingsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CloudProxyBaseUri(self): return self.CloudProxyBaseUri
    def set_CloudProxyBaseUri(self, CloudProxyBaseUri): self.CloudProxyBaseUri = CloudProxyBaseUri
    def get_CloudProxyBaseUriPublicCertChain(self): return self.CloudProxyBaseUriPublicCertChain
    def set_CloudProxyBaseUriPublicCertChain(self, CloudProxyBaseUriPublicCertChain): self.CloudProxyBaseUriPublicCertChain = CloudProxyBaseUriPublicCertChain
    def get_CloudProxyBaseUriOverride(self): return self.CloudProxyBaseUriOverride
    def set_CloudProxyBaseUriOverride(self, CloudProxyBaseUriOverride): self.CloudProxyBaseUriOverride = CloudProxyBaseUriOverride
    def get_CloudProxyBaseUriPublicCertChainOverride(self): return self.CloudProxyBaseUriPublicCertChainOverride
    def set_CloudProxyBaseUriPublicCertChainOverride(self, CloudProxyBaseUriPublicCertChainOverride): self.CloudProxyBaseUriPublicCertChainOverride = CloudProxyBaseUriPublicCertChainOverride
    def hasContent_(self):
        if (
            self.CloudProxyBaseUri is not None or
            self.CloudProxyBaseUriPublicCertChain is not None or
            self.CloudProxyBaseUriOverride is not None or
            self.CloudProxyBaseUriPublicCertChainOverride is not None or
            super(HybridSettingsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HybridSettingsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HybridSettingsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HybridSettingsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HybridSettingsType'):
        super(HybridSettingsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HybridSettingsType')
    def exportChildren(self, outfile, level, namespace_='', name_='HybridSettingsType', fromsubclass_=False, pretty_print=True):
        super(HybridSettingsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CloudProxyBaseUri is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCloudProxyBaseUri>%s</%sCloudProxyBaseUri>%s' % (namespace_, self.gds_format_string(quote_xml(self.CloudProxyBaseUri).encode(ExternalEncoding), input_name='CloudProxyBaseUri'), namespace_, eol_))
        if self.CloudProxyBaseUriPublicCertChain is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCloudProxyBaseUriPublicCertChain>%s</%sCloudProxyBaseUriPublicCertChain>%s' % (namespace_, self.gds_format_string(quote_xml(self.CloudProxyBaseUriPublicCertChain).encode(ExternalEncoding), input_name='CloudProxyBaseUriPublicCertChain'), namespace_, eol_))
        if self.CloudProxyBaseUriOverride is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCloudProxyBaseUriOverride>%s</%sCloudProxyBaseUriOverride>%s' % (namespace_, self.gds_format_string(quote_xml(self.CloudProxyBaseUriOverride).encode(ExternalEncoding), input_name='CloudProxyBaseUriOverride'), namespace_, eol_))
        if self.CloudProxyBaseUriPublicCertChainOverride is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCloudProxyBaseUriPublicCertChainOverride>%s</%sCloudProxyBaseUriPublicCertChainOverride>%s' % (namespace_, self.gds_format_string(quote_xml(self.CloudProxyBaseUriPublicCertChainOverride).encode(ExternalEncoding), input_name='CloudProxyBaseUriPublicCertChainOverride'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='HybridSettingsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(HybridSettingsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HybridSettingsType, self).exportLiteralChildren(outfile, level, name_)
        if self.CloudProxyBaseUri is not None:
            showIndent(outfile, level)
            outfile.write('CloudProxyBaseUri=%s,\n' % quote_python(self.CloudProxyBaseUri).encode(ExternalEncoding))
        if self.CloudProxyBaseUriPublicCertChain is not None:
            showIndent(outfile, level)
            outfile.write('CloudProxyBaseUriPublicCertChain=%s,\n' % quote_python(self.CloudProxyBaseUriPublicCertChain).encode(ExternalEncoding))
        if self.CloudProxyBaseUriOverride is not None:
            showIndent(outfile, level)
            outfile.write('CloudProxyBaseUriOverride=%s,\n' % quote_python(self.CloudProxyBaseUriOverride).encode(ExternalEncoding))
        if self.CloudProxyBaseUriPublicCertChainOverride is not None:
            showIndent(outfile, level)
            outfile.write('CloudProxyBaseUriPublicCertChainOverride=%s,\n' % quote_python(self.CloudProxyBaseUriPublicCertChainOverride).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HybridSettingsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CloudProxyBaseUri':
            CloudProxyBaseUri_ = child_.text
            CloudProxyBaseUri_ = self.gds_validate_string(CloudProxyBaseUri_, node, 'CloudProxyBaseUri')
            self.CloudProxyBaseUri = CloudProxyBaseUri_
        elif nodeName_ == 'CloudProxyBaseUriPublicCertChain':
            CloudProxyBaseUriPublicCertChain_ = child_.text
            CloudProxyBaseUriPublicCertChain_ = self.gds_validate_string(CloudProxyBaseUriPublicCertChain_, node, 'CloudProxyBaseUriPublicCertChain')
            self.CloudProxyBaseUriPublicCertChain = CloudProxyBaseUriPublicCertChain_
        elif nodeName_ == 'CloudProxyBaseUriOverride':
            CloudProxyBaseUriOverride_ = child_.text
            CloudProxyBaseUriOverride_ = self.gds_validate_string(CloudProxyBaseUriOverride_, node, 'CloudProxyBaseUriOverride')
            self.CloudProxyBaseUriOverride = CloudProxyBaseUriOverride_
        elif nodeName_ == 'CloudProxyBaseUriPublicCertChainOverride':
            CloudProxyBaseUriPublicCertChainOverride_ = child_.text
            CloudProxyBaseUriPublicCertChainOverride_ = self.gds_validate_string(CloudProxyBaseUriPublicCertChainOverride_, node, 'CloudProxyBaseUriPublicCertChainOverride')
            self.CloudProxyBaseUriPublicCertChainOverride = CloudProxyBaseUriPublicCertChainOverride_
        super(HybridSettingsType, self).buildChildren(child_, node, nodeName_, True)
# end class HybridSettingsType


class VMWareToolsType(GeneratedsSuper):
    """none The version of VMmware tools installed on this virtual machine."""
    subclass = None
    superclass = None
    def __init__(self, version=None):
        self.original_tagname_ = None
        self.version = _cast(None, version)
    def factory(*args_, **kwargs_):
        if VMWareToolsType.subclass:
            return VMWareToolsType.subclass(*args_, **kwargs_)
        else:
            return VMWareToolsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VMWareToolsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VMWareToolsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VMWareToolsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VMWareToolsType'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='VMWareToolsType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='VMWareToolsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VMWareToolsType


class EntryType(GeneratedsSuper):
    """always VM BIOS UUID as described in the OVF Virtual System always
    Datastore path of replicated VM's vmx file. always Destination
    storage profile to associate with VM. This must be a valid
    profile for the given datastore path."""
    subclass = None
    superclass = None
    def __init__(self, storageProfile=None, datastorePath=None, biosUuid=None):
        self.original_tagname_ = None
        self.storageProfile = _cast(None, storageProfile)
        self.datastorePath = _cast(None, datastorePath)
        self.biosUuid = _cast(None, biosUuid)
    def factory(*args_, **kwargs_):
        if EntryType.subclass:
            return EntryType.subclass(*args_, **kwargs_)
        else:
            return EntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_storageProfile(self): return self.storageProfile
    def set_storageProfile(self, storageProfile): self.storageProfile = storageProfile
    def get_datastorePath(self): return self.datastorePath
    def set_datastorePath(self, datastorePath): self.datastorePath = datastorePath
    def get_biosUuid(self): return self.biosUuid
    def set_biosUuid(self, biosUuid): self.biosUuid = biosUuid
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntryType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntryType'):
        if self.storageProfile is not None and 'storageProfile' not in already_processed:
            already_processed.add('storageProfile')
            outfile.write(' storageProfile=%s' % (self.gds_format_string(quote_attrib(self.storageProfile).encode(ExternalEncoding), input_name='storageProfile'), ))
        if self.datastorePath is not None and 'datastorePath' not in already_processed:
            already_processed.add('datastorePath')
            outfile.write(' datastorePath=%s' % (self.gds_format_string(quote_attrib(self.datastorePath).encode(ExternalEncoding), input_name='datastorePath'), ))
        if self.biosUuid is not None and 'biosUuid' not in already_processed:
            already_processed.add('biosUuid')
            outfile.write(' biosUuid=%s' % (self.gds_format_string(quote_attrib(self.biosUuid).encode(ExternalEncoding), input_name='biosUuid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntryType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EntryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.storageProfile is not None and 'storageProfile' not in already_processed:
            already_processed.add('storageProfile')
            showIndent(outfile, level)
            outfile.write('storageProfile="%s",\n' % (self.storageProfile,))
        if self.datastorePath is not None and 'datastorePath' not in already_processed:
            already_processed.add('datastorePath')
            showIndent(outfile, level)
            outfile.write('datastorePath="%s",\n' % (self.datastorePath,))
        if self.biosUuid is not None and 'biosUuid' not in already_processed:
            already_processed.add('biosUuid')
            showIndent(outfile, level)
            outfile.write('biosUuid="%s",\n' % (self.biosUuid,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('storageProfile', node)
        if value is not None and 'storageProfile' not in already_processed:
            already_processed.add('storageProfile')
            self.storageProfile = value
        value = find_attr_value_('datastorePath', node)
        if value is not None and 'datastorePath' not in already_processed:
            already_processed.add('datastorePath')
            self.datastorePath = value
        value = find_attr_value_('biosUuid', node)
        if value is not None and 'biosUuid' not in already_processed:
            already_processed.add('biosUuid')
            self.biosUuid = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntryType


class EntryType1(GeneratedsSuper):
    """always OVF network name. always Name of organization network."""
    subclass = None
    superclass = None
    def __init__(self, vdcNetwork=None, ovfNetwork=None):
        self.original_tagname_ = None
        self.vdcNetwork = _cast(None, vdcNetwork)
        self.ovfNetwork = _cast(None, ovfNetwork)
    def factory(*args_, **kwargs_):
        if EntryType1.subclass:
            return EntryType1.subclass(*args_, **kwargs_)
        else:
            return EntryType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vdcNetwork(self): return self.vdcNetwork
    def set_vdcNetwork(self, vdcNetwork): self.vdcNetwork = vdcNetwork
    def get_ovfNetwork(self): return self.ovfNetwork
    def set_ovfNetwork(self, ovfNetwork): self.ovfNetwork = ovfNetwork
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntryType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntryType1', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntryType1'):
        if self.vdcNetwork is not None and 'vdcNetwork' not in already_processed:
            already_processed.add('vdcNetwork')
            outfile.write(' vdcNetwork=%s' % (self.gds_format_string(quote_attrib(self.vdcNetwork).encode(ExternalEncoding), input_name='vdcNetwork'), ))
        if self.ovfNetwork is not None and 'ovfNetwork' not in already_processed:
            already_processed.add('ovfNetwork')
            outfile.write(' ovfNetwork=%s' % (self.gds_format_string(quote_attrib(self.ovfNetwork).encode(ExternalEncoding), input_name='ovfNetwork'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntryType1', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EntryType1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vdcNetwork is not None and 'vdcNetwork' not in already_processed:
            already_processed.add('vdcNetwork')
            showIndent(outfile, level)
            outfile.write('vdcNetwork="%s",\n' % (self.vdcNetwork,))
        if self.ovfNetwork is not None and 'ovfNetwork' not in already_processed:
            already_processed.add('ovfNetwork')
            showIndent(outfile, level)
            outfile.write('ovfNetwork="%s",\n' % (self.ovfNetwork,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vdcNetwork', node)
        if value is not None and 'vdcNetwork' not in already_processed:
            already_processed.add('vdcNetwork')
            self.vdcNetwork = value
        value = find_attr_value_('ovfNetwork', node)
        if value is not None and 'ovfNetwork' not in already_processed:
            already_processed.add('ovfNetwork')
            self.ovfNetwork = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntryType1


class EntryType2(GeneratedsSuper):
    """always External NAT IP address on source site. always External NAT
    IP address on destination site."""
    subclass = None
    superclass = None
    def __init__(self, destinationNatIp=None, sourceNatIp=None):
        self.original_tagname_ = None
        self.destinationNatIp = _cast(None, destinationNatIp)
        self.sourceNatIp = _cast(None, sourceNatIp)
    def factory(*args_, **kwargs_):
        if EntryType2.subclass:
            return EntryType2.subclass(*args_, **kwargs_)
        else:
            return EntryType2(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_destinationNatIp(self): return self.destinationNatIp
    def set_destinationNatIp(self, destinationNatIp): self.destinationNatIp = destinationNatIp
    def get_sourceNatIp(self): return self.sourceNatIp
    def set_sourceNatIp(self, sourceNatIp): self.sourceNatIp = sourceNatIp
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntryType2', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryType2')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntryType2', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntryType2'):
        if self.destinationNatIp is not None and 'destinationNatIp' not in already_processed:
            already_processed.add('destinationNatIp')
            outfile.write(' destinationNatIp=%s' % (self.gds_format_string(quote_attrib(self.destinationNatIp).encode(ExternalEncoding), input_name='destinationNatIp'), ))
        if self.sourceNatIp is not None and 'sourceNatIp' not in already_processed:
            already_processed.add('sourceNatIp')
            outfile.write(' sourceNatIp=%s' % (self.gds_format_string(quote_attrib(self.sourceNatIp).encode(ExternalEncoding), input_name='sourceNatIp'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntryType2', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EntryType2'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.destinationNatIp is not None and 'destinationNatIp' not in already_processed:
            already_processed.add('destinationNatIp')
            showIndent(outfile, level)
            outfile.write('destinationNatIp="%s",\n' % (self.destinationNatIp,))
        if self.sourceNatIp is not None and 'sourceNatIp' not in already_processed:
            already_processed.add('sourceNatIp')
            showIndent(outfile, level)
            outfile.write('sourceNatIp="%s",\n' % (self.sourceNatIp,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('destinationNatIp', node)
        if value is not None and 'destinationNatIp' not in already_processed:
            already_processed.add('destinationNatIp')
            self.destinationNatIp = value
        value = find_attr_value_('sourceNatIp', node)
        if value is not None and 'sourceNatIp' not in already_processed:
            already_processed.add('sourceNatIp')
            self.sourceNatIp = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntryType2


class EntryType3(GeneratedsSuper):
    """always Source site NIC IP address. always Destination site NIC IP
    address."""
    subclass = None
    superclass = None
    def __init__(self, sourceNicIp=None, destinationNicIp=None):
        self.original_tagname_ = None
        self.sourceNicIp = _cast(None, sourceNicIp)
        self.destinationNicIp = _cast(None, destinationNicIp)
    def factory(*args_, **kwargs_):
        if EntryType3.subclass:
            return EntryType3.subclass(*args_, **kwargs_)
        else:
            return EntryType3(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sourceNicIp(self): return self.sourceNicIp
    def set_sourceNicIp(self, sourceNicIp): self.sourceNicIp = sourceNicIp
    def get_destinationNicIp(self): return self.destinationNicIp
    def set_destinationNicIp(self, destinationNicIp): self.destinationNicIp = destinationNicIp
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EntryType3', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryType3')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EntryType3', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EntryType3'):
        if self.sourceNicIp is not None and 'sourceNicIp' not in already_processed:
            already_processed.add('sourceNicIp')
            outfile.write(' sourceNicIp=%s' % (self.gds_format_string(quote_attrib(self.sourceNicIp).encode(ExternalEncoding), input_name='sourceNicIp'), ))
        if self.destinationNicIp is not None and 'destinationNicIp' not in already_processed:
            already_processed.add('destinationNicIp')
            outfile.write(' destinationNicIp=%s' % (self.gds_format_string(quote_attrib(self.destinationNicIp).encode(ExternalEncoding), input_name='destinationNicIp'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EntryType3', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EntryType3'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.sourceNicIp is not None and 'sourceNicIp' not in already_processed:
            already_processed.add('sourceNicIp')
            showIndent(outfile, level)
            outfile.write('sourceNicIp="%s",\n' % (self.sourceNicIp,))
        if self.destinationNicIp is not None and 'destinationNicIp' not in already_processed:
            already_processed.add('destinationNicIp')
            showIndent(outfile, level)
            outfile.write('destinationNicIp="%s",\n' % (self.destinationNicIp,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sourceNicIp', node)
        if value is not None and 'sourceNicIp' not in already_processed:
            already_processed.add('sourceNicIp')
            self.sourceNicIp = value
        value = find_attr_value_('destinationNicIp', node)
        if value is not None and 'destinationNicIp' not in already_processed:
            already_processed.add('destinationNicIp')
            self.destinationNicIp = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EntryType3


class DiskType4(VCloudExtensibleType):
    """always Identifies a specific disk of the virtual machine. This must
    match the InstanceId in the disk RASD element. 5.5true"""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, instanceId=None, Size=None):
        self.original_tagname_ = None
        super(DiskType4, self).__init__(VCloudExtension, )
        self.instanceId = _cast(None, instanceId)
        self.Size = Size
    def factory(*args_, **kwargs_):
        if DiskType4.subclass:
            return DiskType4.subclass(*args_, **kwargs_)
        else:
            return DiskType4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Size(self): return self.Size
    def set_Size(self, Size): self.Size = Size
    def get_instanceId(self): return self.instanceId
    def set_instanceId(self, instanceId): self.instanceId = instanceId
    def hasContent_(self):
        if (
            self.Size is not None or
            super(DiskType4, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiskType4', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiskType4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DiskType4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiskType4'):
        super(DiskType4, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DiskType4')
        if self.instanceId is not None and 'instanceId' not in already_processed:
            already_processed.add('instanceId')
            outfile.write(' instanceId=%s' % (self.gds_format_string(quote_attrib(self.instanceId).encode(ExternalEncoding), input_name='instanceId'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DiskType4', fromsubclass_=False, pretty_print=True):
        super(DiskType4, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSize>%s</%sSize>%s' % (namespace_, self.gds_format_integer(self.Size, input_name='Size'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DiskType4'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.instanceId is not None and 'instanceId' not in already_processed:
            already_processed.add('instanceId')
            showIndent(outfile, level)
            outfile.write('instanceId="%s",\n' % (self.instanceId,))
        super(DiskType4, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DiskType4, self).exportLiteralChildren(outfile, level, name_)
        if self.Size is not None:
            showIndent(outfile, level)
            outfile.write('Size=%d,\n' % self.Size)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('instanceId', node)
        if value is not None and 'instanceId' not in already_processed:
            already_processed.add('instanceId')
            self.instanceId = value
        super(DiskType4, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Size')
            self.Size = ival_
        super(DiskType4, self).buildChildren(child_, node, nodeName_, True)
# end class DiskType4


class ProtocolsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Tcp=None, Udp=None, Icmp=None, Any=None, Other=None):
        self.original_tagname_ = None
        self.Tcp = Tcp
        self.Udp = Udp
        self.Icmp = Icmp
        self.Any = Any
        self.Other = Other
    def factory(*args_, **kwargs_):
        if ProtocolsType.subclass:
            return ProtocolsType.subclass(*args_, **kwargs_)
        else:
            return ProtocolsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Tcp(self): return self.Tcp
    def set_Tcp(self, Tcp): self.Tcp = Tcp
    def get_Udp(self): return self.Udp
    def set_Udp(self, Udp): self.Udp = Udp
    def get_Icmp(self): return self.Icmp
    def set_Icmp(self, Icmp): self.Icmp = Icmp
    def get_Any(self): return self.Any
    def set_Any(self, Any): self.Any = Any
    def get_Other(self): return self.Other
    def set_Other(self, Other): self.Other = Other
    def hasContent_(self):
        if (
            self.Tcp is not None or
            self.Udp is not None or
            self.Icmp is not None or
            self.Any is not None or
            self.Other is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProtocolsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProtocolsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProtocolsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProtocolsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProtocolsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Tcp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTcp>%s</%sTcp>%s' % (namespace_, self.gds_format_boolean(self.Tcp, input_name='Tcp'), namespace_, eol_))
        if self.Udp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUdp>%s</%sUdp>%s' % (namespace_, self.gds_format_boolean(self.Udp, input_name='Udp'), namespace_, eol_))
        if self.Icmp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIcmp>%s</%sIcmp>%s' % (namespace_, self.gds_format_boolean(self.Icmp, input_name='Icmp'), namespace_, eol_))
        if self.Any is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAny>%s</%sAny>%s' % (namespace_, self.gds_format_boolean(self.Any, input_name='Any'), namespace_, eol_))
        if self.Other is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOther>%s</%sOther>%s' % (namespace_, self.gds_format_string(quote_xml(self.Other).encode(ExternalEncoding), input_name='Other'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ProtocolsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Tcp is not None:
            showIndent(outfile, level)
            outfile.write('Tcp=%s,\n' % self.Tcp)
        if self.Udp is not None:
            showIndent(outfile, level)
            outfile.write('Udp=%s,\n' % self.Udp)
        if self.Icmp is not None:
            showIndent(outfile, level)
            outfile.write('Icmp=%s,\n' % self.Icmp)
        if self.Any is not None:
            showIndent(outfile, level)
            outfile.write('Any=%s,\n' % self.Any)
        if self.Other is not None:
            showIndent(outfile, level)
            outfile.write('Other=%s,\n' % quote_python(self.Other).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Tcp':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Tcp')
            self.Tcp = ival_
        elif nodeName_ == 'Udp':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Udp')
            self.Udp = ival_
        elif nodeName_ == 'Icmp':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Icmp')
            self.Icmp = ival_
        elif nodeName_ == 'Any':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Any')
            self.Any = ival_
        elif nodeName_ == 'Other':
            Other_ = child_.text
            Other_ = self.gds_validate_string(Other_, node, 'Other')
            self.Other = Other_
# end class ProtocolsType


class MsgType(GeneratedsSuper):
    """String element valueString element identifier"""
    subclass = None
    superclass = None
    def __init__(self, msgid=None, valueOf_=None):
        self.original_tagname_ = None
        self.msgid = _cast(None, msgid)
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if MsgType.subclass:
            return MsgType.subclass(*args_, **kwargs_)
        else:
            return MsgType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_msgid(self): return self.msgid
    def set_msgid(self, msgid): self.msgid = msgid
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MsgType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MsgType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MsgType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MsgType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.msgid is not None and 'msgid' not in already_processed:
            already_processed.add('msgid')
            outfile.write(' msgid=%s' % (self.gds_format_string(quote_attrib(self.msgid).encode(ExternalEncoding), input_name='msgid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='MsgType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='MsgType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.msgid is not None and 'msgid' not in already_processed:
            already_processed.add('msgid')
            showIndent(outfile, level)
            outfile.write('msgid="%s",\n' % (self.msgid,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('msgid', node)
        if value is not None and 'msgid' not in already_processed:
            already_processed.add('msgid')
            self.msgid = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class MsgType


class IconType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mimeType=None, width=None, fileRef=None, height=None):
        self.original_tagname_ = None
        self.mimeType = _cast(None, mimeType)
        self.width = _cast(int, width)
        self.fileRef = _cast(None, fileRef)
        self.height = _cast(int, height)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if IconType.subclass:
            return IconType.subclass(*args_, **kwargs_)
        else:
            return IconType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mimeType(self): return self.mimeType
    def set_mimeType(self, mimeType): self.mimeType = mimeType
    def get_width(self): return self.width
    def set_width(self, width): self.width = width
    def get_fileRef(self): return self.fileRef
    def set_fileRef(self, fileRef): self.fileRef = fileRef
    def get_height(self): return self.height
    def set_height(self, height): self.height = height
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IconType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IconType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IconType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IconType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.mimeType is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            outfile.write(' mimeType=%s' % (self.gds_format_string(quote_attrib(self.mimeType).encode(ExternalEncoding), input_name='mimeType'), ))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            outfile.write(' width="%s"' % self.gds_format_integer(self.width, input_name='width'))
        if self.fileRef is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            outfile.write(' fileRef=%s' % (self.gds_format_string(quote_attrib(self.fileRef).encode(ExternalEncoding), input_name='fileRef'), ))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            outfile.write(' height="%s"' % self.gds_format_integer(self.height, input_name='height'))
    def exportChildren(self, outfile, level, namespace_='', name_='IconType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='IconType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.mimeType is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            showIndent(outfile, level)
            outfile.write('mimeType="%s",\n' % (self.mimeType,))
        if self.width is not None and 'width' not in already_processed:
            already_processed.add('width')
            showIndent(outfile, level)
            outfile.write('width=%d,\n' % (self.width,))
        if self.fileRef is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            showIndent(outfile, level)
            outfile.write('fileRef="%s",\n' % (self.fileRef,))
        if self.height is not None and 'height' not in already_processed:
            already_processed.add('height')
            showIndent(outfile, level)
            outfile.write('height=%d,\n' % (self.height,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('mimeType', node)
        if value is not None and 'mimeType' not in already_processed:
            already_processed.add('mimeType')
            self.mimeType = value
        value = find_attr_value_('width', node)
        if value is not None and 'width' not in already_processed:
            already_processed.add('width')
            try:
                self.width = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('fileRef', node)
        if value is not None and 'fileRef' not in already_processed:
            already_processed.add('fileRef')
            self.fileRef = value
        value = find_attr_value_('height', node)
        if value is not None and 'height' not in already_processed:
            already_processed.add('height')
            try:
                self.height = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class IconType


class PropertyType5(GeneratedsSuper):
    """Property identifierProperty typeA comma-separated set of type
    qualifiersDetermines whether the property value is configurable
    during installationDefault value for propertyDetermines whether
    the property value should be obscured during deployment"""
    subclass = None
    superclass = None
    def __init__(self, userConfigurable=False, value='', key=None, password=False, type_=None, qualifiers=None, Label=None, Description=None, Value=None):
        self.original_tagname_ = None
        self.userConfigurable = _cast(bool, userConfigurable)
        self.value = _cast(None, value)
        self.key = _cast(None, key)
        self.password = _cast(bool, password)
        self.type_ = _cast(None, type_)
        self.qualifiers = _cast(None, qualifiers)
        self.Label = Label
        self.Description = Description
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PropertyType5.subclass:
            return PropertyType5.subclass(*args_, **kwargs_)
        else:
            return PropertyType5(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value_at(self, index, value): self.Value.insert(index, value)
    def replace_Value_at(self, index, value): self.Value[index] = value
    def get_userConfigurable(self): return self.userConfigurable
    def set_userConfigurable(self, userConfigurable): self.userConfigurable = userConfigurable
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_password(self): return self.password
    def set_password(self, password): self.password = password
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_qualifiers(self): return self.qualifiers
    def set_qualifiers(self, qualifiers): self.qualifiers = qualifiers
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Label is not None or
            self.Description is not None or
            self.Value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertyType5', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyType5')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PropertyType5', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyType5'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.userConfigurable is not None and 'userConfigurable' not in already_processed:
            already_processed.add('userConfigurable')
            outfile.write(' userConfigurable="%s"' % self.gds_format_boolean(self.userConfigurable, input_name='userConfigurable'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
        if self.password is not None and 'password' not in already_processed:
            already_processed.add('password')
            outfile.write(' password="%s"' % self.gds_format_boolean(self.password, input_name='password'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.qualifiers is not None and 'qualifiers' not in already_processed:
            already_processed.add('qualifiers')
            outfile.write(' qualifiers=%s' % (self.gds_format_string(quote_attrib(self.qualifiers).encode(ExternalEncoding), input_name='qualifiers'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyType5', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Label is not None:
            self.Label.export(outfile, level, namespace_, name_='Label', pretty_print=pretty_print)
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for Value_ in self.Value:
            Value_.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PropertyType5'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.userConfigurable is not None and 'userConfigurable' not in already_processed:
            already_processed.add('userConfigurable')
            showIndent(outfile, level)
            outfile.write('userConfigurable=%s,\n' % (self.userConfigurable,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            showIndent(outfile, level)
            outfile.write('key="%s",\n' % (self.key,))
        if self.password is not None and 'password' not in already_processed:
            already_processed.add('password')
            showIndent(outfile, level)
            outfile.write('password=%s,\n' % (self.password,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        if self.qualifiers is not None and 'qualifiers' not in already_processed:
            already_processed.add('qualifiers')
            showIndent(outfile, level)
            outfile.write('qualifiers="%s",\n' % (self.qualifiers,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Label is not None:
            showIndent(outfile, level)
            outfile.write('Label=model_.Msg_Type(\n')
            self.Label.exportLiteral(outfile, level, name_='Label')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Msg_Type(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('model_.PropertyConfigurationValue_Type(\n')
            Value_.exportLiteral(outfile, level, name_='PropertyConfigurationValue_Type')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('userConfigurable', node)
        if value is not None and 'userConfigurable' not in already_processed:
            already_processed.add('userConfigurable')
            if value in ('true', '1'):
                self.userConfigurable = True
            elif value in ('false', '0'):
                self.userConfigurable = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            self.key = value
        value = find_attr_value_('password', node)
        if value is not None and 'password' not in already_processed:
            already_processed.add('password')
            if value in ('true', '1'):
                self.password = True
            elif value in ('false', '0'):
                self.password = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('qualifiers', node)
        if value is not None and 'qualifiers' not in already_processed:
            already_processed.add('qualifiers')
            self.qualifiers = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Label':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Label = obj_
            obj_.original_tagname_ = 'Label'
        elif nodeName_ == 'Description':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Value':
            obj_ = PropertyConfigurationValue_Type.factory()
            obj_.build(child_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
# end class PropertyType5


class NetworkType6(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, Description=None):
        self.original_tagname_ = None
        self.name = _cast(None, name)
        self.Description = Description
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if NetworkType6.subclass:
            return NetworkType6.subclass(*args_, **kwargs_)
        else:
            return NetworkType6(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkType6', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkType6')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkType6', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkType6'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkType6', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkType6'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Msg_Type(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
# end class NetworkType6


class ItemType(GeneratedsSuper):
    """Unique identifier of the content (within a VirtualSystemCollection)
    Startup order. Entities are started up starting with lower-
    numbers first, starting from 0. Items with same order identifier
    may be started up concurrently or in any order. The order is
    reversed for shutdown.Delay in seconds to wait for power on to
    completeResumes power-on sequence if guest software reports
    okDelay in seconds to wait for power off to completeStart action
    to use, valid values are: 'powerOn', 'none' Stop action to use,
    valid values are: ''powerOff' , 'guestShutdown', 'none'"""
    subclass = None
    superclass = None
    def __init__(self, stopDelay=0, order=None, startAction='powerOn', startDelay=0, waitingForGuest=False, stopAction='powerOff', id=None):
        self.original_tagname_ = None
        self.stopDelay = _cast(int, stopDelay)
        self.order = _cast(int, order)
        self.startAction = _cast(None, startAction)
        self.startDelay = _cast(int, startDelay)
        self.waitingForGuest = _cast(bool, waitingForGuest)
        self.stopAction = _cast(None, stopAction)
        self.id = _cast(None, id)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ItemType.subclass:
            return ItemType.subclass(*args_, **kwargs_)
        else:
            return ItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_stopDelay(self): return self.stopDelay
    def set_stopDelay(self, stopDelay): self.stopDelay = stopDelay
    def get_order(self): return self.order
    def set_order(self, order): self.order = order
    def get_startAction(self): return self.startAction
    def set_startAction(self, startAction): self.startAction = startAction
    def get_startDelay(self): return self.startDelay
    def set_startDelay(self, startDelay): self.startDelay = startDelay
    def get_waitingForGuest(self): return self.waitingForGuest
    def set_waitingForGuest(self, waitingForGuest): self.waitingForGuest = waitingForGuest
    def get_stopAction(self): return self.stopAction
    def set_stopAction(self, stopAction): self.stopAction = stopAction
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ItemType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ItemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ItemType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ItemType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.stopDelay is not None and 'stopDelay' not in already_processed:
            already_processed.add('stopDelay')
            outfile.write(' stopDelay="%s"' % self.gds_format_integer(self.stopDelay, input_name='stopDelay'))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            outfile.write(' order="%s"' % self.gds_format_integer(self.order, input_name='order'))
        if self.startAction is not None and 'startAction' not in already_processed:
            already_processed.add('startAction')
            outfile.write(' startAction=%s' % (self.gds_format_string(quote_attrib(self.startAction).encode(ExternalEncoding), input_name='startAction'), ))
        if self.startDelay is not None and 'startDelay' not in already_processed:
            already_processed.add('startDelay')
            outfile.write(' startDelay="%s"' % self.gds_format_integer(self.startDelay, input_name='startDelay'))
        if self.waitingForGuest is not None and 'waitingForGuest' not in already_processed:
            already_processed.add('waitingForGuest')
            outfile.write(' waitingForGuest="%s"' % self.gds_format_boolean(self.waitingForGuest, input_name='waitingForGuest'))
        if self.stopAction is not None and 'stopAction' not in already_processed:
            already_processed.add('stopAction')
            outfile.write(' stopAction=%s' % (self.gds_format_string(quote_attrib(self.stopAction).encode(ExternalEncoding), input_name='stopAction'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ItemType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ItemType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.stopDelay is not None and 'stopDelay' not in already_processed:
            already_processed.add('stopDelay')
            showIndent(outfile, level)
            outfile.write('stopDelay=%d,\n' % (self.stopDelay,))
        if self.order is not None and 'order' not in already_processed:
            already_processed.add('order')
            showIndent(outfile, level)
            outfile.write('order=%d,\n' % (self.order,))
        if self.startAction is not None and 'startAction' not in already_processed:
            already_processed.add('startAction')
            showIndent(outfile, level)
            outfile.write('startAction="%s",\n' % (self.startAction,))
        if self.startDelay is not None and 'startDelay' not in already_processed:
            already_processed.add('startDelay')
            showIndent(outfile, level)
            outfile.write('startDelay=%d,\n' % (self.startDelay,))
        if self.waitingForGuest is not None and 'waitingForGuest' not in already_processed:
            already_processed.add('waitingForGuest')
            showIndent(outfile, level)
            outfile.write('waitingForGuest=%s,\n' % (self.waitingForGuest,))
        if self.stopAction is not None and 'stopAction' not in already_processed:
            already_processed.add('stopAction')
            showIndent(outfile, level)
            outfile.write('stopAction="%s",\n' % (self.stopAction,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('stopDelay', node)
        if value is not None and 'stopDelay' not in already_processed:
            already_processed.add('stopDelay')
            try:
                self.stopDelay = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('order', node)
        if value is not None and 'order' not in already_processed:
            already_processed.add('order')
            try:
                self.order = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('startAction', node)
        if value is not None and 'startAction' not in already_processed:
            already_processed.add('startAction')
            self.startAction = value
        value = find_attr_value_('startDelay', node)
        if value is not None and 'startDelay' not in already_processed:
            already_processed.add('startDelay')
            try:
                self.startDelay = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('waitingForGuest', node)
        if value is not None and 'waitingForGuest' not in already_processed:
            already_processed.add('waitingForGuest')
            if value in ('true', '1'):
                self.waitingForGuest = True
            elif value in ('false', '0'):
                self.waitingForGuest = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('stopAction', node)
        if value is not None and 'stopAction' not in already_processed:
            already_processed.add('stopAction')
            self.stopAction = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ItemType


class ConfigurationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, default=False, id=None, Label=None, Description=None):
        self.original_tagname_ = None
        self.default = _cast(bool, default)
        self.id = _cast(None, id)
        self.Label = Label
        self.Description = Description
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if ConfigurationType.subclass:
            return ConfigurationType.subclass(*args_, **kwargs_)
        else:
            return ConfigurationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Label(self): return self.Label
    def set_Label(self, Label): self.Label = Label
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def get_default(self): return self.default
    def set_default(self, default): self.default = default
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            self.Label is not None or
            self.Description is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConfigurationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConfigurationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConfigurationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConfigurationType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            outfile.write(' default="%s"' % self.gds_format_boolean(self.default, input_name='default'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ConfigurationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Label is not None:
            self.Label.export(outfile, level, namespace_, name_='Label', pretty_print=pretty_print)
        if self.Description is not None:
            self.Description.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ConfigurationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.default is not None and 'default' not in already_processed:
            already_processed.add('default')
            showIndent(outfile, level)
            outfile.write('default=%s,\n' % (self.default,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Label is not None:
            showIndent(outfile, level)
            outfile.write('Label=model_.Msg_Type(\n')
            self.Label.exportLiteral(outfile, level, name_='Label')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Description is not None:
            showIndent(outfile, level)
            outfile.write('Description=model_.Msg_Type(\n')
            self.Description.exportLiteral(outfile, level, name_='Description')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default', node)
        if value is not None and 'default' not in already_processed:
            already_processed.add('default')
            if value in ('true', '1'):
                self.default = True
            elif value in ('false', '0'):
                self.default = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Label':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Label = obj_
            obj_.original_tagname_ = 'Label'
        elif nodeName_ == 'Description':
            obj_ = Msg_Type.factory()
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = 'Description'
# end class ConfigurationType


class PropertyType7(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None, key=None):
        self.original_tagname_ = None
        self.value = _cast(None, value)
        self.key = _cast(None, key)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if PropertyType7.subclass:
            return PropertyType7.subclass(*args_, **kwargs_)
        else:
            return PropertyType7(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PropertyType7', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PropertyType7')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PropertyType7', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PropertyType7'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PropertyType7', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PropertyType7'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
        if self.key is not None and 'key' not in already_processed:
            already_processed.add('key')
            showIndent(outfile, level)
            outfile.write('key="%s",\n' % (self.key,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.add('key')
            self.key = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PropertyType7


class LevelType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vendor='', level=None, eax=None, edx=None, ebx=None, ecx=None):
        self.original_tagname_ = None
        self.vendor = _cast(None, vendor)
        self.level = _cast(None, level)
        self.eax = _cast(None, eax)
        self.edx = _cast(None, edx)
        self.ebx = _cast(None, ebx)
        self.ecx = _cast(None, ecx)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if LevelType.subclass:
            return LevelType.subclass(*args_, **kwargs_)
        else:
            return LevelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vendor(self): return self.vendor
    def set_vendor(self, vendor): self.vendor = vendor
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def get_eax(self): return self.eax
    def set_eax(self, eax): self.eax = eax
    def get_edx(self): return self.edx
    def set_edx(self, edx): self.edx = edx
    def get_ebx(self): return self.ebx
    def set_ebx(self, ebx): self.ebx = ebx
    def get_ecx(self): return self.ecx
    def set_ecx(self, ecx): self.ecx = ecx
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LevelType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LevelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LevelType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LevelType'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            outfile.write(' vendor=%s' % (self.gds_format_string(quote_attrib(self.vendor).encode(ExternalEncoding), input_name='vendor'), ))
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            outfile.write(' level=%s' % (quote_attrib(self.level), ))
        if self.eax is not None and 'eax' not in already_processed:
            already_processed.add('eax')
            outfile.write(' eax=%s' % (self.gds_format_string(quote_attrib(self.eax).encode(ExternalEncoding), input_name='eax'), ))
        if self.edx is not None and 'edx' not in already_processed:
            already_processed.add('edx')
            outfile.write(' edx=%s' % (self.gds_format_string(quote_attrib(self.edx).encode(ExternalEncoding), input_name='edx'), ))
        if self.ebx is not None and 'ebx' not in already_processed:
            already_processed.add('ebx')
            outfile.write(' ebx=%s' % (self.gds_format_string(quote_attrib(self.ebx).encode(ExternalEncoding), input_name='ebx'), ))
        if self.ecx is not None and 'ecx' not in already_processed:
            already_processed.add('ecx')
            outfile.write(' ecx=%s' % (self.gds_format_string(quote_attrib(self.ecx).encode(ExternalEncoding), input_name='ecx'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LevelType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LevelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vendor is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            showIndent(outfile, level)
            outfile.write('vendor="%s",\n' % (self.vendor,))
        if self.level is not None and 'level' not in already_processed:
            already_processed.add('level')
            showIndent(outfile, level)
            outfile.write('level=%s,\n' % (self.level,))
        if self.eax is not None and 'eax' not in already_processed:
            already_processed.add('eax')
            showIndent(outfile, level)
            outfile.write('eax="%s",\n' % (self.eax,))
        if self.edx is not None and 'edx' not in already_processed:
            already_processed.add('edx')
            showIndent(outfile, level)
            outfile.write('edx="%s",\n' % (self.edx,))
        if self.ebx is not None and 'ebx' not in already_processed:
            already_processed.add('ebx')
            showIndent(outfile, level)
            outfile.write('ebx="%s",\n' % (self.ebx,))
        if self.ecx is not None and 'ecx' not in already_processed:
            already_processed.add('ecx')
            showIndent(outfile, level)
            outfile.write('ecx="%s",\n' % (self.ecx,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vendor', node)
        if value is not None and 'vendor' not in already_processed:
            already_processed.add('vendor')
            self.vendor = value
        value = find_attr_value_('level', node)
        if value is not None and 'level' not in already_processed:
            already_processed.add('level')
            self.level = value
        value = find_attr_value_('eax', node)
        if value is not None and 'eax' not in already_processed:
            already_processed.add('eax')
            self.eax = value
        value = find_attr_value_('edx', node)
        if value is not None and 'edx' not in already_processed:
            already_processed.add('edx')
            self.edx = value
        value = find_attr_value_('ebx', node)
        if value is not None and 'ebx' not in already_processed:
            already_processed.add('ebx')
            self.ebx = value
        value = find_attr_value_('ecx', node)
        if value is not None and 'ecx' not in already_processed:
            already_processed.add('ecx')
            self.ecx = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LevelType


class RASD_Type(CIM_ResourceAllocationSettingData_Type):
    """Wrapper for CIM_ResourceAllocationSettingData_TypeDetermines whether
    import should fail if entry is not understoodConfiguration from
    DeploymentOptionSection this entry is valid forStates that this
    entry is a range marker"""
    subclass = None
    superclass = CIM_ResourceAllocationSettingData_Type
    def __init__(self, Address=None, AddressOnParent=None, AllocationUnits=None, AutomaticAllocation=None, AutomaticDeallocation=None, Caption=None, Connection=None, ConsumerVisibility=None, Description=None, ElementName=None, HostResource=None, InstanceID=None, Limit=None, MappingBehavior=None, OtherResourceType=None, Parent=None, PoolID=None, Reservation=None, ResourceSubType=None, ResourceType=None, VirtualQuantity=None, VirtualQuantityUnits=None, Weight=None, anytypeobjs_=None, required=True, bound=None, configuration=None):
        self.original_tagname_ = None
        super(RASD_Type, self).__init__(Address, AddressOnParent, AllocationUnits, AutomaticAllocation, AutomaticDeallocation, Caption, Connection, ConsumerVisibility, Description, ElementName, HostResource, InstanceID, Limit, MappingBehavior, OtherResourceType, Parent, PoolID, Reservation, ResourceSubType, ResourceType, VirtualQuantity, VirtualQuantityUnits, Weight, anytypeobjs_, )
        self.required = _cast(bool, required)
        self.bound = _cast(None, bound)
        self.configuration = _cast(None, configuration)
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if RASD_Type.subclass:
            return RASD_Type.subclass(*args_, **kwargs_)
        else:
            return RASD_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_required(self): return self.required
    def set_required(self, required): self.required = required
    def get_bound(self): return self.bound
    def set_bound(self, bound): self.bound = bound
    def get_configuration(self): return self.configuration
    def set_configuration(self, configuration): self.configuration = configuration
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            super(RASD_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RASD_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RASD_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RASD_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RASD_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(RASD_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RASD_Type')
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            outfile.write(' required="%s"' % self.gds_format_boolean(self.required, input_name='required'))
        if self.bound is not None and 'bound' not in already_processed:
            already_processed.add('bound')
            outfile.write(' bound=%s' % (self.gds_format_string(quote_attrib(self.bound).encode(ExternalEncoding), input_name='bound'), ))
        if self.configuration is not None and 'configuration' not in already_processed:
            already_processed.add('configuration')
            outfile.write(' configuration=%s' % (self.gds_format_string(quote_attrib(self.configuration).encode(ExternalEncoding), input_name='configuration'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RASD_Type', fromsubclass_=False, pretty_print=True):
        super(RASD_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RASD_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.required is not None and 'required' not in already_processed:
            already_processed.add('required')
            showIndent(outfile, level)
            outfile.write('required=%s,\n' % (self.required,))
        if self.bound is not None and 'bound' not in already_processed:
            already_processed.add('bound')
            showIndent(outfile, level)
            outfile.write('bound="%s",\n' % (self.bound,))
        if self.configuration is not None and 'configuration' not in already_processed:
            already_processed.add('configuration')
            showIndent(outfile, level)
            outfile.write('configuration="%s",\n' % (self.configuration,))
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(RASD_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RASD_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('required', node)
        if value is not None and 'required' not in already_processed:
            already_processed.add('required')
            if value in ('true', '1'):
                self.required = True
            elif value in ('false', '0'):
                self.required = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('bound', node)
        if value is not None and 'bound' not in already_processed:
            already_processed.add('bound')
            self.bound = value
        value = find_attr_value_('configuration', node)
        if value is not None and 'configuration' not in already_processed:
            already_processed.add('configuration')
            self.configuration = value
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(RASD_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RASD_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RASD_Type


class VSSD_Type(CIM_VirtualSystemSettingData_Type):
    """Wrapper for CIM_VirtualSystemSettingData_Type"""
    subclass = None
    superclass = CIM_VirtualSystemSettingData_Type
    def __init__(self, AutomaticRecoveryAction=None, AutomaticShutdownAction=None, AutomaticStartupAction=None, AutomaticStartupActionDelay=None, AutomaticStartupActionSequenceNumber=None, Caption=None, ConfigurationDataRoot=None, ConfigurationFile=None, ConfigurationID=None, CreationTime=None, Description=None, ElementName=None, InstanceID=None, LogDataRoot=None, Notes=None, RecoveryFile=None, SnapshotDataRoot=None, SuspendDataRoot=None, SwapFileDataRoot=None, VirtualSystemIdentifier=None, VirtualSystemType=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(VSSD_Type, self).__init__(AutomaticRecoveryAction, AutomaticShutdownAction, AutomaticStartupAction, AutomaticStartupActionDelay, AutomaticStartupActionSequenceNumber, Caption, ConfigurationDataRoot, ConfigurationFile, ConfigurationID, CreationTime, Description, ElementName, InstanceID, LogDataRoot, Notes, RecoveryFile, SnapshotDataRoot, SuspendDataRoot, SwapFileDataRoot, VirtualSystemIdentifier, VirtualSystemType, anytypeobjs_, )
        self.anyAttributes_ = {}
    def factory(*args_, **kwargs_):
        if VSSD_Type.subclass:
            return VSSD_Type.subclass(*args_, **kwargs_)
        else:
            return VSSD_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def hasContent_(self):
        if (
            super(VSSD_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VSSD_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VSSD_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VSSD_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VSSD_Type'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:yyy%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' yyy%d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        super(VSSD_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VSSD_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='VSSD_Type', fromsubclass_=False, pretty_print=True):
        super(VSSD_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='VSSD_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        for name, value in self.anyAttributes_.items():
            showIndent(outfile, level)
            outfile.write('%s="%s",\n' % (name, value,))
        super(VSSD_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VSSD_Type, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        super(VSSD_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VSSD_Type, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VSSD_Type


class DefaultStorageProfileSection_Type(Section_Type):
    """5.1 Name of the storage profile that will be specified for this
    virtual machine. The named storage profile must exist in the
    organization vDC that contains the virtual machine. If not
    specified, the default storage profile for the vDC is used."""
    subclass = None
    superclass = Section_Type
    def __init__(self, StorageProfile=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(DefaultStorageProfileSection_Type, self).__init__()
        self.StorageProfile = StorageProfile
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if DefaultStorageProfileSection_Type.subclass:
            return DefaultStorageProfileSection_Type.subclass(*args_, **kwargs_)
        else:
            return DefaultStorageProfileSection_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StorageProfile(self): return self.StorageProfile
    def set_StorageProfile(self, StorageProfile): self.StorageProfile = StorageProfile
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.StorageProfile is not None or
            self.anytypeobjs_ or
            super(DefaultStorageProfileSection_Type, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DefaultStorageProfileSection_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefaultStorageProfileSection_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DefaultStorageProfileSection_Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DefaultStorageProfileSection_Type'):
        super(DefaultStorageProfileSection_Type, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DefaultStorageProfileSection_Type')
    def exportChildren(self, outfile, level, namespace_='', name_='DefaultStorageProfileSection_Type', fromsubclass_=False, pretty_print=True):
        super(DefaultStorageProfileSection_Type, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StorageProfile is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStorageProfile>%s</%sStorageProfile>%s' % (namespace_, self.gds_format_string(quote_xml(self.StorageProfile).encode(ExternalEncoding), input_name='StorageProfile'), namespace_, eol_))
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DefaultStorageProfileSection_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DefaultStorageProfileSection_Type, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DefaultStorageProfileSection_Type, self).exportLiteralChildren(outfile, level, name_)
        if self.StorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('StorageProfile=%s,\n' % quote_python(self.StorageProfile).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DefaultStorageProfileSection_Type, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StorageProfile':
            StorageProfile_ = child_.text
            StorageProfile_ = self.gds_validate_string(StorageProfile_, node, 'StorageProfile')
            self.StorageProfile = StorageProfile_
        else:
            obj_ = self.gds_build_any(child_, 'DefaultStorageProfileSection_Type')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(DefaultStorageProfileSection_Type, self).buildChildren(child_, node, nodeName_, True)
# end class DefaultStorageProfileSection_Type


class SnapshotSectionType(Section_Type):
    """5.1 Represents information about vApp and virtual machine snapshots.
    5.1none A reference to the section in URL format. false5.1none
    The MIME type of the section. false"""
    subclass = None
    superclass = Section_Type
    def __init__(self, href=None, type_=None, Link=None, Snapshot=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(SnapshotSectionType, self).__init__()
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
        self.Snapshot = Snapshot
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if SnapshotSectionType.subclass:
            return SnapshotSectionType.subclass(*args_, **kwargs_)
        else:
            return SnapshotSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def add_Link(self, value): self.Link.append(value)
    def insert_Link_at(self, index, value): self.Link.insert(index, value)
    def replace_Link_at(self, index, value): self.Link[index] = value
    def get_Snapshot(self): return self.Snapshot
    def set_Snapshot(self, Snapshot): self.Snapshot = Snapshot
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.Link or
            self.Snapshot is not None or
            self.anytypeobjs_ or
            super(SnapshotSectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SnapshotSectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SnapshotSectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SnapshotSectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SnapshotSectionType'):
        super(SnapshotSectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SnapshotSectionType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SnapshotSectionType', fromsubclass_=False, pretty_print=True):
        super(SnapshotSectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
        if self.Snapshot is not None:
            self.Snapshot.export(outfile, level, namespace_, name_='Snapshot', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SnapshotSectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(SnapshotSectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SnapshotSectionType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            Link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Snapshot is not None:
            showIndent(outfile, level)
            outfile.write('Snapshot=model_.SnapshotType(\n')
            self.Snapshot.exportLiteral(outfile, level, name_='Snapshot')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(SnapshotSectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.Link.append(obj_)
            obj_.original_tagname_ = 'Link'
        elif nodeName_ == 'Snapshot':
            obj_ = SnapshotType.factory()
            obj_.build(child_)
            self.Snapshot = obj_
            obj_.original_tagname_ = 'Snapshot'
        else:
            obj_ = self.gds_build_any(child_, 'SnapshotSectionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(SnapshotSectionType, self).buildChildren(child_, node, nodeName_, True)
# end class SnapshotSectionType


class GuestCustomizationSectionType(Section_Type):
    """1.0 Represents a guest customization settings. none A reference to
    the section in URL format. falsenone The MIME type of the
    section. false"""
    subclass = None
    superclass = Section_Type
    def __init__(self, href=None, type_=None, Enabled=None, ChangeSid=None, VirtualMachineId=None, JoinDomainEnabled=None, UseOrgSettings=None, DomainName=None, DomainUserName=None, DomainUserPassword=None, MachineObjectOU=None, AdminPasswordEnabled=None, AdminPasswordAuto=None, AdminPassword=None, AdminAutoLogonEnabled=None, AdminAutoLogonCount=None, ResetPasswordRequired=None, CustomizationScript=None, ComputerName=None, Link=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(GuestCustomizationSectionType, self).__init__()
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        self.Enabled = Enabled
        self.ChangeSid = ChangeSid
        self.VirtualMachineId = VirtualMachineId
        self.JoinDomainEnabled = JoinDomainEnabled
        self.UseOrgSettings = UseOrgSettings
        self.DomainName = DomainName
        self.DomainUserName = DomainUserName
        self.DomainUserPassword = DomainUserPassword
        self.MachineObjectOU = MachineObjectOU
        self.AdminPasswordEnabled = AdminPasswordEnabled
        self.AdminPasswordAuto = AdminPasswordAuto
        self.AdminPassword = AdminPassword
        self.AdminAutoLogonEnabled = AdminAutoLogonEnabled
        self.AdminAutoLogonCount = AdminAutoLogonCount
        self.ResetPasswordRequired = ResetPasswordRequired
        self.CustomizationScript = CustomizationScript
        self.ComputerName = ComputerName
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if GuestCustomizationSectionType.subclass:
            return GuestCustomizationSectionType.subclass(*args_, **kwargs_)
        else:
            return GuestCustomizationSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Enabled(self): return self.Enabled
    def set_Enabled(self, Enabled): self.Enabled = Enabled
    def get_ChangeSid(self): return self.ChangeSid
    def set_ChangeSid(self, ChangeSid): self.ChangeSid = ChangeSid
    def get_VirtualMachineId(self): return self.VirtualMachineId
    def set_VirtualMachineId(self, VirtualMachineId): self.VirtualMachineId = VirtualMachineId
    def get_JoinDomainEnabled(self): return self.JoinDomainEnabled
    def set_JoinDomainEnabled(self, JoinDomainEnabled): self.JoinDomainEnabled = JoinDomainEnabled
    def get_UseOrgSettings(self): return self.UseOrgSettings
    def set_UseOrgSettings(self, UseOrgSettings): self.UseOrgSettings = UseOrgSettings
    def get_DomainName(self): return self.DomainName
    def set_DomainName(self, DomainName): self.DomainName = DomainName
    def get_DomainUserName(self): return self.DomainUserName
    def set_DomainUserName(self, DomainUserName): self.DomainUserName = DomainUserName
    def get_DomainUserPassword(self): return self.DomainUserPassword
    def set_DomainUserPassword(self, DomainUserPassword): self.DomainUserPassword = DomainUserPassword
    def get_MachineObjectOU(self): return self.MachineObjectOU
    def set_MachineObjectOU(self, MachineObjectOU): self.MachineObjectOU = MachineObjectOU
    def get_AdminPasswordEnabled(self): return self.AdminPasswordEnabled
    def set_AdminPasswordEnabled(self, AdminPasswordEnabled): self.AdminPasswordEnabled = AdminPasswordEnabled
    def get_AdminPasswordAuto(self): return self.AdminPasswordAuto
    def set_AdminPasswordAuto(self, AdminPasswordAuto): self.AdminPasswordAuto = AdminPasswordAuto
    def get_AdminPassword(self): return self.AdminPassword
    def set_AdminPassword(self, AdminPassword): self.AdminPassword = AdminPassword
    def get_AdminAutoLogonEnabled(self): return self.AdminAutoLogonEnabled
    def set_AdminAutoLogonEnabled(self, AdminAutoLogonEnabled): self.AdminAutoLogonEnabled = AdminAutoLogonEnabled
    def get_AdminAutoLogonCount(self): return self.AdminAutoLogonCount
    def set_AdminAutoLogonCount(self, AdminAutoLogonCount): self.AdminAutoLogonCount = AdminAutoLogonCount
    def get_ResetPasswordRequired(self): return self.ResetPasswordRequired
    def set_ResetPasswordRequired(self, ResetPasswordRequired): self.ResetPasswordRequired = ResetPasswordRequired
    def get_CustomizationScript(self): return self.CustomizationScript
    def set_CustomizationScript(self, CustomizationScript): self.CustomizationScript = CustomizationScript
    def get_ComputerName(self): return self.ComputerName
    def set_ComputerName(self, ComputerName): self.ComputerName = ComputerName
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def add_Link(self, value): self.Link.append(value)
    def insert_Link_at(self, index, value): self.Link.insert(index, value)
    def replace_Link_at(self, index, value): self.Link[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.Enabled is not None or
            self.ChangeSid is not None or
            self.VirtualMachineId is not None or
            self.JoinDomainEnabled is not None or
            self.UseOrgSettings is not None or
            self.DomainName is not None or
            self.DomainUserName is not None or
            self.DomainUserPassword is not None or
            self.MachineObjectOU is not None or
            self.AdminPasswordEnabled is not None or
            self.AdminPasswordAuto is not None or
            self.AdminPassword is not None or
            self.AdminAutoLogonEnabled is not None or
            self.AdminAutoLogonCount is not None or
            self.ResetPasswordRequired is not None or
            self.CustomizationScript is not None or
            self.ComputerName is not None or
            self.Link or
            self.anytypeobjs_ or
            super(GuestCustomizationSectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GuestCustomizationSectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GuestCustomizationSectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='GuestCustomizationSectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GuestCustomizationSectionType'):
        super(GuestCustomizationSectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GuestCustomizationSectionType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='GuestCustomizationSectionType', fromsubclass_=False, pretty_print=True):
        super(GuestCustomizationSectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Enabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEnabled>%s</%sEnabled>%s' % (namespace_, self.gds_format_boolean(self.Enabled, input_name='Enabled'), namespace_, eol_))
        if self.ChangeSid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sChangeSid>%s</%sChangeSid>%s' % (namespace_, self.gds_format_boolean(self.ChangeSid, input_name='ChangeSid'), namespace_, eol_))
        if self.VirtualMachineId is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVirtualMachineId>%s</%sVirtualMachineId>%s' % (namespace_, self.gds_format_string(quote_xml(self.VirtualMachineId).encode(ExternalEncoding), input_name='VirtualMachineId'), namespace_, eol_))
        if self.JoinDomainEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sJoinDomainEnabled>%s</%sJoinDomainEnabled>%s' % (namespace_, self.gds_format_boolean(self.JoinDomainEnabled, input_name='JoinDomainEnabled'), namespace_, eol_))
        if self.UseOrgSettings is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUseOrgSettings>%s</%sUseOrgSettings>%s' % (namespace_, self.gds_format_boolean(self.UseOrgSettings, input_name='UseOrgSettings'), namespace_, eol_))
        if self.DomainName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDomainName>%s</%sDomainName>%s' % (namespace_, self.gds_format_string(quote_xml(self.DomainName).encode(ExternalEncoding), input_name='DomainName'), namespace_, eol_))
        if self.DomainUserName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDomainUserName>%s</%sDomainUserName>%s' % (namespace_, self.gds_format_string(quote_xml(self.DomainUserName).encode(ExternalEncoding), input_name='DomainUserName'), namespace_, eol_))
        if self.DomainUserPassword is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDomainUserPassword>%s</%sDomainUserPassword>%s' % (namespace_, self.gds_format_string(quote_xml(self.DomainUserPassword).encode(ExternalEncoding), input_name='DomainUserPassword'), namespace_, eol_))
        if self.MachineObjectOU is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMachineObjectOU>%s</%sMachineObjectOU>%s' % (namespace_, self.gds_format_string(quote_xml(self.MachineObjectOU).encode(ExternalEncoding), input_name='MachineObjectOU'), namespace_, eol_))
        if self.AdminPasswordEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdminPasswordEnabled>%s</%sAdminPasswordEnabled>%s' % (namespace_, self.gds_format_boolean(self.AdminPasswordEnabled, input_name='AdminPasswordEnabled'), namespace_, eol_))
        if self.AdminPasswordAuto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdminPasswordAuto>%s</%sAdminPasswordAuto>%s' % (namespace_, self.gds_format_boolean(self.AdminPasswordAuto, input_name='AdminPasswordAuto'), namespace_, eol_))
        if self.AdminPassword is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdminPassword>%s</%sAdminPassword>%s' % (namespace_, self.gds_format_string(quote_xml(self.AdminPassword).encode(ExternalEncoding), input_name='AdminPassword'), namespace_, eol_))
        if self.AdminAutoLogonEnabled is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdminAutoLogonEnabled>%s</%sAdminAutoLogonEnabled>%s' % (namespace_, self.gds_format_boolean(self.AdminAutoLogonEnabled, input_name='AdminAutoLogonEnabled'), namespace_, eol_))
        if self.AdminAutoLogonCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAdminAutoLogonCount>%s</%sAdminAutoLogonCount>%s' % (namespace_, self.gds_format_integer(self.AdminAutoLogonCount, input_name='AdminAutoLogonCount'), namespace_, eol_))
        if self.ResetPasswordRequired is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sResetPasswordRequired>%s</%sResetPasswordRequired>%s' % (namespace_, self.gds_format_boolean(self.ResetPasswordRequired, input_name='ResetPasswordRequired'), namespace_, eol_))
        if self.CustomizationScript is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCustomizationScript>%s</%sCustomizationScript>%s' % (namespace_, self.gds_format_string(quote_xml(self.CustomizationScript).encode(ExternalEncoding), input_name='CustomizationScript'), namespace_, eol_))
        if self.ComputerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComputerName>%s</%sComputerName>%s' % (namespace_, self.gds_format_string(quote_xml(self.ComputerName).encode(ExternalEncoding), input_name='ComputerName'), namespace_, eol_))
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GuestCustomizationSectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(GuestCustomizationSectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GuestCustomizationSectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.Enabled is not None:
            showIndent(outfile, level)
            outfile.write('Enabled=%s,\n' % self.Enabled)
        if self.ChangeSid is not None:
            showIndent(outfile, level)
            outfile.write('ChangeSid=%s,\n' % self.ChangeSid)
        if self.VirtualMachineId is not None:
            showIndent(outfile, level)
            outfile.write('VirtualMachineId=%s,\n' % quote_python(self.VirtualMachineId).encode(ExternalEncoding))
        if self.JoinDomainEnabled is not None:
            showIndent(outfile, level)
            outfile.write('JoinDomainEnabled=%s,\n' % self.JoinDomainEnabled)
        if self.UseOrgSettings is not None:
            showIndent(outfile, level)
            outfile.write('UseOrgSettings=%s,\n' % self.UseOrgSettings)
        if self.DomainName is not None:
            showIndent(outfile, level)
            outfile.write('DomainName=%s,\n' % quote_python(self.DomainName).encode(ExternalEncoding))
        if self.DomainUserName is not None:
            showIndent(outfile, level)
            outfile.write('DomainUserName=%s,\n' % quote_python(self.DomainUserName).encode(ExternalEncoding))
        if self.DomainUserPassword is not None:
            showIndent(outfile, level)
            outfile.write('DomainUserPassword=%s,\n' % quote_python(self.DomainUserPassword).encode(ExternalEncoding))
        if self.MachineObjectOU is not None:
            showIndent(outfile, level)
            outfile.write('MachineObjectOU=%s,\n' % quote_python(self.MachineObjectOU).encode(ExternalEncoding))
        if self.AdminPasswordEnabled is not None:
            showIndent(outfile, level)
            outfile.write('AdminPasswordEnabled=%s,\n' % self.AdminPasswordEnabled)
        if self.AdminPasswordAuto is not None:
            showIndent(outfile, level)
            outfile.write('AdminPasswordAuto=%s,\n' % self.AdminPasswordAuto)
        if self.AdminPassword is not None:
            showIndent(outfile, level)
            outfile.write('AdminPassword=%s,\n' % quote_python(self.AdminPassword).encode(ExternalEncoding))
        if self.AdminAutoLogonEnabled is not None:
            showIndent(outfile, level)
            outfile.write('AdminAutoLogonEnabled=%s,\n' % self.AdminAutoLogonEnabled)
        if self.AdminAutoLogonCount is not None:
            showIndent(outfile, level)
            outfile.write('AdminAutoLogonCount=%d,\n' % self.AdminAutoLogonCount)
        if self.ResetPasswordRequired is not None:
            showIndent(outfile, level)
            outfile.write('ResetPasswordRequired=%s,\n' % self.ResetPasswordRequired)
        if self.CustomizationScript is not None:
            showIndent(outfile, level)
            outfile.write('CustomizationScript=%s,\n' % quote_python(self.CustomizationScript).encode(ExternalEncoding))
        if self.ComputerName is not None:
            showIndent(outfile, level)
            outfile.write('ComputerName=%s,\n' % quote_python(self.ComputerName).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            Link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(GuestCustomizationSectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Enabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Enabled')
            self.Enabled = ival_
        elif nodeName_ == 'ChangeSid':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ChangeSid')
            self.ChangeSid = ival_
        elif nodeName_ == 'VirtualMachineId':
            VirtualMachineId_ = child_.text
            VirtualMachineId_ = self.gds_validate_string(VirtualMachineId_, node, 'VirtualMachineId')
            self.VirtualMachineId = VirtualMachineId_
        elif nodeName_ == 'JoinDomainEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'JoinDomainEnabled')
            self.JoinDomainEnabled = ival_
        elif nodeName_ == 'UseOrgSettings':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'UseOrgSettings')
            self.UseOrgSettings = ival_
        elif nodeName_ == 'DomainName':
            DomainName_ = child_.text
            DomainName_ = self.gds_validate_string(DomainName_, node, 'DomainName')
            self.DomainName = DomainName_
        elif nodeName_ == 'DomainUserName':
            DomainUserName_ = child_.text
            DomainUserName_ = self.gds_validate_string(DomainUserName_, node, 'DomainUserName')
            self.DomainUserName = DomainUserName_
        elif nodeName_ == 'DomainUserPassword':
            DomainUserPassword_ = child_.text
            DomainUserPassword_ = self.gds_validate_string(DomainUserPassword_, node, 'DomainUserPassword')
            self.DomainUserPassword = DomainUserPassword_
        elif nodeName_ == 'MachineObjectOU':
            MachineObjectOU_ = child_.text
            MachineObjectOU_ = self.gds_validate_string(MachineObjectOU_, node, 'MachineObjectOU')
            self.MachineObjectOU = MachineObjectOU_
        elif nodeName_ == 'AdminPasswordEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AdminPasswordEnabled')
            self.AdminPasswordEnabled = ival_
        elif nodeName_ == 'AdminPasswordAuto':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AdminPasswordAuto')
            self.AdminPasswordAuto = ival_
        elif nodeName_ == 'AdminPassword':
            AdminPassword_ = child_.text
            AdminPassword_ = self.gds_validate_string(AdminPassword_, node, 'AdminPassword')
            self.AdminPassword = AdminPassword_
        elif nodeName_ == 'AdminAutoLogonEnabled':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'AdminAutoLogonEnabled')
            self.AdminAutoLogonEnabled = ival_
        elif nodeName_ == 'AdminAutoLogonCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'AdminAutoLogonCount')
            self.AdminAutoLogonCount = ival_
        elif nodeName_ == 'ResetPasswordRequired':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ResetPasswordRequired')
            self.ResetPasswordRequired = ival_
        elif nodeName_ == 'CustomizationScript':
            CustomizationScript_ = child_.text
            CustomizationScript_ = self.gds_validate_string(CustomizationScript_, node, 'CustomizationScript')
            self.CustomizationScript = CustomizationScript_
        elif nodeName_ == 'ComputerName':
            ComputerName_ = child_.text
            ComputerName_ = self.gds_validate_string(ComputerName_, node, 'ComputerName')
            self.ComputerName = ComputerName_
        elif nodeName_ == 'Link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.Link.append(obj_)
            obj_.original_tagname_ = 'Link'
        else:
            obj_ = self.gds_build_any(child_, 'GuestCustomizationSectionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(GuestCustomizationSectionType, self).buildChildren(child_, node, nodeName_, True)
# end class GuestCustomizationSectionType


class RuntimeInfoSectionType(Section_Type):
    """1.5 VMware Tools and other runtime information for this virtual
    machine."""
    subclass = None
    superclass = Section_Type
    def __init__(self, VMWareTools=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(RuntimeInfoSectionType, self).__init__()
        self.VMWareTools = VMWareTools
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if RuntimeInfoSectionType.subclass:
            return RuntimeInfoSectionType.subclass(*args_, **kwargs_)
        else:
            return RuntimeInfoSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VMWareTools(self): return self.VMWareTools
    def set_VMWareTools(self, VMWareTools): self.VMWareTools = VMWareTools
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def hasContent_(self):
        if (
            self.VMWareTools is not None or
            self.anytypeobjs_ or
            super(RuntimeInfoSectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RuntimeInfoSectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RuntimeInfoSectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RuntimeInfoSectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RuntimeInfoSectionType'):
        super(RuntimeInfoSectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RuntimeInfoSectionType')
    def exportChildren(self, outfile, level, namespace_='', name_='RuntimeInfoSectionType', fromsubclass_=False, pretty_print=True):
        super(RuntimeInfoSectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.VMWareTools is not None:
            self.VMWareTools.export(outfile, level, namespace_, name_='VMWareTools', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RuntimeInfoSectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RuntimeInfoSectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RuntimeInfoSectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.VMWareTools is not None:
            showIndent(outfile, level)
            outfile.write('VMWareTools=model_.VMWareToolsType(\n')
            self.VMWareTools.exportLiteral(outfile, level, name_='VMWareTools')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RuntimeInfoSectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VMWareTools':
            obj_ = VMWareToolsType.factory()
            obj_.build(child_)
            self.VMWareTools = obj_
            obj_.original_tagname_ = 'VMWareTools'
        else:
            obj_ = self.gds_build_any(child_, 'RuntimeInfoSectionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(RuntimeInfoSectionType, self).buildChildren(child_, node, nodeName_, True)
# end class RuntimeInfoSectionType


class NetworkConnectionSectionType(Section_Type):
    """0.9 Container for the network connections of this virtual machine.
    none A reference to the section in URL format. falsenone The
    MIME type of the section. false"""
    subclass = None
    superclass = Section_Type
    def __init__(self, href=None, type_=None, PrimaryNetworkConnectionIndex=None, NetworkConnection=None, Link=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(NetworkConnectionSectionType, self).__init__()
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        self.PrimaryNetworkConnectionIndex = PrimaryNetworkConnectionIndex
        if NetworkConnection is None:
            self.NetworkConnection = []
        else:
            self.NetworkConnection = NetworkConnection
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if NetworkConnectionSectionType.subclass:
            return NetworkConnectionSectionType.subclass(*args_, **kwargs_)
        else:
            return NetworkConnectionSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PrimaryNetworkConnectionIndex(self): return self.PrimaryNetworkConnectionIndex
    def set_PrimaryNetworkConnectionIndex(self, PrimaryNetworkConnectionIndex): self.PrimaryNetworkConnectionIndex = PrimaryNetworkConnectionIndex
    def get_NetworkConnection(self): return self.NetworkConnection
    def set_NetworkConnection(self, NetworkConnection): self.NetworkConnection = NetworkConnection
    def add_NetworkConnection(self, value): self.NetworkConnection.append(value)
    def insert_NetworkConnection_at(self, index, value): self.NetworkConnection.insert(index, value)
    def replace_NetworkConnection_at(self, index, value): self.NetworkConnection[index] = value
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def add_Link(self, value): self.Link.append(value)
    def insert_Link_at(self, index, value): self.Link.insert(index, value)
    def replace_Link_at(self, index, value): self.Link[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.PrimaryNetworkConnectionIndex is not None or
            self.NetworkConnection or
            self.Link or
            self.anytypeobjs_ or
            super(NetworkConnectionSectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkConnectionSectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConnectionSectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkConnectionSectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkConnectionSectionType'):
        super(NetworkConnectionSectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConnectionSectionType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkConnectionSectionType', fromsubclass_=False, pretty_print=True):
        super(NetworkConnectionSectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PrimaryNetworkConnectionIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrimaryNetworkConnectionIndex>%s</%sPrimaryNetworkConnectionIndex>%s' % (namespace_, self.gds_format_integer(self.PrimaryNetworkConnectionIndex, input_name='PrimaryNetworkConnectionIndex'), namespace_, eol_))
        for NetworkConnection_ in self.NetworkConnection:
            NetworkConnection_.export(outfile, level, namespace_, name_='NetworkConnection', pretty_print=pretty_print)
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkConnectionSectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(NetworkConnectionSectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkConnectionSectionType, self).exportLiteralChildren(outfile, level, name_)
        if self.PrimaryNetworkConnectionIndex is not None:
            showIndent(outfile, level)
            outfile.write('PrimaryNetworkConnectionIndex=%d,\n' % self.PrimaryNetworkConnectionIndex)
        showIndent(outfile, level)
        outfile.write('NetworkConnection=[\n')
        level += 1
        for NetworkConnection_ in self.NetworkConnection:
            showIndent(outfile, level)
            outfile.write('model_.NetworkConnectionType(\n')
            NetworkConnection_.exportLiteral(outfile, level, name_='NetworkConnectionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            Link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(NetworkConnectionSectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PrimaryNetworkConnectionIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PrimaryNetworkConnectionIndex')
            self.PrimaryNetworkConnectionIndex = ival_
        elif nodeName_ == 'NetworkConnection':
            obj_ = NetworkConnectionType.factory()
            obj_.build(child_)
            self.NetworkConnection.append(obj_)
            obj_.original_tagname_ = 'NetworkConnection'
        elif nodeName_ == 'Link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.Link.append(obj_)
            obj_.original_tagname_ = 'Link'
        else:
            obj_ = self.gds_build_any(child_, 'NetworkConnectionSectionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(NetworkConnectionSectionType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkConnectionSectionType


class LeaseSettingsSectionType(Section_Type):
    """0.9 Represents vApp lease settings. none A reference to the section
    in URL format. falsenone The MIME type of the section. false"""
    subclass = None
    superclass = Section_Type
    def __init__(self, href=None, type_=None, Link=None, DeploymentLeaseInSeconds=None, StorageLeaseInSeconds=None, DeploymentLeaseExpiration=None, StorageLeaseExpiration=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(LeaseSettingsSectionType, self).__init__()
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
        self.DeploymentLeaseInSeconds = DeploymentLeaseInSeconds
        self.StorageLeaseInSeconds = StorageLeaseInSeconds
        if isinstance(DeploymentLeaseExpiration, basestring):
            initvalue_ = datetime_.datetime.strptime(DeploymentLeaseExpiration, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DeploymentLeaseExpiration
        self.DeploymentLeaseExpiration = initvalue_
        if isinstance(StorageLeaseExpiration, basestring):
            initvalue_ = datetime_.datetime.strptime(StorageLeaseExpiration, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = StorageLeaseExpiration
        self.StorageLeaseExpiration = initvalue_
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if LeaseSettingsSectionType.subclass:
            return LeaseSettingsSectionType.subclass(*args_, **kwargs_)
        else:
            return LeaseSettingsSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def add_Link(self, value): self.Link.append(value)
    def insert_Link_at(self, index, value): self.Link.insert(index, value)
    def replace_Link_at(self, index, value): self.Link[index] = value
    def get_DeploymentLeaseInSeconds(self): return self.DeploymentLeaseInSeconds
    def set_DeploymentLeaseInSeconds(self, DeploymentLeaseInSeconds): self.DeploymentLeaseInSeconds = DeploymentLeaseInSeconds
    def get_StorageLeaseInSeconds(self): return self.StorageLeaseInSeconds
    def set_StorageLeaseInSeconds(self, StorageLeaseInSeconds): self.StorageLeaseInSeconds = StorageLeaseInSeconds
    def get_DeploymentLeaseExpiration(self): return self.DeploymentLeaseExpiration
    def set_DeploymentLeaseExpiration(self, DeploymentLeaseExpiration): self.DeploymentLeaseExpiration = DeploymentLeaseExpiration
    def get_StorageLeaseExpiration(self): return self.StorageLeaseExpiration
    def set_StorageLeaseExpiration(self, StorageLeaseExpiration): self.StorageLeaseExpiration = StorageLeaseExpiration
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.Link or
            self.DeploymentLeaseInSeconds is not None or
            self.StorageLeaseInSeconds is not None or
            self.DeploymentLeaseExpiration is not None or
            self.StorageLeaseExpiration is not None or
            self.anytypeobjs_ or
            super(LeaseSettingsSectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LeaseSettingsSectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LeaseSettingsSectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LeaseSettingsSectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LeaseSettingsSectionType'):
        super(LeaseSettingsSectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LeaseSettingsSectionType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LeaseSettingsSectionType', fromsubclass_=False, pretty_print=True):
        super(LeaseSettingsSectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
        if self.DeploymentLeaseInSeconds is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeploymentLeaseInSeconds>%s</%sDeploymentLeaseInSeconds>%s' % (namespace_, self.gds_format_integer(self.DeploymentLeaseInSeconds, input_name='DeploymentLeaseInSeconds'), namespace_, eol_))
        if self.StorageLeaseInSeconds is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStorageLeaseInSeconds>%s</%sStorageLeaseInSeconds>%s' % (namespace_, self.gds_format_integer(self.StorageLeaseInSeconds, input_name='StorageLeaseInSeconds'), namespace_, eol_))
        if self.DeploymentLeaseExpiration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDeploymentLeaseExpiration>%s</%sDeploymentLeaseExpiration>%s' % (namespace_, self.gds_format_datetime(self.DeploymentLeaseExpiration, input_name='DeploymentLeaseExpiration'), namespace_, eol_))
        if self.StorageLeaseExpiration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStorageLeaseExpiration>%s</%sStorageLeaseExpiration>%s' % (namespace_, self.gds_format_datetime(self.StorageLeaseExpiration, input_name='StorageLeaseExpiration'), namespace_, eol_))
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LeaseSettingsSectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(LeaseSettingsSectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LeaseSettingsSectionType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            Link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DeploymentLeaseInSeconds is not None:
            showIndent(outfile, level)
            outfile.write('DeploymentLeaseInSeconds=%d,\n' % self.DeploymentLeaseInSeconds)
        if self.StorageLeaseInSeconds is not None:
            showIndent(outfile, level)
            outfile.write('StorageLeaseInSeconds=%d,\n' % self.StorageLeaseInSeconds)
        if self.DeploymentLeaseExpiration is not None:
            showIndent(outfile, level)
            outfile.write('DeploymentLeaseExpiration=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.DeploymentLeaseExpiration, input_name='DeploymentLeaseExpiration'))
        if self.StorageLeaseExpiration is not None:
            showIndent(outfile, level)
            outfile.write('StorageLeaseExpiration=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.StorageLeaseExpiration, input_name='StorageLeaseExpiration'))
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(LeaseSettingsSectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.Link.append(obj_)
            obj_.original_tagname_ = 'Link'
        elif nodeName_ == 'DeploymentLeaseInSeconds':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DeploymentLeaseInSeconds')
            self.DeploymentLeaseInSeconds = ival_
        elif nodeName_ == 'StorageLeaseInSeconds':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'StorageLeaseInSeconds')
            self.StorageLeaseInSeconds = ival_
        elif nodeName_ == 'DeploymentLeaseExpiration':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DeploymentLeaseExpiration = dval_
        elif nodeName_ == 'StorageLeaseExpiration':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.StorageLeaseExpiration = dval_
        else:
            obj_ = self.gds_build_any(child_, 'LeaseSettingsSectionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(LeaseSettingsSectionType, self).buildChildren(child_, node, nodeName_, True)
# end class LeaseSettingsSectionType


class NetworkConfigSectionType(Section_Type):
    """0.9 Container for vApp networks. none A reference to the section in
    URL format. falsenone The MIME type of the section. false"""
    subclass = None
    superclass = Section_Type
    def __init__(self, href=None, type_=None, Link=None, NetworkConfig=None, anytypeobjs_=None):
        self.original_tagname_ = None
        super(NetworkConfigSectionType, self).__init__()
        self.href = _cast(None, href)
        self.type_ = _cast(None, type_)
        if Link is None:
            self.Link = []
        else:
            self.Link = Link
        if NetworkConfig is None:
            self.NetworkConfig = []
        else:
            self.NetworkConfig = NetworkConfig
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if NetworkConfigSectionType.subclass:
            return NetworkConfigSectionType.subclass(*args_, **kwargs_)
        else:
            return NetworkConfigSectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Link(self): return self.Link
    def set_Link(self, Link): self.Link = Link
    def add_Link(self, value): self.Link.append(value)
    def insert_Link_at(self, index, value): self.Link.insert(index, value)
    def replace_Link_at(self, index, value): self.Link[index] = value
    def get_NetworkConfig(self): return self.NetworkConfig
    def set_NetworkConfig(self, NetworkConfig): self.NetworkConfig = NetworkConfig
    def add_NetworkConfig(self, value): self.NetworkConfig.append(value)
    def insert_NetworkConfig_at(self, index, value): self.NetworkConfig.insert(index, value)
    def replace_NetworkConfig_at(self, index, value): self.NetworkConfig[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.Link or
            self.NetworkConfig or
            self.anytypeobjs_ or
            super(NetworkConfigSectionType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NetworkConfigSectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConfigSectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NetworkConfigSectionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NetworkConfigSectionType'):
        super(NetworkConfigSectionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NetworkConfigSectionType')
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='NetworkConfigSectionType', fromsubclass_=False, pretty_print=True):
        super(NetworkConfigSectionType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Link_ in self.Link:
            Link_.export(outfile, level, namespace_, name_='Link', pretty_print=pretty_print)
        for NetworkConfig_ in self.NetworkConfig:
            NetworkConfig_.export(outfile, level, namespace_, name_='NetworkConfig', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NetworkConfigSectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
        super(NetworkConfigSectionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NetworkConfigSectionType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Link=[\n')
        level += 1
        for Link_ in self.Link:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            Link_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('NetworkConfig=[\n')
        level += 1
        for NetworkConfig_ in self.NetworkConfig:
            showIndent(outfile, level)
            outfile.write('model_.VAppNetworkConfigurationType(\n')
            NetworkConfig_.exportLiteral(outfile, level, name_='VAppNetworkConfigurationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(NetworkConfigSectionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Link':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.Link.append(obj_)
            obj_.original_tagname_ = 'Link'
        elif nodeName_ == 'NetworkConfig':
            obj_ = VAppNetworkConfigurationType.factory()
            obj_.build(child_)
            self.NetworkConfig.append(obj_)
            obj_.original_tagname_ = 'NetworkConfig'
        else:
            obj_ = self.gds_build_any(child_, 'NetworkConfigSectionType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
        super(NetworkConfigSectionType, self).buildChildren(child_, node, nodeName_, True)
# end class NetworkConfigSectionType


class DiskType(ResourceEntityType):
    """5.1 Represents an independent disk. none Size of the disk in MB.<br>
    <br> You must supply this attribute in an update request, but
    you cannot change its value after the object has been created.
    truenone Disk bus type expressed as a number. One of:<br>
    <b>5</b> IDE bus<br> <b>6</b> SCSI bus (default)<br> <b>20</b>
    SATA bus<br> <br> You must supply this attribute in an update
    request, but you cannot change its value after the object has
    been created. falsenone Disk bus subtype expressed as a string.
    One of:<br> "" (null)&nbsp;&nbsp;IDE, requires busType 5<br>
    <b>buslogic</b>&nbsp;&nbsp;BusLogic Parallel SCSI controller,
    requires busType 6<br> <b>lsilogic</b>&nbsp;&nbsp;LSI Logic
    Parallel SCSI controller, requires busType 6<br>
    <b>lsilogicsas</b>&nbsp;&nbsp;LSI Logic SAS SCSI controller,
    requires busType 6<br> <b>VirtualSCSI</b>&nbsp;&nbsp;Paravirtual
    SCSI controller, requires busType 6<br>
    <b>vmware.sata.ahci</b>&nbsp;&nbsp;SATA controller, requires
    busType 20<br> <br> You must supply this attribute in an update
    request, but you cannot change its value after the object has
    been created. false"""
    subclass = None
    superclass = ResourceEntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, Files=None, busType=None, busSubType=None, size=None, StorageProfile=None, Owner=None):
        self.original_tagname_ = None
        super(DiskType, self).__init__(operationKey, id, name, Description, Tasks, status, Files, )
        self.busType = _cast(None, busType)
        self.busSubType = _cast(None, busSubType)
        self.size = _cast(int, size)
        self.StorageProfile = StorageProfile
        self.Owner = Owner
    def factory(*args_, **kwargs_):
        if DiskType.subclass:
            return DiskType.subclass(*args_, **kwargs_)
        else:
            return DiskType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StorageProfile(self): return self.StorageProfile
    def set_StorageProfile(self, StorageProfile): self.StorageProfile = StorageProfile
    def get_Owner(self): return self.Owner
    def set_Owner(self, Owner): self.Owner = Owner
    def get_busType(self): return self.busType
    def set_busType(self, busType): self.busType = busType
    def get_busSubType(self): return self.busSubType
    def set_busSubType(self, busSubType): self.busSubType = busSubType
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def hasContent_(self):
        if (
            self.StorageProfile is not None or
            self.Owner is not None or
            super(DiskType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DiskType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DiskType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DiskType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DiskType'):
        super(DiskType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DiskType')
        if self.busType is not None and 'busType' not in already_processed:
            already_processed.add('busType')
            outfile.write(' busType=%s' % (self.gds_format_string(quote_attrib(self.busType).encode(ExternalEncoding), input_name='busType'), ))
        if self.busSubType is not None and 'busSubType' not in already_processed:
            already_processed.add('busSubType')
            outfile.write(' busSubType=%s' % (self.gds_format_string(quote_attrib(self.busSubType).encode(ExternalEncoding), input_name='busSubType'), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size="%s"' % self.gds_format_integer(self.size, input_name='size'))
    def exportChildren(self, outfile, level, namespace_='', name_='DiskType', fromsubclass_=False, pretty_print=True):
        super(DiskType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StorageProfile is not None:
            self.StorageProfile.export(outfile, level, namespace_, name_='StorageProfile', pretty_print=pretty_print)
        if self.Owner is not None:
            self.Owner.export(outfile, level, namespace_, name_='Owner', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DiskType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.busType is not None and 'busType' not in already_processed:
            already_processed.add('busType')
            showIndent(outfile, level)
            outfile.write('busType="%s",\n' % (self.busType,))
        if self.busSubType is not None and 'busSubType' not in already_processed:
            already_processed.add('busSubType')
            showIndent(outfile, level)
            outfile.write('busSubType="%s",\n' % (self.busSubType,))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % (self.size,))
        super(DiskType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DiskType, self).exportLiteralChildren(outfile, level, name_)
        if self.StorageProfile is not None:
            showIndent(outfile, level)
            outfile.write('StorageProfile=model_.ReferenceType(\n')
            self.StorageProfile.exportLiteral(outfile, level, name_='StorageProfile')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Owner is not None:
            showIndent(outfile, level)
            outfile.write('Owner=model_.OwnerType(\n')
            self.Owner.exportLiteral(outfile, level, name_='Owner')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('busType', node)
        if value is not None and 'busType' not in already_processed:
            already_processed.add('busType')
            self.busType = value
        value = find_attr_value_('busSubType', node)
        if value is not None and 'busSubType' not in already_processed:
            already_processed.add('busSubType')
            self.busSubType = value
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            try:
                self.size = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(DiskType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StorageProfile':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.StorageProfile = obj_
            obj_.original_tagname_ = 'StorageProfile'
        elif nodeName_ == 'Owner':
            obj_ = OwnerType.factory()
            obj_.build(child_)
            self.Owner = obj_
            obj_.original_tagname_ = 'Owner'
        super(DiskType, self).buildChildren(child_, node, nodeName_, True)
# end class DiskType


class TaskType(EntityType):
    """0.9 Represents an asynchronous operation in vCloud Director. none
    The execution status of the task. One of:<br> <b>queued</b> (The
    task has been queued for execution)<br> <b>preRunning</b> (The
    task is awaiting preprocessing or administrative action.)<br>
    <b>running</b> (The task is running.)<br> <b>success</b> (The
    task completed with a status of success.)<br> <b>error</b> (The
    task encountered an error while running.)<br> <b>canceled</b>
    (The task was canceled by the owner or an administrator.)<br>
    <b>aborted</b> (The task was aborted by an administrative
    action.) truealways A message describing the operation that is
    tracked by this task. falsenone The short name of the operation
    that is tracked by this task. false5.1createtrue Identifier of
    the service that created the task. It must not start with
    com.vmware.vcloud and the length must be between 1 and 128
    symbols. none The date and time the system started executing the
    task. May not be present if the task has not been executed yet.
    falsenone The date and time that processing of the task was
    completed. May not be present if the task is still being
    executed. falsenone The date and time at which the task resource
    will be destroyed and no longer available for retrieval. May not
    be present if the task has not been executed or is still being
    executed. false5.1nonefalse Whether user has requested this
    processing to be canceled."""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, status=None, operationName=None, expiryTime=None, cancelRequested=None, startTime=None, operation=None, endTime=None, serviceNamespace=None, Owner=None, Error=None, User=None, Organization=None, Progress=None, Params=None, Details=None):
        self.original_tagname_ = None
        super(TaskType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.status = _cast(None, status)
        self.operationName = _cast(None, operationName)
        if isinstance(expiryTime, basestring):
            initvalue_ = datetime_.datetime.strptime(expiryTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = expiryTime
        self.expiryTime = initvalue_
        self.cancelRequested = _cast(bool, cancelRequested)
        if isinstance(startTime, basestring):
            initvalue_ = datetime_.datetime.strptime(startTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = startTime
        self.startTime = initvalue_
        self.operation = _cast(None, operation)
        if isinstance(endTime, basestring):
            initvalue_ = datetime_.datetime.strptime(endTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = endTime
        self.endTime = initvalue_
        self.serviceNamespace = _cast(None, serviceNamespace)
        self.Owner = Owner
        self.Error = Error
        self.User = User
        self.Organization = Organization
        self.Progress = Progress
        self.Params = Params
        self.Details = Details
    def factory(*args_, **kwargs_):
        if TaskType.subclass:
            return TaskType.subclass(*args_, **kwargs_)
        else:
            return TaskType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Owner(self): return self.Owner
    def set_Owner(self, Owner): self.Owner = Owner
    def get_Error(self): return self.Error
    def set_Error(self, Error): self.Error = Error
    def get_User(self): return self.User
    def set_User(self, User): self.User = User
    def get_Organization(self): return self.Organization
    def set_Organization(self, Organization): self.Organization = Organization
    def get_Progress(self): return self.Progress
    def set_Progress(self, Progress): self.Progress = Progress
    def get_Params(self): return self.Params
    def set_Params(self, Params): self.Params = Params
    def get_Details(self): return self.Details
    def set_Details(self, Details): self.Details = Details
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_operationName(self): return self.operationName
    def set_operationName(self, operationName): self.operationName = operationName
    def get_expiryTime(self): return self.expiryTime
    def set_expiryTime(self, expiryTime): self.expiryTime = expiryTime
    def get_cancelRequested(self): return self.cancelRequested
    def set_cancelRequested(self, cancelRequested): self.cancelRequested = cancelRequested
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def get_operation(self): return self.operation
    def set_operation(self, operation): self.operation = operation
    def get_endTime(self): return self.endTime
    def set_endTime(self, endTime): self.endTime = endTime
    def get_serviceNamespace(self): return self.serviceNamespace
    def set_serviceNamespace(self, serviceNamespace): self.serviceNamespace = serviceNamespace
    def hasContent_(self):
        if (
            self.Owner is not None or
            self.Error is not None or
            self.User is not None or
            self.Organization is not None or
            self.Progress is not None or
            self.Params is not None or
            self.Details is not None or
            super(TaskType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TaskType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TaskType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TaskType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TaskType'):
        super(TaskType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TaskType')
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.operationName is not None and 'operationName' not in already_processed:
            already_processed.add('operationName')
            outfile.write(' operationName=%s' % (self.gds_format_string(quote_attrib(self.operationName).encode(ExternalEncoding), input_name='operationName'), ))
        if self.expiryTime is not None and 'expiryTime' not in already_processed:
            already_processed.add('expiryTime')
            outfile.write(' expiryTime="%s"' % self.gds_format_datetime(self.expiryTime, input_name='expiryTime'))
        if self.cancelRequested is not None and 'cancelRequested' not in already_processed:
            already_processed.add('cancelRequested')
            outfile.write(' cancelRequested="%s"' % self.gds_format_boolean(self.cancelRequested, input_name='cancelRequested'))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            outfile.write(' startTime="%s"' % self.gds_format_datetime(self.startTime, input_name='startTime'))
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            outfile.write(' operation=%s' % (self.gds_format_string(quote_attrib(self.operation).encode(ExternalEncoding), input_name='operation'), ))
        if self.endTime is not None and 'endTime' not in already_processed:
            already_processed.add('endTime')
            outfile.write(' endTime="%s"' % self.gds_format_datetime(self.endTime, input_name='endTime'))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            outfile.write(' serviceNamespace=%s' % (self.gds_format_string(quote_attrib(self.serviceNamespace).encode(ExternalEncoding), input_name='serviceNamespace'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='TaskType', fromsubclass_=False, pretty_print=True):
        super(TaskType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Owner is not None:
            self.Owner.export(outfile, level, namespace_, name_='Owner', pretty_print=pretty_print)
        if self.Error is not None:
            self.Error.export(outfile, level, namespace_, name_='Error', pretty_print=pretty_print)
        if self.User is not None:
            self.User.export(outfile, level, namespace_, name_='User', pretty_print=pretty_print)
        if self.Organization is not None:
            self.Organization.export(outfile, level, namespace_, name_='Organization', pretty_print=pretty_print)
        if self.Progress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProgress>%s</%sProgress>%s' % (namespace_, self.gds_format_integer(self.Progress, input_name='Progress'), namespace_, eol_))
        if self.Params is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sParams>%s</%sParams>%s' % (namespace_, self.gds_format_string(quote_xml(self.Params).encode(ExternalEncoding), input_name='Params'), namespace_, eol_))
        if self.Details is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDetails>%s</%sDetails>%s' % (namespace_, self.gds_format_string(quote_xml(self.Details).encode(ExternalEncoding), input_name='Details'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TaskType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.operationName is not None and 'operationName' not in already_processed:
            already_processed.add('operationName')
            showIndent(outfile, level)
            outfile.write('operationName="%s",\n' % (self.operationName,))
        if self.expiryTime is not None and 'expiryTime' not in already_processed:
            already_processed.add('expiryTime')
            showIndent(outfile, level)
            outfile.write('expiryTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.expiryTime, input_name='expiryTime'))
        if self.cancelRequested is not None and 'cancelRequested' not in already_processed:
            already_processed.add('cancelRequested')
            showIndent(outfile, level)
            outfile.write('cancelRequested=%s,\n' % (self.cancelRequested,))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            showIndent(outfile, level)
            outfile.write('startTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.startTime, input_name='startTime'))
        if self.operation is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            showIndent(outfile, level)
            outfile.write('operation="%s",\n' % (self.operation,))
        if self.endTime is not None and 'endTime' not in already_processed:
            already_processed.add('endTime')
            showIndent(outfile, level)
            outfile.write('endTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.endTime, input_name='endTime'))
        if self.serviceNamespace is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            showIndent(outfile, level)
            outfile.write('serviceNamespace="%s",\n' % (self.serviceNamespace,))
        super(TaskType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TaskType, self).exportLiteralChildren(outfile, level, name_)
        if self.Owner is not None:
            showIndent(outfile, level)
            outfile.write('Owner=model_.ReferenceType(\n')
            self.Owner.exportLiteral(outfile, level, name_='Owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Error is not None:
            showIndent(outfile, level)
            outfile.write('Error=model_.ErrorType(\n')
            self.Error.exportLiteral(outfile, level, name_='Error')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.User is not None:
            showIndent(outfile, level)
            outfile.write('User=model_.ReferenceType(\n')
            self.User.exportLiteral(outfile, level, name_='User')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Organization is not None:
            showIndent(outfile, level)
            outfile.write('Organization=model_.ReferenceType(\n')
            self.Organization.exportLiteral(outfile, level, name_='Organization')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Progress is not None:
            showIndent(outfile, level)
            outfile.write('Progress=%d,\n' % self.Progress)
        if self.Params is not None:
            showIndent(outfile, level)
            outfile.write('Params=%s,\n' % quote_python(self.Params).encode(ExternalEncoding))
        if self.Details is not None:
            showIndent(outfile, level)
            outfile.write('Details=%s,\n' % quote_python(self.Details).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
        value = find_attr_value_('operationName', node)
        if value is not None and 'operationName' not in already_processed:
            already_processed.add('operationName')
            self.operationName = value
        value = find_attr_value_('expiryTime', node)
        if value is not None and 'expiryTime' not in already_processed:
            already_processed.add('expiryTime')
            try:
                self.expiryTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (expiryTime): %s' % exp)
        value = find_attr_value_('cancelRequested', node)
        if value is not None and 'cancelRequested' not in already_processed:
            already_processed.add('cancelRequested')
            if value in ('true', '1'):
                self.cancelRequested = True
            elif value in ('false', '0'):
                self.cancelRequested = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('startTime', node)
        if value is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            try:
                self.startTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (startTime): %s' % exp)
        value = find_attr_value_('operation', node)
        if value is not None and 'operation' not in already_processed:
            already_processed.add('operation')
            self.operation = value
        value = find_attr_value_('endTime', node)
        if value is not None and 'endTime' not in already_processed:
            already_processed.add('endTime')
            try:
                self.endTime = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (endTime): %s' % exp)
        value = find_attr_value_('serviceNamespace', node)
        if value is not None and 'serviceNamespace' not in already_processed:
            already_processed.add('serviceNamespace')
            self.serviceNamespace = value
        super(TaskType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Owner':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Owner = obj_
            obj_.original_tagname_ = 'Owner'
        elif nodeName_ == 'Error':
            obj_ = ErrorType.factory()
            obj_.build(child_)
            self.Error = obj_
            obj_.original_tagname_ = 'Error'
        elif nodeName_ == 'User':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.User = obj_
            obj_.original_tagname_ = 'User'
        elif nodeName_ == 'Organization':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Organization = obj_
            obj_.original_tagname_ = 'Organization'
        elif nodeName_ == 'Progress':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Progress')
            self.Progress = ival_
        elif nodeName_ == 'Params':
            Params_ = child_.text
            Params_ = self.gds_validate_string(Params_, node, 'Params')
            self.Params = Params_
        elif nodeName_ == 'Details':
            Details_ = child_.text
            Details_ = self.gds_validate_string(Details_, node, 'Details')
            self.Details = Details_
        super(TaskType, self).buildChildren(child_, node, nodeName_, True)
# end class TaskType


class LinkType(ReferenceType):
    """0.9 Extends reference type by adding relation attribute. Defines a
    hyper-link with a relationship, hyper-link reference, and an
    optional MIME type. always Defines the relationship of the link
    to the object that contains it. A relationship can be the name
    of an operation on the object, a reference to a contained or
    containing object, or a reference to an alternate representation
    of the object. The relationship value implies the HTTP verb to
    use when you use the link's href as a request URL. See the
    vCloud API Programming Guide for a list of links and link
    relations. true"""
    subclass = None
    superclass = ReferenceType
    def __init__(self, VCloudExtension=None, href=None, type_=None, id=None, name=None, rel=None):
        self.original_tagname_ = None
        super(LinkType, self).__init__(VCloudExtension, href, type_, id, name, )
        self.rel = _cast(None, rel)
    def factory(*args_, **kwargs_):
        if LinkType.subclass:
            return LinkType.subclass(*args_, **kwargs_)
        else:
            return LinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rel(self): return self.rel
    def set_rel(self, rel): self.rel = rel
    def hasContent_(self):
        if (
            super(LinkType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkType'):
        super(LinkType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LinkType')
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            outfile.write(' rel=%s' % (self.gds_format_string(quote_attrib(self.rel).encode(ExternalEncoding), input_name='rel'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LinkType', fromsubclass_=False, pretty_print=True):
        super(LinkType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LinkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            showIndent(outfile, level)
            outfile.write('rel="%s",\n' % (self.rel,))
        super(LinkType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LinkType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rel', node)
        if value is not None and 'rel' not in already_processed:
            already_processed.add('rel')
            self.rel = value
        super(LinkType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LinkType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LinkType


class PublishCatalogParamsType(VCloudExtensibleType):
    """0.9 Parameters required when sharing a catalog with other
    organizations."""
    subclass = None
    superclass = VCloudExtensibleType
    def __init__(self, VCloudExtension=None, IsPublished=None):
        self.original_tagname_ = None
        super(PublishCatalogParamsType, self).__init__(VCloudExtension, )
        self.IsPublished = IsPublished
    def factory(*args_, **kwargs_):
        if PublishCatalogParamsType.subclass:
            return PublishCatalogParamsType.subclass(*args_, **kwargs_)
        else:
            return PublishCatalogParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IsPublished(self): return self.IsPublished
    def set_IsPublished(self, IsPublished): self.IsPublished = IsPublished
    def hasContent_(self):
        if (
            self.IsPublished is not None or
            super(PublishCatalogParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PublishCatalogParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PublishCatalogParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PublishCatalogParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PublishCatalogParamsType'):
        super(PublishCatalogParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PublishCatalogParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='PublishCatalogParamsType', fromsubclass_=False, pretty_print=True):
        super(PublishCatalogParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IsPublished is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsPublished>%s</%sIsPublished>%s' % (namespace_, self.gds_format_boolean(self.IsPublished, input_name='IsPublished'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PublishCatalogParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PublishCatalogParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PublishCatalogParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.IsPublished is not None:
            showIndent(outfile, level)
            outfile.write('IsPublished=%s,\n' % self.IsPublished)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PublishCatalogParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IsPublished':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsPublished')
            self.IsPublished = ival_
        super(PublishCatalogParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class PublishCatalogParamsType


class CopyOrMoveCatalogItemParamsType(ParamsType):
    """5.5 Parameters for a copyCatalogItem or moveCatalogItem request."""
    subclass = None
    superclass = ParamsType
    def __init__(self, VCloudExtension=None, name=None, Description=None, Source=None):
        self.original_tagname_ = None
        super(CopyOrMoveCatalogItemParamsType, self).__init__(VCloudExtension, name, Description, )
        self.Source = Source
    def factory(*args_, **kwargs_):
        if CopyOrMoveCatalogItemParamsType.subclass:
            return CopyOrMoveCatalogItemParamsType.subclass(*args_, **kwargs_)
        else:
            return CopyOrMoveCatalogItemParamsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def hasContent_(self):
        if (
            self.Source is not None or
            super(CopyOrMoveCatalogItemParamsType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CopyOrMoveCatalogItemParamsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CopyOrMoveCatalogItemParamsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CopyOrMoveCatalogItemParamsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CopyOrMoveCatalogItemParamsType'):
        super(CopyOrMoveCatalogItemParamsType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CopyOrMoveCatalogItemParamsType')
    def exportChildren(self, outfile, level, namespace_='', name_='CopyOrMoveCatalogItemParamsType', fromsubclass_=False, pretty_print=True):
        super(CopyOrMoveCatalogItemParamsType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Source is not None:
            self.Source.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CopyOrMoveCatalogItemParamsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CopyOrMoveCatalogItemParamsType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CopyOrMoveCatalogItemParamsType, self).exportLiteralChildren(outfile, level, name_)
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.ReferenceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CopyOrMoveCatalogItemParamsType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Source':
            class_obj_ = self.get_class_obj_(child_, ReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Source = obj_
            obj_.original_tagname_ = 'Source'
        super(CopyOrMoveCatalogItemParamsType, self).buildChildren(child_, node, nodeName_, True)
# end class CopyOrMoveCatalogItemParamsType


class CatalogType(EntityType):
    """0.9 Represents the user view of a Catalog object."""
    subclass = None
    superclass = EntityType
    def __init__(self, operationKey=None, id=None, name=None, Description=None, Tasks=None, Owner=None, CatalogItems=None, IsPublished=None, DateCreated=None, VersionNumber=None):
        self.original_tagname_ = None
        super(CatalogType, self).__init__(operationKey, id, name, Description, Tasks, )
        self.Owner = Owner
        self.CatalogItems = CatalogItems
        self.IsPublished = IsPublished
        if isinstance(DateCreated, basestring):
            initvalue_ = datetime_.datetime.strptime(DateCreated, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = DateCreated
        self.DateCreated = initvalue_
        self.VersionNumber = VersionNumber
    def factory(*args_, **kwargs_):
        if CatalogType.subclass:
            return CatalogType.subclass(*args_, **kwargs_)
        else:
            return CatalogType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Owner(self): return self.Owner
    def set_Owner(self, Owner): self.Owner = Owner
    def get_CatalogItems(self): return self.CatalogItems
    def set_CatalogItems(self, CatalogItems): self.CatalogItems = CatalogItems
    def get_IsPublished(self): return self.IsPublished
    def set_IsPublished(self, IsPublished): self.IsPublished = IsPublished
    def get_DateCreated(self): return self.DateCreated
    def set_DateCreated(self, DateCreated): self.DateCreated = DateCreated
    def get_VersionNumber(self): return self.VersionNumber
    def set_VersionNumber(self, VersionNumber): self.VersionNumber = VersionNumber
    def hasContent_(self):
        if (
            self.Owner is not None or
            self.CatalogItems is not None or
            self.IsPublished is not None or
            self.DateCreated is not None or
            self.VersionNumber is not None or
            super(CatalogType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CatalogType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CatalogType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CatalogType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CatalogType'):
        super(CatalogType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CatalogType')
    def exportChildren(self, outfile, level, namespace_='', name_='CatalogType', fromsubclass_=False, pretty_print=True):
        super(CatalogType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Owner is not None:
            self.Owner.export(outfile, level, namespace_, name_='Owner', pretty_print=pretty_print)
        if self.CatalogItems is not None:
            self.CatalogItems.export(outfile, level, namespace_, name_='CatalogItems', pretty_print=pretty_print)
        if self.IsPublished is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIsPublished>%s</%sIsPublished>%s' % (namespace_, self.gds_format_boolean(self.IsPublished, input_name='IsPublished'), namespace_, eol_))
        if self.DateCreated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDateCreated>%s</%sDateCreated>%s' % (namespace_, self.gds_format_datetime(self.DateCreated, input_name='DateCreated'), namespace_, eol_))
        if self.VersionNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersionNumber>%s</%sVersionNumber>%s' % (namespace_, self.gds_format_integer(self.VersionNumber, input_name='VersionNumber'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CatalogType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CatalogType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CatalogType, self).exportLiteralChildren(outfile, level, name_)
        if self.Owner is not None:
            showIndent(outfile, level)
            outfile.write('Owner=model_.OwnerType(\n')
            self.Owner.exportLiteral(outfile, level, name_='Owner')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CatalogItems is not None:
            showIndent(outfile, level)
            outfile.write('CatalogItems=model_.CatalogItemsType(\n')
            self.CatalogItems.exportLiteral(outfile, level, name_='CatalogItems')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IsPublished is not None:
            showIndent(outfile, level)
            outfile.write('IsPublished=%s,\n' % self.IsPublished)
        if self.DateCreated is not None:
            showIndent(outfile, level)
            outfile.write('DateCreated=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.DateCreated, input_name='DateCreated'))
        if self.VersionNumber is not None:
            showIndent(outfile, level)
            outfile.write('VersionNumber=%d,\n' % self.VersionNumber)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CatalogType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Owner':
            obj_ = OwnerType.factory()
            obj_.build(child_)
            self.Owner = obj_
            obj_.original_tagname_ = 'Owner'
        elif nodeName_ == 'CatalogItems':
            obj_ = CatalogItemsType.factory()
            obj_.build(child_)
            self.CatalogItems = obj_
            obj_.original_tagname_ = 'CatalogItems'
        elif nodeName_ == 'IsPublished':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'IsPublished')
            self.IsPublished = ival_
        elif nodeName_ == 'DateCreated':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.DateCreated = dval_
        elif nodeName_ == 'VersionNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'VersionNumber')
            self.VersionNumber = ival_
        super(CatalogType, self).buildChildren(child_, node, nodeName_, True)
# end class CatalogType


GDSClassesMapping = {
    'ServiceResourceResourceReferences': ReferencesType,
    'OrgNetworkReference': ReferenceType,
    'VAppOrgNetworkRelationReference': ReferenceType,
    'SnapshotSection': SnapshotSectionType,
    'CoresPerSocket': CoresPerSocket_Type,
    'SubnetParticipation': SubnetParticipationType,
    'TaskReferences': ReferencesType,
    'NetworkSection': NetworkSection_Type,
    'Metadata': MetadataType,
    'Parent': cimString,
    'CloneMediaParams': CloneMediaParamsType,
    'GroupRecord': QueryResultGroupRecordType,
    'RelativeStartTime': RelativeTimeType,
    'GroupReferences': ReferencesType,
    'OrgVdcNetworkReferences': ReferencesType,
    'TaskReference': ReferenceType,
    'ConfigurationDataRoot': cimString,
    'ProviderVdcResourcePoolRelationRecord': QueryResultProviderVdcResourcePoolRelationRecordType,
    'VMWProviderVdcReference': ReferenceType,
    'OtherResourceType': cimString,
    'StartupSection': StartupSection_Type,
    'SourceVm': VmSelectionType,
    'OrgVdcStorageProfileReference': ReferenceType,
    'ProductSectionList': ProductSectionListType,
    'Reference': ReferenceType,
    'NetworkPoolReferences': ReferencesType,
    'ResourceSubType': cimString,
    'Entity': Entity_Type,
    'ApiExtensibility': ApiExtensibilityType,
    'EdgeGateway': GatewayType,
    'VmReference': ReferenceType,
    'AdminDiskRecord': QueryResultAdminDiskRecordType,
    'GatewayNatRule': GatewayNatRuleType,
    'DatastoreReference': ReferenceType,
    'SnapshotDataRoot': cimString,
    'AdminVAppTemplateRecord': QueryResultAdminVAppTemplateRecordType,
    'DatastoreProviderVdcRelationRecord': QueryResultDatastoreProviderVdcRelationRecordType,
    'StaticRoute': StaticRouteType,
    'Label': Msg_Type,
    'RasdItemsList': RasdItemsListType,
    'MediaReferences': ReferencesType,
    'ApiDefinition': ApiDefinitionType,
    'VmDiskRelationRecord': QueryResultVmDiskRelationRecordType,
    'OrgVdcResourcePoolRelationRecord': QueryResultOrgVdcResourcePoolRelationRecordType,
    'MetadataValue': MetadataValueType,
    'AclRuleReference': ReferenceType,
    'UndeployVAppParams': UndeployVAppParamsType,
    'OrgVdcStorageProfileReferences': ReferencesType,
    'FirewallService': FirewallServiceType,
    'BootOrderSection': BootOrderSection_Type,
    'VsToVmxMap': VsToVmxMapType,
    'Link': LinkType,
    'AdminVdcReferences': ReferencesType,
    'Org': ReferenceType,
    'VirtualCenterRecord': QueryResultVirtualCenterRecordType,
    'DiskCreateParams': DiskCreateParamsType,
    'HostRecord': QueryResultHostRecordType,
    'AddressOnParent': cimString,
    'LeaseSettingsSection': LeaseSettingsSectionType,
    'DatastoreRecord': QueryResultDatastoreRecordType,
    'Cpu': CapacityWithUsageType,
    'DestinationVm': VmSelectionType,
    'BlockingTaskRecord': QueryResultBlockingTaskRecordType,
    'RegisterVAppParams': RegisterVAppParamsType,
    'VAppOrgNetworkRelationReferences': ReferencesType,
    'FirewallRule': FirewallRuleType,
    'AccessSetting': AccessSettingType,
    'VAppOrgVdcNetworkRelationRecord': QueryResultVAppOrgVdcNetworkRelationRecordType,
    'DiskReference': ReferenceType,
    'SuspendDataRoot': cimString,
    'AnnotationSection': AnnotationSection_Type,
    'VirtualSystemType': cimString,
    'Owner': OwnerType,
    'VAppNetworkReference': ReferenceType,
    'Category': Msg_Type,
    'VAppTemplate': VAppTemplateType,
    'LocalityParams': LocalityParamsType,
    'ServiceLinkReference': ReferenceType,
    'Member': LBPoolMemberType,
    'GatewayInterface': GatewayInterfaceType,
    'VmGeneralParams': VmGeneralParamsType,
    'VMReference': ReferenceType,
    'ToCloudTunnelReference': ReferenceType,
    'VMWProviderVdcReferences': ReferencesType,
    'IpScope': IpScopeType,
    'CloneVAppParams': CloneVAppParamsType,
    'Strings': Strings_Type,
    'CatalogReference': ReferenceType,
    'Media': MediaType,
    'AclRuleReferences': ReferencesType,
    'AccessSettings': AccessSettingsType,
    'AllocationUnits': cimString,
    'QueryResultRecords': QueryResultRecordsType,
    'PublishCatalogParams': PublishCatalogParamsType,
    'Connection': cimString,
    'AdminVdcRecord': QueryResultAdminVdcRecordType,
    'Snapshot': SnapshotType,
    'VAppNetworkReferences': ReferencesType,
    'DvSwitchRecord': QueryResultDvSwitchRecordType,
    'AdminMediaRecord': QueryResultAdminMediaRecordType,
    'NetworkPool': ReferenceType,
    'TunnelingApplicationRegisterParams': TunnelingApplicationRegisterParamsType,
    'ToCloudTunnelCreateParams': ToCloudTunnelCreateParamsType,
    'MetadataEntry': MetadataEntryType,
    'Pool': LoadBalancerPoolType,
    'AllocatedIpAddresses': IpAddressesType,
    'Children': VAppTemplateChildrenType,
    'ComplianceResult': ComplianceResultType,
    'ApiDefinitionRecord': QueryResultApiDefinitionRecordType,
    'UserReferences': ReferencesType,
    'OrgVdcNetworkReference': ReferenceType,
    'PeerSubnet': IpsecVpnSubnetType,
    'DiskReferences': ReferencesType,
    'StaticRoutingService': StaticRoutingServiceType,
    'CloneVAppTemplateParams': CloneVAppTemplateParamsType,
    'FileDescriptor': FileDescriptorType,
    'UserRecord': QueryResultUserRecordType,
    'OperatingSystem': OperatingSystemInfoType,
    'Persistence': LBPersistenceType,
    'NetworkService': NetworkServiceType,
    'HardwareCustomization': InstantiateVmHardwareCustomizationParamsType,
    'VAppOrgVdcNetworkRelationReference': ReferenceType,
    'InstallSection': InstallSection_Type,
    'Reservation': cimUnsignedLong,
    'TypedValue': MetadataTypedValue,
    'License': Msg_Type,
    'EdgeGatewayServices': NetworkServiceInsertionType,
    'VAppTemplateReference': ReferenceType,
    'AdminDiskReferences': ReferencesType,
    'VirtualSystem': VirtualSystem_Type,
    'VApp': VAppType,
    'ResourceEntity': ResourceReferenceType,
    'Locale': cimString,
    'CatalogItemReference': ReferenceType,
    'IpsecVpnThirdPartyPeer': IpsecVpnThirdPartyPeerType,
    'File': ReferenceType,
    'AdminAllocatedExternalAddressRecord': QueryResultAdminAllocatedExternalAddressRecordType,
    'OrgVdcStorageProfileRecord': QueryResultOrgVdcStorageProfileRecordType,
    'ControlAccessParams': ControlAccessParamsType,
    'LogDataRoot': cimString,
    'CreationTime': cimDateTime,
    'ConfigurationFile': cimString,
    'HostReference': ReferenceType,
    'VendorUrl': cimString,
    'NetworkConnectionSection': NetworkConnectionSectionType,
    'AllocatedExternalAddressRecord': QueryResultAllocatedExternalAddressRecordType,
    'StrandedItemReferences': ReferencesType,
    'ServiceLinkReferences': ReferencesType,
    'ToCloudTunnelRecord': QueryResultToCloudTunnelRecordType,
    'Task': TaskType,
    'OneToOneBasicRule': NatOneToOneBasicRuleType,
    'PoolID': cimString,
    'NetworkConfig': VAppNetworkConfigurationType,
    'Choices': VmQuestionAnswerChoiceType,
    'AdminServiceReference': ReferenceType,
    'DhcpService': DhcpServiceType,
    'BlockingTaskReferences': ReferencesType,
    'AdminUserRecord': QueryResultAdminUserRecordType,
    'ToCloudTunnel': ToCloudTunnelType,
    'GuestCustomizationSection': GuestCustomizationSectionType,
    'AdminServiceReferences': ReferencesType,
    'VirtualHardwareSection': VirtualHardwareSection_Type,
    'ResourcePoolVMRecord': QueryResultResourcePoolVMRecordType,
    'Disk': VirtualDiskDesc_Type,
    'Subject': ReferenceType,
    'Network': NetworkType6,
    'OrgVdcReferences': ReferencesType,
    'NatRule': NatRuleType,
    'UserReference': ReferenceType,
    'AdminServiceRecord': QueryResultAdminServiceRecordType,
    'GatewayInterfaces': GatewayInterfacesType,
    'LoadBalancerTemplates': VendorTemplateType,
    'AdminOrgVdcStorageProfileReference': ReferenceType,
    'NetworkServiceInsertion': NetworkServiceInsertionType,
    'AdminVMRecord': QueryResultAdminVMRecordType,
    'EdgeGatewayRecord': QueryResultEdgeGatewayRecordType,
    'ConfigurationID': cimString,
    'TaskRecord': QueryResultTaskRecordType,
    'Record': QueryResultRecordType,
    'IpsecVpnPeer': IpsecVpnPeerType,
    'Metric': SimpleMetricType,
    'OvfToVdcNetworkMap': OvfToVdcNetworkMapType,
    'PortForwardingRule': NatPortForwardingRuleType,
    'VMWareTools': VMWareToolsType,
    'VirtualCenterReferences': ReferencesType,
    'RuntimeInfoSection': RuntimeInfoSectionType,
    'HistoricUsage': HistoricUsageType,
    'OrgVdcRecord': QueryResultOrgVdcRecordType,
    'FullVersion': cimString,
    'VAppTemplateRecord': QueryResultVAppTemplateRecordType,
    'CreateSnapshotParams': CreateSnapshotParamsType,
    'DiskRecord': QueryResultDiskRecordType,
    'AdminEventReferences': ReferencesType,
    'SourcedVmInstantiationParams': SourcedVmInstantiationParamsType,
    'Features': NetworkFeaturesType,
    'MediaReference': ReferenceType,
    'Version': cimString,
    'References': References_Type,
    'NetworkMapping': NetworkMappingType,
    'AutomaticStartupActionSequenceNumber': cimUnsignedShort,
    'AutomaticAllocation': cimBoolean,
    'NetworkRecord': QueryResultNetworkRecordType,
    'Capabilities': CapabilitiesType,
    'HybridTicket': HybridTicketType,
    'MetricSeries': TimeSeriesMetricType,
    'VAppOrgNetworkRelationRecord': QueryResultVAppOrgNetworkRelationRecordType,
    'CopyOrMoveCatalogItemParams': CopyOrMoveCatalogItemParamsType,
    'VirtualSystemCollection': VirtualSystemCollection_Type,
    'NetworkPoolRecord': QueryResultNetworkPoolRecordType,
    'OperatingSystemFamilyInfo': OperatingSystemFamilyInfoType,
    'ServiceReferences': ReferencesType,
    'InstantiateOvfParams': InstantiateOvfParamsType,
    'AdminFileDescriptorReferences': ReferencesType,
    'SyslogServerSettings': SyslogServerSettingsType,
    'HostReferences': ReferencesType,
    'OrgVdcReference': ReferenceType,
    'AdminDiskReference': ReferenceType,
    'AdminEventRecord': QueryResultAdminEventRecordType,
    'Name': Msg_Type,
    'AclRuleRecord': QueryResultAclRuleRecordType,
    'SubAllocation': SubAllocationType,
    'ApiFilterReference': ReferenceType,
    'IpRange': IpRangeType,
    'RoleReferences': ReferencesType,
    'ServiceResourceRecord': QueryResultServiceResourceRecordType,
    'RoleRecord': QueryResultRoleRecordType,
    'ServicePort': LBPoolServicePortType,
    'Sample': SampleType,
    'VmPendingQuestion': VmPendingQuestionType,
    'InstantiateVmParams': InstantiateVmParamsType,
    'VirtualSystemIdentifier': cimString,
    'Vms': VmsType,
    'CurrentUsageSpec': CurrentUsageSpecType,
    'ResourceClassActionReference': ReferenceType,
    'IpsecVpnService': IpsecVpnServiceType,
    'CatalogReferences': ReferencesType,
    'CreateItem': VmType,
    'FileDescriptorRecord': QueryResultFileDescriptorRecordType,
    'Service': ServiceType,
    'PropertySection': PropertySection_Type,
    'AutomaticStartupActionDelay': cimDateTime,
    'Protocols': ProtocolsType,
    'Level': LevelType,
    'Notes': cimString,
    'ConditionRecord': QueryResultConditionRecordType,
    'Value': PropertyConfigurationValue_Type,
    'EdgeGatewayReferences': ReferencesType,
    'OperatingSystemSection': OperatingSystemSection_Type,
    'Organization': ReferenceType,
    'NicIpMap': NicIpMapType,
    'VmRule': NatVmRuleType,
    'AdminTaskRecord': QueryResultAdminTaskRecordType,
    'IpAssignmentSection': IpAssignmentSection_Type,
    'OrgVdcNetwork': OrgVdcNetworkType,
    'ServiceReference': ReferenceType,
    'AllowedExternalIpAddresses': IpAddressesType,
    'Source': ReferenceType,
    'RoleReference': ReferenceType,
    'NatService': NatServiceType,
    'DeployVAppParams': DeployVAppParamsType,
    'ApiFilterReferences': ReferencesType,
    'ComputeCapacity': ComputeCapacityType,
    'VMReferences': ReferencesType,
    'VCloudExtension': VCloudExtensionType,
    'Info': Msg_Type,
    'Kind': cimString,
    'PlatformSection': PlatformSection_Type,
    'Tunnel': GatewayIpsecVpnTunnelType,
    'DiskAttachOrDetachParams': DiskAttachOrDetachParamsType,
    'RouterInfo': RouterInfoType,
    'VirtualCenterReference': ReferenceType,
    'ResourceClassRecord': QueryResultResourceClassRecordType,
    'TasksList': TasksListType,
    'ResourceClassActionReferences': ReferencesType,
    'DiskSection': DiskSection_Type,
    'VAppTemplateReferences': ReferencesType,
    'ProviderVdcStorageProfileReferences': ReferencesType,
    'AdminApiDefinitionReference': ReferenceType,
    'VmQuestionAnswer': VmQuestionAnswerType,
    'ShadowVMReferences': ReferencesType,
    'EdgeGatewayServiceConfiguration': GatewayFeaturesType,
    'AdminCatalogRecord': QueryResultAdminCatalogRecordType,
    'RightReferences': ReferencesType,
    'CpuCompatibilitySection': CpuCompatibilitySection_Type,
    'CatalogItemReferences': ReferencesType,
    'TargetCatalogItem': ReferenceType,
    'InstantiationParams': InstantiationParamsType,
    'ServiceRecord': QueryResultServiceRecordType,
    'HistoricUsageSpec': HistoricUsageSpecType,
    'QueryList': QueryListType,
    'SwapFileDataRoot': cimString,
    'VirtualQuantity': cimUnsignedLong,
    'CatalogRecord': QueryResultCatalogRecordType,
    'GatewayDhcpService': GatewayDhcpServiceType,
    'VAppParent': ReferenceType,
    'ApiFilterRecord': QueryResultApiFilterRecordType,
    'AbsoluteEndTime': AbsoluteTimeType,
    'NetworkConnection': NetworkConnectionType,
    'NetworkConfigSection': NetworkConfigSectionType,
    'NetworkReferences': ReferencesType,
    'ResourcePoolRecord': QueryResultResourcePoolRecordType,
    'ScreenTicket': ScreenTicketType,
    'CatalogItemRecord': QueryResultCatalogItemRecordType,
    'ParentNetwork': ReferenceType,
    'CatalogItem': ReferenceType,
    'SubAllocations': SubAllocationsType,
    'OrgNetworkReferences': ReferencesType,
    'AdminVmDiskRelationRecord': QueryResultAdminVmDiskRelationRecordType,
    'ResourceEntities': ResourceEntitiesType,
    'ServiceProfile': LBVirtualServerServiceProfileType,
    'Content': Content_Type,
    'AvailableNetworks': AvailableNetworksType,
    'AdminOrgNetworkRecord': QueryResultAdminOrgNetworkRecordType,
    'GroupReference': ReferenceType,
    'Product': Msg_Type,
    'AdminFileDescriptorReference': ReferenceType,
    'ProductUrl': cimString,
    'Session': SessionType,
    'Address': cimString,
    'VirtualQuantityUnits': cimString,
    'DeleteItem': ReferenceType,
    'EulaSection': EulaSection_Type,
    'CIM_ResourceAllocationSettingData': CIM_ResourceAllocationSettingData_Type,
    'AdminCatalogItemRecord': QueryResultAdminCatalogItemRecordType,
    'ServiceLinkRecord': QueryResultServiceLinkRecordType,
    'Item': ItemType,
    'DefaultStorageProfileSection': DefaultStorageProfileSection_Type,
    'ResourceClassReferences': ReferencesType,
    'SupportedApiVersions': VersionsType,
    'Vm': VAppTemplateType,
    'VAppReferences': ReferencesType,
    'SupportedHardwareVersions': SupportedHardwareVersionsType,
    'ApiDefinitionReferences': ReferencesType,
    'ProviderVdcStorageProfileRecord': QueryResultProviderVdcStorageProfileRecordType,
    'RecoveryFile': cimString,
    'VAppNetwork': VAppNetworkType,
    'ProviderVdcStorageProfileReference': ReferenceType,
    'ExternalNatIpMap': ExternalNatIpMapType,
    'VdcStorageProfile': ReferenceType,
    'LoadBalancerService': LoadBalancerServiceType,
    'AdminToCloudTunnel': AdminToCloudTunnelType,
    'HostResource': cimString,
    'CatalogItems': CatalogItemsType,
    'AdminApiDefinitionReferences': ReferencesType,
    'UploadVAppTemplateParams': UploadVAppTemplateParamsType,
    'Files': FilesListType,
    'CaptureVAppParams': CaptureVAppParamsType,
    'RecomposeVAppParams': RecomposeVAppParamsType,
    'PortgroupRecord': QueryResultPortgroupRecordType,
    'IpsecVpnRemotePeer': IpsecVpnRemotePeerType,
    'Annotation': Msg_Type,
    'Icon': IconType,
    'AdminOrgVdcStorageProfileRecord': QueryResultAdminOrgVdcStorageProfileRecordType,
    'StrandedItemRecord': QueryResultStrandedItemRecordType,
    'ResourceClassActionRecord': QueryResultResourceClassActionRecordType,
    'NetworkReference': ReferenceType,
    'StrandedUserRecord': QueryResultStrandedUserRecordType,
    'Limit': cimUnsignedLong,
    'VAppReference': ReferenceType,
    'VdcStorageProfiles': VdcStorageProfilesType,
    'ServiceConfig': GatewayFeaturesType,
    'AdminApiDefinitionRecord': QueryResultAdminApiDefinitionRecordType,
    'AdminGroupRecord': QueryResultAdminGroupRecordType,
    'MediaInsertOrEjectParams': MediaInsertOrEjectParamsType,
    'CellRecord': QueryResultCellRecordType,
    'Datastore': ReferenceType,
    'EdgeGatewayReference': ReferenceType,
    'Section': Section_Type,
    'System': VSSD_Type,
    'OrgVdcNetworkRecord': QueryResultOrgVdcNetworkRecordType,
    'AdminEventReference': ReferenceType,
    'ProductSection': ProductSection_Type,
    'Vendor': cimString,
    'AutomaticDeallocation': cimBoolean,
    'ServiceResourceResourceReference': ReferenceType,
    'NetworkServices': NetworkServiceInsertionType,
    'Catalog': CatalogType,
    'RightReference': ReferenceType,
    'VendorTemplates': VendorTemplateType,
    'RightRecord': QueryResultRightRecordType,
    'HybridSettings': HybridSettingsType,
    'Interface': ReferenceType,
    'EventRecord': QueryResultEventRecordType,
    'Configuration': ConfigurationType,
    'VAppRecord': QueryResultVAppRecordType,
    'IpRanges': IpRangesType,
    'OrgRecord': QueryResultOrgRecordType,
    'StrandedItemReference': ReferenceType,
    'HealthCheck': LBPoolHealthCheckType,
    'AdminFileDescriptorRecord': QueryResultAdminFileDescriptorRecordType,
    'IpScopes': IpScopesType,
    'OrgReferences': ReferencesType,
    'SourcedItem': SourcedCompositionItemParamType,
    'InstantiateVAppTemplateParams': InstantiateVAppTemplateParamsType,
    'Property': PropertyType7,
    'Domain': MetadataDomainTagType,
    'Tasks': TasksInProgressType,
    'CustomizationSection': CustomizationSectionType,
    'Weight': cimUnsignedInt,
    'DeploymentOptionSection': DeploymentOptionSection_Type,
    'ExtraConfig': ExtraConfig_Type,
    'AdminVAppNetworkRecord': QueryResultAdminVAppNetworkRecordType,
    'TunnelingApplication': TunnelingApplicationType,
    'ExternalLocalizationRecord': QueryResultExternalLocalizationRecordType,
    'CurrentUsage': CurrentUsageType,
    'NetworkPoolReference': ReferenceType,
    'LocalSubnet': IpsecVpnSubnetType,
    'IpsecVpnLocalPeer': IpsecVpnLocalPeerType,
    'VendorTemplateAttributes': VendorTemplateAttributesType,
    'Locality': ReferenceType,
    'StorageProfile': ReferenceType,
    'ApiDefinitionReference': ReferenceType,
    'Environment': Environment_Type,
    'Msg': MsgType,
    'Config': Config_Type,
    'ToCloudTunnelReferences': ReferencesType,
    'InstantiateOvfProperty': InstantiateOvfPropertyType,
    'ComposeVAppParams': ComposeVAppParamsType,
    'ElementName': cimString,
    'RelocateParams': RelocateParamsType,
    'AdminVAppRecord': QueryResultAdminVAppRecordType,
    'User': ReferenceType,
    'AdminOrgVdcStorageProfileReferences': ReferencesType,
    'IpsecVpnTunnel': IpsecVpnTunnelType,
    'VMRecord': QueryResultVMRecordType,
    'VAppNetworkRecord': QueryResultVAppNetworkRecordType,
    'Vdc': VdcType,
    'Error': ErrorType,
    'RelativeEndTime': RelativeTimeType,
    'CIM_VirtualSystemSettingData': CIM_VirtualSystemSettingData_Type,
    'GatewayIpsecVpnService': GatewayIpsecVpnServiceType,
    'OrgList': OrgListType,
    'OrgReference': ReferenceType,
    'SupportedOperatingSystemsInfo': SupportedOperatingSystemsInfoType,
    'AppUrl': cimString,
    'InstanceID': cimString,
    'VirtualServer': LoadBalancerVirtualServerType,
    'Memory': CapacityWithUsageType,
    'BlockingTaskReference': ReferenceType,
    'AbsoluteStartTime': AbsoluteTimeType,
    'IpAddress': AllocatedIpAddressType,
    'VAppOrgVdcNetworkRelationReferences': ReferencesType,
    'VmCapabilities': VmCapabilitiesType,
    'Description': Msg_Type,
    'OneToOneVmRule': NatOneToOneVmRuleType,
    'Envelope': EnvelopeType,
    'VMWProviderVdcRecord': QueryResultVMWProviderVdcRecordType,
    'ResourceClassReference': ReferenceType,
    'AdminShadowVMRecord': QueryResultAdminShadowVMRecordType,
    'Endpoint': GatewayIpsecVpnEndpointType,
    'AdminVdcReference': ReferenceType,
    'MediaRecord': QueryResultMediaRecordType,
    'OrgNetworkRecord': QueryResultOrgNetworkRecordType,
    'TunnelingApplicationList': TunnelingApplicationListType,
    'Entry': EntryType3,
    'MksTicket': MksTicketType,
    'StorageCapacity': CapacityWithUsageType,
    'DatastoreReferences': ReferencesType,
    'HybridOrg': HybridOrgType,
    'NetworkAssignment': NetworkAssignmentType,
    'ResourceAllocationSection': ResourceAllocationSection_Type,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'CatalogType'
        rootClass = CatalogType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'CatalogType'
        rootClass = CatalogType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'CatalogType'
        rootClass = CatalogType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'CatalogType'
        rootClass = CatalogType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from vcloudType import *\n\n')
        sys.stdout.write('import vcloudType as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AbsoluteTimeType",
    "AbstractVAppType",
    "AccessSettingType",
    "AccessSettingsType",
    "AdminToCloudTunnelType",
    "AllocatedIpAddressType",
    "AllocatedIpAddressesType",
    "AnnotationSection_Type",
    "ApiDefinitionType",
    "ApiExtensibilityType",
    "AutomaticRecoveryAction",
    "AutomaticShutdownAction",
    "AutomaticStartupAction",
    "AvailableNetworksType",
    "BootOrderSection_Type",
    "CIM_ResourceAllocationSettingData_Type",
    "CIM_VirtualSystemSettingData_Type",
    "CapabilitiesType",
    "CapacityType",
    "CapacityWithUsageType",
    "Caption",
    "CaptureVAppParamsType",
    "CatalogItemType",
    "CatalogItemsType",
    "CatalogType",
    "CloneMediaParamsType",
    "CloneVAppParamsType",
    "CloneVAppTemplateParamsType",
    "ComplianceResultType",
    "ComposeVAppParamsType",
    "ComputeCapacityType",
    "ConfigKeyValue_Type",
    "Config_Type",
    "ConfigurationType",
    "ConsumerVisibility",
    "ContainerType",
    "Content_Type",
    "ControlAccessParamsType",
    "CopyOrMoveCatalogItemParamsType",
    "CoresPerSocket_Type",
    "CpuCompatibilitySection_Type",
    "CreateSnapshotParamsType",
    "CurrentUsageSpecType",
    "CurrentUsageType",
    "CustomizationSectionType",
    "DefaultStorageProfileSection_Type",
    "DeployVAppParamsType",
    "DeploymentOptionSection_Type",
    "DhcpPoolServiceType",
    "DhcpServiceType",
    "DiskAttachOrDetachParamsType",
    "DiskCreateParamsType",
    "DiskSection_Type",
    "DiskType",
    "DiskType4",
    "EntityLinkType",
    "EntityReferenceType",
    "EntityType",
    "Entity_Type",
    "EntryType",
    "EntryType1",
    "EntryType2",
    "EntryType3",
    "EnvelopeType",
    "Environment_Type",
    "ErrorType",
    "EulaSection_Type",
    "ExternalNatIpMapType",
    "ExtraConfig_Type",
    "FileDescriptorType",
    "FileType",
    "FileUploadParamsType",
    "FileUploadSocketType",
    "File_Type",
    "FilesListType",
    "FirewallRuleType",
    "FirewallServiceType",
    "GatewayConfigurationType",
    "GatewayDhcpServiceType",
    "GatewayFeaturesType",
    "GatewayInterfaceType",
    "GatewayInterfacesType",
    "GatewayIpsecVpnEndpointType",
    "GatewayIpsecVpnServiceType",
    "GatewayIpsecVpnTunnelType",
    "GatewayNatRuleType",
    "GatewayType",
    "GuestCustomizationSectionType",
    "HistoricUsageSpecType",
    "HistoricUsageType",
    "HybridOrgType",
    "HybridSettingsType",
    "HybridTicketType",
    "IconType",
    "IdentifiableResourceType",
    "InstallSection_Type",
    "InstantiateOvfParamsType",
    "InstantiateOvfPropertyType",
    "InstantiateVAppParamsType",
    "InstantiateVAppTemplateParamsType",
    "InstantiateVmHardwareCustomizationParamsType",
    "InstantiateVmParamsType",
    "InstantiationParamsType",
    "IpAddressesType",
    "IpAssignmentSection_Type",
    "IpRangeType",
    "IpRangesType",
    "IpScopeType",
    "IpScopesType",
    "IpsecVpnLocalPeerType",
    "IpsecVpnManagedPeerType",
    "IpsecVpnPeerType",
    "IpsecVpnRemotePeerType",
    "IpsecVpnServiceType",
    "IpsecVpnSubnetType",
    "IpsecVpnThirdPartyPeerType",
    "IpsecVpnTunnelType",
    "IpsecVpnUnmanagedPeerType",
    "ItemType",
    "LBPersistenceType",
    "LBPoolHealthCheckType",
    "LBPoolMemberType",
    "LBPoolServicePortType",
    "LBVirtualServerServiceProfileType",
    "LeaseSettingsSectionType",
    "LevelType",
    "LinkType",
    "LoadBalancerPoolType",
    "LoadBalancerServiceType",
    "LoadBalancerVirtualServerType",
    "LocalityParamsType",
    "MappingBehavior",
    "MediaInsertOrEjectParamsType",
    "MediaType",
    "MetadataBooleanValue",
    "MetadataDateTimeValue",
    "MetadataDomainTagType",
    "MetadataEntryType",
    "MetadataNumberValue",
    "MetadataStringValue",
    "MetadataType",
    "MetadataTypedValue",
    "MetadataValueType",
    "MksTicketType",
    "MsgType",
    "Msg_Type",
    "NatOneToOneBasicRuleType",
    "NatOneToOneVmRuleType",
    "NatPortForwardingRuleType",
    "NatRuleType",
    "NatServiceType",
    "NatVmRuleType",
    "NetworkAssignmentType",
    "NetworkConfigSectionType",
    "NetworkConfigurationType",
    "NetworkConnectionSectionType",
    "NetworkConnectionType",
    "NetworkFeaturesType",
    "NetworkMappingType",
    "NetworkSection_Type",
    "NetworkServiceInsertionType",
    "NetworkServiceType",
    "NetworkType",
    "NetworkType6",
    "NicIpMapType",
    "OperatingSystemFamilyInfoType",
    "OperatingSystemInfoType",
    "OperatingSystemSection_Type",
    "OrgListType",
    "OrgNetworkType",
    "OrgType",
    "OrgVdcNetworkType",
    "OvfToVdcNetworkMapType",
    "OwnerType",
    "ParamsType",
    "PlatformSection_Type",
    "ProductSectionListType",
    "ProductSection_Type",
    "PropertyConfigurationValue_Type",
    "PropertySection_Type",
    "PropertyType",
    "PropertyType5",
    "PropertyType7",
    "ProtocolsType",
    "PublishCatalogParamsType",
    "QueryListType",
    "QueryResultAclRuleRecordType",
    "QueryResultAdminAllocatedExternalAddressRecordType",
    "QueryResultAdminApiDefinitionRecordType",
    "QueryResultAdminCatalogItemRecordType",
    "QueryResultAdminCatalogRecordType",
    "QueryResultAdminDiskRecordType",
    "QueryResultAdminEventRecordType",
    "QueryResultAdminFileDescriptorRecordType",
    "QueryResultAdminGroupRecordType",
    "QueryResultAdminMediaRecordType",
    "QueryResultAdminOrgNetworkRecordType",
    "QueryResultAdminOrgVdcStorageProfileRecordType",
    "QueryResultAdminServiceRecordType",
    "QueryResultAdminShadowVMRecordType",
    "QueryResultAdminTaskRecordType",
    "QueryResultAdminUserRecordType",
    "QueryResultAdminVAppNetworkRecordType",
    "QueryResultAdminVAppRecordType",
    "QueryResultAdminVAppTemplateRecordType",
    "QueryResultAdminVMRecordType",
    "QueryResultAdminVdcRecordType",
    "QueryResultAdminVmDiskRelationRecordType",
    "QueryResultAllocatedExternalAddressRecordType",
    "QueryResultApiDefinitionRecordType",
    "QueryResultApiFilterRecordType",
    "QueryResultBlockingTaskRecordType",
    "QueryResultCatalogItemRecordType",
    "QueryResultCatalogRecordType",
    "QueryResultCellRecordType",
    "QueryResultConditionRecordType",
    "QueryResultDatastoreProviderVdcRelationRecordType",
    "QueryResultDatastoreRecordType",
    "QueryResultDiskRecordType",
    "QueryResultDvSwitchRecordType",
    "QueryResultEdgeGatewayRecordType",
    "QueryResultEventRecordType",
    "QueryResultExternalLocalizationRecordType",
    "QueryResultFileDescriptorRecordType",
    "QueryResultGroupRecordType",
    "QueryResultHostRecordType",
    "QueryResultMediaRecordType",
    "QueryResultNetworkPoolRecordType",
    "QueryResultNetworkRecordType",
    "QueryResultOrgNetworkRecordType",
    "QueryResultOrgRecordType",
    "QueryResultOrgVdcNetworkRecordType",
    "QueryResultOrgVdcRecordType",
    "QueryResultOrgVdcResourcePoolRelationRecordType",
    "QueryResultOrgVdcStorageProfileRecordType",
    "QueryResultPortgroupRecordType",
    "QueryResultProviderVdcResourcePoolRelationRecordType",
    "QueryResultProviderVdcStorageProfileRecordType",
    "QueryResultRecordType",
    "QueryResultRecordsType",
    "QueryResultResourceClassActionRecordType",
    "QueryResultResourceClassRecordType",
    "QueryResultResourcePoolRecordType",
    "QueryResultResourcePoolVMRecordType",
    "QueryResultRightRecordType",
    "QueryResultRoleRecordType",
    "QueryResultServiceLinkRecordType",
    "QueryResultServiceRecordType",
    "QueryResultServiceResourceRecordType",
    "QueryResultStrandedItemRecordType",
    "QueryResultStrandedUserRecordType",
    "QueryResultTaskRecordType",
    "QueryResultToCloudTunnelRecordType",
    "QueryResultType",
    "QueryResultUserRecordType",
    "QueryResultVAppNetworkRecordType",
    "QueryResultVAppOrgNetworkRelationRecordType",
    "QueryResultVAppOrgVdcNetworkRelationRecordType",
    "QueryResultVAppRecordType",
    "QueryResultVAppTemplateRecordType",
    "QueryResultVMRecordType",
    "QueryResultVMWProviderVdcRecordType",
    "QueryResultVirtualCenterRecordType",
    "QueryResultVmDiskRelationRecordType",
    "RASD_Type",
    "RasdItemsListType",
    "RecomposeVAppParamsType",
    "ReferenceType",
    "ReferencesType",
    "References_Type",
    "RegisterVAppParamsType",
    "RelativeTimeType",
    "RelocateParamsType",
    "ResourceAllocationSection_Type",
    "ResourceEntitiesType",
    "ResourceEntityType",
    "ResourceReferenceType",
    "ResourceType",
    "RouterInfoType",
    "RuntimeInfoSectionType",
    "SampleType",
    "ScreenTicketType",
    "Section_Type",
    "ServiceType",
    "SessionType",
    "SimpleMetricType",
    "SnapshotSectionType",
    "SnapshotType",
    "SourcedCompositionItemParamType",
    "SourcedVmInstantiationParamsType",
    "StartupSection_Type",
    "StaticRouteType",
    "StaticRoutingServiceType",
    "Strings_Type",
    "SubAllocationType",
    "SubAllocationsType",
    "SubnetParticipationType",
    "SupportedHardwareVersionsType",
    "SupportedOperatingSystemsInfoType",
    "SyslogServerSettingsType",
    "TaskOperationListType",
    "TaskType",
    "TasksInProgressType",
    "TasksListType",
    "TimeSeriesMetricType",
    "TimeType",
    "ToCloudTunnelCreateParamsType",
    "ToCloudTunnelType",
    "TunnelingApplicationListType",
    "TunnelingApplicationRegisterParamsType",
    "TunnelingApplicationType",
    "UndeployVAppParamsType",
    "UploadVAppTemplateParamsType",
    "VAppChildrenType",
    "VAppCreationParamsType",
    "VAppNetworkConfigurationType",
    "VAppNetworkType",
    "VAppTemplateChildrenType",
    "VAppTemplateType",
    "VAppType",
    "VCloudExtensibleType",
    "VCloudExtensionType",
    "VMWareToolsType",
    "VSSD_Type",
    "VdcStorageProfileType",
    "VdcStorageProfilesType",
    "VdcType",
    "VdcsType",
    "VendorServicesType",
    "VendorTemplateAttributesType",
    "VendorTemplateType",
    "VersionsType",
    "VirtualDiskDesc_Type",
    "VirtualHardwareSection_Type",
    "VirtualSystemCollection_Type",
    "VirtualSystem_Type",
    "VmCapabilitiesType",
    "VmGeneralParamsType",
    "VmPendingQuestionType",
    "VmQuestionAnswerChoiceType",
    "VmQuestionAnswerType",
    "VmSelectionType",
    "VmType",
    "VmsType",
    "VsToVmxMapType",
    "cimAnySimpleType",
    "cimBase64Binary",
    "cimBoolean",
    "cimByte",
    "cimChar16",
    "cimDateTime",
    "cimDouble",
    "cimFloat",
    "cimHexBinary",
    "cimInt",
    "cimLong",
    "cimReference",
    "cimShort",
    "cimString",
    "cimUnsignedByte",
    "cimUnsignedInt",
    "cimUnsignedLong",
    "cimUnsignedShort",
    "qualifierBoolean",
    "qualifierSArray",
    "qualifierSInt64",
    "qualifierString",
    "qualifierUInt32"
]
